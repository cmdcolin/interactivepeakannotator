(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	"JBrowse/Model/FileBlob":"./src/JBrowse/Model/FileBlob.js",
	"JBrowse/Model/XHRBlob":"./src/JBrowse/Model/XHRBlob.js",
	"JBrowse/Util/TextIterator":"./src/JBrowse/Util/TextIterator.js",
	"JBrowse/View/FileDialog/TrackList/BAMDriver":"./src/JBrowse/View/FileDialog/TrackList/BAMDriver.js",
	"JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver":"./src/JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver.js",
	"JBrowse/View/FileDialog/TrackList/GFF3TabixDriver":"./src/JBrowse/View/FileDialog/TrackList/GFF3TabixDriver.js",
	"JBrowse/View/FileDialog/TrackList/IndexedFASTADriver":"./src/JBrowse/View/FileDialog/TrackList/IndexedFASTADriver.js",
	"JBrowse/View/FileDialog/TrackList/_IndexedFileDriver":"./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js",
	"JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver":"./src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js",
	"JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver":"./src/JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[9],{

/***/ "./src/JBrowse/Model/FileBlob.js":
/*!***************************************!*\
  !*** ./src/JBrowse/Model/FileBlob.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! JBrowse/Util/TextIterator */ \"./src/JBrowse/Util/TextIterator.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, has, TextIterator) {\n    var FileBlob = declare(null,\n    /**\n     * @lends JBrowse.Model.FileBlob.prototype\n     */\n    {\n\n        /**\n         * Blob of binary data fetched from a local file (with FileReader).\n         *\n         * Adapted by Robert Buels from the BlobFetchable object in the\n         * Dalliance Genome Explorer, which is copyright Thomas Down\n         * 2006-2011.\n         * @constructs\n         */\n        constructor: function constructor(b) {\n            this.blob = b;\n            this.size = b.size;\n            this.totalSize = b.size;\n        },\n\n        slice: function slice(start, length) {\n            var sliceFunc = this.blob.mozSlice || this.blob.slice || this.blob.webkitSlice;\n            return new FileBlob(length ? sliceFunc.call(this.blob, start, start + length) : sliceFunc.call(this.blob, start));\n        },\n\n        fetchLines: function fetchLines(lineCallback, endCallback, failCallback) {\n            var thisB = this;\n            this.fetch(function (data) {\n                data = new Uint8Array(data);\n\n                var lineIterator = new TextIterator.FromBytes({ bytes: data,\n                    // only return a partial line at the end\n                    // if we are not operating on a slice of\n                    // the file\n                    returnPartialRecord: !this.end\n                });\n                var line;\n                while (line = lineIterator.getline()) {\n                    lineCallback(line);\n                }\n\n                endCallback();\n            }, failCallback);\n        },\n\n        readLines: function readLines() {\n            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var length = arguments[1];\n            var lineCallback = arguments[2];\n            var endCallback = arguments[3];\n            var failCallback = arguments[4];\n\n            var start = this.start + offset,\n                end = start + length;\n            var skipFirst = offset != 0;\n            this.slice(offset, length).fetchLines(function () {\n                // skip the first line if we have a\n                // nonzero offset, because it is probably\n                // incomplete\n                if (!skipFirst) lineCallback();\n                skipFirst = false;\n            }, endCallback, failCallback);\n        },\n\n        read: function read() {\n            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var length = arguments[1];\n            var callback = arguments[2];\n            var failCallback = arguments[3];\n\n            var start = this.start + offset,\n                end = start + length;\n\n            // short-circuit a read of 0 bytes here, because browsers\n            // actually sometimes crash if you try to read 0 bytes from\n            // a local file!\n            if (!length) {\n                callback(new ArrayBuffer());\n                return;\n            }\n\n            this.slice(offset, length).fetch(callback, failCallback);\n        },\n\n        readBufferPromise: function readBufferPromise(offset, length) {\n            var _this = this;\n\n            return new Promise(function (resolve, reject) {\n                _this.read(offset, length, function (data) {\n                    resolve(window.Buffer.from(data));\n                }, reject);\n            });\n        },\n\n\n        fetch: function fetch(callback, failCallback) {\n            try {\n                var reader = new FileReader();\n                reader.onloadend = function (ev) {\n                    callback(reader.result);\n                };\n                reader.onerror = failCallback;\n                reader.readAsArrayBuffer(this.blob);\n            } catch (e) {\n                failCallback(e);\n            }\n        },\n\n        fetchBufferPromise: function fetchBufferPromise() {\n            var _this2 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this2.fetch(function (data) {\n                    resolve(window.Buffer.from(data));\n                }, reject);\n            });\n        },\n        stat: function stat(callback, failCallback) {\n            this.statPromise().then(callback, failCallback);\n        },\n        statPromise: function statPromise() {\n            var _this3 = this;\n\n            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                return _context.abrupt('return', { size: _this3.blob.size });\n\n                            case 1:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, _this3);\n            }))();\n        }\n    });\n    return FileBlob;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/FileBlob.js?");

/***/ }),

/***/ "./src/JBrowse/Model/XHRBlob.js":
/*!**************************************!*\
  !*** ./src/JBrowse/Model/XHRBlob.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n__webpack_require__(/*! whatwg-fetch */ \"./node_modules/whatwg-fetch/fetch.js\");\nvar tenaciousFetch = __webpack_require__(/*! tenacious-fetch */ \"./node_modules/tenacious-fetch/dist/tenacious-fetch.m.js\").default;\n\nvar _cjsRequire = __webpack_require__(/*! http-range-fetcher */ \"./node_modules/http-range-fetcher/dist/index.js\"),\n    HttpRangeFetcher = _cjsRequire.HttpRangeFetcher;\n\nvar _cjsRequire2 = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _cjsRequire2.Buffer;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob) {\n\n    //throw 404 errors for plain-old-fetch xref https://github.com/github/fetch/issues/155\n    function fetchwrapper(f) {\n        return function (url, options) {\n            return f(url, options).then(function (res) {\n                if (res.status >= 200 && res.status < 300) {\n                    return Promise.resolve(res);\n                } else {\n                    var error = new Error('HTTP ' + res.status + ' when fetching ' + res.url);\n                    error.response = res;\n                    return Promise.reject(error);\n                }\n            });\n        };\n    }\n    function getfetch(url) {\n        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        var mfetch = void 0;\n        if (Util.isElectron()) {\n            if (url.slice(0, 4) === 'http') {\n                mfetch = fetchwrapper(electronRequire('node-fetch'));\n            } else {\n                url = url.replace('%20', ' ');\n                mfetch = fetchwrapper(fetch);\n            }\n        } else {\n            mfetch = tenaciousFetch; // already throws on 404\n        }\n        return mfetch(url, Object.assign({\n            method: 'GET',\n            credentials: 'same-origin',\n            retries: 5,\n            retryDelay: 1000, // 1 sec, 2 sec, 3 sec\n            retryStatus: [500, 404, 503],\n            onRetry: function onRetry(_ref) {\n                var retriesLeft = _ref.retriesLeft,\n                    retryDelay = _ref.retryDelay;\n\n                console.warn(url + ' request failed, retrying (' + retriesLeft + ' retries left)');\n            }\n        }, opts));\n    }\n\n    function fetchBinaryRange(url, start, end) {\n        var requestDate = new Date();\n        var headers = {\n            headers: { range: 'bytes=' + start + '-' + end },\n            onRetry: function onRetry(_ref2) {\n                var retriesLeft = _ref2.retriesLeft,\n                    retryDelay = _ref2.retryDelay;\n\n                console.warn(url + ' bytes ' + start + '-' + end + ' request failed, retrying (' + retriesLeft + ' retries left)');\n            }\n        };\n\n        return getfetch(url, headers).then(function (res) {\n            var responseDate = new Date();\n            if (res.status !== 206 && res.status !== 200) throw new Error('HTTP ' + res.status + ' when fetching ' + url + ' bytes ' + start + '-' + end);\n\n            // translate the Headers object into a regular key -> value object.\n            // will miss duplicate headers of course\n            var headers = {};\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = res.headers.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var entry = _step.value;\n\n                    headers[entry[0]] = entry[1];\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            if (Util.isElectron()) {\n                // electron charmingly returns HTTP 200 for byte range requests,\n                // and does not fill in content-range. so we will fill it in\n                try {\n                    if (!headers['content-range']) {\n                        var fs = electronRequire(\"fs\"); //Load the filesystem module\n                        var stats = fs.statSync(Util.unReplacePath(url));\n                        headers['content-range'] = start + '-' + end + '/' + stats.size;\n                    }\n                } catch (e) {\n                    console.error('Could not get size of file', url, e);\n                }\n            } else if (res.status === 200) {\n                throw new Error('HTTP ' + res.status + ' when fetching ' + url + ' bytes ' + start + '-' + end);\n            }\n\n            // return the response headers, and the data buffer\n            return res.arrayBuffer().then(function (arrayBuffer) {\n                return {\n                    headers: headers,\n                    requestDate: requestDate,\n                    responseDate: responseDate,\n                    buffer: Buffer.from(arrayBuffer)\n                };\n            });\n        }, function (res) {\n            throw new Error('HTTP ' + res.status + ' when fetching ' + url + ' bytes ' + start + '-' + end);\n        });\n    }\n    var globalCache = new HttpRangeFetcher({\n        fetch: fetchBinaryRange,\n        size: 50 * 1024 * 1024, // 50MB\n        chunkSize: Math.pow(2, 18), // 256KB\n        aggregationTime: 50\n    });\n\n    var XHRBlob = declare(FileBlob,\n    /**\n     * @lends JBrowse.Model.XHRBlob.prototype\n     */\n    {\n\n        /**\n         * Blob of binary data fetched with an XMLHTTPRequest.\n         *\n         * Adapted by Robert Buels from the URLFetchable object in the\n         * Dalliance Genome Explorer, which was is copyright Thomas Down\n         * 2006-2011.\n         * @constructs\n         */\n        constructor: function constructor(url, start, end, opts) {\n            if (!opts) {\n                if ((typeof start === 'undefined' ? 'undefined' : _typeof(start)) === 'object') {\n                    opts = start;\n                    start = undefined;\n                } else {\n                    opts = {};\n                }\n            }\n\n            this.url = url;\n            this.start = start || 0;\n            if (end) {\n                this.end = end;\n            }\n            this.opts = opts;\n        },\n        slice: function slice(s, l) {\n            var ns = this.start,\n                ne = this.end;\n            if (ns && s) {\n                ns = ns + s;\n            } else {\n                ns = s || ns;\n            }\n            if (l && ns) {\n                ne = ns + l - 1;\n            } else {\n                ne = ne || l - 1;\n            }\n            return new XHRBlob(this.url, ns, ne, this.opts);\n        },\n        fetch: function fetch(callback, failCallback) {\n            var length = this.end === undefined ? undefined : this.end - this.start + 1;\n            if (length < 0) {\n                throw new Error('Length less than 0 received');\n            } else if (length == undefined && this.start == 0) {\n                getfetch(this.url).then(function (res) {\n                    return res.arrayBuffer();\n                }).then(callback).catch(failCallback);\n            } else {\n                globalCache.getRange(this.url, this.start, length).then(this._getResponseArrayBuffer.bind(this, callback), failCallback);\n            }\n        },\n        fetchBufferPromise: function fetchBufferPromise() {\n            var _this = this;\n\n            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                var length, _range, range, bytes;\n\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                length = _this.end === undefined ? undefined : _this.end - _this.start + 1;\n                                _context.prev = 1;\n\n                                if (!(length < 0)) {\n                                    _context.next = 6;\n                                    break;\n                                }\n\n                                throw new Error('Length less than 0 received');\n\n                            case 6:\n                                if (!(length == undefined && _this.start == 0)) {\n                                    _context.next = 19;\n                                    break;\n                                }\n\n                                _context.next = 9;\n                                return getfetch(_this.url);\n\n                            case 9:\n                                _range = _context.sent;\n\n                                if (_range.ok) {\n                                    _context.next = 12;\n                                    break;\n                                }\n\n                                throw new Error('HTTP ' + _range.status + ' when fetching ' + _this.url);\n\n                            case 12:\n                                _context.t0 = Buffer;\n                                _context.next = 15;\n                                return _range.arrayBuffer();\n\n                            case 15:\n                                _context.t1 = _context.sent;\n                                return _context.abrupt('return', new _context.t0(_context.t1));\n\n                            case 19:\n                                _context.next = 21;\n                                return globalCache.getRange(_this.url, _this.start, length);\n\n                            case 21:\n                                range = _context.sent;\n                                return _context.abrupt('return', range.buffer);\n\n                            case 23:\n                                _context.next = 31;\n                                break;\n\n                            case 25:\n                                _context.prev = 25;\n                                _context.t2 = _context['catch'](1);\n\n                                if (_context.t2.message) {\n                                    _context.next = 30;\n                                    break;\n                                }\n\n                                bytes = length ? ' bytes ' + _this.start + '-' + _this.end : '';\n                                throw new Error('HTTP ' + _context.t2.status + ' when fetching ' + _context.t2.url + ' ' + bytes);\n\n                            case 30:\n                                throw _context.t2;\n\n                            case 31:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, _this, [[1, 25]]);\n            }))();\n        },\n        _getResponseArrayBuffer: function _getResponseArrayBuffer(callback, _ref3) {\n            var buffer = _ref3.buffer;\n\n            if (buffer.buffer) {\n                var arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n                callback(arrayBuffer);\n            } else throw new Error('could not convert response to ArrayBuffer');\n        },\n        read: function read() {\n            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var length = arguments[1];\n            var callback = arguments[2];\n            var failCallback = arguments[3];\n\n            globalCache.getRange(this.url, this.start + offset, length).then(this._getResponseArrayBuffer.bind(this, callback), failCallback);\n        },\n        readBufferPromise: function readBufferPromise() {\n            var _this2 = this;\n\n            var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var length = arguments[1];\n            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                var range;\n                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                        switch (_context2.prev = _context2.next) {\n                            case 0:\n                                _context2.next = 2;\n                                return globalCache.getRange(_this2.url, _this2.start + offset, length);\n\n                            case 2:\n                                range = _context2.sent;\n                                return _context2.abrupt('return', range.buffer);\n\n                            case 4:\n                            case 'end':\n                                return _context2.stop();\n                        }\n                    }\n                }, _callee2, _this2);\n            }))();\n        },\n        stat: function stat(callback, failCallback) {\n            this.statPromise().then(callback, failCallback);\n        },\n        statPromise: function statPromise() {\n            return globalCache.stat(this.url);\n        }\n    });\n    return XHRBlob;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/XHRBlob.js?");

/***/ }),

/***/ "./src/JBrowse/Util/TextIterator.js":
/*!******************************************!*\
  !*** ./src/JBrowse/Util/TextIterator.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Classes to iterate over records in an array-like structure of bytes (FromBytes).\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    var FromBytes = function FromBytes(args) {\n        this.bytes = args.bytes;\n        this.offset = args.offset || 0;\n        this.length = args.length || this.bytes.length;\n        this._recordSeparator = (args.inputRecordSeparator || \"\\n\").charCodeAt(0);\n        this.returnPartialRecord = args.returnPartialRecord;\n    };\n\n    FromBytes.prototype.getOffset = function () {\n        return this.offset;\n    };\n\n    // get a line of text, properly decoding UTF-8\n    FromBytes.prototype.getline = function () {\n        var bytes = this.bytes;\n        var i = this.offset;\n\n        var line = [];\n        while (i < this.length) {\n            var c1 = bytes[i],\n                c2,\n                c3;\n            if (c1 < 128) {\n                line.push(String.fromCharCode(c1));\n                i++;\n                if (c1 == this._recordSeparator) {\n                    this.offset = i;\n                    return line.join('');\n                }\n            } else if (c1 > 191 && c1 < 224) {\n                c2 = bytes[i + 1];\n                line.push(String.fromCharCode((c1 & 31) << 6 | c2 & 63));\n                i += 2;\n            } else {\n                c2 = bytes[i + 1];\n                c3 = bytes[i + 2];\n                line.push(String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63));\n                i += 3;\n            }\n        }\n\n        // did not get a full line\n        this.offset = i;\n        // return our partial line if we are set to return partial records\n        return this.returnPartialRecord ? line.join('') : null;\n    };\n\n    return {\n        FromBytes: FromBytes\n    };\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Util/TextIterator.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/BAMDriver.js":
/*!************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/BAMDriver.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! ./_MultiIndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, MultiIndexedFileDriver) {\n    return declare(MultiIndexedFileDriver, {\n        name: 'BAM',\n        storeType: 'JBrowse/Store/SeqFeature/BAM',\n\n        fileExtension: 'bam',\n        fileConfKey: 'bam',\n        fileUrlConfKey: 'urlTemplate',\n\n        indexTypes: [{\n            indexExtension: 'bam.bai',\n            indexConfKey: 'bai',\n            indexUrlConfKey: 'baiUrlTemplate'\n        }, {\n            indexExtension: 'bam.csi',\n            indexConfKey: 'csi',\n            indexUrlConfKey: 'csiUrlTemplate'\n        }]\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/BAMDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver.js":
/*!**************************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n        name: 'BGZFASTA',\n        storeType: 'JBrowse/Store/SeqFeature/BgzipIndexedFasta',\n        fileExtension: 'fasta.gz',\n        fileExtensionMap: ['.fasta.gz', '.fa.gz', '.fna.gz', '.mfa.gz'],\n        fileConfKey: 'bgzfa',\n        fileUrlConfKey: 'urlTemplate',\n\n        indexExtension: 'fasta.gz.fai',\n        indexExtensionMap: ['.fasta.gz.fai', '.fa.gz.fai', '.fna.gz.fai', '.mfa.gz.fai'],\n        indexConfKey: 'fai',\n        indexUrlConfKey: 'faiUrlTemplate',\n\n        doubleIndexExtension: 'gzi',\n        doubleIndexExtensionMap: ['.fasta.gz.gzi', '.fa.gz.gzi', '.fna.gz.gzi', '.mfa.gz.gzi'],\n        doubleIndexConfKey: 'gzi',\n        doubleIndexUrlConfKey: 'gziUrlTemplate',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == this.fileExtension) {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', this.fileExtensionMap);\n                if (!basename) return false;\n\n                // go through the configs and see if there is one for an index that seems to match\n                for (var n in configs) {\n                    var c = configs[n];\n                    if (Util.basename(c[this.indexConfKey] ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name : c[this.indexUrlConfKey], this.indexExtensionMap) == basename || Util.basename(c[this.doubleIndexConfKey] ? c[this.doubleIndexConfKey].url || c[this.doubleIndexConfKey].blob.name : c[this.doubleIndexUrlConfKey], this.doubleIndexExtensionMap) == basename) {\n\n                        // it's a match, put it in\n                        c[this.fileConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n                // otherwise make a new store config for it\n                var newName = this.name + '_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    name: newName,\n                    fileBasename: basename\n                };\n                configs[newName][this.fileConfKey] = this._makeBlob(resource);\n\n                return true;\n            } else if (resource.type == this.indexExtension) {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', this.indexExtensionMap);\n                if (!basename) return false;\n\n                for (var n in configs) {\n                    var c = configs[n];\n                    if (Util.basename(c[this.fileConfKey] ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name : c[this.fileConfKey], this.fileExtensionMap) == basename || Util.basename(c[this.doubleIndexConfKey] ? c[this.doubleIndexConfKey].url || c[this.doubleIndexConfKey].blob.name : c[this.doubleIndexUrlConfKey], this.doubleIndexExtensionMap) == basename) {\n\n                        // it's a match, put it in\n                        c[this.indexConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n\n                // otherwise make a new store\n                var newName = this.name + '_' + Util.basename(basename, '.' + this.fileExtension) + '_' + uniqCounter++;\n                configs[newName] = {\n                    name: newName,\n                    type: this.storeType\n                };\n\n                configs[newName][this.indexConfKey] = this._makeBlob(resource);\n                return true;\n            } else if (resource.type == this.doubleIndexExtension) {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', this.doubleIndexExtensionMap);\n                if (!basename) return false;\n\n                for (var n in configs) {\n                    var c = configs[n];\n                    if (Util.basename(c[this.fileConfKey] ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name : c[this.fileConfKey], this.fileExtensionMap) == basename || Util.basename(c[this.indexConfKey] ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name : c[this.indexUrlConfKey], this.indexExtensionMap) == basename) {\n\n                        // it's a match, put it in\n                        c[this.doubleIndexConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n\n                // otherwise make a new store\n                var newName = this.name + '_' + Util.basename(basename, '.' + this.fileExtension) + '_' + uniqCounter++;\n                configs[newName] = {\n                    name: newName,\n                    type: this.storeType\n                };\n\n                configs[newName][this.doubleIndexConfKey] = this._makeBlob(resource);\n                return true;\n            } else return false;\n        },\n\n        // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n        finalizeConfiguration: function finalizeConfiguration(configs) {\n\n            for (var n in configs) {\n                var conf = configs[n];\n                if (conf.type === this.storeType) {\n                    var v1 = conf[this.indexConfKey] || conf[this.indexUrlConfKey];\n                    var v2 = conf[this.fileConfKey] || conf[this.fileUrlConfKey];\n                    var v3 = conf[this.doubleIndexConfKey] || conf[this.doubleIndexUrlConfKey];\n                    if (!(v1 && v2 && v3)) {\n                        delete configs[n];\n                    }\n                }\n            }\n        },\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) && (conf[this.indexConfKey] || conf[this.indexUrlConfKey]) && (conf[this.doubleIndexConfKey] || conf[this.doubleIndexUrlConfKey]);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/GFF3TabixDriver.js":
/*!******************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/GFF3TabixDriver.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! ./_MultiIndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, MultiIndexedFileDriver) {\n    return declare(MultiIndexedFileDriver, {\n        name: 'GFF3+Tabix',\n        storeType: 'JBrowse/Store/SeqFeature/GFF3Tabix',\n\n        fileExtension: 'gff3.gz',\n        fileExtensionMap: ['.gff3.gz', '.gff.gz'],\n        fileConfKey: 'file',\n        fileUrlConfKey: 'urlTemplate',\n        indexTypes: [{\n            indexExtension: 'gff3.gz.tbi',\n            indexExtensionMap: ['.gff3.gz.tbi', '.gff.gz.tbi'],\n            indexConfKey: 'tbi',\n            indexUrlConfKey: 'tbiUrlTemplate'\n        }, {\n            indexExtension: 'gff3.gz.csi',\n            indexExtensionMap: ['.gff3.gz.csi', '.gff.gz.csi'],\n            indexConfKey: 'csi',\n            indexUrlConfKey: 'csiUrlTemplate'\n        }]\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/GFF3TabixDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/IndexedFASTADriver.js":
/*!*********************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/IndexedFASTADriver.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! ./_OptionallyIndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, OptionallyIndexedFileDriver) {\n    return declare(OptionallyIndexedFileDriver, {\n        name: 'FASTA',\n        storeType: 'JBrowse/Store/SeqFeature/IndexedFasta',\n        unindexedStoreType: 'JBrowse/Store/SeqFeature/UnindexedFasta',\n\n        fileExtension: 'fasta',\n        fileConfKey: 'fasta',\n        fileUrlConfKey: 'urlTemplate',\n\n        indexExtension: 'fai',\n        indexConfKey: 'fai',\n        indexUrlConfKey: 'faiUrlTemplate'\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/IndexedFASTADriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js":
/*!*********************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == this.fileExtension) {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '');\n                if (!basename) return false;\n\n                // go through the configs and see if there is one for an index that seems to match\n                for (var n in configs) {\n                    var c = configs[n];\n                    if (Util.basename(c[this.indexConfKey] ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name : c[this.indexUrlConfKey], '.' + this.indexExtension) == basename) {\n                        // it's a match, put it in\n                        c[this.fileConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n                // go through again and look for index files that don't have the base extension in them\n                basename = Util.basename(basename, '.' + this.fileExtension);\n                for (var n in configs) {\n                    var c = configs[n];\n                    if (Util.basename(c[this.indexConfKey] ? c[this.indexConfKey].url || c[this.indexConfKey].blob.name : c[this.indexUrlConfKey], '.' + this.indexExtension) == basename) {\n                        // it's a match, put it in\n                        c[this.fileConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n\n                // otherwise make a new store config for it\n                var newName = this.name + '_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    name: newName,\n                    fileBasename: basename\n                };\n                configs[newName][this.fileConfKey] = this._makeBlob(resource);\n\n                return true;\n            } else if (resource.type == this.indexExtension) {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', '.' + this.indexExtension);\n                if (!basename) return false;\n\n                // go through the configs and look for data files that match like zee.bam -> zee.bam.bai\n                for (var n in configs) {\n                    var c = configs[n];\n                    if (Util.basename(c[this.fileConfKey] ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name : c[this.fileUrlConfKey]) == basename) {\n                        // it's a match, put it in\n                        c[this.indexConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n                // go through again and look for data files that match like zee.bam -> zee.bai\n                for (var n in configs) {\n                    var c = configs[n];\n                    if (Util.basename(c[this.fileConfKey] ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name : c[this.fileUrlConfKey], '.' + this.fileExtension) == basename) {\n                        // it's a match, put it in\n                        c[this.indexConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n\n                // otherwise make a new store\n                var newName = this.name + '_' + Util.basename(basename, '.' + this.fileExtension) + '_' + uniqCounter++;\n                configs[newName] = {\n                    name: newName,\n                    type: this.storeType\n                };\n\n                configs[newName][this.indexConfKey] = this._makeBlob(resource);\n                return true;\n            } else return false;\n        },\n\n        // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n        finalizeConfiguration: function finalizeConfiguration(configs) {\n            var singletonIndexes = {};\n            var singletonIndexCount = 0;\n            var singletonFiles = {};\n            var singletonFileCount = 0;\n            for (var n in configs) {\n                var conf = configs[n];\n                if (conf.type === this.storeType) {\n                    if ((conf[this.indexConfKey] || conf[this.indexUrlConfKey]) && !(conf[this.fileConfKey] || conf[this.fileUrlConfKey])) {\n                        // singleton Index\n                        singletonIndexCount++;\n                        singletonIndexes[n] = conf;\n                    } else if ((conf[this.fileConfKey] || conf[this.fileUrlConfKey]) && !(conf[this.indexConfKey] || conf[this.indexUrlConfKey])) {\n                        // singleton File\n                        singletonFileCount++;\n                        singletonFiles[n] = conf;\n                    }\n                }\n            }\n\n            // if we have a single File and single Index left at the end,\n            // stick them together and we'll see what happens\n            if (singletonFileCount == 1 && singletonIndexCount == 1) {\n                for (var indexName in singletonIndexes) {\n                    for (var fileName in singletonFiles) {\n                        if (singletonIndexes[indexName][this.indexUrlConfKey]) singletonFiles[fileName][this.indexUrlConfKey] = singletonIndexes[indexName][this.indexUrlConfKey];\n                        if (singletonIndexes[indexName][this.indexConfKey]) singletonFiles[fileName][this.indexConfKey] = singletonIndexes[indexName][this.indexConfKey];\n\n                        delete configs[indexName];\n                    }\n                }\n            }\n\n            // delete any remaining singleton Indexes, since they don't have\n            // a hope of working\n            for (var indexName in singletonIndexes) {\n                delete configs[indexName];\n            }\n\n            // delete any remaining singleton Files, unless they are URLs\n            for (var fileName in singletonFiles) {\n                if (!configs[fileName][this.fileUrlConfKey]) delete configs[fileName];\n            }\n        },\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) && (conf[this.indexConfKey] || conf[this.indexUrlConfKey] || conf[this.fileUrlConfKey]);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js":
/*!**************************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == this.fileExtension) {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '');\n                if (!basename) return false;\n\n                // go through the configs and see if there is one for an index that seems to match\n                for (var n in configs) {\n                    var c = configs[n];\n                    for (var m in this.indexTypes) {\n                        var index = this.indexTypes[m];\n                        if (Util.basename(c[index.indexConfKey] ? c[index.indexConfKey].url || c[index.indexConfKey].blob.name : c[index.indexUrlConfKey], index.indexExtensionMap || '.' + index.indexExtension) == basename) {\n                            // it's a match, put it in\n                            c[this.fileConfKey] = this._makeBlob(resource);\n                            return true;\n                        }\n                    }\n                }\n                // go through again and look for index files that don't have the base extension in them\n                basename = Util.basename(basename, this.fileExtensionMap || '.' + this.fileExtension);\n                for (var n in configs) {\n                    var c = configs[n];\n                    for (var _m in this.indexTypes) {\n                        var index = this.indexTypes[_m];\n                        if (Util.basename(c[index.indexConfKey] ? c[index.indexConfKey].url || c[index.indexConfKey].blob.name : c[index.indexUrlConfKey], index.indexExtensionMap || '.' + index.indexExtension) == basename) {\n                            // it's a match, put it in\n                            c[this.fileConfKey] = this._makeBlob(resource);\n                            return true;\n                        }\n                    }\n                }\n\n                // otherwise make a new store config for it\n                var newName = this.name + '_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    name: newName,\n                    fileBasename: basename\n                };\n                configs[newName][this.fileConfKey] = this._makeBlob(resource);\n\n                return true;\n            } else {\n                for (var _m2 in this.indexTypes) {\n                    var index = this.indexTypes[_m2];\n                    if (resource.type == index.indexExtension) {\n                        var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', index.indexExtensionMap || '.' + index.indexExtension);\n                        if (!basename) return false;\n\n                        // go through the configs and look for data files that match like zee.bam -> zee.bam.bai\n                        for (var n in configs) {\n                            var c = configs[n];\n                            if (Util.basename(c[this.fileConfKey] ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name : c[this.fileUrlConfKey]) == basename) {\n                                // it's a match, put it in\n                                c[index.indexConfKey] = this._makeBlob(resource);\n                                return true;\n                            }\n                        }\n                        // go through again and look for data files that match like zee.bam -> zee.bai\n                        for (var n in configs) {\n                            var c = configs[n];\n                            if (Util.basename(c[this.fileConfKey] ? c[this.fileConfKey].url || c[this.fileConfKey].blob.name : c[this.fileUrlConfKey], this.fileExtensionMap || '.' + this.fileExtension) == basename) {\n                                // it's a match, put it in\n                                c[index.indexConfKey] = this._makeBlob(resource);\n                                return true;\n                            }\n                        }\n\n                        // otherwise make a new store\n                        var newName = this.name + '_' + Util.basename(basename, this.fileExtensionMap || '.' + this.fileExtension) + '_' + uniqCounter++;\n                        configs[newName] = {\n                            name: newName,\n                            type: this.storeType\n                        };\n\n                        configs[newName][index.indexConfKey] = this._makeBlob(resource);\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n\n        // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n        finalizeConfiguration: function finalizeConfiguration(configs) {\n            var singletonIndexes = {};\n            var singletonIndexCount = 0;\n            var singletonFiles = {};\n            var singletonFileCount = 0;\n            for (var n in configs) {\n                var conf = configs[n];\n                if (conf.type === this.storeType) {\n                    var flag = false;\n                    for (var m in this.indexTypes) {\n                        var index = this.indexTypes[m];\n                        flag |= !!(conf[index.indexConfKey] || conf[index.indexUrlConfKey]);\n                    }\n                    if (flag && !(conf[this.fileConfKey] || conf[this.fileUrlConfKey])) {\n                        singletonIndexCount++;\n                        singletonIndexes[n] = conf;\n                    }\n\n                    flag = true;\n                    for (var _m3 in this.indexTypes) {\n                        var _index = this.indexTypes[_m3];\n                        flag &= !(conf[_index.indexConfKey] || conf[_index.indexUrlConfKey]);\n                    }\n                    if (flag && !!(conf[this.fileConfKey] || conf[this.fileUrlConfKey])) {\n                        singletonFileCount++;\n                        singletonFiles[n] = conf;\n                    }\n                }\n            }\n\n            // if we have a single File and single Index left at the end,\n            // stick them together and we'll see what happens\n            if (singletonFileCount == 1 && singletonIndexCount == 1) {\n                for (var indexName in singletonIndexes) {\n                    for (var fileName in singletonFiles) {\n                        for (var _m4 in this.indexTypes) {\n                            var _index2 = this.indexTypes[_m4];\n                            if (singletonIndexes[indexName][_index2.indexUrlConfKey]) singletonFiles[fileName][_index2.indexUrlConfKey] = singletonIndexes[indexName][_index2.indexUrlConfKey];\n                            if (singletonIndexes[indexName][_index2.indexConfKey]) singletonFiles[fileName][_index2.indexConfKey] = singletonIndexes[indexName][_index2.indexConfKey];\n\n                            delete configs[indexName];\n                        }\n                    }\n                }\n            }\n\n            // delete any remaining singleton Indexes, since they don't have\n            // a hope of working\n            for (var indexName in singletonIndexes) {\n                delete configs[indexName];\n            }\n\n            // delete any remaining singleton Files, unless they are URLs\n            for (var fileName in singletonFiles) {\n                if (!configs[fileName][this.fileUrlConfKey]) delete configs[fileName];\n            }\n        },\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            var valid = false;\n            for (var m in this.indexTypes) {\n                var index = this.indexTypes[m];\n                valid |= (conf[this.fileConfKey] || conf[this.fileUrlConfKey]) && (conf[index.indexConfKey] || conf[index.indexUrlConfKey] || conf[this.fileUrlConfKey]);\n            }\n            return valid;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver.js":
/*!*******************************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! ./_IndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, _IndexedFileDriver) {\n    return declare(_IndexedFileDriver, {\n\n        // try to merge any singleton file and index stores.  currently can only do this if there is one of each\n        finalizeConfiguration: function finalizeConfiguration(configs) {\n            var singletonIndexes = {};\n            var singletonIndexCount = 0;\n            var singletonFiles = {};\n            var singletonFileCount = 0;\n            for (var n in configs) {\n                var conf = configs[n];\n                if (conf.type === this.storeType) {\n                    if ((conf[this.indexConfKey] || conf[this.indexUrlConfKey]) && !(conf[this.fileConfKey] || conf[this.fileUrlConfKey])) {\n                        // singleton Index\n                        singletonIndexCount++;\n                        singletonIndexes[n] = conf;\n                    } else if ((conf[this.fileConfKey] || conf[this.fileUrlConfKey]) && !(conf[this.indexConfKey] || conf[this.indexUrlConfKey])) {\n                        // singleton File\n                        singletonFileCount++;\n                        singletonFiles[n] = conf;\n                    }\n                }\n            }\n\n            // if we have a single File and single Index left at the end,\n            // stick them together and we'll see what happens\n            if (singletonFileCount == 1 && singletonIndexCount == 1) {\n                for (var indexName in singletonIndexes) {\n                    for (var fileName in singletonFiles) {\n                        if (singletonIndexes[indexName][this.indexUrlConfKey]) singletonFiles[fileName][this.indexUrlConfKey] = singletonIndexes[indexName][this.indexUrlConfKey];\n                        if (singletonIndexes[indexName][this.indexConfKey]) singletonFiles[fileName][this.indexConfKey] = singletonIndexes[indexName][this.indexConfKey];\n\n                        delete configs[indexName];\n                    }\n                }\n            }\n\n            // delete any remaining singleton Indexes, since they don't have\n            // a hope of working\n            for (var indexName in singletonIndexes) {\n                delete configs[indexName];\n            }\n\n            // make any remaining singleton data files be unindexed stores\n            for (var fileName in singletonFiles) {\n                configs[fileName].type = this.unindexedStoreType;\n            }\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf[this.fileConfKey] || conf[this.fileUrlConfKey];\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/_OptionallyIndexedFileDriver.js?");

/***/ })

}]);