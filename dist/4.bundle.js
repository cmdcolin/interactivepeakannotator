(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	"JBrowse/Component":"./src/JBrowse/Component.js",
	"JBrowse/ConfigAdaptor/AdaptorUtil":"./src/JBrowse/ConfigAdaptor/AdaptorUtil.js",
	"JBrowse/ConfigAdaptor/JB_json_v1":"./src/JBrowse/ConfigAdaptor/JB_json_v1.js",
	"JBrowse/ConfigAdaptor/conf":"./src/JBrowse/ConfigAdaptor/conf.js",
	"JBrowse/ConfigManager":"./src/JBrowse/ConfigManager.js",
	"JBrowse/Digest/Crc32":"./src/JBrowse/Digest/Crc32.js",
	"JBrowse/Finisher":"./src/JBrowse/Finisher.js",
	"JBrowse/Model/NestedFrequencyTable":"./src/JBrowse/Model/NestedFrequencyTable.js",
	"JBrowse/Model/SimpleFeature":"./src/JBrowse/Model/SimpleFeature.js",
	"JBrowse/Store":"./src/JBrowse/Store.js",
	"JBrowse/Store/DeferredFeaturesMixin":"./src/JBrowse/Store/DeferredFeaturesMixin.js",
	"JBrowse/Store/DeferredStatsMixin":"./src/JBrowse/Store/DeferredStatsMixin.js",
	"JBrowse/Store/Hash":"./src/JBrowse/Store/Hash.js",
	"JBrowse/Store/LRUCache":"./src/JBrowse/Store/LRUCache.js",
	"JBrowse/Store/LazyArray":"./src/JBrowse/Store/LazyArray.js",
	"JBrowse/Store/SeqFeature":"./src/JBrowse/Store/SeqFeature.js",
	"JBrowse/Store/SeqFeature/REST":"./src/JBrowse/Store/SeqFeature/REST.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[4],{

/***/ "./src/JBrowse/Component.js":
/*!**********************************!*\
  !*** ./src/JBrowse/Component.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * A JBrowse component keeps a reference to the main browser object, and is configurable.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Util) {\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            args = args || {};\n\n            // merge our config with the config defaults\n            this._finalizeConfig(args.config);\n\n            this.browser = args.browser;\n            if (!this.browser) throw \"a reference to the main browser is required by this constructor\";\n\n            this.compiledConfig = {};\n        },\n\n        _finalizeConfig: function _finalizeConfig(config) {\n            this.config = this._mergeConfigs(dojo.clone(this._defaultConfig()), config || {});\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return {\n                baseUrl: '/'\n            };\n        },\n\n        resolveUrl: function resolveUrl(url, args) {\n            args = args || {};\n            return Util.resolveUrl(this.getConf('baseUrl', []), this.fillTemplate(url, args));\n        },\n\n        _mergeConfigs: function _mergeConfigs(a, b) {\n            if (b === null) return null;\n            if (a === null) a = {};\n\n            for (var prop in b) {\n                if (prop in a && \"object\" == _typeof(b[prop]) && \"object\" == _typeof(a[prop])) {\n                    a[prop] = this._mergeConfigs(a[prop], b[prop]);\n                } else if (typeof a[prop] == 'undefined' || typeof b[prop] != 'undefined') {\n                    a[prop] = b[prop];\n                }\n            }\n            return a;\n        },\n\n        _compileConfigurationPath: function _compileConfigurationPath(path) {\n            var confVal = this.config;\n\n            if (typeof path == 'string') path = path.split('.');\n            while (path.length && confVal) {\n                confVal = confVal[path.shift()];\n            }if (path.length) return function () {\n                return null;\n            };\n\n            return typeof confVal == 'function' ? confVal : function () {\n                return confVal;\n            };\n        },\n\n        /**\n         * Given a dot-separated string configuration path into the config\n         * (e.g. \"style.bg_color\"), get the value of the configuration.\n         *\n         * If args are given, evaluate the configuration using them.\n         * Otherwise, return a function that returns the value of the\n         * configuration when called.\n         */\n        getConf: function getConf(path, args) {\n            var func = this.compiledConfig[path];\n            if (!func) {\n                func = this.compiledConfig[path] = this._compileConfigurationPath(path);\n            }\n\n            return args ? func.apply(this, args) : func.call(this);\n        },\n\n        /**\n         * Given a string with templating strings like {refseq}, fill them\n         * in using the given values.\n         *\n         * With no additional values given, knows how to interpolate\n         * {refseq}, {refSeq}, {refSeqNum}, and {refSeqNumNoLeadingZeroes}.\n         *\n         * @param {String} str string to interpolate values into\n         * @param {Object} values optional object with additional values that can be interpolated\n         * @returns new string with interpolations\n         */\n        fillTemplate: function fillTemplate(str, values) {\n\n            // skip if it's not a string or the string has no interpolations\n            if (typeof str != 'string' || str.indexOf('{') == -1) return str;\n\n            // fill in a bunch of args for this.refSeq or this.ref\n            var templateFillArgs = {\n                'refseq': (this.refSeq || {}).name || (this.ref || {}).name || this.ref || ''\n            };\n            templateFillArgs.refSeq = templateFillArgs.refseq;\n\n            if (templateFillArgs.refSeq) {\n                templateFillArgs.refSeqNum = (/\\d+/.exec(templateFillArgs.refSeq) || [])[0] || '';\n            }\n            // make refseqNumNoLeadingZeroes\n            if (templateFillArgs.refSeqNum) {\n                templateFillArgs.refSeqNumNoLeadingZeroes = (/^0*(\\d+)/.exec(templateFillArgs.refSeqNum) || [])[1] || '';\n            }\n\n            if (values) lang.mixin(templateFillArgs, values);\n\n            return Util.fillTemplate(str, templateFillArgs);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Component.js?");

/***/ }),

/***/ "./src/JBrowse/ConfigAdaptor/AdaptorUtil.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/ConfigAdaptor/AdaptorUtil.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojox/lang/functional/object */ \"./node_modules/dojox/lang/functional/object.js\"), __webpack_require__(/*! dojox/lang/functional/fold */ \"./node_modules/dojox/lang/functional/fold.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    var AdaptorUtil;\n    AdaptorUtil = {\n\n        evalHooks: function evalHooks(conf) {\n            for (var x in conf) {\n                if (_typeof(conf[x]) == 'object')\n                    // recur\n                    conf[x] = this.evalHooks(conf[x]);else if (typeof conf[x] == 'string') {\n                    // compile\n                    var spec = conf[x];\n                    if (/^\\s*function\\s*\\(/.test(spec)) {\n                        conf[x] = this.evalHook(spec);\n                    }\n                }\n            }\n            return conf;\n        },\n\n        evalHook: function evalHook() {\n            // can't bind arguments because the closure compiler\n            // renames variables, and we need to assign in the eval\n            if (\"string\" != typeof arguments[0]) return arguments[0];\n            try {\n                eval(\"arguments[0]=\" + arguments[0] + \";\");\n            } catch (e) {\n                console.error(e + \" parsing config callback '\" + arguments[0] + \"'\");\n            }\n            return arguments[0];\n        }\n    };\n    return AdaptorUtil;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/ConfigAdaptor/AdaptorUtil.js?");

/***/ }),

/***/ "./src/JBrowse/ConfigAdaptor/JB_json_v1.js":
/*!*************************************************!*\
  !*** ./src/JBrowse/ConfigAdaptor/JB_json_v1.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var hash = __webpack_require__(/*! object-hash */ \"./node_modules/object-hash/dist/object_hash.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/json */ \"./node_modules/dojo/_base/json.js\"), __webpack_require__(/*! dojo/request */ \"./node_modules/dojo/request.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Digest/Crc32 */ \"./src/JBrowse/Digest/Crc32.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, json, request, Util, digest) {\n\n    var dojof = Util.dojof;\n\n    return declare('JBrowse.ConfigAdaptor.JB_json_v1', null,\n\n    /**\n     * @lends JBrowse.ConfigAdaptor.JB_json_v1.prototype\n     */\n    {\n\n        /**\n         * Configuration adaptor for JBrowse JSON version 1 configuration\n         * files (formerly known as trackList.json files).\n         * @constructs\n         */\n        constructor: function constructor() {},\n\n        /**\n         * Load the configuration file from a URL.\n         *\n         * @param args.config.url {String} URL for fetching the config file.\n         */\n        load: function load( /**Object*/args) {\n            var that = this;\n            if (args.config.url) {\n                var url = Util.resolveUrl(args.baseUrl || window.location.href, args.config.url);\n                return request(url + (args.config.cacheBuster ? '?v=' + Math.random() : ''), { handleAs: 'text', headers: { 'X-Requested-With': null } }).then(function (o) {\n                    o = that.parse_conf(o, args) || {};\n                    o.sourceUrl = url;\n                    o = that.regularize_conf(o, args);\n                    return o;\n                });\n            } else if (args.config.data) {\n                return Util.resolved(this.regularize_conf(args.config.data, args));\n            }\n        },\n\n        /**\n         * In this adaptor, just evals the conf text to parse the JSON, but\n         * other conf adaptors might want to inherit and override this.\n         * @param {String} conf_text the configuration text\n         * @param {Object} load_args the arguments that were passed to <code>load()</code>\n         * @returns {Object} the parsed JSON\n         */\n        parse_conf: function parse_conf(conf_text, load_args) {\n            try {\n                return json.fromJson(conf_text);\n            } catch (e) {\n                throw e + \" when parsing \" + (load_args.config.url || 'configuration') + \".\";\n            }\n        },\n\n        /**\n         * Applies defaults and any other necessary tweaks to the loaded JSON\n         * configuration.  Called by <code>load()</code> on the JSON\n         * configuration before it calls the <code>onSuccess</code> callback.\n         * @param {Object} o the object containing the configuration, which it\n         *                   modifies in-place\n         * @param {Object} load_args the arguments that were passed to <code>load()</code>\n         * @returns the same object it was passed\n         */\n        regularize_conf: function regularize_conf(o, load_args) {\n            // if tracks is not an array, convert it to one\n            if (o.tracks && !lang.isArray(o.tracks)) {\n                // if it's a single track config, wrap it in an arrayref\n                if (o.tracks.label) {\n                    o.tracks = [o.tracks];\n                }\n                // otherwise, coerce it to an array\n                else {\n                        var tracks = [];\n                        for (var label in o.tracks) {\n                            if (!('label' in o.tracks[label])) o.tracks[label].label = label;\n                            tracks.push(o.tracks[label]);\n                        }\n                        o.tracks = tracks;\n                    }\n            }\n\n            // regularize trackMetadata.sources\n            var meta = o.trackMetadata;\n            if (meta && meta.sources) {\n                // if it's a single source config, wrap it in an arrayref\n                if (meta.sources.url || typeof meta.sources == 'string') {\n                    meta.sources = [meta.sources];\n                }\n\n                if (!lang.isArray(meta.sources)) {\n                    var sources = [];\n                    for (var name in meta.sources) {\n                        if (!('name' in meta.sources)) meta.sources[name].name = name;\n                        sources.push(meta.sources[name]);\n                    }\n                    meta.sources = sources;\n                }\n\n                // coerce any string source defs to be URLs, and try to detect their types\n                array.forEach(meta.sources, function (sourceDef, i) {\n                    if (typeof sourceDef == 'string') {\n                        meta.sources[i] = { url: sourceDef };\n                        var typeMatch = sourceDef.match(/\\.(\\w+)$/);\n                        if (typeMatch) meta.sources[i].type = typeMatch[1].toLowerCase();\n                    }\n                });\n            }\n\n            o.sourceUrl = o.sourceUrl || load_args.config.url;\n            o.baseUrl = o.baseUrl || Util.resolveUrl(o.sourceUrl, '.');\n            if (o.baseUrl.length && !/\\/$/.test(o.baseUrl)) o.baseUrl += \"/\";\n\n            if (o.sourceUrl) {\n                // set a default baseUrl in each of the track and store\n                // confs, and the names conf, if needed\n                var addBase = [].concat(o.tracks || []).concat(dojof.values(o.stores || {}));\n                if (o.names) addBase.push(o.names);\n\n                array.forEach(addBase, function (t) {\n                    if (!t.baseUrl) t.baseUrl = o.baseUrl || '/';\n                }, this);\n\n                //resolve the refSeqs and nameUrl if present\n                if (o.refSeqs && typeof o.refSeqs == 'string') o.refSeqs = Util.resolveUrl(o.sourceUrl, o.refSeqs);\n                if (o.nameUrl) o.nameUrl = Util.resolveUrl(o.sourceUrl, o.nameUrl);\n            }\n\n            o = this.regularizeTrackConfigs(o);\n\n            return o;\n        },\n        regularizeTrackConfigs: function regularizeTrackConfigs(conf) {\n            conf.stores = conf.stores || {};\n\n            array.forEach(conf.tracks || [], function (trackConfig) {\n\n                // if there is a `config` subpart,\n                // just copy its keys in to the\n                // top-level config\n                if (trackConfig.config) {\n                    var c = trackConfig.config;\n                    delete trackConfig.config;\n                    for (var prop in c) {\n                        if (!(prop in trackConfig) && c.hasOwnProperty(prop)) {\n                            trackConfig[prop] = c[prop];\n                        }\n                    }\n                }\n\n                // skip if it's a new-style track def\n                if (trackConfig.store) return;\n\n                var trackClassName = this._regularizeClass('JBrowse/View/Track', {\n                    'FeatureTrack': 'JBrowse/View/Track/HTMLFeatures',\n                    'ImageTrack': 'JBrowse/View/Track/FixedImage',\n                    'ImageTrack.Wiggle': 'JBrowse/View/Track/FixedImage/Wiggle',\n                    'SequenceTrack': 'JBrowse/View/Track/Sequence'\n                }[trackConfig.type] || trackConfig.type);\n                trackConfig.type = trackClassName;\n\n                this._synthesizeTrackStoreConfig(conf, trackConfig);\n\n                if (trackConfig.histograms) {\n                    if (!trackConfig.histograms.baseUrl) trackConfig.histograms.baseUrl = trackConfig.baseUrl;\n                    this._synthesizeTrackStoreConfig(conf, trackConfig.histograms);\n                }\n            }, this);\n\n            return conf;\n        },\n\n        _synthesizeTrackStoreConfig: function _synthesizeTrackStoreConfig(mainconf, trackConfig) {\n            // figure out what data store class to use with the track,\n            // applying some defaults if it is not explicit in the\n            // configuration\n            var urlTemplate = trackConfig.urlTemplate;\n            var storeClass = this._regularizeClass('JBrowse/Store', trackConfig.storeClass ? trackConfig.storeClass : /\\/FixedImage/.test(trackConfig.type) ? 'JBrowse/Store/TiledImage/Fixed' + (trackConfig.backendVersion == 0 ? '_v0' : '') : /\\.jsonz?$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/NCList' + (trackConfig.backendVersion == 0 ? '_v0' : '') : /\\.bam$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/BAM' : /\\.cram$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/CRAM' : /\\.gff3?$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/GFF3' : /\\.bed$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/BED' : /\\.vcf.gz$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/VCFTabix' : /\\.gff3?.gz$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/GFF3Tabix' : /\\.bed.gz$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/BEDTabix' : /\\.(bw|bigwig)$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/BigWig' : /\\.(bb|bigbed)$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/BigBed' : /\\.(fa|fasta)$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/IndexedFasta' : /\\.(fa|fasta)\\.gz$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/BgzipIndexedFasta' : /\\.2bit$/i.test(urlTemplate) ? 'JBrowse/Store/SeqFeature/TwoBit' : /\\/Sequence$/.test(trackConfig.type) ? 'JBrowse/Store/Sequence/StaticChunked' : null);\n\n            if (!storeClass) {\n                console.warn(\"Unable to determine an appropriate data store to use with track '\" + trackConfig.label + \"', please explicitly specify a \" + \"storeClass in the configuration.\");\n                return;\n            }\n\n            // synthesize a separate store conf\n            var storeConf = lang.mixin({}, trackConfig);\n            lang.mixin(storeConf, {\n                type: storeClass\n            });\n\n            // if this is the first sequence store we see, and we\n            // have no refseqs store defined explicitly, make this the refseqs store.\n            if ((storeClass == 'JBrowse/Store/Sequence/StaticChunked' || storeClass == 'JBrowse/Store/Sequence/IndexedFasta' || storeClass == 'JBrowse/Store/SeqFeature/IndexedFasta' || storeClass == 'JBrowse/Store/SeqFeature/BgzipIndexedFasta' || storeClass == 'JBrowse/Store/SeqFeature/TwoBit' || storeClass == 'JBrowse/Store/Sequence/TwoBit' || trackConfig.useAsRefSeqStore) && !mainconf.stores['refseqs']) {\n                storeConf.name = 'refseqs';\n            } else {\n                storeConf.name = 'store' + hash(storeConf);\n            }\n            // record it\n            mainconf.stores[storeConf.name] = storeConf;\n\n            // connect it to the track conf\n            trackConfig.store = storeConf.name;\n        },\n\n        _regularizeClass: function _regularizeClass(root, class_) {\n            if (!class_) return null;\n\n            // prefix the class names with JBrowse/* if they contain no slashes\n            if (!/\\//.test(class_)) class_ = root + '/' + class_;\n            class_ = class_.replace(/^\\//);\n            return class_;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/ConfigAdaptor/JB_json_v1.js?");

/***/ }),

/***/ "./src/JBrowse/ConfigAdaptor/conf.js":
/*!*******************************************!*\
  !*** ./src/JBrowse/ConfigAdaptor/conf.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Configuration adaptor for JBrowse's text configuration format.\n * That is, the text configuration format that is not JSON.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\"), __webpack_require__(/*! JBrowse/ConfigAdaptor/JB_json_v1 */ \"./src/JBrowse/ConfigAdaptor/JB_json_v1.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, JSON, JB_json) {\n    return declare([JB_json], {\n\n        _isAlwaysArray: function _isAlwaysArray(varname) {\n            return { include: true }[varname];\n        },\n\n        parse_conf: function parse_conf(text, load_args) {\n            var section = [],\n                keypath,\n                operation,\n                value;\n            var data = {};\n            var lineNumber;\n\n            function recordVal() {\n                if (value !== undefined) {\n                    try {\n                        var match;\n                        // parse json\n                        if (match = value.match(/^json:(.+)/i)) {\n                            value = JSON.parse(match[1]);\n                        }\n                        // parse numbers if it looks numeric\n                        else if (/^[\\+\\-]?[\\d\\.,]+([eE][\\-\\+]?\\d+)?$/.test(value)) value = parseFloat(value.replace(/,/g, ''));\n\n                        var path = section.concat(keypath).join('.');\n                        if (operation == '+=') {\n                            var existing = lang.getObject(path, false, data);\n                            if (existing) {\n                                if (!lang.isArray(existing)) existing = [existing];\n                            } else {\n                                existing = [];\n                            }\n                            existing.push(value);\n                            value = existing;\n                        }\n                        if (value == \"true\") value = true;\n                        if (value == \"false\") value = false;\n                        lang.setObject(path, value, data);\n                    } catch (e) {\n                        throw new Error(\"syntax error\" + ((load_args.config || {}).url ? ' in ' + load_args.config.url : '') + (lineNumber ? \" at line \" + (lineNumber - 1) : ''));\n                    }\n                }\n            }\n\n            array.forEach(text.split(\"\\n\"), function (line, i) {\n                lineNumber = i + 1;\n                line = line.replace(/^\\s*#.+/, '');\n                var match;\n\n                // new section\n                if (match = line.match(/^\\s*\\[([^\\]]+)/)) {\n                    // new section\n                    recordVal();\n                    keypath = value = undefined;\n                    section = match[1].trim().split(/\\s*\\.\\s*/);\n                    if (section.length == 1 && section[0].toLowerCase() == 'general') section = [];\n                }\n                // new value\n                else if (match = line.match(value == undefined ? /^([^\\+=]+)(\\+?=)(.*)/ : /^(\\S[^\\+=]+)(\\+?=)(.*)/)) {\n                        recordVal();\n                        keypath = match[1].trim().split(/\\s*\\.\\s*/);\n                        operation = match[2];\n                        if (this._isAlwaysArray(section.concat(keypath).join('.'))) {\n                            operation = '+=';\n                        }\n                        value = match[3].trim();\n                    }\n                    // add to existing array value\n                    else if (keypath !== undefined && (match = line.match(/^\\s{0,4}\\+\\s*(.+)/))) {\n                            recordVal();\n                            operation = '+=';\n                            value = match[1].trim();\n                        }\n                        // add to existing value\n                        else if (value !== undefined && (match = line.match(/^\\s+(\\S.*)/))) {\n                                value += value.length ? ' ' + match[1].trim() : match[1].trim();\n                            }\n                            // done with last value\n                            else {\n                                    recordVal();\n                                    keypath = value = undefined;\n                                }\n            }, this);\n\n            recordVal();\n\n            return data;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/ConfigAdaptor/conf.js?");

/***/ }),

/***/ "./src/JBrowse/ConfigManager.js":
/*!**************************************!*\
  !*** ./src/JBrowse/ConfigManager.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/ConfigAdaptor/AdaptorUtil */ \"./src/JBrowse/ConfigAdaptor/AdaptorUtil.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, Deferred, all, Util, AdaptorUtil) {\n\n    return declare(null,\n\n    /**\n     * @lends JBrowse.ConfigManager.prototype\n     */\n    {\n\n        /**\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this.bootConfig = lang.clone(args.bootConfig || {});\n            this.defaults = lang.clone(args.defaults || {});\n            this.browser = args.browser;\n            this.skipValidation = args.skipValidation;\n\n            this.bootConfig = this._regularizeIncludes([this.bootConfig])[0];\n            if (this.bootConfig.cacheBuster === false) {\n                this.bootConfig.cacheBuster = false;\n            } else {\n                this.bootConfig.cacheBuster = true;\n            }\n            var thisB = this;\n            this._getConfigAdaptor(this.bootConfig).then(function (adaptor) {\n                thisB.bootConfig = adaptor.regularizeTrackConfigs(thisB.bootConfig);\n            });\n\n            // this.topLevelIncludes = this._fillTemplates(\n            //     lang.clone( this.config.include || this.defaults.include ),\n            //     this._applyDefaults( lang.clone( this.config ), this.defaults )\n            // );\n            // delete this.defaults.include;\n            // delete this.config.include;\n        },\n\n        /**\n         * @param callback {Function} callback, receives a single arguments,\n         * which is the final processed configuration object\n         */\n        getFinalConfig: function getFinalConfig() {\n            return this.finalConfig || (this.finalConfig = function () {\n                var thisB = this;\n                var bootstrapConf = this._applyDefaults(lang.clone(this.bootConfig), this.defaults);\n                return this._loadIncludes(bootstrapConf).then(function (includedConfig) {\n\n                    // merge the boot config *into* the included config last, so\n                    // that values in the boot config override the others\n                    var finalConf = thisB._mergeConfigs(includedConfig, thisB.bootConfig);\n\n                    thisB._fillTemplates(finalConf, finalConf);\n\n                    finalConf = AdaptorUtil.evalHooks(finalConf);\n\n                    if (!thisB.skipValidation) thisB._validateConfig(finalConf);\n\n                    return finalConf;\n                });\n            }.call(this));\n        },\n\n        /**\n         * Instantiate the right config adaptor for a given configuration source.\n         * @param {Object} config the configuraiton\n         * @param {Function} callback called with the new config object\n         * @returns {Object} the right configuration adaptor to use, or\n         * undefined if one could not be found\n         * @private\n         */\n\n        _getConfigAdaptor: function _getConfigAdaptor(config_def, callback) {\n            var adaptor_name = \"JBrowse/ConfigAdaptor/\" + config_def.format;\n            if ('version' in config_def) adaptor_name += '_v' + config_def.version;\n            adaptor_name.replace(/\\W/g, '');\n            return Util.loadJS([adaptor_name]).then(function (modules) {\n                return new modules[0](config_def);\n            });\n        },\n\n        _fillTemplates: function _fillTemplates(subconfig, config) {\n            // skip \"menuTemplate\" keys to prevent messing\n            // up their feature-based {} interpolation\n            //var skip = { menuTemplate: true };\n            var skip = {};\n\n            var type = typeof subconfig === 'undefined' ? 'undefined' : _typeof(subconfig);\n            if (lang.isArray(subconfig)) {\n                for (var i = 0; i < subconfig.length; i++) {\n                    subconfig[i] = this._fillTemplates(subconfig[i], config);\n                }\n            } else if (type == 'object') {\n                for (var name in subconfig) {\n                    if (subconfig.hasOwnProperty(name) && !skip[name]) subconfig[name] = this._fillTemplates(subconfig[name], config);\n                }\n            } else if (type == 'string') {\n                return Util.fillTemplate(subconfig, config);\n            }\n\n            return subconfig;\n        },\n\n        /**\n         * Recursively fetch, parse, and merge all the includes in the given\n         * config object.  Calls the callback with the resulting configuration\n         * when finished.\n         * @private\n         */\n        _loadIncludes: function _loadIncludes(inputConfig) {\n            var thisB = this;\n            inputConfig = lang.clone(inputConfig);\n\n            function _loadRecur(config, upstreamConf) {\n                var sourceUrl = config.sourceUrl || config.baseUrl;\n                var newUpstreamConf = thisB._mergeConfigs(lang.clone(upstreamConf), config);\n                var includes = thisB._fillTemplates(thisB._regularizeIncludes(config.include || []), newUpstreamConf);\n                delete config.include;\n\n                var loads = includes.map(function (include) {\n                    include.cacheBuster = inputConfig.cacheBuster;\n                    return thisB._loadInclude(include, sourceUrl).then(function (includedData) {\n                        return _loadRecur(includedData, newUpstreamConf);\n                    });\n                });\n                return all(loads).then(function (includedDataObjects) {\n                    array.forEach(includedDataObjects, function (includedData) {\n                        config = thisB._mergeConfigs(config, includedData);\n                    });\n                    return config;\n                });\n            }\n\n            return _loadRecur(inputConfig, {});\n        },\n\n        _loadInclude: function _loadInclude(include, baseUrl) {\n            var thisB = this;\n            // instantiate the adaptor and load the config\n            return this._getConfigAdaptor(include).then(function (adaptor) {\n                if (!adaptor) throw new Error(\"Could not load config \" + include.url + \", \" + \"no configuration adaptor found for config format \" + include.format + ' version ' + include.version);\n\n                return adaptor.load({ config: include,\n                    baseUrl: baseUrl\n                });\n            }).then(null, function (error) {\n                try {\n                    if (error.response.status == 404) return {};\n                } catch (e) {}\n\n                throw error;\n            });\n        },\n\n        _regularizeIncludes: function _regularizeIncludes(includes) {\n            if (!includes) return [];\n\n            // coerce include to an array\n            if ((typeof includes === 'undefined' ? 'undefined' : _typeof(includes)) != 'object') includes = [includes];\n\n            // include array might have undefined elements in it if\n            // somebody left a trailing comma in and we are running under\n            // IE\n            includes = array.filter(includes, function (r) {\n                return r;\n            });\n\n            return array.map(includes, function (include) {\n                // coerce bare strings in the includes to URLs\n                if (typeof include == 'string') include = { url: include };\n\n                // set defaults for format and version\n                if (!('format' in include)) {\n                    include.format = /\\.conf$/.test(include.url) ? 'conf' : 'JB_json';\n                }\n                if (include.format == 'JB_json' && !('version' in include)) {\n                    include.version = 1;\n                }\n                return include;\n            });\n        },\n\n        /**\n         * @private\n         */\n        _applyDefaults: function _applyDefaults(config, defaults) {\n            return Util.deepUpdate(dojo.clone(defaults), config);\n        },\n\n        /**\n         * Examine the loaded and merged configuration for errors.  Throws\n         * exceptions if it finds anything amiss.\n         * @private\n         * @returns nothing meaningful\n         */\n        _validateConfig: function _validateConfig(c) {\n            if (!c.tracks) c.tracks = [];\n            if (!c.baseUrl) {\n                this._fatalError('Must provide a `baseUrl` in configuration');\n            }\n            if (this.hasFatalErrors) throw \"Errors in configuration, cannot start.\";\n        },\n\n        /**\n         * @private\n         */\n        _fatalError: function _fatalError(error) {\n            this.hasFatalErrors = true;\n            // if( error.url )\n            //     error = error + ' when loading '+error.url;\n            this.browser.fatalError(error);\n        },\n\n        // list of config properties that should not be recursively merged\n        _noRecursiveMerge: function _noRecursiveMerge(propName) {\n            return propName == 'datasets';\n        },\n\n        /**\n         * Merges config object b into a.  a <- b\n         * @private\n         */\n        _mergeConfigs: function _mergeConfigs(a, b) {\n            if (b === null) return null;\n\n            if (a === null) a = {};\n\n            for (var prop in b) {\n                if (prop == 'tracks' && prop in a) {\n                    a[prop] = this._mergeTrackConfigs(a[prop] || [], b[prop] || []);\n                } else if (!this._noRecursiveMerge(prop) && prop in a && \"object\" == _typeof(b[prop]) && \"object\" == _typeof(a[prop])) {\n                    a[prop] = Util.deepUpdate(a[prop], b[prop]);\n                } else if (prop == 'dataRoot') {\n                    if (a[prop] === undefined || a[prop] == 'data' && b[prop] !== undefined) {\n                        a[prop] = b[prop];\n                    }\n                } else if (a[prop] === undefined || b[prop] !== undefined) {\n                    a[prop] = b[prop];\n                }\n            }\n            return a;\n        },\n\n        /**\n         * Special-case merging of two <code>tracks</code> configuration\n         * arrays.\n         * @private\n         */\n        _mergeTrackConfigs: function _mergeTrackConfigs(a, b) {\n            if (!b.length) return a;\n\n            // index the tracks in `a` by track label\n            var aTracks = {};\n            array.forEach(a, function (t, i) {\n                t.index = i;\n                aTracks[t.label] = t;\n            });\n\n            array.forEach(b, function (bT) {\n                var aT = aTracks[bT.label];\n                if (aT) {\n                    this._mergeConfigs(aT, bT);\n                } else {\n                    a.push(bT);\n                }\n            }, this);\n\n            return a;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/ConfigManager.js?");

/***/ }),

/***/ "./src/JBrowse/Digest/Crc32.js":
/*!*************************************!*\
  !*** ./src/JBrowse/Digest/Crc32.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    var Crc32 = {\n        crc32Table: \"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D\",\n\n        stringToBytes: function stringToBytes(str) {\n            var ch,\n                st,\n                re = [];\n            for (var i = 0; i < str.length; i++) {\n                ch = str.charCodeAt(i); // get char\n                st = []; // set up \"stack\"\n                do {\n                    st.push(ch & 0xFF); // push byte to stack\n                    ch = ch >> 8; // shift value down by 1 byte\n                } while (ch);\n                // add stack contents to result\n                // done because chars have \"wrong\" endianness\n                re = re.concat(st.reverse());\n            }\n            // return an array of bytes\n            return re;\n        },\n\n        crc32_raw: function crc32_raw(bytes, start, end) {\n            var crc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n            var n = 0; //a number between 0 and 255\n            var x = 0; //a hex number\n            var table = Crc32.crc32Table;\n\n            crc = crc ^ -1;\n            for (var i = start, iTop = end; i < iTop; i++) {\n                n = (crc ^ bytes[i]) & 0xFF;\n                x = \"0x\" + table.substr(n * 9, 8);\n                crc = crc >>> 8 ^ x;\n            }\n            crc = crc ^ -1;\n            //convert to unsigned 32-bit int if needed\n            if (crc < 0) {\n                crc += 4294967296;\n            }\n            return crc;\n        },\n\n        crc32: function crc32(str) {\n            var crc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            var bytes = Crc32.stringToBytes(str);\n            var n = 0; //a number between 0 and 255\n            var x = 0; //a hex number\n            var table = Crc32.crc32Table;\n\n            crc = crc ^ -1;\n            for (var i = 0, iTop = bytes.length; i < iTop; i++) {\n                n = (crc ^ bytes[i]) & 0xFF;\n                x = \"0x\" + table.substr(n * 9, 8);\n                crc = crc >>> 8 ^ x;\n            }\n            crc = crc ^ -1;\n            //convert to unsigned 32-bit int if needed\n            if (crc < 0) {\n                crc += 4294967296;\n            }\n            return crc;\n        },\n\n        /**\n         * Does a (deep) crc32 of any object.\n         * @returns {Number}\n         */\n        objectFingerprint: function objectFingerprint(obj) {\n            var crc = 0;\n            if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) == 'object') {\n                for (var prop in obj) {\n                    crc = Crc32.crc32('' + Crc32.objectFingerprint(prop), crc);\n                    crc = Crc32.crc32('' + Crc32.objectFingerprint(obj[prop]), crc);\n                }\n            } else {\n                crc = Crc32.crc32('' + obj, crc);\n            }\n            return crc;\n        }\n    };\n\n    return Crc32;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Digest/Crc32.js?");

/***/ }),

/***/ "./src/JBrowse/Finisher.js":
/*!*********************************!*\
  !*** ./src/JBrowse/Finisher.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare) {\n    return declare(null, {\n        constructor: function constructor(fun) {\n            this.fun = fun;\n            this.count = 0;\n            this.finished = false;\n        },\n        inc: function inc() {\n            this.count++;\n        },\n        dec: function dec() {\n            this.count--;\n            this.finish();\n        },\n        finish: function finish() {\n            if (this.count <= 0 && !this.finished) {\n                this.fun();\n                this.finished = true;\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Finisher.js?");

/***/ }),

/***/ "./src/JBrowse/Model/NestedFrequencyTable.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/Model/NestedFrequencyTable.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Util) {\n\n    // A class that keeps a frequency table.  the categories in the\n    // frequency table can be other frequency tables.\n    // Note that the frequency table acts like a number (its total) when\n    // used as a number or a string.  E.g.  0+table is like table.total()\n\n    var NestedFrequencyTable = Util.fastDeclare({\n\n        constructor: function constructor(initialData) {\n            this._categories = {};\n            if (initialData) dojo.mixin(this._categories, initialData);\n        },\n\n        // get the sum of all the category counts\n        total: function total() {\n            // calculate total if necessary\n            var t = 0;\n            for (var k in this._categories) {\n                var v = this._categories[k];\n                t += v.total ? v.total() : v;\n            }\n            return t;\n        },\n\n        // decrement the count for the given category\n        decrement: function decrement(slotName, amount) {\n            if (!amount) amount = 1;\n\n            if (!slotName) slotName = 'default';else slotName = slotName.toString();\n\n            if (this._categories[slotName]) return this._categories[slotName] = Math.max(0, this._categories[slotName] - amount);else return 0;\n        },\n\n        // increment the count for the given category\n        increment: function increment(slotName, amount) {\n            if (!amount) amount = 1;\n\n            if (!slotName) slotName = 'default';else slotName = slotName.toString();\n            return this._categories[slotName] = (this._categories[slotName] || 0) + amount;\n        },\n\n        // get the value of the given category.  may be a number or a\n        // frequency table.\n        get: function get(slotName) {\n            return this._categories[slotName] || 0;\n        },\n\n        // get a given category as a frequency table\n        getNested: function getNested(path) {\n            if (typeof path == 'string') path = path.split('/');\n\n            if (!path.length) return this;\n\n            var slotName = path[0].toString();\n            var slot = this._categories[slotName];\n            if (!slot || !slot._categories) slot = this._categories[slotName] = new NestedFrequencyTable(slot ? { \"default\": slot + 0 } : {});\n\n            if (path.length > 1) {\n                return slot.getNested(path.slice(1));\n            } else return slot;\n        },\n\n        // returns array of category names that are present\n        categories: function categories() {\n            return Util.dojof.keys(this._categories);\n        },\n\n        toString: function toString() {\n            return this.total().toPrecision(6).toString().replace(/\\.?0+$/, '');\n        },\n\n        valueOf: function valueOf() {\n            return this.total();\n        },\n\n        // iterate through the categories and counts, call like:\n        //\n        //   tbl.forEach( function( count, categoryName ) {\n        //      // do something\n        //   }, this );\n        //\n        forEach: function forEach(func, ctx) {\n            var c = this._categories;\n            if (ctx) {\n                for (var slotName in c) {\n                    func.call(ctx, c[slotName], slotName);\n                }\n            } else {\n                for (var slotName in c) {\n                    func(c[slotName], slotName);\n                }\n            }\n        }\n\n    });\n\n    return NestedFrequencyTable;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/NestedFrequencyTable.js?");

/***/ }),

/***/ "./src/JBrowse/Model/SimpleFeature.js":
/*!********************************************!*\
  !*** ./src/JBrowse/Model/SimpleFeature.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Simple implementation of a feature object.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Util) {\n\n    var counter = 0;\n\n    var SimpleFeature = Util.fastDeclare({\n\n        /**\n         * @param args.data {Object} key-value data, must include 'start' and 'end'\n         * @param args.parent {Feature} optional parent feature\n         * @param args.id {String} optional unique identifier.  can also be in data.uniqueID.\n         *\n         * Note: args.data.subfeatures can be an array of these same args,\n         * which will be inflated to more instances of this class.\n         */\n        constructor: function constructor(args) {\n            args = args || {};\n            this.data = args.data || {};\n            this._parent = args.parent;\n            this._uniqueID = args.id || this.data.uniqueID || (this._parent ? this._parent.id() + '_' + counter++ : 'SimpleFeature_' + counter++);\n\n            // inflate any subfeatures that are not already feature objects\n            var subfeatures;\n            if (subfeatures = this.data.subfeatures) {\n                for (var i = 0; i < subfeatures.length; i++) {\n                    if (typeof subfeatures[i].get != 'function') {\n                        subfeatures[i] = new SimpleFeature({ data: subfeatures[i],\n                            parent: this\n                        });\n                    }\n                }\n            }\n        },\n\n        /**\n         * Get a piece of data about the feature.  All features must have\n         * 'start' and 'end', but everything else is optional.\n         */\n        get: function get(name) {\n            return this.data[name.toLowerCase()];\n        },\n\n        /**\n         * Set an item of data.\n         */\n        set: function set(name, val) {\n            this.data[name] = val;\n        },\n\n        /**\n         * Get an array listing which data keys are present in this feature.\n         */\n        tags: function tags() {\n            var t = [];\n            var d = this.data;\n            for (var k in d) {\n                if (d.hasOwnProperty(k)) t.push(k);\n            }\n            return t;\n        },\n\n        /**\n         * Get the unique ID of this feature.\n         */\n        id: function id(newid) {\n            if (newid) this._uniqueID = newid;\n            return this._uniqueID;\n        },\n\n        /**\n         * Get this feature's parent feature, or undefined if none.\n         */\n        parent: function parent() {\n            return this._parent;\n        },\n\n        /**\n         * Get an array of child features, or undefined if none.\n         */\n        children: function children() {\n            return this.get('subfeatures');\n        },\n\n        toJSON: function toJSON() {\n            var d = Object.assign({}, this);\n            delete d._parent;\n            return d;\n        }\n\n    });\n\n    return SimpleFeature;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/SimpleFeature.js?");

/***/ }),

/***/ "./src/JBrowse/Store.js":
/*!******************************!*\
  !*** ./src/JBrowse/Store.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Component */ \"./src/JBrowse/Component.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Component) {\n\n    var uniqCounter = 0;\n    return declare(Component,\n\n    /**\n     * @lends JBrowse.Store.prototype\n     */\n    {\n        namePrefix: 'store-',\n\n        /**\n         * Base class for all JBrowse data stores.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this.refSeq = dojo.clone(args.refSeq);\n            this.name = args.name || this.namePrefix + ++uniqCounter;\n            this.changeCallback = args.changeCallback || function () {};\n        },\n\n        // not really utilized.  ignore for now\n        notifyChanged: function notifyChanged(changeDescription) {\n            if (this.changeCallback) this.changeCallback(changeDescription);\n        },\n\n        /**\n         * If this store has any internal deferreds, resolves them all\n         * with the given error.\n         */\n        _failAllDeferred: function _failAllDeferred(error) {\n            var deferreds = this._deferred || {};\n            for (var dname in deferreds) {\n                if (deferreds.hasOwnProperty(dname)) {\n                    deferreds[dname].reject(error);\n                }\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store.js?");

/***/ }),

/***/ "./src/JBrowse/Store/DeferredFeaturesMixin.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/DeferredFeaturesMixin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Mixin for a store class that needs to load some remote stuff (or do\n * some other kind of asynchronous thing) before its features are\n * available through getFeatures,\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Deferred) {\n\n    return declare(null, {\n\n        // note that dojo.declare automatically chains constructors\n        // without needing inherited()\n        constructor: function constructor(args) {\n            this._deferFeatures();\n        },\n\n        /**\n         * sets us up to defer calls to getFeatures().  calls will be\n         * queued until the Deferred is resolved.\n         */\n        _deferFeatures: function _deferFeatures() {\n            if (!this._deferred) this._deferred = {};\n            this._deferred.features = new Deferred();\n        },\n\n        /**\n         * Runs calls to getFeatures through a Deferred that will queue\n         * and aggregate feature requests until the Deferred is resolved.\n         */\n        getFeatures: function getFeatures(query, featCallback, endCallback, errorCallback) {\n            this._deferred.features.then(dojo.hitch(this, '_getFeatures', query, featCallback, endCallback, errorCallback), errorCallback);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/DeferredFeaturesMixin.js?");

/***/ }),

/***/ "./src/JBrowse/Store/DeferredStatsMixin.js":
/*!*************************************************!*\
  !*** ./src/JBrowse/Store/DeferredStatsMixin.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Mixin for a store class that needs to load some remote stuff (or do\n * some other kind of asynchronous thing) before its stats are\n * available through getGlobalStats or getRegionStats.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Deferred, Util) {\n\n    return declare(null, {\n\n        // note that dojo.declare automatically chains constructors\n        // without needing inherited()\n        constructor: function constructor(args) {\n            this._deferGlobalStats();\n        },\n\n        /**\n         * sets us up to defer calls to getGlobalStats().  calls will be\n         * queued until the Deferred is resolved.\n         */\n        _deferGlobalStats: function _deferGlobalStats() {\n            if (!this._deferred) this._deferred = {};\n            this._deferred.stats = new Deferred();\n        },\n\n        /**\n         * Runs calls to getGlobalStats through a Deferred that will queue\n         * and aggregate stats requests until the Deferred is resolved.\n         */\n        getGlobalStats: function getGlobalStats(successCallback, errorCallback) {\n            var thisB = this;\n            this._deferred.stats.then(dojo.hitch(this, '_getGlobalStats', successCallback, errorCallback), errorCallback);\n        },\n\n        _getGlobalStats: function _getGlobalStats(successCallback, errorCallback) {\n            successCallback(this.globalStats || {});\n        },\n\n        getRegionStats: function getRegionStats(query, successCallback, errorCallback) {\n            var thisB = this;\n            this._deferred.stats.then(dojo.hitch(this, '_getRegionStats', query, successCallback, errorCallback), errorCallback);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/DeferredStatsMixin.js?");

/***/ }),

/***/ "./src/JBrowse/Store/Hash.js":
/*!***********************************!*\
  !*** ./src/JBrowse/Store/Hash.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/store/JsonRest */ \"./node_modules/dojo/store/JsonRest.js\"), __webpack_require__(/*! dojo/store/util/QueryResults */ \"./node_modules/dojo/store/util/QueryResults.js\"), __webpack_require__(/*! JBrowse/Digest/Crc32 */ \"./src/JBrowse/Digest/Crc32.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dojoJSONRest, QueryResults, digest, Util) {\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            // make sure url has a trailing slash\n            var url = /\\/$/.test(args.url) ? args.url : args.url + '/';\n            this.bucketStore = new dojoJSONRest({\n                target: url\n            });\n\n            this.meta = {};\n\n            this.browser = args.browser;\n\n            // this.ready is a Deferred that will be resolved when we have\n            // read the meta.json file with the params of this hashstore\n            this.ready = this._readMeta();\n        },\n\n        _readMeta: function _readMeta() {\n            var thisB = this;\n            return this.bucketStore.get('meta.json').then(function (meta) {\n                dojo.mixin(thisB.meta, meta || {});\n                thisB.meta.hash_hex_characters = Math.ceil(thisB.meta.hash_bits / 4);\n            });\n        },\n\n        query: function query(_query, options) {\n            return this.get((_query.name || '').toString()).then(function (value) {\n                return QueryResults((value || {}).exact || []);\n            });\n        },\n\n        get: function get(key) {\n            return this._getBucket(key).then(function (bucket) {\n                return bucket[key];\n            });\n        },\n\n        _getBucket: function _getBucket(key) {\n            var thisB = this;\n            return this.ready.then(function () {\n                var bucketIdent = thisB._hash(key);\n                return thisB.bucketStore.get(thisB._hexToDirPath(bucketIdent)).then(function (value) {\n                    return value;\n                }, function (err) {\n                    if (Util.isElectron() || err.status == 404) {\n                        // 404 is expected if the name is not in the store\n                        return {};\n                    }\n                });\n            });\n        },\n\n        _hexToDirPath: function _hexToDirPath(hex) {\n            // zero-pad the hex string to be 8 chars if necessary\n            while (hex.length < 8) {\n                hex = '0' + hex;\n            }hex = hex.substr(8 - this.meta.hash_hex_characters);\n            var dirpath = [];\n            for (var i = 0; i < hex.length; i += 3) {\n                dirpath.push(hex.substring(i, i + 3));\n            }\n            return dirpath.join('/') + '.json' + (this.meta.compress ? 'z' : '');\n        },\n\n        _hash: function _hash(data) {\n            return digest.objectFingerprint(data).toString(16).toLowerCase().replace('-', 'n');\n        },\n\n        getIdentity: function getIdentity(object) {\n            return object.id;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/Hash.js?");

/***/ }),

/***/ "./src/JBrowse/Store/LRUCache.js":
/*!***************************************!*\
  !*** ./src/JBrowse/Store/LRUCache.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Digest/Crc32 */ \"./src/JBrowse/Digest/Crc32.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Util, digest) {\n\n    return declare(null,\n\n    /**\n     * @lends JBrowse.Store.LRUCache\n     */\n    {\n\n        /**\n         * An LRU cache.\n         *\n         * @param args.fillCallback\n         * @param args.maxSize\n         * @param args.sizeFunction\n         * @param args.keyFunction\n         * @param args.name\n         * @param args.verbose\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this.fill = args.fillCallback;\n            this.maxSize = args.maxSize || 1000000;\n\n            this.verbose = args.verbose;\n\n            this.name = args.name || 'LRUcache';\n\n            this._size = args.sizeFunction || this._size;\n            this._keyString = args.keyFunction || this._keyString;\n\n            this.itemCount = 0;\n            this.size = 0;\n\n            this._cacheByKey = {};\n\n            // each end of a doubly-linked list, sorted in usage order\n            this._cacheOldest = null;\n            this._cacheNewest = null;\n\n            // we aggregate cache fill calls that are in progress, indexed\n            // by cache key\n            this._inProgressFills = {};\n        },\n\n        get: function get(inKey, callback) {\n            var keyString = this._keyString(inKey);\n            var record = this._cacheByKey[keyString];\n\n            if (!record) {\n                this._log('miss', keyString);\n\n                // call our fill callback if we can\n                this._attemptFill(inKey, keyString, callback);\n                return;\n            } else {\n                this._log('hit', keyString);\n                this.touchRecord(record);\n                window.setTimeout(function () {\n                    callback(record.value);\n                }, 1);\n            }\n        },\n\n        query: function query(keyRegex) {\n            var results = [];\n            var cache = this._cacheByKey;\n            for (var k in cache) {\n                if (keyRegex.test(k) && cache.hasOwnProperty(k)) results.push(cache[k]);\n            }\n            return results;\n        },\n\n        forEach: function forEach(func, context) {\n            if (!context) context = this;\n            var i = 0;\n            for (var record = this._cacheNewest; record; record = record.next) {\n                func.call(context, record, i++);\n            }\n        },\n        some: function some(func, context) {\n            if (!context) context = this;\n            var i = 0;\n            for (var record = this._cacheNewest; record; record = record.next) {\n                if (func.call(context, record, i++)) return true;\n            }\n            return false;\n        },\n\n        touch: function touch(inKey) {\n            this.touchRecord(this._cacheByKey[this._keyString(inKey)]);\n        },\n\n        touchRecord: function touchRecord(record) {\n            if (!record) return;\n\n            // already newest, nothing to do\n            if (this._cacheNewest === record) return;\n\n            // take it out of the linked list\n            this._llRemove(record);\n\n            // add it back into the list as newest\n            this._llPush(record);\n        },\n\n        // take a record out of the LRU linked list\n        _llRemove: function _llRemove(record) {\n            if (record.prev) record.prev.next = record.next;\n            if (record.next) record.next.prev = record.prev;\n\n            if (this._cacheNewest === record) this._cacheNewest = record.prev;\n\n            if (this._cacheOldest === record) this._cacheOldest = record.next;\n\n            record.prev = null;\n            record.next = null;\n        },\n\n        _llPush: function _llPush(record) {\n            if (this._cacheNewest) {\n                this._cacheNewest.next = record;\n                record.prev = this._cacheNewest;\n            }\n            this._cacheNewest = record;\n            if (!this._cacheOldest) this._cacheOldest = record;\n        },\n\n        _attemptFill: function _attemptFill(inKey, keyString, callback) {\n            if (this.fill) {\n\n                var fillRecord = this._inProgressFills[keyString] = this._inProgressFills[keyString] || { callbacks: [], running: false };\n\n                fillRecord.callbacks.push(callback);\n\n                if (!fillRecord.running) {\n                    fillRecord.running = true;\n                    this.fill(inKey, dojo.hitch(this, function (keyString, inKey, fillRecord, value, error, hints) {\n                        delete this._inProgressFills[keyString];\n                        fillRecord.running = false;\n\n                        if (value && !(hints && hints.nocache)) {\n                            this._log('fill', keyString);\n                            this.set(inKey, value);\n                        }\n                        array.forEach(fillRecord.callbacks, function (cb) {\n                            try {\n                                cb.call(this, value, error);\n                            } catch (x) {\n                                console.error('' + x, x.stack, x);\n                            }\n                        }, this);\n                    }, keyString, inKey, fillRecord));\n                }\n            } else {\n                try {\n                    callback(undefined);\n                } catch (x) {\n                    console.error(x);\n                }\n            }\n        },\n\n        set: function set(inKey, value) {\n            var keyString = this._keyString(inKey);\n            if (this._cacheByKey[keyString]) {\n                return;\n            }\n\n            // make a cache record for it\n            var size = void 0;\n            try {\n                size = this._size(value);\n            } catch (e) {\n                e.message = 'Error calculating item size: ' + e.message;\n                console.error(e);\n                size = 1;\n            }\n            var record = {\n                value: value,\n                key: inKey,\n                keyString: keyString,\n                size: size\n            };\n\n            if (record.size > this.maxSize) {\n                this._warn('Cache cannot fit', keyString, '(' + Util.addCommas(record.size) + ' > ' + Util.addCommas(this.maxSize) + ')');\n                return;\n            }\n\n            this._log('set', keyString, record, this.size);\n\n            // evict items if necessary\n            this._prune(record.size);\n\n            // put it in the byKey structure\n            this._cacheByKey[keyString] = record;\n\n            // put it in the doubly-linked list\n            this._llPush(record);\n\n            // update our total size and item count\n            this.size += record.size;\n            this.itemCount++;\n\n            return;\n        },\n\n        _keyString: function _keyString(inKey) {\n            var type = typeof inKey === 'undefined' ? 'undefined' : _typeof(inKey);\n            if (type == 'object' && typeof inKey.toUniqueString == 'function') {\n                return inKey.toUniqueString();\n            } else {\n                return digest.objectFingerprint(inKey);\n            }\n        },\n\n        _size: function _size(value) {\n            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n            var sum = 0;\n            if (type == 'object' && type !== null) {\n                var sizeType = _typeof(value.size);\n                if (sizeType == 'number') {\n                    return sizeType;\n                } else if (sizeType == 'function') {\n                    return value.size();\n                } else if (value.byteLength) {\n                    return value.byteLength;\n                } else {\n                    for (var k in value) {\n                        if (value.hasOwnProperty(k)) {\n                            sum += this._size(value[k]);\n                        }\n                    }\n                }\n                return sum;\n            } else if (type == 'string') {\n                return value.length;\n            } else {\n                return 1;\n            }\n        },\n\n        _prune: function _prune(newItemSize) {\n            while (this.size + (newItemSize || 0) > this.maxSize) {\n                var oldest = this._cacheOldest;\n                if (oldest) {\n                    this._log('evict', oldest);\n\n                    // // update the oldest and newest pointers\n                    // if( ! oldest.next ) // if this was also the newest\n                    //     this._cacheNewest = oldest.prev; // probably undef\n                    // this._cacheOldest = oldest.next; // maybe undef\n\n                    // take it out of the linked list\n                    this._llRemove(oldest);\n\n                    // delete it from the byKey structure\n                    delete this._cacheByKey[oldest.keyString];\n\n                    // remove its linked-list links in case that makes it\n                    // easier for the GC\n                    delete oldest.next;\n                    delete oldest.prev;\n\n                    // update our size and item counts\n                    this.itemCount--;\n                    this.size -= oldest.size;\n                } else {\n                    // should usually not be reached\n                    this._error(\"eviction error\", this.size, newItemSize, this);\n                    return;\n                }\n            }\n        },\n\n        _log: function _log() {\n            if (this.verbose) console.log.apply(console, arguments);\n        },\n        _warn: function _warn() {\n            console.warn.apply(console, arguments);\n        },\n        _error: function _error() {\n            console.error.apply(console, arguments);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/LRUCache.js?");

/***/ }),

/***/ "./src/JBrowse/Store/LazyArray.js":
/*!****************************************!*\
  !*** ./src/JBrowse/Store/LazyArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Finisher */ \"./src/JBrowse/Finisher.js\"), __webpack_require__(/*! dojo/_base/xhr */ \"./node_modules/dojo/_base/xhr.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Util, Finisher, xhr) {\n\n    /*\n     * For a JSON array that gets too large to load in one go, this class\n     * helps break it up into chunks and provides an\n     * async API for using the information in the array.\n     */\n\n    /**\n     * Construct a new LazyArray, which partially loads large JSON arrays.\n     * @class\n     * @constructor\n     * @param lazyArrayParams {Object} as:\n     * <ul>\n     * <li><code>urlTemplate</code> - for each lazily-loaded array chunk, the chunk number will get substituted for {chunk} in this template, and the result will beused as the URL of the JSON for that array chunk</li>\n     * <li><code>length</code> - length of the overall array</li>\n     * <li><code>chunkSize</code> - the size of each array chunk</li>\n     * </ul>\n     */\n    var LazyArray = function LazyArray(lazyArrayParams, baseUrl) {\n        this.urlTemplate = lazyArrayParams.urlTemplate;\n        this.chunkSize = lazyArrayParams.chunkSize;\n        this.length = lazyArrayParams.length;\n        this.baseUrl = baseUrl === undefined ? \"\" : baseUrl;\n        // Once a range gets loaded, it goes into the \"chunks\" array.\n        // this.chunks[n] contains data for indices in the range\n        // [n * chunkSize, Math.min(length - 1, (n * (chunkSize + 1)) - 1)]\n        this.chunks = [];\n        // If a range is currently loading, this will contain a property\n        // \"chunk number\": [{start, end, callback, param}, ...]\n        this.toProcess = {};\n    };\n\n    /**\n     * call the callback on one element of the array\n     * @param i index\n     * @param callback callback, gets called with (i, value, param)\n     * @param param (optional) callback will get this as its last parameter\n     */\n    LazyArray.prototype.index = function (i, callback, param) {\n        this.range(i, i, callback, undefined, param);\n    };\n\n    /**\n     * call the callback on each element in the range [start, end]\n     * @param start index of first element to call the callback on\n     * @param end index of last element to call the callback on\n     * @param callback callback, gets called with (i, value, param)\n     * @param postFun (optional) callback that gets called when <code>callback</code> has been run on every element in the range\n     * @param param (optional) callback will get this as its last parameter\n     */\n    LazyArray.prototype.range = function (start, end, callback, postFun, param) {\n        start = Math.max(0, start);\n        end = Math.min(end, this.length - 1);\n\n        var firstChunk = Math.floor(start / this.chunkSize);\n        var lastChunk = Math.floor(end / this.chunkSize);\n\n        if (postFun === undefined) /** @inner */postFun = function postFun() {};\n        var finish = new Finisher(postFun);\n\n        for (var chunk = firstChunk; chunk <= lastChunk; chunk++) {\n            if (this.chunks[chunk]) {\n                // chunk is loaded\n                this._processChunk(start, end, chunk, callback, param);\n            } else {\n                var toProcessInfo = {\n                    start: start,\n                    end: end,\n                    callback: callback,\n                    param: param,\n                    finish: finish\n                };\n\n                finish.inc();\n                if (this.toProcess[chunk]) {\n                    // chunk is currently being loaded\n                    this.toProcess[chunk].push(toProcessInfo);\n                } else {\n                    // start loading chunk\n                    this.toProcess[chunk] = [toProcessInfo];\n                    var url = this.urlTemplate.replace(/\\{Chunk\\}/gi, chunk);\n                    var thisObj = this;\n                    dojo.xhrGet({\n                        url: this.baseUrl ? Util.resolveUrl(this.baseUrl, url) : url,\n                        handleAs: \"json\",\n                        load: this._makeLoadFun(chunk),\n                        error: function error() {\n                            finish.dec();\n                        }\n                    });\n                }\n            }\n        }\n        finish.finish();\n    };\n\n    LazyArray.prototype._makeLoadFun = function (chunk) {\n        var thisObj = this;\n        return function (data) {\n            thisObj.chunks[chunk] = data;\n            var toProcess = thisObj.toProcess[chunk];\n            delete thisObj.toProcess[chunk];\n            for (var i = 0; i < toProcess.length; i++) {\n                thisObj._processChunk(toProcess[i].start, toProcess[i].end, chunk, toProcess[i].callback, toProcess[i].param);\n                toProcess[i].finish.dec();\n            }\n        };\n    };\n\n    LazyArray.prototype._processChunk = function (start, end, chunk, callback, param) {\n        // index (in the overall lazy array) of the first position in this chunk\n        var firstIndex = chunk * this.chunkSize;\n\n        var chunkStart = start - firstIndex;\n        var chunkEnd = end - firstIndex;\n        chunkStart = Math.max(0, chunkStart);\n        chunkEnd = Math.min(chunkEnd, this.chunkSize - 1);\n\n        for (var i = chunkStart; i <= chunkEnd; i++) {\n            callback(i + firstIndex, this.chunks[chunk][i], param);\n        }\n    };\n\n    return LazyArray;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/LazyArray.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature.js":
/*!*****************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store */ \"./src/JBrowse/Store.js\"), __webpack_require__(/*! JBrowse/Store/LRUCache */ \"./src/JBrowse/Store/LRUCache.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Util, Store, LRUCache) {\n\n    /**\n     * Base class for JBrowse data backends that hold sequences and\n     * features.\n     *\n     * @class JBrowse.SeqFeatureStore\n     * @extends JBrowse.Store\n     * @constructor\n     */\n\n    return declare(Store, {\n\n        constructor: function constructor(args) {\n            this.globalStats = {};\n            this.storeTimeout = args.storeTimeout ? args.storeTimeout : 3000;\n            this._featureTransforms = args.featureTransforms || [];\n\n            // install general transform function if defined\n            this._configureFeaturesTransforms();\n        },\n\n        _configureFeaturesTransforms: function _configureFeaturesTransforms() {\n            var featureTransform = this.getConf('featureTransform');\n            if (typeof featureTransform === 'string') {\n                featureTransform = this.getPredefinedFeatureTransform(featureTransform);\n            }\n\n            if (featureTransform) {\n                this.addFeatureTransform(featureTransform);\n            }\n\n            // install `config.topLevelFeatures` transform if necessary\n            this._configureTopLevelFeaturesTransform();\n        },\n\n        /**\n         * get a predefined feature transform function by name, or undef if no\n         * transform by that name is defined\n         * @param {string} name\n         */\n        getPredefinedFeatureTransform: function getPredefinedFeatureTransform(name) {},\n\n\n        /**\n         * Get a metadata object, if one is available, for the\n         * given feature tag name\n         * @param {string} tagName\n         * @returns {object} containing 'description' member, and optionally anything else\n         */\n        getTagMetadata: function getTagMetadata(tagName) {},\n\n\n        /**\n         * If the `topLevelFeatures` configuration variable is set on this\n         * store, creates and installs a feature transform function to\n         * implement it.\n         */\n        _configureTopLevelFeaturesTransform: function _configureTopLevelFeaturesTransform() {\n            var _this = this;\n\n            var confVal = this.getConf('topLevelFeatures', [this]);\n            if (!confVal) return;\n\n            if (typeof confVal === 'function') {\n                this._topLevelFeaturesTransform = confVal;\n            } else {\n                var typesList = void 0;\n                if (Array.isArray(confVal)) {\n                    typesList = confVal;\n                } else if (typeof confVal === 'string') {\n                    typesList = confVal.trim().split(/\\s*,\\s*/);\n                } else {\n                    throw new Error('invalid topLevelFeatures configuration value', confVal);\n                }\n                if (typesList.length) {\n                    this._topLevelFeatureTypes = typesList;\n                    this._topLevelFeaturesTransform = function (features) {\n                        var resultFeatures = [];\n                        features.forEach(function (feature) {\n                            resultFeatures.push.apply(resultFeatures, _toConsumableArray(_this._findSubfeaturesWithTypes(typesList, feature)));\n                        });\n                        return resultFeatures;\n                    };\n                }\n            }\n\n            if (this._topLevelFeaturesTransform) {\n                try {\n                    this.addFeatureTransform(this._topLevelFeaturesTransform);\n                } catch (e) {\n                    throw new Error('store class ' + this.getConf('type') + ' does not support topLevelFeatures configuration');\n                }\n            }\n        },\n\n        _isTopLevelFeatureType: function _isTopLevelFeatureType(featureType) {\n            if (this._topLevelFeatureTypes) {\n                return this._topLevelFeatureTypes.includes(featureType);\n            } else if (this._topLevelFeaturesTransform) {\n                throw new Error('custom top-level feature transforms not supported in this use case');\n            }\n            return true;\n        },\n\n\n        _evalConf: function _evalConf(confVal, confKey) {\n            // evaluate callbacks as functions\n            return typeof confVal == 'function' ? confVal.call(this, this) : confVal;\n        },\n\n        /**\n         * Fetch global statistics the features in this store.\n         *\n         * @param {Function} successCallback(stats) callback to receive the\n         *   statistics.  called with one argument, an object containing\n         *   attributes with various statistics.\n         * @param {Function} errorCallback(error) in the event of an error, this\n         *   callback will be called with one argument, which is anything\n         *   that can stringify to an error message.\n         */\n        getGlobalStats: function getGlobalStats(callback, errorCallback) {\n            callback(this.globalStats || {});\n        },\n\n        /**\n         * Fetch statistics about the features in a specific region.\n         *\n         * @param {String} query.ref    the name of the reference sequence\n         * @param {Number} query.start  start of the region in interbase coordinates\n         * @param {Number} query.end    end of the region in interbase coordinates\n         * @param {Function} successCallback(stats) callback to receive the\n         *   statistics.  called with one argument, an object containing\n         *   attributes with various statistics.\n         * @param {Function} errorCallback(error) in the event of an error, this\n         *   callback will be called with one argument, which is anything\n         *   that can stringify to an error message.\n         */\n        getRegionStats: function getRegionStats(query, successCallback, errorCallback) {\n            return this._getRegionStats.apply(this, arguments);\n        },\n\n        _getRegionStats: function _getRegionStats(query, successCallback, errorCallback) {\n            var thisB = this;\n            var cache = thisB._regionStatsCache = thisB._regionStatsCache || new LRUCache({\n                name: 'regionStatsCache',\n                maxSize: 1000, // cache stats for up to 1000 different regions\n                sizeFunction: function sizeFunction(stats) {\n                    return 1;\n                },\n                fillCallback: function fillCallback(query, callback) {\n                    //console.log( '_getRegionStats', query );\n                    var s = {\n                        scoreMax: -Infinity,\n                        scoreMin: Infinity,\n                        scoreSum: 0,\n                        scoreSumSquares: 0,\n                        basesCovered: query.end - query.start,\n                        featureCount: 0\n                    };\n                    thisB.getFeatures(query, function (feature) {\n                        var score = feature.get('score') || 0;\n                        s.scoreMax = Math.max(score, s.scoreMax);\n                        s.scoreMin = Math.min(score, s.scoreMin);\n                        s.scoreSum += score;\n                        s.scoreSumSquares += score * score;\n                        s.featureCount++;\n                    }, function () {\n                        s.scoreMean = s.featureCount ? s.scoreSum / s.featureCount : 0;\n                        s.scoreStdDev = thisB._calcStdFromSums(s.scoreSum, s.scoreSumSquares, s.featureCount);\n                        s.featureDensity = s.featureCount / s.basesCovered;\n                        //console.log( '_getRegionStats done', s );\n                        callback(s);\n                    }, function (error) {\n                        callback(null, error);\n                    });\n                }\n            });\n\n            cache.get(query, function (stats, error) {\n                if (error) errorCallback(error);else successCallback(stats);\n            });\n        },\n\n        // utility method that calculates standard deviation from sum and sum of squares\n        _calcStdFromSums: function _calcStdFromSums(sum, sumSquares, n) {\n            if (n == 0) return 0;\n\n            var variance = sumSquares - sum * sum / n;\n            if (n > 1) {\n                variance /= n - 1;\n            }\n            return variance < 0 ? 0 : Math.sqrt(variance);\n        },\n\n        /**\n         * Fetch feature data from this store.\n         *\n         * @param {String} query.ref    the name of the reference sequence\n         * @param {Number} query.start  start of the region in interbase coordinates\n         * @param {Number} query.end    end of the region in interbase coordinates\n         * @param {Function} featureCallback(feature) callback that is called once\n         *   for each feature in the region of interest, with a single\n         *   argument; the feature.\n         * @param {Function} endCallback() callback that is called once\n         *   for each feature in the region of interest, with a single\n         *   argument; the feature.\n         * @param {Function} errorCallback(error) in the event of an error, this\n         *   callback will be called with one argument, which is anything\n         *   that can stringify to an error message.\n         */\n        getFeatures: function getFeatures(query, featureCallback, endCallback, errorCallback) {\n            endCallback();\n        },\n\n        /**\n         * Add a transformation function to be applied to features read from the store.\n         */\n        addFeatureTransform: function addFeatureTransform(transformFunction) {\n            if (!this.supportsFeatureTransforms) throw new Error('store class ' + this.getConf('type') + ' does not support feature transforms');\n            this._featureTransforms.push(transformFunction);\n        },\n\n        /**\n         * Apply all of this store's registered transform functions to the set of features\n         * @param {Array[feature]} features\n         */\n        applyFeatureTransforms: function applyFeatureTransforms(features) {\n            var _this2 = this;\n\n            var resultFeatures = features;\n            this._featureTransforms.forEach(function (transformFunction) {\n                resultFeatures = transformFunction.call(_this2, resultFeatures, _this2);\n            });\n            return resultFeatures;\n        },\n\n        /**\n         * Apply the topLevelFeatures configuration to possibly extract\n         * subfeature from this feature, and run the given callback on\n         * each of the new top-level features.\n         *\n         * @param {Array[SimpleFeature|LazyFeature|*]} features\n         * @private\n         */\n        _applyTopLevelFeaturesTransform: function _applyTopLevelFeaturesTransform(features) {\n            var _this3 = this;\n\n            return Util.flattenOneLevel(features.map(function (feature) {\n                return _this3._topLevelFeaturesTransform(feature);\n            }));\n        },\n\n\n        /**\n         * traverse the subfeature hierarchy of the given feature,\n         * return an array of features whose types are in the given list\n         * @param {Array[string]} types\n         * @param {SimpleFeature|LazyFeature|*} feature\n         * @private\n         */\n        _findSubfeaturesWithTypes: function _findSubfeaturesWithTypes(types, feature) {\n            var _this4 = this;\n\n            if (types.includes(feature.get('type'))) return [feature];else {\n                var children = feature.children();\n                if (children && children.length) {\n                    var matchingFeatures = [];\n                    children.forEach(function (childFeature) {\n                        return matchingFeatures.push.apply(matchingFeatures, _toConsumableArray(_this4._findSubfeaturesWithTypes(types, childFeature)));\n                    });\n                    return matchingFeatures;\n                } else return [];\n            }\n        },\n\n\n        /**\n         * Given a plain query object, call back with a single sequence\n         * string that is the naively-assembled sequence for that region,\n         * assembled from the 'residues' or 'seq' attributes of the\n         * features that come back from the store.  Add\n         * \"reference_sequences_only: true\" to the query it send to the\n         * store.\n         */\n        getReferenceSequence: function getReferenceSequence(query, seqCallback, errorCallback) {\n\n            // insert the `replacement` string into `str` at the given\n            // `offset`, putting in `length` characters.\n            function replaceAt(str, offset, replacement) {\n                var rOffset = 0;\n                if (offset < 0) {\n                    rOffset = -offset;\n                    offset = 0;\n                }\n\n                var length = Math.min(str.length - offset, replacement.length - rOffset);\n\n                return str.substr(0, offset) + replacement.substr(rOffset, length) + str.substr(offset + length);\n            }\n\n            // pad with spaces at the beginning of the string if necessary\n            var len = query.end - query.start;\n            var sequence = '';\n            while (sequence.length < len) {\n                sequence += ' ';\n            }var thisB = this;\n            this.getFeatures(lang.mixin({ reference_sequences_only: true }, query), function (f) {\n                var seq = f.get('residues') || f.get('seq');\n                if (seq) sequence = replaceAt(sequence, f.get('start') - query.start, seq);\n            }, function () {\n                seqCallback(sequence);\n            }, errorCallback);\n        },\n        saveStore: function saveStore() {\n            console.log('unimplemented');\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/REST.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/REST.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Store that gets data from any set of web services that implement\n * the JBrowse REST API.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/io-query */ \"./node_modules/dojo/io-query.js\"), __webpack_require__(/*! dojo/request */ \"./node_modules/dojo/request.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Store/LRUCache */ \"./src/JBrowse/Store/LRUCache.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, ioquery, dojoRequest, Deferred, LRUCache, SeqFeatureStore, DeferredFeaturesMixin, DeferredStatsMixin, Util, SimpleFeature) {\n\n    return declare(SeqFeatureStore, {\n\n        constructor: function constructor(args) {\n            this.region_cache_hits = 0; //< stats mostly for unit tests\n\n            // make sure the baseUrl has a trailing slash\n            this.baseUrl = args.baseUrl || this.config.baseUrl;\n            if (this.baseUrl.charAt(this.baseUrl.length - 1) != '/') this.baseUrl = this.baseUrl + '/';\n\n            // enable feature density bin fetching if turned on\n            if (this.config.region_feature_densities && !this.getRegionFeatureDensities) {\n                this.getRegionFeatureDensities = this._getRegionFeatureDensities;\n            }\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return {\n                noCache: false\n            };\n        },\n\n        getGlobalStats: function getGlobalStats(callback, errorCallback) {\n            var url = this._makeURL('stats/global');\n            this._get({ url: url, type: 'globalStats' }, callback, errorCallback);\n        },\n\n        getRegionStats: function getRegionStats(query, successCallback, errorCallback) {\n\n            if (!this.config.region_stats) {\n                this._getRegionStats.apply(this, arguments);\n                return;\n            }\n\n            query = this._assembleQuery(query);\n            var url = this._makeURL('stats/region', query);\n            this._get({ url: url, query: query, type: 'regionStats' }, successCallback, errorCallback);\n        },\n\n        getFeatures: function getFeatures(query, featureCallback, endCallback, errorCallback) {\n            var thisB = this;\n            query = this._assembleQuery(query);\n            var url = this._makeURL('features', query);\n\n            // look for cached feature regions if configured to do so\n            var cachedFeatureRegions;\n            if (this.config.feature_range_cache && !this.config.noCache && (cachedFeatureRegions = this._getCachedFeatureRegions(query))) {\n                this.region_cache_hits++;\n                this._makeFeaturesFromCachedRegions(cachedFeatureRegions, query, featureCallback, endCallback, errorCallback);\n            }\n            // otherwise just fetch and cache like all the other requests\n            else {\n                    this._get({ url: url, query: query, type: 'features' }, dojo.hitch(this, '_makeFeatures', featureCallback, endCallback, errorCallback), errorCallback);\n                }\n        },\n\n        // look in the REST backend's cache for cached feature requests\n        // that are relevant to the given query params (overlap the\n        // start/end region, and match other params).  return an array\n        // like [ {features: [...], start: 123, end: 456 }, ... ]\n        _getCachedFeatureRegions: function _getCachedFeatureRegions(query) {\n            var cache = this._getCache();\n\n            function tilingIsComplete(regions, start, end) {\n                regions.sort(function (a, b) {\n                    return a.start - b.start;\n                });\n                var coverStart = regions[0].start,\n                    coverEnd;\n                var i;\n                var tilingComplete;\n                for (i = 0; !tilingComplete && i < regions.length; i++) {\n                    if (coverEnd === undefined || regions[i].start <= coverEnd && regions[i].end > coverEnd) {\n                        coverEnd = regions[i].end;\n                        tilingComplete = coverStart <= start && coverEnd >= end;\n                    }\n                }\n\n                if (tilingComplete) {\n                    // touch all of the regions we processed in the cache,\n                    // cause we are going to use them\n                    for (i--; i >= 0; i--) {\n                        cache.touchRecord(regions[i].cacheRecord);\n                    }return true;\n                }\n\n                return false;\n            }\n\n            function queriesMatch(q1, q2) {\n                var keys = Util.dojof.keys(q1).concat(Util.dojof.keys(q2));\n                for (var k in q1) {\n                    if (k == 'start' || k == 'end') continue;\n                    if (q1[k] != q2[k]) return false;\n                }\n                for (var k in q2) {\n                    if (k == 'start' || k == 'end') continue;\n                    if (q1[k] != q2[k]) return false;\n                }\n                return true;\n            }\n\n            var relevantRegions = [];\n            if (cache.some(function (cacheRecord) {\n                var cachedRequest = cacheRecord.value.request;\n                var cachedResponse = cacheRecord.value.response;\n                if (cachedRequest.type != 'features' || !cachedResponse) return false;\n                if (!queriesMatch(cachedRequest.query, query)) return false;\n                if (!(cachedRequest.query.end < query.start || cachedRequest.query.start > query.end)) {\n                    relevantRegions.push({ features: cachedResponse.features,\n                        start: cachedRequest.query.start,\n                        end: cachedRequest.query.end,\n                        cacheRecord: cacheRecord\n                    });\n                    if (tilingIsComplete(relevantRegions, query.start, query.end)) return true;\n                }\n                return false;\n            }, this)) {\n                return relevantRegions;\n            }\n            return null;\n        },\n\n        // given an array of records of cached feature data like that\n        // returned by _getCachedFeatureRegions, make feature objects from\n        // them and emit them via the callbacks\n        _makeFeaturesFromCachedRegions: function _makeFeaturesFromCachedRegions(cachedFeatureRegions, query, featureCallback, endCallback, errorCallback) {\n            // gather and uniqify all the relevant feature data objects from the cached regions\n            var seen = {};\n            var featureData = [];\n            array.forEach(cachedFeatureRegions, function (region) {\n                if (region && region.features) {\n                    array.forEach(region.features, function (feature) {\n                        if (!seen[feature.uniqueID]) {\n                            seen[feature.uniqueID] = true;\n                            if (!(feature.start > query.end || feature.end < query.start)) featureData.push(feature);\n                        }\n                    });\n                }\n            });\n\n            // iterate over them and make feature objects from them\n            this._makeFeatures(featureCallback, endCallback, errorCallback, { features: featureData });\n        },\n\n        // this method is copied to getRegionFeatureDensities in the\n        // constructor if config.region_feature_densities is true\n        _getRegionFeatureDensities: function _getRegionFeatureDensities(query, histDataCallback, errorCallback) {\n            var url = this._makeURL('stats/regionFeatureDensities', this._assembleQuery(query));\n            this._get({ url: url }, histDataCallback, errorCallback);\n\n            // query like:\n            //    { ref: 'ctgA, start: 123, end: 456, basesPerBin: 200 }\n\n            // callback like:\n            //   histDataCallback({\n            //     \"bins\":  [ 51,50,58,63,57,57,65,66,63,61,56,49,50,47,39,38,54,41,50,71,61,44,64,60,42 ],\n            //     \"stats\": { \"basesPerBin\":\"200\",\"max\":88,\"mean\":57.772 } //< `max` used to set the Y scale\n            //   });\n\n            // or error like:\n            //   errorCallback( 'aieeee i died' );\n        },\n        // STUB method to satisfy requirements when setting the REST track to a VCF type\n        getVCFHeader: function getVCFHeader(query, filterFunctionCallback, errorCallback) {\n            return new Deferred(function () {/* console.log(\"REST store getVCFHeader\"); */});\n        },\n\n        clearCache: function clearCache() {\n            delete this._cache;\n        },\n\n        // HELPER METHODS\n        _get: function _get(request, callback, errorCallback) {\n            var thisB = this;\n            if (this.config.noCache) dojoRequest(request.url, {\n                method: 'GET',\n                handleAs: 'json'\n            }).then(callback, this._errorHandler(errorCallback));else this._getCache().get(request, function (record, error) {\n                if (error) thisB._errorHandler(errorCallback)(error);else callback(record.response);\n            });\n        },\n\n        _getCache: function _getCache() {\n            var thisB = this;\n            return this._cache || (this._cache = new LRUCache({\n                name: 'REST data cache ' + this.name,\n                maxSize: 25000, // cache up to about 5MB of data (assuming about 200B per feature)\n                sizeFunction: function sizeFunction(data) {\n                    return data.length || 1;\n                },\n                fillCallback: function fillCallback(request, callback) {\n                    var get = dojoRequest(request.url, { method: 'GET', handleAs: 'json' }, true // work around dojo/request bug\n                    );\n                    get.then(function (data) {\n                        var nocacheResponse = /no-cache/.test(get.response.getHeader('Cache-Control')) || /no-cache/.test(get.response.getHeader('Pragma'));\n                        callback({ response: data, request: request }, null, { nocache: nocacheResponse });\n                    }, thisB._errorHandler(lang.partial(callback, null)));\n                }\n            }));\n        },\n\n        _errorHandler: function _errorHandler(handler) {\n            handler = handler || function (e) {\n                console.error(e, e.stack);\n                throw e;\n            };\n            return dojo.hitch(this, function (error) {\n                var httpStatus = ((error || {}).response || {}).status;\n                if (httpStatus >= 400) {\n                    handler(\"HTTP \" + httpStatus + \" fetching \" + error.response.url + \" : \" + error.response.text);\n                } else {\n                    handler(error);\n                }\n            });\n        },\n\n        _assembleQuery: function _assembleQuery(query) {\n            return lang.mixin({ ref: (this.refSeq || {}).name }, this.config.query || {}, query || {});\n        },\n\n        _makeURL: function _makeURL(subpath, query) {\n            var url = this.baseUrl + subpath;\n\n            if (query) {\n                if (query.ref) {\n                    url += '/' + query.ref;\n                    query = lang.mixin({}, query);\n                    delete query.ref;\n                }\n\n                query = ioquery.objectToQuery(query);\n                if (query) url += '?' + query;\n            }\n\n            return url;\n        },\n\n        _makeFeatures: function _makeFeatures(featureCallback, endCallback, errorCallback, featureData) {\n            var features = void 0;\n            if (featureData && (features = featureData.features)) {\n                for (var i = 0; i < features.length; i++) {\n                    var f = this._makeFeature(features[i]);\n                    this.applyFeatureTransforms([f]).forEach(featureCallback);\n                }\n            }\n\n            endCallback();\n        },\n\n        supportsFeatureTransforms: true,\n\n        _parseInt: function _parseInt(data) {\n            array.forEach(['start', 'end', 'strand'], function (field) {\n                if (field in data) data[field] = parseInt(data[field]);\n            });\n            if ('score' in data) data.score = parseFloat(data.score);\n            if ('subfeatures' in data) for (var i = 0; i < data.subfeatures.length; i++) {\n                this._parseInt(data.subfeatures[i]);\n            }\n        },\n\n        _makeFeature: function _makeFeature(data, parent) {\n            this._parseInt(data);\n            return new SimpleFeature({ data: data, parent: parent });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/REST.js?");

/***/ })

}]);