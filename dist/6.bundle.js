(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	"JBrowse/QueryParamConfigMapper":"./src/JBrowse/QueryParamConfigMapper.js",
	"JBrowse/Util/dot-object":"./src/JBrowse/Util/dot-object.js",
	"JBrowse/View/GranularRectLayout":"./src/JBrowse/View/GranularRectLayout.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[6],{

/***/ "./src/JBrowse/QueryParamConfigMapper.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/QueryParamConfigMapper.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * This library interprets options passed in via dot-notation instead of JSON in the Query URL.\n * The implementation is both for readability and security in some systems, esp. tomcat where\n * passing JSON in the Query URL is both bad-form and potentially insecure.\n *\n * This is the dot-object library: https://www.npmjs.com/package/dot-object\n *\n * Usage is depicted here:\n * http://gmod.org/wiki/JBrowse_Configuration_Guide#addFeatures\n *\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Util/dot-object */ \"./src/JBrowse/Util/dot-object.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dotObject) {\n    return declare(null, {\n\n        constructor: function constructor() {},\n\n        generateUrl: function generateUrl(input) {\n            var returnObject = dotObject.dot(input);\n            var returnString;\n            Object.keys(returnObject).forEach(function (key) {\n                var stringEntry = key + '=' + returnObject[key];\n                if (!returnString) {\n                    returnString = stringEntry;\n                } else {\n                    returnString += '&' + stringEntry;\n                }\n            });\n\n            return returnString;\n        },\n\n        generateJsonFromKeyArray: function generateJsonFromKeyArray(inputJson, keyArray, keyDepth, value) {\n            if (!keyArray || keyArray.length == keyDepth) return;\n\n            var firstKey = keyArray[keyDepth - 1];\n            // set value if the last one\n            if (keyArray.length == keyDepth - 1) {\n                inputJson[firstKey] = value;\n                return;\n            }\n\n            // more keys available, so if nothing is set, just set to null\n            if (!inputJson.hasOwnProperty(firstKey)) {\n                inputJson[firstKey] = {};\n            }\n            this.generateJsonFromKeyArray(inputJson[firstKey], keyArray, ++keyDepth, value);\n        },\n\n        mapParam: function mapParam(inputJson, queryParam) {\n            var inputQA = queryParam.split(\"=\");\n            var query = inputQA[0];\n            var value = inputQA[1];\n            dotObject.str(query, value, inputJson);\n        },\n\n        generateJsonFromKey: function generateJsonFromKey(inputJson, keyString) {\n            var allParams = keyString.split(\"\\&\");\n            var mapParamB = this.mapParam;\n            allParams.forEach(function (queryParam) {\n                mapParamB(inputJson, queryParam);\n            });\n        },\n\n        handleQueryParams: function handleQueryParams(config, queryParams) {\n            var queryNameArray, storeName, propertyName, internalStore;\n            var storeTracks = {};\n            var storeBookmarks = {};\n\n            var featuresArray = [];\n            var featureIndex;\n\n            Object.keys(queryParams).forEach(function (queryParam) {\n                if (queryParam.indexOf('addStores\\.') == 0) {\n                    queryNameArray = queryParam.split(\"\\.\");\n                    propertyName = queryNameArray.slice(1).join('.');\n                    dotObject.str('stores.' + propertyName, queryParams[queryParam], config);\n                } else if (queryParam.indexOf('addTracks\\.') == 0) {\n                    queryNameArray = queryParam.split(\"\\.\");\n                    storeName = queryNameArray[1];\n                    internalStore = storeTracks[storeName] ? storeTracks[storeName] : {};\n                    propertyName = queryNameArray.slice(2).join('.');\n                    if (storeName !== 'none') {\n                        dotObject.str('store', storeName, internalStore);\n                    }\n                    dotObject.str(propertyName, queryParams[queryParam], internalStore);\n                    dotObject.str(storeName, internalStore, storeTracks);\n                } else if (queryParam.indexOf('addBookmarks\\.') == 0) {\n                    queryNameArray = queryParam.split(\"\\.\");\n                    storeName = queryNameArray[1];\n                    internalStore = storeBookmarks[storeName] ? storeBookmarks[storeName] : {};\n                    propertyName = queryNameArray.slice(2).join('.');\n                    dotObject.str(propertyName, queryParams[queryParam], internalStore);\n                    dotObject.str(storeName, internalStore, storeBookmarks);\n                } else if (queryParam.indexOf('addFeatures\\.') == 0) {\n                    queryNameArray = queryParam.split(\"\\.\");\n                    featureIndex = queryNameArray[1];\n                    propertyName = queryNameArray.slice(2).join('.');\n                    var feature = featuresArray[featureIndex];\n                    feature = feature ? feature : {};\n                    dotObject.str(propertyName, queryParams[queryParam], feature);\n                    featuresArray[featureIndex] = feature;\n                }\n            });\n\n            // convert to an array\n            if (storeTracks) {\n                // add one for each\n                for (var track in storeTracks) {\n                    if (!config.tracks) {\n                        config.tracks = [];\n                    }\n                    var storeTrack = storeTracks[track];\n                    config.tracks.push(storeTrack);\n                }\n            }\n\n            if (storeBookmarks) {\n                // add one for each\n                for (var bookmark in storeBookmarks) {\n                    if (!config.bookmarks) {\n                        config.bookmarks = {};\n                    }\n                    if (!config.bookmarks.features) {\n                        config.bookmarks.features = [];\n                    }\n                    var storeBookmark = storeBookmarks[bookmark];\n                    // explicitly try to handle loc strings?\n                    config.bookmarks.features.push(storeBookmark);\n                }\n            }\n\n            if (featuresArray.length > 0) {\n                config.stores = config.stores ? config.stores : {};\n                config.stores.url = config.stores.url ? config.stores.url : {};\n                config.stores.url.features = array.filter(featuresArray, function (el) {\n                    return el != null;\n                });\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/QueryParamConfigMapper.js?");

/***/ }),

/***/ "./src/JBrowse/Util/dot-object.js":
/*!****************************************!*\
  !*** ./src/JBrowse/Util/dot-object.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// from: https://unpkg.com/dot-object@1.7.0/dist/dot-object.js\n(function (global, exportName) {\n    'use strict';\n\n    function _process(v, mod) {\n        var i;\n        var r;\n\n        if (typeof mod === 'function') {\n            r = mod(v);\n            if (r !== undefined) {\n                v = r;\n            }\n        } else if (Array.isArray(mod)) {\n            for (i = 0; i < mod.length; i++) {\n                r = mod[i](v);\n                if (r !== undefined) {\n                    v = r;\n                }\n            }\n        }\n\n        return v;\n    }\n\n    function parseKey(key, val) {\n        // detect negative index notation\n        if (key[0] === '-' && Array.isArray(val) && /^-\\d+$/.test(key)) {\n            return val.length + parseInt(key, 10);\n        }\n        return key;\n    }\n\n    function isIndex(k) {\n        return (/^\\d+/.test(k)\n        );\n    }\n\n    function isObject(val) {\n        return Object.prototype.toString.call(val) === '[object Object]';\n    }\n\n    function isArrayOrObject(val) {\n        return Object(val) === val;\n    }\n\n    function isEmptyObject(val) {\n        return Object.keys(val).length === 0;\n    }\n\n    function parsePath(path, sep) {\n        if (path.indexOf('[') >= 0) {\n            path = path.replace(/\\[/g, '.').replace(/]/g, '');\n        }\n        return path.split(sep);\n    }\n\n    function DotObject(seperator, override, useArray) {\n        if (!(this instanceof DotObject)) {\n            return new DotObject(seperator, override, useArray);\n        }\n\n        if (typeof override === 'undefined') override = false;\n        if (typeof useArray === 'undefined') useArray = true;\n        this.seperator = seperator || '.';\n        this.override = override;\n        this.useArray = useArray;\n        this.keepArray = false;\n\n        // contains touched arrays\n        this.cleanup = [];\n    }\n\n    var dotDefault = new DotObject('.', false, true);\n\n    function wrap(method) {\n        return function () {\n            return dotDefault[method].apply(dotDefault, arguments);\n        };\n    }\n\n    DotObject.prototype._fill = function (a, obj, v, mod) {\n        var k = a.shift();\n\n        if (a.length > 0) {\n            obj[k] = obj[k] || (this.useArray && isIndex(a[0]) ? [] : {});\n\n            if (!isArrayOrObject(obj[k])) {\n                if (this.override) {\n                    obj[k] = {};\n                } else {\n                    if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n                        throw new Error('Trying to redefine `' + k + '` which is a ' + _typeof(obj[k]));\n                    }\n\n                    return;\n                }\n            }\n\n            this._fill(a, obj[k], v, mod);\n        } else {\n            if (!this.override && isArrayOrObject(obj[k]) && !isEmptyObject(obj[k])) {\n                if (!(isArrayOrObject(v) && isEmptyObject(v))) {\n                    throw new Error(\"Trying to redefine non-empty obj['\" + k + \"']\");\n                }\n\n                return;\n            }\n\n            obj[k] = _process(v, mod);\n        }\n    };\n\n    /**\n     *\n     * Converts an object with dotted-key/value pairs to it's expanded version\n     *\n     * Optionally transformed by a set of modifiers.\n     *\n     * Usage:\n     *\n     *   var row = {\n     *     'nr': 200,\n     *     'doc.name': '  My Document  '\n     *   }\n     *\n     *   var mods = {\n     *     'doc.name': [_s.trim, _s.underscored]\n     *   }\n     *\n     *   dot.object(row, mods)\n     *\n     * @param {Object} obj\n     * @param {Object} mods\n     */\n    DotObject.prototype.object = function (obj, mods) {\n        var self = this;\n\n        Object.keys(obj).forEach(function (k) {\n            var mod = mods === undefined ? null : mods[k];\n            // normalize array notation.\n            var ok = parsePath(k, self.seperator).join(self.seperator);\n\n            if (ok.indexOf(self.seperator) !== -1) {\n                self._fill(ok.split(self.seperator), obj, obj[k], mod);\n                delete obj[k];\n            } else if (self.override) {\n                obj[k] = _process(obj[k], mod);\n            }\n        });\n\n        return obj;\n    };\n\n    /**\n     * @param {String} path dotted path\n     * @param {String} v value to be set\n     * @param {Object} obj object to be modified\n     * @param {Function|Array} mod optional modifier\n     */\n    DotObject.prototype.str = function (path, v, obj, mod) {\n        if (path.indexOf(this.seperator) !== -1) {\n            this._fill(path.split(this.seperator), obj, v, mod);\n        } else if (!obj.hasOwnProperty(path) || this.override) {\n            obj[path] = _process(v, mod);\n        }\n\n        return obj;\n    };\n\n    /**\n     *\n     * Pick a value from an object using dot notation.\n     *\n     * Optionally remove the value\n     *\n     * @param {String} path\n     * @param {Object} obj\n     * @param {Boolean} remove\n     */\n    DotObject.prototype.pick = function (path, obj, remove) {\n        var i;\n        var keys;\n        var val;\n        var key;\n        var cp;\n\n        keys = parsePath(path, this.seperator);\n        for (i = 0; i < keys.length; i++) {\n            key = parseKey(keys[i], obj);\n            if (obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && key in obj) {\n                if (i === keys.length - 1) {\n                    if (remove) {\n                        val = obj[key];\n                        delete obj[key];\n                        if (Array.isArray(obj)) {\n                            cp = keys.slice(0, -1).join('.');\n                            if (this.cleanup.indexOf(cp) === -1) {\n                                this.cleanup.push(cp);\n                            }\n                        }\n                        return val;\n                    } else {\n                        return obj[key];\n                    }\n                } else {\n                    obj = obj[key];\n                }\n            } else {\n                return undefined;\n            }\n        }\n        if (remove && Array.isArray(obj)) {\n            obj = obj.filter(function (n) {\n                return n !== undefined;\n            });\n        }\n        return obj;\n    };\n\n    /**\n     *\n     * Remove value from an object using dot notation.\n     *\n     * @param {String} path\n     * @param {Object} obj\n     * @return {Mixed} The removed value\n     */\n    DotObject.prototype.remove = function (path, obj) {\n        var i;\n\n        this.cleanup = [];\n        if (Array.isArray(path)) {\n            for (i = 0; i < path.length; i++) {\n                this.pick(path[i], obj, true);\n            }\n            this._cleanup(obj);\n            return obj;\n        } else {\n            return this.pick(path, obj, true);\n        }\n    };\n\n    DotObject.prototype._cleanup = function (obj) {\n        var ret;\n        var i;\n        var keys;\n        var root;\n        if (this.cleanup.length) {\n            for (i = 0; i < this.cleanup.length; i++) {\n                keys = this.cleanup[i].split('.');\n                root = keys.splice(0, -1).join('.');\n                ret = root ? this.pick(root, obj) : obj;\n                ret = ret[keys[0]].filter(function (v) {\n                    return v !== undefined;\n                });\n                this.set(this.cleanup[i], ret, obj);\n            }\n            this.cleanup = [];\n        }\n    };\n\n    // alias method\n    DotObject.prototype.del = DotObject.prototype.remove;\n\n    /**\n     *\n     * Move a property from one place to the other.\n     *\n     * If the source path does not exist (undefined)\n     * the target property will not be set.\n     *\n     * @param {String} source\n     * @param {String} target\n     * @param {Object} obj\n     * @param {Function|Array} mods\n     * @param {Boolean} merge\n     */\n    DotObject.prototype.move = function (source, target, obj, mods, merge) {\n        if (typeof mods === 'function' || Array.isArray(mods)) {\n            this.set(target, _process(this.pick(source, obj, true), mods), obj, merge);\n        } else {\n            merge = mods;\n            this.set(target, this.pick(source, obj, true), obj, merge);\n        }\n\n        return obj;\n    };\n\n    /**\n     *\n     * Transfer a property from one object to another object.\n     *\n     * If the source path does not exist (undefined)\n     * the property on the other object will not be set.\n     *\n     * @param {String} source\n     * @param {String} target\n     * @param {Object} obj1\n     * @param {Object} obj2\n     * @param {Function|Array} mods\n     * @param {Boolean} merge\n     */\n    DotObject.prototype.transfer = function (source, target, obj1, obj2, mods, merge) {\n        if (typeof mods === 'function' || Array.isArray(mods)) {\n            this.set(target, _process(this.pick(source, obj1, true), mods), obj2, merge);\n        } else {\n            merge = mods;\n            this.set(target, this.pick(source, obj1, true), obj2, merge);\n        }\n\n        return obj2;\n    };\n\n    /**\n     *\n     * Copy a property from one object to another object.\n     *\n     * If the source path does not exist (undefined)\n     * the property on the other object will not be set.\n     *\n     * @param {String} source\n     * @param {String} target\n     * @param {Object} obj1\n     * @param {Object} obj2\n     * @param {Function|Array} mods\n     * @param {Boolean} merge\n     */\n    DotObject.prototype.copy = function (source, target, obj1, obj2, mods, merge) {\n        if (typeof mods === 'function' || Array.isArray(mods)) {\n            this.set(target, _process(\n            // clone what is picked\n            JSON.parse(JSON.stringify(this.pick(source, obj1, false))), mods), obj2, merge);\n        } else {\n            merge = mods;\n            this.set(target, this.pick(source, obj1, false), obj2, merge);\n        }\n\n        return obj2;\n    };\n\n    /**\n     *\n     * Set a property on an object using dot notation.\n     *\n     * @param {String} path\n     * @param {Mixed} val\n     * @param {Object} obj\n     * @param {Boolean} merge\n     */\n    DotObject.prototype.set = function (path, val, obj, merge) {\n        var i;\n        var k;\n        var keys;\n        var key;\n\n        // Do not operate if the value is undefined.\n        if (typeof val === 'undefined') {\n            return obj;\n        }\n        keys = parsePath(path, this.seperator);\n\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            if (i === keys.length - 1) {\n                if (merge && isObject(val) && isObject(obj[key])) {\n                    for (k in val) {\n                        if (val.hasOwnProperty(k)) {\n                            obj[key][k] = val[k];\n                        }\n                    }\n                } else if (merge && Array.isArray(obj[key]) && Array.isArray(val)) {\n                    for (var j = 0; j < val.length; j++) {\n                        obj[keys[i]].push(val[j]);\n                    }\n                } else {\n                    obj[key] = val;\n                }\n            } else if (\n            // force the value to be an object\n            !obj.hasOwnProperty(key) || !isObject(obj[key]) && !Array.isArray(obj[key])) {\n                // initialize as array if next key is numeric\n                if (/^\\d+$/.test(keys[i + 1])) {\n                    obj[key] = [];\n                } else {\n                    obj[key] = {};\n                }\n            }\n            obj = obj[key];\n        }\n        return obj;\n    };\n\n    /**\n     *\n     * Transform an object\n     *\n     * Usage:\n     *\n     *   var obj = {\n     *     \"id\": 1,\n     *    \"some\": {\n     *      \"thing\": \"else\"\n     *    }\n     *   }\n     *\n     *   var transform = {\n     *     \"id\": \"nr\",\n     *    \"some.thing\": \"name\"\n     *   }\n     *\n     *   var tgt = dot.transform(transform, obj)\n     *\n     * @param {Object} recipe Transform recipe\n     * @param {Object} obj Object to be transformed\n     * @param {Array} mods modifiers for the target\n     */\n    DotObject.prototype.transform = function (recipe, obj, tgt) {\n        obj = obj || {};\n        tgt = tgt || {};\n        Object.keys(recipe).forEach(function (key) {\n            this.set(recipe[key], this.pick(key, obj), tgt);\n        }.bind(this));\n        return tgt;\n    };\n\n    /**\n     *\n     * Convert object to dotted-key/value pair\n     *\n     * Usage:\n     *\n     *   var tgt = dot.dot(obj)\n     *\n     *   or\n     *\n     *   var tgt = {}\n     *   dot.dot(obj, tgt)\n     *\n     * @param {Object} obj source object\n     * @param {Object} tgt target object\n     * @param {Array} path path array (internal)\n     */\n    DotObject.prototype.dot = function (obj, tgt, path) {\n        tgt = tgt || {};\n        path = path || [];\n        Object.keys(obj).forEach(function (key) {\n            if (isArrayOrObject(obj[key]) && (isObject(obj[key]) && !isEmptyObject(obj[key]) || Array.isArray(obj[key]) && !this.keepArray && obj[key].length !== 0)) {\n                return this.dot(obj[key], tgt, path.concat(key));\n            } else {\n                tgt[path.concat(key).join(this.seperator)] = obj[key];\n            }\n        }.bind(this));\n        return tgt;\n    };\n\n    DotObject.pick = wrap('pick');\n    DotObject.move = wrap('move');\n    DotObject.transfer = wrap('transfer');\n    DotObject.transform = wrap('transform');\n    DotObject.copy = wrap('copy');\n    DotObject.object = wrap('object');\n    DotObject.str = wrap('str');\n    DotObject.set = wrap('set');\n    DotObject.del = DotObject.remove = wrap('remove');\n    DotObject.dot = wrap('dot');\n    ['override', 'overwrite'].forEach(function (prop) {\n        Object.defineProperty(DotObject, prop, {\n            get: function get() {\n                return dotDefault.override;\n            },\n            set: function set(val) {\n                dotDefault.override = !!val;\n            }\n        });\n    });\n    ['useArray', 'keepArray'].forEach(function (prop) {\n        Object.defineProperty(DotObject, prop, {\n            get: function get() {\n                return dotDefault[prop];\n            },\n            set: function set(val) {\n                dotDefault[prop] = val;\n            }\n        });\n    });\n\n    DotObject._process = _process;\n\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return DotObject;\n        }).call(null, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(undefined, 'DotObject');\n\n//# sourceURL=webpack:///./src/JBrowse/Util/dot-object.js?");

/***/ }),

/***/ "./src/JBrowse/View/GranularRectLayout.js":
/*!************************************************!*\
  !*** ./src/JBrowse/View/GranularRectLayout.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* Rectangle-layout manager that lays out rectangles using bitmaps at\n* resolution that, for efficiency, may be somewhat lower than that of\n* the coordinate system for the rectangles being laid out.  `pitchX`\n* and `pitchY` are the ratios of input scale resolution to internal\n* bitmap resolution.\n*/\n\n// minimum excess size of the array at which we garbage collect\nvar minSizeToBotherWith = 10000;\nvar maxFeaturePitchWidth = 20000;\n\n// a single row in the layout\n\nvar LayoutRow = function () {\n    function LayoutRow(rowNumber) {\n        _classCallCheck(this, LayoutRow);\n\n        this.rowNumber = rowNumber;\n        this.padding = 1;\n        this.sizeLimit = 1000000;\n\n        // this.offset is the offset of the bits array relative to the genomic coordinates\n        //      (modified by pitchX, but we don't know that in this class)\n        // this.bits is the array of items in the layout row, indexed by (x - this.offset)\n        // this.min is the leftmost edge of all the rectangles we have in the layout\n        // this.max is the rightmost edge of all the rectangles we have in the layout\n    }\n\n    _createClass(LayoutRow, [{\n        key: 'log',\n        value: function log(msg) {\n            //if (this.rowNumber === 0)\n            console.log('r' + this.rowNumber + ': ' + msg);\n        }\n    }, {\n        key: 'setAllFilled',\n        value: function setAllFilled(data) {\n            this.allFilled = data;\n        }\n    }, {\n        key: 'getItemAt',\n        value: function getItemAt(x) {\n            if (this.allFilled) return this.allFilled;\n            // return (\n            //     this.min !== undefined &&\n            //     x >= this.min &&\n            //     x <= this.max &&\n            //     this.bits[x - this.min]\n            // )\n\n            if (this.min === undefined) return undefined;\n            if (x < this.min) return undefined;\n            if (x >= this.max) return undefined;\n            var offset = x - this.offset;\n            // if (offset < 0)\n            //     debugger\n            // if (offset >= this.bits.length)\n            //     debugger\n            return this.bits[offset];\n        }\n    }, {\n        key: 'isRangeClear',\n        value: function isRangeClear(left, right) {\n            if (this.allFilled) return false;\n\n            if (this.min === undefined) return true;\n\n            if (right <= this.min || left >= this.max) return true;\n\n            // TODO: check right and middle before looping\n            var maxX = Math.min(this.max, right);\n            var x = Math.max(this.min, left);\n            for (; x < right && x < maxX; x += 1) {\n                if (this.getItemAt(x)) return false;\n            }return true;\n        }\n    }, {\n        key: 'initialize',\n        value: function initialize(left, right) {\n            // NOTE: this.min, this.max, and this.offset are interbase coordinates\n            var rectWidth = right - left;\n            this.offset = left - rectWidth;\n            this.min = left;\n            this.max = right;\n            this.bits = new Array(right - left + 2 * rectWidth);\n            // this.log(`initialize ${this.min} - ${this.max} (${this.bits.length})`)\n        }\n    }, {\n        key: 'addRect',\n        value: function addRect(rect, data) {\n            var left = rect.l;\n            var right = rect.r + this.padding; // only padding on the right\n\n            // initialize if necessary\n            if (this.min === undefined) {\n                this.initialize(left, right);\n            } else {\n                // or check if we need to expand to the left and/or to the right\n\n                // expand rightward by the feature length + whole current length if necessary\n                var currLength = this.bits.length;\n\n                if (right - this.offset >= this.bits.length) {\n                    var additionalLength = right - this.offset - this.bits.length + 1 + this.bits.length;\n                    if (this.bits.length + additionalLength > this.sizeLimit) {\n                        console.warn('Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.');\n                        this.initialize(left, right);\n                    } else if (additionalLength > 0) {\n                        this.bits = this.bits.concat(new Array(additionalLength));\n                        // this.log(`expand right (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n                    }\n                }\n\n                // expand by 2x leftward if necessary\n                if (left < this.offset) {\n                    var _additionalLength = this.offset - left + currLength;\n                    if (this.bits.length + _additionalLength > this.sizeLimit) {\n                        console.warn('Layout width limit exceeded, discarding old layout. Please be more careful about discarding unused blocks.');\n                        this.initialize(left, right);\n                    } else {\n                        this.bits = new Array(_additionalLength).concat(this.bits);\n                        this.offset -= _additionalLength;\n                        // this.log(`expand left (${additionalLength}): ${this.offset} | ${this.min} - ${this.max}`)\n                    }\n                }\n            }\n\n            // set the bits in the bitmask\n            var oLeft = left - this.offset;\n            var oRight = right - this.offset;\n            // if (oLeft < 0) debugger\n            // if (oRight < 0) debugger\n            // if (oRight <= oLeft) debugger\n            // if (oRight > this.bits.length) debugger\n            if (oRight - oLeft > maxFeaturePitchWidth) {\n                console.warn('Layout X pitch set too low, feature spans ' + (oRight - oLeft) + ' bits in a single row.', rect, data);\n            }\n\n            for (var x = oLeft; x < oRight; x += 1) {\n                //if (this.bits[x] && this.bits[x].get('name') !== data.get('name')) debugger\n                this.bits[x] = data;\n            }\n\n            if (left < this.min) this.min = left;\n            if (right > this.max) this.max = right;\n            //// this.log(`added ${leftX} - ${rightX}`)\n        }\n\n        /**\n        *  Given a range of interbase coordinates, deletes all data dealing with that range\n        */\n\n    }, {\n        key: 'discardRange',\n        value: function discardRange(left, right) {\n            if (this.allFilled) return; // allFilled is irrevocable currently\n\n            // if we have no data, do nothing\n            if (!this.bits) return;\n\n            // if doesn't overlap at all, do nothing\n            if (right <= this.min || left >= this.max) return;\n\n            // if completely encloses range, discard everything\n            if (left <= this.min && right >= this.max) {\n                this.min = undefined;\n                this.max = undefined;\n                this.bits = undefined;\n                this.offset = undefined;\n                return;\n            }\n\n            // if overlaps left edge, adjust the min\n            if (right > this.min && left <= this.min) {\n                this.min = right;\n            }\n\n            // if overlaps right edge, adjust the max\n            if (left < this.max && right >= this.max) {\n                this.max = left;\n            }\n\n            // now trim the left, right, or both sides of the array\n            if (this.offset < this.min - minSizeToBotherWith && this.bits.length > this.max + minSizeToBotherWith - this.offset) {\n                // trim both sides\n                var leftTrimAmount = this.min - this.offset;\n                var rightTrimAmount = this.bits.length - 1 - (this.max - this.offset);\n                // if (rightTrimAmount <= 0) debugger\n                // if (leftTrimAmount <= 0) debugger\n                // this.log(`trim both sides, ${leftTrimAmount} from left, ${rightTrimAmount} from right`)\n                this.bits = this.bits.slice(leftTrimAmount, this.bits.length - rightTrimAmount);\n                this.offset += leftTrimAmount;\n                // if (this.offset > this.min) debugger\n                // if (this.bits.length <= this.max - this.offset) debugger\n            } else if (this.offset < this.min - minSizeToBotherWith) {\n                // trim left side\n                var desiredOffset = this.min - Math.floor(minSizeToBotherWith / 2);\n                var trimAmount = desiredOffset - this.offset;\n                // this.log(`trim left side by ${trimAmount}`)\n                this.bits.splice(0, trimAmount);\n                this.offset += trimAmount;\n                // if (this.offset > this.min) debugger\n                // if (this.bits.length <= this.max - this.offset) debugger\n            } else if (this.bits.length > this.max - this.offset + minSizeToBotherWith) {\n                // trim right side\n                var desiredLength = this.max - this.offset + 1 + Math.floor(minSizeToBotherWith / 2);\n                // this.log(`trim right side by ${this.bits.length-desiredLength}`)\n                // if (desiredLength > this.bits.length) debugger\n                this.bits.length = desiredLength;\n                // if (this.offset > this.min) debugger\n                // if (this.bits.length <= this.max - this.offset) debugger\n            }\n\n            // if (this.offset > this.min) debugger\n            // if (this.bits.length <= this.max - this.offset) debugger\n\n            // if range now enclosed in the new bounds, loop through and clear the bits\n            var oLeft = Math.max(this.min, left) - this.offset;\n            // if (oLeft < 0) debugger\n            // if (oLeft >= this.bits.length) debugger\n            // if (oRight < 0) debugger\n            // if (oRight >= this.bits.length) debugger\n\n            var oRight = Math.min(right, this.max) - this.offset;\n            for (var x = oLeft; x >= 0 && x < oRight; x += 1) {\n                this.bits[x] = undefined;\n            }\n        }\n    }]);\n\n    return LayoutRow;\n}();\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare) {\n    return declare(null, {\n        /**\n        * @param args.pitchX  layout grid pitch in the X direction\n        * @param args.pitchY  layout grid pitch in the Y direction\n        * @param args.maxHeight  maximum layout height, default Infinity (no max)\n        */\n        constructor: function constructor(args) {\n            this.pitchX = args.pitchX || 10;\n            this.pitchY = args.pitchY || 10;\n\n            this.displayMode = args.displayMode;\n\n            // reduce the pitchY to try and pack the features tighter\n            if (this.displayMode === 'compact') {\n                this.pitchY = Math.round(this.pitchY / 4) || 1;\n                this.pitchX = Math.round(this.pitchX / 4) || 1;\n            }\n\n            // console.log(`pitch: ${this.pitchX} / ${this.pitchY}`)\n\n            this.bitmap = [];\n            this.rectangles = {};\n            this.maxHeight = Math.ceil((args.maxHeight || Infinity) / this.pitchY);\n            this.pTotalHeight = 0; // total height, in units of bitmap squares (px/pitchY)\n        },\n\n\n        /**\n        * @returns {Number} top position for the rect, or Null if laying out the rect would exceed maxHeight\n        */\n        addRect: function addRect(id, left, right, height, data) {\n            // if we have already laid it out, return its layout\n            if (id in this.rectangles) {\n                var storedRec = this.rectangles[id];\n                if (storedRec.top === null) return null;\n\n                // add it to the bitmap again, since that bitmap range may have been discarded\n                this._addRectToBitmap(storedRec, data);\n                return storedRec.top * this.pitchY;\n            }\n\n            var pLeft = Math.floor(left / this.pitchX);\n            var pRight = Math.floor(right / this.pitchX);\n            var pHeight = Math.ceil(height / this.pitchY);\n\n            var midX = Math.floor((pLeft + pRight) / 2);\n            var rectangle = { id: id, l: pLeft, r: pRight, mX: midX, h: pHeight };\n            if (data) rectangle.data = data;\n\n            var maxTop = this.maxHeight - pHeight;\n            var top = 0;\n            for (; top <= maxTop; top += 1) {\n                if (!this._collides(rectangle, top)) break;\n            }\n\n            if (top > maxTop) {\n                rectangle.top = top = null;\n                this.rectangles[id] = rectangle;\n                this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight);\n                return null;\n            }\n            rectangle.top = top;\n            this._addRectToBitmap(rectangle, data);\n            this.rectangles[id] = rectangle;\n            this.pTotalHeight = Math.max(this.pTotalHeight || 0, top + pHeight);\n            // console.log(`G2 ${data.get('name')} ${top}`)\n            return top * this.pitchY;\n        },\n        _collides: function _collides(rect, top) {\n            if (this.displayMode === 'collapsed') return false;\n\n            var bitmap = this.bitmap;\n            // var mY = top + rect.h/2; // Y midpoint: ( top+height  + top ) / 2\n\n            // test exhaustively\n            var maxY = top + rect.h;\n            for (var y = top; y < maxY; y += 1) {\n                var row = bitmap[y];\n                if (row && !row.isRangeClear(rect.l, rect.r)) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n\n        /**\n        * make a subarray if it does not exist\n        * @private\n        */\n        _autovivifyRow: function _autovivifyRow(bitmap, y) {\n            var row = bitmap[y];\n            if (!row) {\n                row = new LayoutRow(y);\n                bitmap[y] = row;\n            }\n            return row;\n        },\n        _addRectToBitmap: function _addRectToBitmap(rect, data) {\n            if (rect.top === null) return;\n\n            data = data || true;\n            var bitmap = this.bitmap;\n            var av = this._autovivifyRow;\n            var yEnd = rect.top + rect.h;\n            if (rect.r - rect.l > maxFeaturePitchWidth) {\n                // the rect is very big in relation to the view size, just\n                // pretend, for the purposes of layout, that it extends\n                // infinitely.  this will cause weird layout if a user\n                // scrolls manually for a very, very long time along the\n                // genome at the same zoom level.  but most users will not\n                // do that.  hopefully.\n                for (var y = rect.top; y < yEnd; y += 1) {\n                    av(bitmap, y).setAllFilled(data);\n                }\n            } else {\n                for (var _y = rect.top; _y < yEnd; _y += 1) {\n                    av(bitmap, _y).addRect(rect, data);\n                }\n            }\n        },\n\n\n        /**\n        *  Given a range of X coordinates, deletes all data dealing with\n        *  the features.\n        */\n        discardRange: function discardRange(left, right) {\n            // console.log( 'discard', left, right );\n            var pLeft = Math.floor(left / this.pitchX);\n            var pRight = Math.floor(right / this.pitchX);\n            var bitmap = this.bitmap;\n            for (var y = 0; y < bitmap.length; y += 1) {\n                var row = bitmap[y];\n                if (row) row.discardRange(pLeft, pRight);\n            }\n        },\n        hasSeen: function hasSeen(id) {\n            return !!this.rectangles[id];\n        },\n        getByCoord: function getByCoord(x, y) {\n            var pY = Math.floor(y / this.pitchY);\n            var row = this.bitmap[pY];\n            if (!row) return undefined;\n            var pX = Math.floor(x / this.pitchX);\n            return row.getItemAt(pX);\n        },\n        getByID: function getByID(id) {\n            var r = this.rectangles[id];\n            if (r) {\n                return r.data || true;\n            }\n            return undefined;\n        },\n        cleanup: function cleanup() {},\n        getTotalHeight: function getTotalHeight() {\n            return this.pTotalHeight * this.pitchY;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/GranularRectLayout.js?");

/***/ })

}]);