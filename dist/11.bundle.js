(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	// "../img/commonIconsDisabled.png" = "./img/commonIconsDisabled.png"
	// "../img/commonIconsEnabled.png" = "./img/commonIconsEnabled.png"
	// "../img/dark_20x2.png" = "./img/dark_20x2.png"
	// "../img/dblhelix-red.png" = "./img/dblhelix-red.png"
	// "../img/glyph-diamond.png" = "./img/glyph-diamond.png"
	// "../img/glyphs_white.png" = "./img/glyphs_white.png"
	// "../img/helix3-green.png" = "./img/helix3-green.png"
	// "../img/loops.png" = "./img/loops.png"
	// "../img/minus-arrowhead.png" = "./img/minus-arrowhead.png"
	// "../img/minus-cds0.png" = "./img/minus-cds0.png"
	// "../img/minus-cds1.png" = "./img/minus-cds1.png"
	// "../img/minus-cds2.png" = "./img/minus-cds2.png"
	// "../img/minus-chevron3.png" = "./img/minus-chevron3.png"
	// "../img/plus-arrowhead.png" = "./img/plus-arrowhead.png"
	// "../img/plus-cds0.png" = "./img/plus-cds0.png"
	// "../img/plus-cds1.png" = "./img/plus-cds1.png"
	// "../img/plus-cds2.png" = "./img/plus-cds2.png"
	// "../img/plus-chevron3.png" = "./img/plus-chevron3.png"
	// "../img/red_crosshatch_bg.png" = "./img/red_crosshatch_bg.png"
	// "../img/scroll_zoom_sprites.png" = "./img/scroll_zoom_sprites.png"
	// "../img/spinner.gif" = "./img/spinner.gif"
	// "../img/spriteArrows.png" = "./img/spriteArrows.png"
	// "../img/tracklist_bg.png" = "./img/tracklist_bg.png"
	// "../img/tristate.png" = "./img/tristate.png"
	// "!!../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/lib/loader.js!./genome.scss" = "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./css/genome.scss"
	"dojo/query!css2":"./node_modules/dojo-webpack-plugin/loaders/dojo/loaderProxy/index.js?loader=dojo%2Fquery&name=css2!./",
	"dojo/loaderProxy?loader=dojo%2Fquery&name=css2!":"./node_modules/dojo-webpack-plugin/loaders/dojo/loaderProxy/index.js?loader=dojo%2Fquery&name=css2!./",
	// "!style-loader!css-loader!sass-loader!../../css/genome.scss" = "./node_modules/style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./css/genome.scss"
	"CategoryUrl/main":"./plugins/CategoryUrl/js/main.js",
	"DebugEvents/main":"./plugins/DebugEvents/js/main.js",
	"HideTrackLabels/main":"./plugins/HideTrackLabels/js/main.js",
	"InteractivePeakAnnotator/Store/SeqFeature/Features":"./plugins/InteractivePeakAnnotator/js/Store/SeqFeature/Features.js",
	"InteractivePeakAnnotator/View/Track/MultiXYPlot":"./plugins/InteractivePeakAnnotator/js/View/Track/MultiXYPlot.js",
	"InteractivePeakAnnotator/View/Track/XYPlot":"./plugins/InteractivePeakAnnotator/js/View/Track/XYPlot.js",
	"InteractivePeakAnnotator/main":"./plugins/InteractivePeakAnnotator/js/main.js",
	"MultiBigWig/Store/SeqFeature/MultiBigWig":"./plugins/MultiBigWig/js/Store/SeqFeature/MultiBigWig.js",
	"MultiBigWig/View/Dialog/MaxScoreDialog":"./plugins/MultiBigWig/js/View/Dialog/MaxScoreDialog.js",
	"MultiBigWig/View/Track/MultiWiggle/MultiDensity":"./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiDensity.js",
	"MultiBigWig/View/Track/MultiWiggle/MultiXYPlot":"./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiXYPlot.js",
	"MultiBigWig/View/Track/MultiWiggleBase":"./plugins/MultiBigWig/js/View/Track/MultiWiggleBase.js",
	"MultiBigWig/main":"./plugins/MultiBigWig/js/main.js",
	"NeatCanvasFeatures/View/FeatureGlyph/Box":"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Box.js",
	"NeatCanvasFeatures/View/FeatureGlyph/Gene":"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Gene.js",
	"NeatCanvasFeatures/View/FeatureGlyph/ProcessedTranscript":"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/ProcessedTranscript.js",
	"NeatCanvasFeatures/View/FeatureGlyph/Segments":"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Segments.js",
	"NeatCanvasFeatures/View/FeatureGlyph/UnprocessedTranscript":"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/UnprocessedTranscript.js",
	"NeatCanvasFeatures/View/Track/NeatFeatures":"./plugins/NeatCanvasFeatures/js/View/Track/NeatFeatures.js",
	"NeatCanvasFeatures/main":"./plugins/NeatCanvasFeatures/js/main.js",
	"NeatHTMLFeatures/View/Track/NeatFeatures":"./plugins/NeatHTMLFeatures/js/View/Track/NeatFeatures.js",
	"NeatHTMLFeatures/main":"./plugins/NeatHTMLFeatures/js/main.js",
	"RegexSequenceSearch/Store/SeqFeature/RegexSearch":"./plugins/RegexSequenceSearch/js/Store/SeqFeature/RegexSearch.js",
	"RegexSequenceSearch/View/SearchSeqDialog":"./plugins/RegexSequenceSearch/js/View/SearchSeqDialog.js",
	"RegexSequenceSearch/main":"./plugins/RegexSequenceSearch/js/main.js",
	"WiggleHighlighter/View/Track/Base":"./plugins/WiggleHighlighter/js/View/Track/Base.js",
	"WiggleHighlighter/View/Track/Density":"./plugins/WiggleHighlighter/js/View/Track/Density.js",
	"WiggleHighlighter/View/Track/MultiDensity":"./plugins/WiggleHighlighter/js/View/Track/MultiDensity.js",
	"WiggleHighlighter/View/Track/MultiXYPlot":"./plugins/WiggleHighlighter/js/View/Track/MultiXYPlot.js",
	"WiggleHighlighter/View/Track/XYPlot":"./plugins/WiggleHighlighter/js/View/Track/XYPlot.js",
	"WiggleHighlighter/main":"./plugins/WiggleHighlighter/js/main.js",
	"vcfview/Store/SeqFeature/Segmentation":"./plugins/vcfview/js/Store/SeqFeature/Segmentation.js",
	"vcfview/Store/SeqFeature/SegmentationMultiBin":"./plugins/vcfview/js/Store/SeqFeature/SegmentationMultiBin.js",
	"vcfview/Store/SeqFeature/vcfview":"./plugins/vcfview/js/Store/SeqFeature/vcfview.js",
	"vcfview/View/Track/SegmentationMultiBin":"./plugins/vcfview/js/View/Track/SegmentationMultiBin.js",
	"vcfview/View/Track/SegmentationTrack":"./plugins/vcfview/js/View/Track/SegmentationTrack.js",
	"vcfview/main":"./plugins/vcfview/js/main.js",
	"JBrowse/BehaviorManager":"./src/JBrowse/BehaviorManager.js",
	"JBrowse/Browser":"./src/JBrowse/Browser.js",
	"JBrowse/CodonTable":"./src/JBrowse/CodonTable.js",
	"JBrowse/ConfigAdaptor/JB_json_v0":"./src/JBrowse/ConfigAdaptor/JB_json_v0.js",
	"JBrowse/Errors":"./src/JBrowse/Errors.js",
	"JBrowse/FeatureFiltererMixin":"./src/JBrowse/FeatureFiltererMixin.js",
	"JBrowse/GenomeView":"./src/JBrowse/GenomeView.js",
	"JBrowse/Model/ArrayRepr":"./src/JBrowse/Model/ArrayRepr.js",
	"JBrowse/Model/BGZip/BGZBlob":"./src/JBrowse/Model/BGZip/BGZBlob.js",
	"JBrowse/Model/BGZip/VirtualOffset":"./src/JBrowse/Model/BGZip/VirtualOffset.js",
	"JBrowse/Model/BinaryTreeNode":"./src/JBrowse/Model/BinaryTreeNode.js",
	// "JBrowse/Model/BlobFilehandleWrapper" = "./src/JBrowse/Model/BlobFilehandleWrapper.js"
	"JBrowse/Model/CSIIndex":"./src/JBrowse/Model/CSIIndex.js",
	"JBrowse/Model/CoverageFeature":"./src/JBrowse/Model/CoverageFeature.js",
	"JBrowse/Model/DataView":"./src/JBrowse/Model/DataView.js",
	"JBrowse/Model/Location":"./src/JBrowse/Model/Location.js",
	"JBrowse/Model/Range":"./src/JBrowse/Model/Range.js",
	"JBrowse/Model/TabixIndex":"./src/JBrowse/Model/TabixIndex.js",
	"JBrowse/Model/VCFFeature":"./src/JBrowse/Model/VCFFeature.js",
	"JBrowse/Model/modEncodeTrackMetadata":"./src/JBrowse/Model/modEncodeTrackMetadata.js",
	"JBrowse/Plugin":"./src/JBrowse/Plugin.js",
	"JBrowse/Store/BigWig":"./src/JBrowse/Store/BigWig.js",
	"JBrowse/Store/LazyTrie":"./src/JBrowse/Store/LazyTrie.js",
	"JBrowse/Store/NCList":"./src/JBrowse/Store/NCList.js",
	"JBrowse/Store/NCList_v0":"./src/JBrowse/Store/NCList_v0.js",
	"JBrowse/Store/Names/Hash":"./src/JBrowse/Store/Names/Hash.js",
	"JBrowse/Store/Names/LazyTrieDojoData":"./src/JBrowse/Store/Names/LazyTrieDojoData.js",
	"JBrowse/Store/Names/REST":"./src/JBrowse/Store/Names/REST.js",
	"JBrowse/Store/SeqFeature/BAM":"./src/JBrowse/Store/SeqFeature/BAM.js",
	"JBrowse/Store/SeqFeature/BAMCombination":"./src/JBrowse/Store/SeqFeature/BAMCombination.js",
	"JBrowse/Store/SeqFeature/BED":"./src/JBrowse/Store/SeqFeature/BED.js",
	"JBrowse/Store/SeqFeature/BED/Parser":"./src/JBrowse/Store/SeqFeature/BED/Parser.js",
	"JBrowse/Store/SeqFeature/BEDTabix":"./src/JBrowse/Store/SeqFeature/BEDTabix.js",
	"JBrowse/Store/SeqFeature/BgzipIndexedFasta":"./src/JBrowse/Store/SeqFeature/BgzipIndexedFasta.js",
	"JBrowse/Store/SeqFeature/BigBed":"./src/JBrowse/Store/SeqFeature/BigBed.js",
	"JBrowse/Store/SeqFeature/BigWig":"./src/JBrowse/Store/SeqFeature/BigWig.js",
	"JBrowse/Store/SeqFeature/BigWig/RequestWorker":"./src/JBrowse/Store/SeqFeature/BigWig/RequestWorker.js",
	"JBrowse/Store/SeqFeature/BigWig/Window":"./src/JBrowse/Store/SeqFeature/BigWig/Window.js",
	"JBrowse/Store/SeqFeature/CRAM":"./src/JBrowse/Store/SeqFeature/CRAM.js",
	"JBrowse/Store/SeqFeature/ChromSizes":"./src/JBrowse/Store/SeqFeature/ChromSizes.js",
	"JBrowse/Store/SeqFeature/Combination":"./src/JBrowse/Store/SeqFeature/Combination.js",
	"JBrowse/Store/SeqFeature/CombinationBase":"./src/JBrowse/Store/SeqFeature/CombinationBase.js",
	"JBrowse/Store/SeqFeature/Coverage":"./src/JBrowse/Store/SeqFeature/Coverage.js",
	"JBrowse/Store/SeqFeature/FromConfig":"./src/JBrowse/Store/SeqFeature/FromConfig.js",
	"JBrowse/Store/SeqFeature/GFF3":"./src/JBrowse/Store/SeqFeature/GFF3.js",
	"JBrowse/Store/SeqFeature/GFF3Tabix":"./src/JBrowse/Store/SeqFeature/GFF3Tabix.js",
	"JBrowse/Store/SeqFeature/GTF":"./src/JBrowse/Store/SeqFeature/GTF.js",
	"JBrowse/Store/SeqFeature/GTF/Parser":"./src/JBrowse/Store/SeqFeature/GTF/Parser.js",
	"JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin":"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js",
	"JBrowse/Store/SeqFeature/IndexedFasta":"./src/JBrowse/Store/SeqFeature/IndexedFasta.js",
	"JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin":"./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js",
	"JBrowse/Store/SeqFeature/Mask":"./src/JBrowse/Store/SeqFeature/Mask.js",
	"JBrowse/Store/SeqFeature/NCList":"./src/JBrowse/Store/SeqFeature/NCList.js",
	"JBrowse/Store/SeqFeature/NCList_v0":"./src/JBrowse/Store/SeqFeature/NCList_v0.js",
	"JBrowse/Store/SeqFeature/QuantitativeCombination":"./src/JBrowse/Store/SeqFeature/QuantitativeCombination.js",
	"JBrowse/Store/SeqFeature/RegionStatsMixin":"./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js",
	"JBrowse/Store/SeqFeature/SNPCoverage":"./src/JBrowse/Store/SeqFeature/SNPCoverage.js",
	"JBrowse/Store/SeqFeature/SPARQL":"./src/JBrowse/Store/SeqFeature/SPARQL.js",
	"JBrowse/Store/SeqFeature/SequenceChunks":"./src/JBrowse/Store/SeqFeature/SequenceChunks.js",
	"JBrowse/Store/SeqFeature/TwoBit":"./src/JBrowse/Store/SeqFeature/TwoBit.js",
	"JBrowse/Store/SeqFeature/UnindexedFasta":"./src/JBrowse/Store/SeqFeature/UnindexedFasta.js",
	"JBrowse/Store/SeqFeature/UnindexedFasta/File":"./src/JBrowse/Store/SeqFeature/UnindexedFasta/File.js",
	"JBrowse/Store/SeqFeature/VCFTabix":"./src/JBrowse/Store/SeqFeature/VCFTabix.js",
	"JBrowse/Store/SeqFeature/VCFTribble":"./src/JBrowse/Store/SeqFeature/VCFTribble.js",
	"JBrowse/Store/SeqFeature/_InsertSizeCache":"./src/JBrowse/Store/SeqFeature/_InsertSizeCache.js",
	"JBrowse/Store/SeqFeature/_MismatchesMixin":"./src/JBrowse/Store/SeqFeature/_MismatchesMixin.js",
	"JBrowse/Store/SeqFeature/_PairCache":"./src/JBrowse/Store/SeqFeature/_PairCache.js",
	"JBrowse/Store/SeqFeature/_SpanCache":"./src/JBrowse/Store/SeqFeature/_SpanCache.js",
	"JBrowse/Store/Sequence/IndexedFasta":"./src/JBrowse/Store/Sequence/IndexedFasta.js",
	"JBrowse/Store/Sequence/StaticChunked":"./src/JBrowse/Store/Sequence/StaticChunked.js",
	"JBrowse/Store/Sequence/TwoBit":"./src/JBrowse/Store/Sequence/TwoBit.js",
	"JBrowse/Store/TiledImage/Fixed":"./src/JBrowse/Store/TiledImage/Fixed.js",
	"JBrowse/Store/TiledImage/Fixed_v0":"./src/JBrowse/Store/TiledImage/Fixed_v0.js",
	"JBrowse/Store/TrackMetaData":"./src/JBrowse/Store/TrackMetaData.js",
	"JBrowse/TouchScreenSupport":"./src/JBrowse/TouchScreenSupport.js",
	"JBrowse/Track":"./src/JBrowse/Track.js",
	"JBrowse/Util/FastPromise":"./src/JBrowse/Util/FastPromise.js",
	"JBrowse/Util/FeatureFilters":"./src/JBrowse/Util/FeatureFilters.js",
	"JBrowse/Util/GTF":"./src/JBrowse/Util/GTF.js",
	"JBrowse/Util/RejectableFastPromise":"./src/JBrowse/Util/RejectableFastPromise.js",
	"JBrowse/View/Animation":"./src/JBrowse/View/Animation.js",
	"JBrowse/View/Animation/Slider":"./src/JBrowse/View/Animation/Slider.js",
	"JBrowse/View/Animation/Zoomer":"./src/JBrowse/View/Animation/Zoomer.js",
	"JBrowse/View/ConfirmDialog":"./src/JBrowse/View/ConfirmDialog.js",
	"JBrowse/View/DetailsMixin":"./src/JBrowse/View/DetailsMixin.js",
	"JBrowse/View/Dialog/OpenDirectory":"./src/JBrowse/View/Dialog/OpenDirectory.js",
	"JBrowse/View/Dialog/Preferences":"./src/JBrowse/View/Dialog/Preferences.js",
	"JBrowse/View/Dialog/QuickHelp":"./src/JBrowse/View/Dialog/QuickHelp.js",
	"JBrowse/View/Dialog/Search":"./src/JBrowse/View/Dialog/Search.js",
	"JBrowse/View/Dialog/SetHighlight":"./src/JBrowse/View/Dialog/SetHighlight.js",
	"JBrowse/View/Dialog/SetTrackHeight":"./src/JBrowse/View/Dialog/SetTrackHeight.js",
	"JBrowse/View/Dialog/WithActionBar":"./src/JBrowse/View/Dialog/WithActionBar.js",
	"JBrowse/View/Export":"./src/JBrowse/View/Export.js",
	"JBrowse/View/Export/BED":"./src/JBrowse/View/Export/BED.js",
	"JBrowse/View/Export/FASTA":"./src/JBrowse/View/Export/FASTA.js",
	"JBrowse/View/Export/GFF3":"./src/JBrowse/View/Export/GFF3.js",
	"JBrowse/View/Export/SequinTable":"./src/JBrowse/View/Export/SequinTable.js",
	"JBrowse/View/Export/Wiggle":"./src/JBrowse/View/Export/Wiggle.js",
	"JBrowse/View/Export/bedGraph":"./src/JBrowse/View/Export/bedGraph.js",
	"JBrowse/View/FASTA":"./src/JBrowse/View/FASTA.js",
	"JBrowse/View/FastaFileDialog":"./src/JBrowse/View/FastaFileDialog.js",
	"JBrowse/View/FeatureGlyph":"./src/JBrowse/View/FeatureGlyph.js",
	"JBrowse/View/FeatureGlyph/Alignment":"./src/JBrowse/View/FeatureGlyph/Alignment.js",
	"JBrowse/View/FeatureGlyph/AlignmentColoring":"./src/JBrowse/View/FeatureGlyph/AlignmentColoring.js",
	"JBrowse/View/FeatureGlyph/Box":"./src/JBrowse/View/FeatureGlyph/Box.js",
	"JBrowse/View/FeatureGlyph/Diamond":"./src/JBrowse/View/FeatureGlyph/Diamond.js",
	"JBrowse/View/FeatureGlyph/Gene":"./src/JBrowse/View/FeatureGlyph/Gene.js",
	"JBrowse/View/FeatureGlyph/PairedAlignment":"./src/JBrowse/View/FeatureGlyph/PairedAlignment.js",
	"JBrowse/View/FeatureGlyph/PairedArc":"./src/JBrowse/View/FeatureGlyph/PairedArc.js",
	"JBrowse/View/FeatureGlyph/PairedReadCloud":"./src/JBrowse/View/FeatureGlyph/PairedReadCloud.js",
	"JBrowse/View/FeatureGlyph/ProcessedTranscript":"./src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js",
	"JBrowse/View/FeatureGlyph/Segments":"./src/JBrowse/View/FeatureGlyph/Segments.js",
	"JBrowse/View/FeatureGlyph/UCSC/BED":"./src/JBrowse/View/FeatureGlyph/UCSC/BED.js",
	"JBrowse/View/FeatureGlyph/UnprocessedTranscript":"./src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js",
	"JBrowse/View/FeatureGlyph/_FeatureLabelMixin":"./src/JBrowse/View/FeatureGlyph/_FeatureLabelMixin.js",
	"JBrowse/View/FileDialog":"./src/JBrowse/View/FileDialog.js",
	"JBrowse/View/FileDialog/ResourceList":"./src/JBrowse/View/FileDialog/ResourceList.js",
	"JBrowse/View/FileDialog/TrackList":"./src/JBrowse/View/FileDialog/TrackList.js",
	"JBrowse/View/FileDialog/TrackList/BEDDriver":"./src/JBrowse/View/FileDialog/TrackList/BEDDriver.js",
	"JBrowse/View/FileDialog/TrackList/BEDTabixDriver":"./src/JBrowse/View/FileDialog/TrackList/BEDTabixDriver.js",
	"JBrowse/View/FileDialog/TrackList/BigBedDriver":"./src/JBrowse/View/FileDialog/TrackList/BigBedDriver.js",
	"JBrowse/View/FileDialog/TrackList/BigWigDriver":"./src/JBrowse/View/FileDialog/TrackList/BigWigDriver.js",
	"JBrowse/View/FileDialog/TrackList/CRAMDriver":"./src/JBrowse/View/FileDialog/TrackList/CRAMDriver.js",
	"JBrowse/View/FileDialog/TrackList/ChromSizesDriver":"./src/JBrowse/View/FileDialog/TrackList/ChromSizesDriver.js",
	"JBrowse/View/FileDialog/TrackList/GFF3Driver":"./src/JBrowse/View/FileDialog/TrackList/GFF3Driver.js",
	"JBrowse/View/FileDialog/TrackList/GTFDriver":"./src/JBrowse/View/FileDialog/TrackList/GTFDriver.js",
	"JBrowse/View/FileDialog/TrackList/TwoBitDriver":"./src/JBrowse/View/FileDialog/TrackList/TwoBitDriver.js",
	"JBrowse/View/FileDialog/TrackList/VCFTabixDriver":"./src/JBrowse/View/FileDialog/TrackList/VCFTabixDriver.js",
	"JBrowse/View/FileDialog/TrackList/VCFTribbleDriver":"./src/JBrowse/View/FileDialog/TrackList/VCFTribbleDriver.js",
	"JBrowse/View/InfoDialog":"./src/JBrowse/View/InfoDialog.js",
	"JBrowse/View/LocationChoiceDialog":"./src/JBrowse/View/LocationChoiceDialog.js",
	"JBrowse/View/LocationList":"./src/JBrowse/View/LocationList.js",
	"JBrowse/View/Ruler":"./src/JBrowse/View/Ruler.js",
	"JBrowse/View/StandaloneDatasetList":"./src/JBrowse/View/StandaloneDatasetList.js",
	"JBrowse/View/Track/Alignments":"./src/JBrowse/View/Track/Alignments.js",
	// undefined = 0
	// undefined = 1
	"JBrowse/View/Track/Alignments2":"./src/JBrowse/View/Track/Alignments2.js",
	"JBrowse/View/Track/BlockBased":"./src/JBrowse/View/Track/BlockBased.js",
	"JBrowse/View/Track/BlockBased/Block":"./src/JBrowse/View/Track/BlockBased/Block.js",
	"JBrowse/View/Track/CanvasFeatures":"./src/JBrowse/View/Track/CanvasFeatures.js",
	"JBrowse/View/Track/CanvasVariants":"./src/JBrowse/View/Track/CanvasVariants.js",
	"JBrowse/View/Track/Combination":"./src/JBrowse/View/Track/Combination.js",
	"JBrowse/View/Track/Combination/CombinationDialog":"./src/JBrowse/View/Track/Combination/CombinationDialog.js",
	"JBrowse/View/Track/FeatureCoverage":"./src/JBrowse/View/Track/FeatureCoverage.js",
	"JBrowse/View/Track/FixedImage":"./src/JBrowse/View/Track/FixedImage.js",
	"JBrowse/View/Track/FixedImage/Wiggle":"./src/JBrowse/View/Track/FixedImage/Wiggle.js",
	"JBrowse/View/Track/GridLines":"./src/JBrowse/View/Track/GridLines.js",
	"JBrowse/View/Track/HTMLFeatures":"./src/JBrowse/View/Track/HTMLFeatures.js",
	"JBrowse/View/Track/HTMLVariants":"./src/JBrowse/View/Track/HTMLVariants.js",
	"JBrowse/View/Track/LocationScale":"./src/JBrowse/View/Track/LocationScale.js",
	"JBrowse/View/Track/SNPCoverage":"./src/JBrowse/View/Track/SNPCoverage.js",
	"JBrowse/View/Track/Sequence":"./src/JBrowse/View/Track/Sequence.js",
	"JBrowse/View/Track/Wiggle":"./src/JBrowse/View/Track/Wiggle.js",
	"JBrowse/View/Track/Wiggle/Density":"./src/JBrowse/View/Track/Wiggle/Density.js",
	"JBrowse/View/Track/Wiggle/XYPlot":"./src/JBrowse/View/Track/Wiggle/XYPlot.js",
	"JBrowse/View/Track/Wiggle/_Scale":"./src/JBrowse/View/Track/Wiggle/_Scale.js",
	"JBrowse/View/Track/WiggleBase":"./src/JBrowse/View/Track/WiggleBase.js",
	"JBrowse/View/Track/_AlignmentsMixin":"./src/JBrowse/View/Track/_AlignmentsMixin.js",
	"JBrowse/View/Track/_ExportMixin":"./src/JBrowse/View/Track/_ExportMixin.js",
	"JBrowse/View/Track/_FeatureContextMenusMixin":"./src/JBrowse/View/Track/_FeatureContextMenusMixin.js",
	"JBrowse/View/Track/_FeatureDetailMixin":"./src/JBrowse/View/Track/_FeatureDetailMixin.js",
	"JBrowse/View/Track/_NamedFeatureFiltersMixin":"./src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js",
	"JBrowse/View/Track/_TrackDetailsStatsMixin":"./src/JBrowse/View/Track/_TrackDetailsStatsMixin.js",
	"JBrowse/View/Track/_VariantDetailMixin":"./src/JBrowse/View/Track/_VariantDetailMixin.js",
	"JBrowse/View/Track/_YScaleMixin":"./src/JBrowse/View/Track/_YScaleMixin.js",
	"JBrowse/View/TrackConfigEditor":"./src/JBrowse/View/TrackConfigEditor.js",
	"JBrowse/View/TrackList/Faceted":"./src/JBrowse/View/TrackList/Faceted.js",
	"JBrowse/View/TrackList/Hierarchical":"./src/JBrowse/View/TrackList/Hierarchical.js",
	"JBrowse/View/TrackList/Null":"./src/JBrowse/View/TrackList/Null.js",
	"JBrowse/View/TrackList/Simple":"./src/JBrowse/View/TrackList/Simple.js",
	"JBrowse/View/TrackList/_TextFilterMixin":"./src/JBrowse/View/TrackList/_TextFilterMixin.js",
	"JBrowse/View/_FeatureDescriptionMixin":"./src/JBrowse/View/_FeatureDescriptionMixin.js",
	"JBrowse/has":"./src/JBrowse/has.js"
	// "./package.json" = "./src/JBrowse/package.json"
	// "../../jdataview-1.1-patch.X" = "./src/jdataview-1.1-patch.X.js"
	// "../lazyload.js" = "./src/lazyload.js"
	// "../../data/human_bigbed/ENST00000610940.4.json" = "./tests/data/human_bigbed/ENST00000610940.4.json"
	// "../../data/volvox.bb.expected.json" = "./tests/data/volvox.bb.expected.json"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[11],{

/***/ "./img/commonIconsDisabled.png":
/*!*************************************!*\
  !*** ./img/commonIconsDisabled.png ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAAAQCAQAAADNYG5iAAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfeAxIHJgp/FE6EAAAAHWlUWHRDb21tZW50AAAAAABDcmVhdGVkIHdpdGggR0lNUGQuZQcAAApXSURBVGje7Zl7cFTVHcc/Zx/JJrtJWIgkJA1lRkAR0CBSSAJYrRPqxBLDLF0RhU0KFVARQbE+kIrGFirwBx3BqglJxcpDMWoGqQ46aiIveRoiEaUQDSHkQZY8dpO99/SPfSTs3kUbQtqZ+ss/99z7vfd37j2fPef3PRH8FL0Sa2QTzwrv8SRj0yqZpX/wyE44oxukwsjfi8fkQxXvhbt7RYxeb0yyVgwlkijGiMvtTV4jJgBcBf1/jL638//40HUdZiRkbMj4LqMzozbj9Yxrg4W2GbZPbI/bAl2zCdvjtk9sd4c8cQCpRPuOo0llQJjM6awlxXecwlrSw/bxqku0ukfSJVrd3yQ1fKt7yNTwrVD8FuFgmfS2Gl6Q2RiU1aPuBCSMXMijCNbcMFn77tyByaetTaJimBqFGUMvDGtBf5aglzk/Dr/ez98DADMS2ct9JGMggRnszxh/sbD//UPMA2aQ70XQJsgfMGOIOX5+yBNT0DOcaCCa4egDkAXHdKJZTAqQwmKimR5Gdx3TyAy0MpnGdZq6cdyPPdCycz/jNPFzcNBWGGgVctDm0MTPwUEZ0MlCDkqHFnhr5LtymZzLSQ4EzurfkEhFRqj5o9MGyevsciFCVeXX6mGtTHMG37I3td9YOZgqXQRGXL0wrHnTseMW+bkTwikmGUetHVl1/ZSu/Od4QlfRS/l7MgM+z2CgAAvzATPrLham/Usv+3XEZ5FvEzZBfnxWvw69/MXpkCdWoaBnOAMYjh6FqnCTBm1Es5h0FhNNG2u0ZckjOY7Fh2AmFo4nj9ScJtM5RYoPQTspnLpKc06N/APg8CJoK8ThOxMSnsWAw4ugLMThOxMy72Wzg6XUcYCPAkvw0c95VHaoUkZ4/na9Q66Wqirk1+YHjzaH5lk++Jd7rv25W0aJWxjCIZzU9ca4dkTmIPm1tIQT+GfpSXO9+T8WBzFQwP7eyd8DAKcC8MeyVv4OwOiLhfe8Nrwa4jrjs8gnPz4rrhOGV9/7WsgT23wIDvHh1xYmc7UPwdk+/Kq1ZZXWHAuNWMgkEwuNOZZKq5buuDvNiJMU7NhJwZlmPO7W0r3wkrXWi6AXP2vtCy9p6RwzXZVeBL34uSodM4Pxm8tJVrPSh9+L3SqnY2+K5URKqY8wrNC3ygh5ImrBvm9f1Kit9LHuRKRFJBHJOGL5gvO9sQSX6NuhoH7jh+EU/lm66bGTicgj4gMEkcRT3yv5ewBgWXyZKBNl1RmRrAUgaLkw7JxV5EfQj9+sIsP7Gs9sC8BUHRY/79WtvqOt4fCDmOKiJB+CFhpzLEVJMcVaOuvGUsWHYArONGOpYt2opUtcv2KVF0EvfitWJa7X0m2qmGP3IujFb459U0UwfnUcAx9+Q4PuP7ZNOnQGQ4Tq0ZvEYePdB07CAhmaZ0jDhS/qRBJGFJxMIJpzoYaC3AmO20KW2ezc6yGvpWcDH5il9e+17xCb0KGQwDKsIfn7zIQAZFj4kLlAOwsvviKkocSPYAC/EqHxSYnuZi6iL5E7JVD3TQ9bKSJcMcVFSYMNNNI42FCUFFMsXNo668ZSJV6HE2e8rlSxbgynS1y/YpXRBWB0rViVuF5bh7qpYo5ddQKozjn2TRWoXReXybnUUcJvxItiNR+xkqZut74lNgkY5Lae9ygeqboSo1Li4LguNMnL8Z3zx429IL9CcgEPTYzGGCwy5U4Rf9UdCungPlH0u8noejr0x94Uy0VURKw5ahdGOkhgAZGMCs1/RSPY8qxkItDK1LK9IUMnt7xzNtuPypnz29/5rTZ+3tqv2mdHwi3CKb7ab6vPjoRdhIXLfKpVApyWg061usKjGtXcHgdQT3Jz+yV09jGKCaDTtGjM5vA1t1q8RBcLoIstXrLJ0R2/pdTxAYsFwFDmBtVN0yTceof+mYgOT1t7TFyzMc5T8Ksl13wRslAmuAtvuP0aqWcfTaTShpMWEkJ7/A5uvsnTeBX5IUrPB/+RTytq9o03ImhnEE+ihsnfhzMgNgDuKtul4R/FludO3+hvfXfjludsWvtFfuvRELAj2uG3HuUBOxIuMlvNKDmWHAtKq7mbIw4Oe3syapoxzYjantzNEQe/R6FyL1hrrbWg3NvliEN8cKFuNrgqXZWgmy0v0tVRwvfdluKNAQPijZun8pRCZ7T528iH9RbF6LYof8q8KQg/k3vLhNsTZIswiWHUswsXzbQQF9qVRRyIHBKdcPGfOlQelfchezbwb4mCKPeWieN/hoJKJJF8HD5/X82AGYKBAOzQwq/LekBVSlwnWfXYntwmQyq7FN+s10YVw8NWd1uZ7pv1qlnD4kA9GIKfv/YDarY30p9M/qmFn7/2gyzj5147slkLP3/tB08vbUrEYWNbrhZ+/toPXtlsGoFDIny6ZEpYxEmQVrTwy5ig/NnjAc7Kh94/Pc3Q/oxeVRI969Lt5d12DTomW1PNUgoTCipWWtlHAhE0BHfFVbA+r949uaAkaPfOxrOF7+et69nAT5MbJjXftA8LHs5xFTp2c55rtfL3HYBlkvB74I91WQ8onu1DsIXng/19tzdo41DY55VT3g3ah8PJZpmLA9ajaBY12xtnWbVcSFZcacB6lDqyjJ87s+JKtXarB9cErMcKnl7alJg0WCuvMyq2y3rYX9lsGuGM8l/7nqW+fT8t/KBjutQLvaxRHz1wagBsu2kgDwiBWTeM0wB74oS4umVbztVmKQSN1NMp3SKOJqUJg/6MM2RTmQKNn2fhawAFlv980L358x9uiIIOkkjjU6/vlEY5UBec/8pG0KfLkABlGhg+8JnZ5Lce4Mkunl2VAm2udROvbAflnTvj03Ve6yFNF2aVq1PqxdtauoJhORe81kOamhzbY/K+1tZtmHfnTq/1kKba+W9PmbdBS0di5YPPveGzHrqZI5+6a8Q6agEWSP/Gy0pN/GC8seMvjDPO33vkGZFNqoSxc9UnxMID7/oAkKDnODfTiU5Woghwcb6h/q3zmCYuv40adOmG8o7L+W4PmNrOFoRZTfdIqGYjFiT9uEXGiOPsAqW9WXjGOlfeTM3/IIAlGw6NurrG/rrX+Urhyd4885tBqV9mz7vSXZQTOOR3qtJEqtjdNzqsNAecr444r9Htws/7P8ZnNdeM0bFCf6SbMZ6or0uMPbPf97Q9TmIMVHKr7KBVNKDSqFQfPvryKx+gowUz3yDSRfll2Ivce+RO3Ql1hG5c8MLtz7+d/Zjphx0LKo3KjpojRk8riuupioOc+O+54LAx9dWpkzjGTu/Gi5CyZGY7I/msD34ju7s7WHb3le6inRW1qxW67ayxyxa0jH2m+DyLN6uQHtAZyoQbncdd5a79ctvhqk+/F1FSxUwHEll+eR+tXryN0JXK2ZpfQEjPNM4ZzjKG857aqo7aL7d9VeVMj5jXmn/iIB3wX5sBf4ofjgWSH8DvB2uwGiFAQYJAYmp85I5/oEciARUV9+X3MjdXvCRue/WT8PkvCEVYZFd+iy5uYEOty9M7+X8C8P868lrQIZCoPTEpfRn/BrgLXh9p74TSAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/commonIconsDisabled.png?");

/***/ }),

/***/ "./img/commonIconsEnabled.png":
/*!************************************!*\
  !*** ./img/commonIconsEnabled.png ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAAAQCAYAAABnaabpAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gMSByc6QNZPaQAAAB1pVFh0Q29tbWVudAAAAAAAQ3JlYXRlZCB3aXRoIEdJTVBkLmUHAAAQXElEQVR42u2bfXRU1bXAf+fOR2aSyRcZSEhIRFFA/CiZASTxqVD79GlqkC4w1SjG91CxLVqwPlptVaT0tT4RWb7nBzUiKFQiPkqePAGpVoUgkAQUJE0U1IAQIB9kksnMZO7c8/7InfQ6DGQmyyIie6271s3Z5+x79809v9ln73MFZ+WsnEZSucAt21sPc9v8A8LYvmugwxI4qj4uUYvsmGZeTGA9QJ0coVwo6jWAbVjvUpBzNJT7xhF4I95rz533cLJiMpkm+VdkZ6aLj50XXoS0DYLELMzjHhHf9LNxu92tgM3Q5K+pqRnwddk/3f3/R4g5WmNhYXEmMBf4IZAJtABvA49VVVX+7WQGp0yZcjNwD/Am8PtVq1bJCL0AfglcBzy3atWqFX3cYwaQCzQAXYb2RGA4sF+/v1ilEJgKPKmPDUsuMBt4DaiK8zkOBI72Q3ciyQYO9kMXVard7tFjamp2xqs7kUgpRwshdsariwV+RbO2wr5FwEJphGD70cATJkw3gAkvpgVbhM1eIP1/FkgJUCWs94YkM8EsVOSTVQnCUxiQ78V67bJ/vXVQTk5OvT8QSNvbdikjL1I0bAMVmZiFUBJOi8laU1MzwO123wM8JaUsrq2tXf912f42+P+PECUK/LKAbcDdQI4OyUzgZqC6sLD4spMZHDBgwE+HDh2alJGRcTMwXweeEX7zMzIybh46dGiS0+m8J4Z7zAVMOuwSI+Bn0vXxyFR9/GzD2DD8EnV9PDIK+BFwTRTdNbpuVBz2xgI/BUqi6Ep03dg44FcG7Kh2u5dE0S3RdWVxwK8M2CGlXBJFt0TXlcUKvMoFbrn1f++TLz80RF5/90uwbxF7qj84rq8DXlXR0BChACGrKsX8LaakgpGiQb5LSklIyns1TMKP1FTkJyJw7oex+vRvd5blTZx49bbRo/PTxrjd0nf+ZN7YN0QJJGSjWJKQvpbTYrK63e6pQogSICCEmO9yucbHa2PXQIelGtvC7ZgbdpNw7d/9n9jrv+XzdGpv2agc3d55Wvl/SgAI/A7I089f7Hn3CIMqCXj6ZAYLCgo+N5lMMi0trdvpdBaFIRiGn9PpLEpLS+s2mUxy3LhxjTHcYwMQMkAwwwC/kK6PR57UI8kwBAsN8OvS9TFLTk7ORUC9/pyuiYCfA6jX+8QWSg4cWAh8oUO5JAJ+ucAXep/Y/sF2+y/DP/JGCOrnZRF9+hRVVWeH7RkhqJ+XRfTpM9ormnQLm9cu4eZfvYlo2sCe6g9466/rj1sCjya4RSPhgW7oDqLKIKrVF+pevEM4yjR8C4IoWhApQoQ+UdMSZhawrz0Wfx5+9MG8CRMmbB05csQ5gUBA2u12cfXE75M07J95c3c33e0HkYdqT4vJKoTottlskwEJ/IuU0hGvjfajgSeCMEnFZPZiWvBmzjl39vg/8pxAICDN/1MpMt96B2l20PCH9bS+v/W08f9UAbDYcP5oVVWlF3jZ0HbJyQzeeuutrwwfPnw/QGpqajAMwTD8UlNTgwDDhw/ff9ttt70Swz12RUBwaAT8uuL0eX8EBG+PgN/+eIzV1dWlT5482QG0GiAYhl/r5MmTHXV1demx2quvrw8UFBRYAI8BgmH4eQoKCiz19fWBmMPTFSuetwwc2GSEoBF+loEDm0atWPF8zEulsrJSv99fZ4SgEX5+v7+urKystC/4haO9RU/M5d4nNn8FfrOf80TNN11Fx+sK4pEQpgQVRQ5Asw4SnY+lYPIGkdYgoU8TEh0/+f4xz77/e3pqTDkrRbGl+APBLEA6HEkiO3sICdYExo0ZRyjtYjbsbENr+fy0mKzV1dVrzGazT18ON+/YsWNjvDYiI2n74ZY5Yk9DFghp3bRVqK++jsSEsNkIDMlli9d22vh/SgBYVVXprKqqFPqxv7CwOAFYaOhy0qWF2WxeP23atKWREIyE37Rp05aazeZ1Md5nVxQw7e8H/IxjX4toey1e+AEkJycvW7p0aXYEBHvht3Tp0uzk5ORlsdpLT09/ae3ataEICPbCb+3ataH09PSXYrWXkJv77IjFix83QtAIvxGLFz+ekJv7bKz2li9f/vH06dNLjBA0wm/69Okly5cv/7gv+ImmDVTX9SwAjPA7/4ILTnr9q/CtUjGV2RHmZCzWoGZXU9BsCYgP2xMTbynsavsM4PqZr8lY/PnReQ+3OLzP1Bw+clRkD87FYraghTQ8nnYKxo+lKeUK3vaM7mtp2grgcrnG5+fn/6Cva44ZM2aSy+W6VB/beSonfGQkrWl+06DnF/k6VqwS/gWLCClmVE2Dc3IY9syTHMqc2Kf/Z1oEaMwHOoCNwJ16kw+4t48wXZrN5jWREIwCvzVCCBnjfSZGyfXlGnKC8UpulFzf1H7kExFC+MMQzMvLM+sQbM3LyzOH4SeE8MdjLwxBp9Op6BD0OJ1OJQy/eO2FIahYrb3jFKvVH4ZfPPYALQxBTdM8vY2a5jHAT4s2MJznE00bWLtmBZfdsEjMfs4jFj0xl7f+up57n9hMe+vhqBdN2aOKZRW/EQDjnL7AkLTAsWNooVY02SU0/8hBAXtBdnsqwLveZCUWR95fgtOjWu+5arzqtnY9K+vr94CEjg4PwVCQtrY2XJeM4JOkq/oyZXO5XNcKIf5LUZQ+C0ChUGi7EGLp2LFjr+xrDv4jpDeSFopdTVRSBidq9mGvPIPNYqU72I3MyyZ93m/odDjIv3h4LP5/a8Xch/4PwD/p516guKqqclsMk05WVFRUHj58eFIkVA4dOnRs9erVlTfddFM88DPm/Pbz1cJIvMvg3Iic32t8tTAS9zJYCOFPSkr6wuv19vrU2NgoBw8e/IXX6/X3B6p2u73d5/Olhtuam5vJyclp9/l8/bJXc9ll+VJVe7dQaN3dto+nTs13b93q78d7oy1btux+RVFS/r6UVFKWLVt2//Lly8tOBL9wnu/tddsovr+md4l6/gUXEAbjicQzyiynAU1Z/FAozE2yy25V1bq8XTI5Iy3UbraSqgR4sWMQ9ycnddT05cDmZabMoD+05Lz8y6/LHDFJ5pue472td9DS+hT5+d+jq6MLj6edzs4OcjIzYnnGlUAA2Ot2u2P6t2iatlF/p0/9xF/W/X6wSh5Mqky+LIVEsHSS2HmQYxe4yHtmEV4h4/L/jIwAgSmG8x9XVVW+HYvRKVOmiIqKit82Nja6InUHDhxwVVRU/NZYHe5DIgseLRxfGIlHIgseVRxfGIlXrvF6vUlAaPLkyQ59ORzS267ph70Sn8+XA2gFBQUWfTms6W0lceeO3O4lUlVvCy97w8thqaq3RasO9yVSyiWKotweXvaGl8OKotwerTrcO+P1yK/p0OaoS+IVSxYeV/wwypEMis0av9ZUIEBieqK6L9kampWg4BBBLLILhz/EfzTlMubk8LPYgv5QxYWXF103KNssu727hWLPEO6R+3C0z2DjXzbh9/tob2+ns9NLSmpaLI/l50KIWrvdPjQ5OTnzZIemaedLKXdJKe+mp6BxyiRljyreXTbAHvSHKi6ZOP6yIXmSdhHgmAIhRzfnWqvZ9pe3df/b4vH/zIoACwuLBTDI0PRmrPAjSsEDoKGhIVdvK2pubmbKlCkPRe4TPEG+LnIfYLgwMrwfebtwxGeM9MKFkdlRcoN9wi8y56e3H1y9enUrMEDvsyFW+EXm/ACKioosW7ZsMRZGVsYKv8icH0D9XXf9e/Do0Sx6CiOMqam5I1b4Reb8AF544YWVNpvtQnoKIwghvmIva/DlrF2zAuM+v9QBmcQKvzYH49Ugv5cB1JAAAYe74b7zfDQecWKWnczFgiZVskSQpz12SlJ8RN1loAaCVyYNyBztSO6UIc0hTLbxaKFqQhIGDzhIQue9bNv+W7Iy07FaE2hpae7rsfhramqedbvdzX6//8rq6uo1J+vscrmmAPNqa2vXud3up0/lhPeMMkv+yBUZB1LHWP70EaZUM6Ggg47DR0jNCmEhRMHqB9jS8gss+aNj9f/MiwCrqiqloRgiqqoqYw3V50QreEQrjAC/isFeC7AzyjK3S2+Pd5NSFTCL6EWVWcS5CXratGlJRBQ8Igsjep+YpKioKJWIgkdkYUTvE5PYhg7NM8IvITf32cjCSLhPTBPI47FHFjwiCyPhPkZpOrSZyH1+scIPoDvAVLyY8JNg9tJi6uCB7A6+EAKZ2cIqLcB/iw5MWgCL0kVSQOMr1ZTmXaS27CZNSswIJmcOuz4JGRRgx9v2Pt7mnagBZMAvcKaayBXzQ61tnaGWlhY+++wzz8nuLfw1Rk1NzWt9wQ+gtrb2ldra2nX6GMepmOhG/9OrmDXoHYtdUyWyQ8MxVJL4Ez+WAOAHixfGrF8otd27tFj8P2OlsLBYho9Yx/zsZz/bNGfOnOo5c+ZUl5eXrw4GgzdKKYWUUgSDwRvLy8tXh/UzZ87c9G1/RlLKG9etWzfd4/HcJaW0GdptHo/nrnXr1k2XUt4Yj73y8vIHWltbZ0Taa21tnVFeXv5AvPY+nzdvnb+xcVakPX9j46zP581bF489IKuurm5+aWnpJRE/oEppaekldXV184Es44AnZ6RItXOXDH26QO56dao0/v3yQ0NiereOMsFyANNTBzBvbrIqlwLI20vFg5JecDZjufNLrJ81YbshCgBk8y5k2x5kdQWys2mR7PryZtnx5WPa3nfQ/rYxRdZtyJMfVQ6Qm5Zam1f/J4vnPVi8+NHHHtlDz9c34YDB+k2+bxMmTLC53e72fgCwx/+VyIMjkM2uwfKIO1UeveY8uW8l2t82JstPH3PKg8MV2TgCdX82LQ25SYcXzpr5icH/M05EXwA0RIQx5ezWrFnz3M6dOy8eNmzYwZKSkhXGaq+UUqiqOmnlypWle/fuHTx69OjdkyZNmnEGQHA8sDOymqoDZ7QQ4oMzyR6QDrRzfLVXAVKBNiP8Ivf5DczorZ30GfkZ5T0lN8WpHTONoqMtqp/cZHqdDVn5fO/QMN7VIgDgAZJNZtj7EYya+LQMdvsJ+TaLjub9qKFUPK1HQocad3+45SP+OG+x8hZoCtBJzwcAe/X5Ir6pwoXL5bpVSrleUZRPNU270GQyjY0l4jT6LxdCcD1YkwYinMkwJ4/OQR29/msv7j7o3IBFdOMVktAehV9fG2QH8Ol3KgfYXykuLi4vLi6+AtgDrDdudRFCSCnlmtLSUh9wEbDpTHiIJwKIDpwPzjR7RsBFiBZNd/wm5/6tqK7U9ntO/mteEQK+hHej+IqQEhVAKJjrNi0Sanc7iiJUv9/c4At82VS7+8iqTTuUhjfe074UQrNLiabDr5ueYoX8hl+1ZiHEnwGhKMpaTdNuj/0d6PHf9HNBaxNmy94ujt2oEgp0qv4Gc0NX94GmHbuPrtrUqjTM7lIKz0XM2ArzfxwK7tD9/+5FgGflrHwd8uSMFAmc8AuPU5QDOyhEz/uuhUDT9PdfIAFbcwu/uOhq/kTPzgIj7DT9CJwOz9Llct0hhHheUZQfbN++/b3++B88JoQMSqGkIaP57yZduZ7uQcvRmvbhU08n/88C8Kycle+o6F+NKPq8lYB2qoooZ6r8P2vrSvrY/SdIAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/commonIconsEnabled.png?");

/***/ }),

/***/ "./img/dark_20x2.png":
/*!***************************!*\
  !*** ./img/dark_20x2.png ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90BFxYkHoGW4MAAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAEklEQVQI12M0NjZmIBcwMVAAAEkmAJ08S5kYAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/dark_20x2.png?");

/***/ }),

/***/ "./img/dblhelix-red.png":
/*!******************************!*\
  !*** ./img/dblhelix-red.png ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAALCAYAAADFo7BPAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAJlSURBVGiB7dRBSFNxHAfw7/YmTJM5GCY8IR07rBRXkTt0kkRiJGOH6hAeSgIRuyhoa1aygXjQtS1kksQeDsdAYZRQjF1kBGu4TIw5hXWJ2ClLYQiP5w7/Tj0UX+HhLQp+X/ge3pf3+/BOT8NEkYFCoVD+g+hQLssPr5NJvIzFIIoibjmdGOrvV9xOG/LII488NT0NKxYZADycnsbbdBqPBgZw1mTCk2AQ5YMDaLRaPB4clLdzPI/I1BSMBsMfYfLII488tT0NW19noXgcLxIJZAQBpoYGAMCzWAyTkQjMPI+1aBQ1Oh0OKxWMBAL4UCggIwio0ekU0b/iLS5iUhD+3e8jjzzyVPe4C01NXm8kglW/H3x9PSBJWEql4BME5MJhvN/aQn5nBz3t7eAqFfR2duJNNitvkKRjXUqlQB555JFXDY9Lb256UxMTON/YCEgS3m1s4F4ggF/bdZsND+bmcInnYTYaAUlS3JRuySOPPPLU8r6WStB+nJ/HRZsNMBjwaXcXN2dmkPD55M3U3Iyox4O7s7P4Afx2U7oljzzyyFPLuzI2Bi7o8Xih1+PL3h56hofxfHQUvd3dgF4v19zaim/7+4gkk7jjcp3YrtrtJ27JI4888tT2wIpF9j2XY1azmQXHxxkrFhV7uL3N7B0dbKivj0mFgrxdbmtjRoOB+d1u+V3yyCOPvGp4nMVq9d53u+F0OPDU7T725ztarq4Ot10uxFdWEFxYQIvFgrVCAauZDM7U1uJzqYQWiwXZfB7kkUceedXwcMPhYK+WlxkTxVM3HAqxa11d7Oit0kYeeeSRp6b3E7LY1SByNnbwAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/dblhelix-red.png?");

/***/ }),

/***/ "./img/glyph-diamond.png":
/*!*******************************!*\
  !*** ./img/glyph-diamond.png ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAQAAADY4iz3AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAJiS0dEAP+Hj8y/AAAACXBIWXMAAABIAAAASABGyWs+AAAAZ0lEQVQY033QOwqFQAxA0QPOQpzCxv2vwPotQCx0HyLkFcbBxkkI+VxCPtxSMPuZM24yYLQJmzHzBqpdOIVdfWBp4Eq7YYHqyGKkP1SYrC/wwNXEkjPeegpLt6szq7vh513db3z88A+u61RcFp/a2wAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNC0wMS0xNFQxMzoyNDowNi0wNTowMFG4eUUAAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTQtMDEtMTRUMTM6MjQ6MDYtMDU6MDAg5cH5AAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/glyph-diamond.png?");

/***/ }),

/***/ "./img/glyphs_white.png":
/*!******************************!*\
  !*** ./img/glyphs_white.png ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUYAAABxCAYAAACp3wpRAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wLEAAPMVinDI8AAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAgAElEQVR42u2de3hU1b33v2uumSSTTC6EQAgJF1G8kailWNAmVEG8QYX6VCsFzlPFUm0FDxR8+5zqq6dS7QHkbanUngICfQuVHiIKvigJKlZFjwQVDsotISaEQMgkmVzmlt/7x6w97OzMPXvPJMP6Ps9+ZmbtNWvtvfban/37rbX2Wmh00IMQEhISEvJLJ4pASEhISIBRSEhISIBRSEhIKBoZRBHEJiLKBFAGYAwPOglgP2OsVZROXMp/EoB/AXAbgBEAugB8DuBlxtjWAXasvwTwSwD5jDFXEpS9EcB0ADlSEAAGoAbAe4wxGvQVTI3OFyLaRkQ5l8kNaSKiFUR0kfrqIhEtJyLxwNH+OoTSkgF0nMOIaCwR5RFRdpLU/xeIqCdAuTuJaBERsTgcx0IiqiCidr5VENHCgQZGIqJGIpqV5DejkYh28vNtJ6ItRPQI37YQUQff91ct4UhEFiK6h4j+QERvE9GH/PMPPNyiYd65RLSPiK4Psv96vj9X42vxHhE9QET5RJRCRI/KbtC6AQKQ40T0sez3BbUeBDzs2TAPiGfjCEVJLiJ6jIh0GpXrKA7BYKogolEJAyO/ASs5IOTaTERZSQrG5bLz/JSIbIr944noBN+/XCMw/ysRnQ9zQ5zn8YwaHMM+WR7XB4CidGz74nxtMmTn3z0A6koxEQ3j31O41Tg0VmsqCBifC1MPnoszFOVwfFwLOIaBoh+OCQEjEf0mxEF5iWiligVxjmJTMxH9i4rHkUlELUTkIKLPeB4fBIDjVUTUyeNmqpj/SCI6qDjHg0R0NxGN45+B9o9UuWLK4eeHY7DwOIJIbj19EKc8XyaiDwOEf0hEX/LvPyeiNiK6Vc2mgwSA/j4FFKv4JunXfJPD8Q4N3OdItTCuYOSWotSe8AsiypIdzH8R0bVxbEsKJ69acCSiWTKL2MahGAyOm/m+WSrlXUxEZwJAz6yIZw4Ax1oiKtYYjg8kGIpLZOfbRUTfjkOeNv4QHCO/DkSUzR9UjFuxV6rRrBLEYvxNmPr/GxXP9+eKtMfJj4t/H6eI83gCrEV1rMYYwFjJM/65LOwdIpqoUQXsrzqJaLYKx/EkT+9h2Y0REI5E9DAPf1KFfM1E9HmA87pbdnO0E9G/Kx5cch0mIpOGcKQEQnGW3IUmohlxyHMRt4huJKLvSW2a/HcHERVyN7eFiAqTpBnp8RjA+JjKx9AexX3fHm8wSgeXFacLooaOqA3GUHBUGYz3BTmncYrr0R6kckr6vgbX5kFFHg8k4IY9Ist/XpzyLODWolH2O52IriCiNL5dRUT6JGpfv6zAqFP5wLNUobW66gLwbyqkc5J/+tuKGGN2AHcB+CeA7wB4k8PxVsV/+qM34Rufp9Q4/vl/ADgArOW/rwwQ93OejqoWI4CXFMFr420xKs43LuMXGWP1AK4GcI6IvgfAA+ACgPUAJgFoBpDGGPNqZSDwsFVh4LBKzUs+AO7lSo3iqupK/yLAvl/wfZVaVYgEtjFKnS+dRHRVgPYmyXI8xDtoVOt8GQRtjA8mso0xgVaUgfc2p/D2RB23FNNkdTczGcBIRPMVaX+Xb8F+9xDRj1Qu70HX+ZLFvzvl7V8qFcaA6JXmxyIN1zlBROMDwPFTWf7LVc5b9EqHAUacoSjBaQwRnSWiW/lDcbPi2DQDY5zPN4+PlY1EPbwD0qLBcQza4Tr/nuQWwt/4eXYQ0VbeEL+If5faQF5Xu7OD5y/GMQ4wMMquy3giGh3g2JLCYpTB8Z0IoLhFspo1KPdBNcC7nX+/G0ks/sbJcCL6HRG1BrgorXzfcKWbq8FxXNZvvgwkMIY5tswkuwfyiejdEFDcFo9rr/UrgazRQQ/mp7O/QiiSi2ECkA7ACMAGYCIuNf5/BeBjAHYAbgAOxphblFrS1oVIQWxLholFiIhJk0PweRF+AiAblzplGICLAN4A8PWgr/tiBm8hISGh3hLzMQoJCQkJMAoJCQkJMAoJCQkJMAoJCQkJMAoJCQkJMAoJCQkJMAoJCQkJMAoJCQklDRiJaKwo1stHfKbqrATkW6Z4Ha1MXA0htWRQubJeDeBTItoG4CdqzkcnNOCAaIZvDsqJAMYQ0TEABwEcYox1aJTnfAC/AFAeZL8NQBWAlxhjGxNULjrGWI+oIeqWKQA9fK/imgCk8M3EwwHAC8AFoJtvLvhezfXGcj0MKh58OoB/ALAA0KsNxVgnCWCMscusEg2Bb8LWRYyxExqkXwRgLnzviN8J3/uyks4B2EdE1QC2M8ZqVYbiBv6zCsAmRZQSAKv55wYigtpwJKL1AB7hP5cxxl5U7H8XwK0cjqTxdZ4EQJq05Q3G2EdJXK0lKKYASINvvoLbAVwHQPJQTwD4AsDb8E3cLH84Rw1G1SaRIKKtAB4EcBTATYyxrmQCozTPHmNsbhTHtUUZX+ObZSKAvwMYCWAbY+yHGuTxPQBP8crn5E9qeQU286f1y4yxfSrme4hDL1JVM8ZKVcx/KYAXANTAN4GIDcC3GGOf8v3FAE4D+BljbJ3G1/kEgDGK4JOMsbFxqGMU7N4Kta+feUoWopWf948AXAvfxBW9ogL4khsGJwG0A+hmjEW9nK5BpQP/KYeiA8B9akMxFtBpNA3VQ9wSiRvsorgG9wL4G7fYAWAOEWVqMLPLUQC/5FAMVMY6AKkAalXOt5xbipHAsTqYu90PLeKfY7iV8hXP41Mefoh//lHj69wEYAiA/wEgrSn0HwDGE9FZxtiwOEBxBmPsrUD3Jl8ydQ/x6XhUytrAwZiugGKg9K/lcVZxV9oTa4bhCuMcgLwgu98FsBTAGv77JwC8RNTMfy9ljP0lGWx5xthcXi96wXEguOrcUpRDsZq70lpMdzWHQ6IrSMUEr8Br4VuPRo3zK+NfNynAuJHXwe8CmC8L3wSghF+n/Sqd95cAijn4WxTHN4VbkLdr6UIT0Q85FL9gjMnnw9xDREc5HO9ljL2uQd53yO6Ft0LcJ29J/CSiO0LFjQGMtyugKIcjKeB4O4DX4WtvjF7hph0LMVPuN3xa91P89zq+LsoRjdZciWoyUq0mL5WtGb05AQDU8+UVsmVhY4moSTGDsUnDY/g2EbkVi68rJyv1qLm2c5B8NijibAgUScVjOM2TNBDRTfz7UtnxtcTh+v+d53V7gH23831/1ijvOyItU1nx36FS3rl8+Y5XiOgjIvqYL9vxiWI7yPd9xOOOi3XS3FiH67gA/ICbq6MA/DeAJwC8Ct/qafL0f6/Gus4DyXIEsIVbjpsDAFOuzSpWzCEA9gB4Hr7V6MCX59zKrQgAeA3ADxhjLg2LoAu+hu1g1iLjTSpdGl+KTWF+qy2p3dAN4BPJYiWi+/n3b0vWIxHdptEQJqkTIdCs4FKYCcknPd/GKuoZFFajvE6Olf0vbmB8AsAUAPcCaOWQ/Df+WykLgP8NoX5ZihyGt8vaDx8E8L/gGy4D7jb8UGMoAkAd3/obp78qC/Nb7QfiiwAWAHgPvlmqr4dvydRtAA4DOM6tqffh6xm9SEQ3qXwY/49/PhNgnxT2lgb17zH+UI6o6UgWZ4/aa0vHTTG40hv4U9HDf99LRHNCuNydaliMsa6fmmSu9COylRjtsu+fa7nOS4Dj+F2YYv+dyvmV8e1pWR4tfEnPYv7ZItv3tPSfOJWDlYjul+V9Hf9+WoM8pQXXanh9eISI6mTnPlajc72sXOloe6WruWX4ITdRX4RviMLHIUz/xxhjO5LEctsM4CHEeRiO7En8J36zvSFznerh6yXs4pU2HmuMNPdzf7TnvZ8P3l4tC7bh0rhGpWYCWMMYs2tYF6zw9Qr/X8ZYu+wGfIkx1sL50apBHbASUTuAIqlJRaHjRDSGMXYqiZwmD2+++wK+jhUEcKlJsX3B/xNTr3QkrnQT/7zIXeb/BFAA4AB8bYxv4FJvqFwXATycLL3SwaAYxnJSs42R+I3xNnfppPGDCxhj9XEujoYQ+2rD7I9VkQ7VAY9XpXEZSGN/FyjCUwO0+6kORwALefPJ6wAWcvf1Ao9yMslezfXA17v8NnyjA+QA7OGbPOxLHrc7VjBGtRgWET3Db/gmIiqIM5gS6kpzF3pzlMelOhhlv39KROsCHEtmHK7FeCI6HuScjxPReA3ynC/L4xARrVbku5qHS5qv4fkXSG6zLOweHrZL5vK/m4AH+Fmt3OpIXORoXO4o8k0hIhsRFfImklf4ksEfKbYP+b4yHtfGB4drB0Y+HMDDt9sTcMEHRBtjAi1WChCmTxAYTUS0MUiRb9RquBCH4yFe4ftMIsHDD2kJRUVd1CnCqxXHlJqguiLBcauW92E0+/qZp5GIUokomwNvPBH9nEOwim+v8LDxPE42/49RazAe4+f8DIQSAsYIFQ8w6viQlEC6LU7lkbDZdbjFaA2yz8An2Eh0fXkuieq+TgZHGxHl8063cRyE4/n3Yr7PJkFR+fDSAowjiWiN0koRumxBbeCVT76ZRckIJYWiaWMUEhISuhwkZvAWEhISEmAUEhISEmAUEhISEmAUEhISEmAUEhISEmAUEhISEmAUEhISEmAUEgomPpO5eNFASIBxgN2YOr7QPOO/WZKe50B939yDWGdNGRzl/jNxlyVWhlhvmEjjqrFYFBHdAGBxjH9fzRj7TOVy80I2/ZjWawgnUpfbutxC/b/nk6H+GAbJcS6Gby7EI4h88WwdgGv4dy0mlX2IiCYzxkZfJjeGNB+lXFvgm58z0ptkfz/zj3jp2mjj9wcG8pufz6R+AMAN4gFzmVmMkVxslV2w1fymPBTljXENes/6rLZGEdFmLWfzJqJfR3gtkn3Wo4eifMhFG18tpSihGON1z2GMNauQzlDG2Ll4eBDJNM1fNLPr+NubIml70mii2Igmf9V6XRYtJ6QNBMYIphr7tVbnmWgrVSrbSOpfsPiD0Dr/GRFlqJDOvUTUQETD1arzUd4XgxaUg8WV7rPgPfiqZQE0A/Ffl+Uhvrj73EQVz0BwqzU4/8FiJWpR39tClH8GfGv7nAmynwFYBuBRAHcxxhoglJxgVMKRB+0ZAFAcCHAkUZW1s5gVbYjhyvozADdI/wmURj+OxwDfWi9PA2BEtBfAOsbYAVkcM4C/wLfe+yQ13ejLSYNuuI58wXsOwoEARaXFktRijM1lfTVX3E4AVGhfDALFGfCtXz0TvvXFiwH8E8B/EtFhIprL12Gq4g/K7wkoJgiMiVprRQbHybLgyQmGYiJ7HhP+gJO168al7TVe11N5TVmECpVGlOU6kYjeAfA7AEsZY9MYY9WMMQdj7PcArgKwHMAD8C1lvAfAXMZYl8DbZeJKD/SbKJFcuozd3X4PyxnguhPAVgCbGWOeAPWOOAz3EFEeY6xJ3I0JAqMYkyXKI4gVnwg4adbhEsrzkbUh5gBowaV1vlWtI4yxp6OIK6CYKBdsAC5bOgO92xoFFIVLHU+ZGGM9l9H1HfRLFRPRq8nsSkuDvkfJwubEoVDlD5MRcTrXp3F5aotK3zV76DHGzooH5KAC+6vcu/hxyOva6KAH89PZX0WR9SlAlszvQEfjSoqbPu7lrvokEoyxP4hy9UMxfJ0Wy6cKCQldDlCMxu0X044JCQldNpZipBJgFBISSmoxxn4cbJypAKOQkJCQsBiFhISEBBiFhISEVFGyvxJog++l+moAC+Q7iKgYvhfx7Yyx6v5mVFVVtXz48OHPjxs3rs8+IkJPTw+8Xi9q2upR9c0n+PLicbS6HCAi2MxWXJt9BcpHfAvFGQXQ6/XQ6XSIdJSMmuk/+eSTQfNZuHAh6uvrV02dOvXJeF7EJUuW0KpVq8SQIaG4qb/jGHP4Z79nGq7dO7sEABVN23FYZSiWcDCWcoiUwDc4vEwW1w5gMWNsY3+gOHLkSKSkpPQCFhHB6/WirasdL1T/Ba8cfQ12ZweGpJnRw0cN6BjD+Q4nbOY0LLzmfiwtWQBrSjr0ej0YY0EBqUX6jDG2ZMmSPsMZVq1axTweD508eVINOLKvdt1TAoCuvGfXYYR511s6HgFHocECxpv554cqgHE1ABRN27FYAyiWA7BzKFbx/TV8XzGPBw7HNWpBsaenBx6PBycu1uIHbz+BYy11uG5oBm4cloU0U+/VPx0uD/67wY4vm9pwdU4xtt+2GmOyCmEwGAJad1qlL/XYyeEoAYmIyOv1gsPxxalTpy6Lpc4BYMffuHc1AFxx9+uLORgpHBgFHIXiJV0/33qR3FE1NItvmkCR71vN929kjI1ijH2fMVYqc7NXcxdbFSi63W4cbTqB8tcXwO4+j3klRbilKBepJr2fBNKWZjLg1uJc/LhkJJqdZ1FWMQ/Hzp+C2+1GT08P5GNStU5fDiAliPR6PcaMGYOCgoKllZWVL8QIRr1Ox2bqdGwmAD2imIE8kDUrJKQ6GPvx35xhw4ZZR44caZW51DG70SajsdhkNBZzlzpWlcA3J10fKHLglQGoYYz1am/kLvRGGaDDqrKycmkgKErg8ng8sHe04oGqpWB6J6aPzUOaUQcQhdzSjXpMH5MHpuvGA5X/itaONng8nj5gjCT9fc8dwquz34k6/XDWWT/hyD7YPK3UbEktMltSiz7YPK00GjAKi1FooINx3KRJkzBjxgwAGNfP45iXlpaKtLRUAJjXDyhKbrLSUoTMsg3W0VIhszjDQrGgoOCFwsLCgFD0er1wOp1Y9cWr+LqlDmVFuUg16EEEfPNZM/4weVev7dU5+/A/b9b5+ZVmNOC7xbk41nIGq7/cDKfTCa/X26tNMVj60tbd7sax3XUwpxtw6r3GXvtCpR+pYoQjA8ByMs1zrbZsWG3ZyMk0z5XCBRSFkgGMxZMmTcIdd9wBFdzpWRaLBRaLJVKL7bQinhyKdu4a2xX/sSsAGahZANFAkR9vL0ku7hl7AzZ9XYFvF2TBYtD39msBzFz7Hf921YxCVP6mGvWfNfvjpBoMmDg8Cxu/3okz9ga/yxtR+gR8vv00rppRiOt/MBqfbz/VZ3+w9KORHI5VVVXPBwGhjrvL0mYw6Nm9qdYMpFozYNCze+EbHSGPo1OCUkBRKJ6KZLjOzQCuUwZOmjQJV1xxBcaMGYP777/fun379kcC/PcLyDpmeAfLE8pI6elpMBj00vfi2r2zA5kua2QdM3YA/wVgP4BNsrZDO7cU+1iFjLFqIrIDKCGi+fIeaCKyAZCWIN0ZKxQlMLpcLhw4V43zXa0oyyhAmlHfJ15BaU6v7w2HLqChutkfnmbUY2RmKg421OPAuWqMyMiH0WgEgIjSP7a7DlOfKkHuFRn4YO0RtDd2wpqf6t8fKv1o4Th69GgAWF5VVYXy8vIV0r4Tu+9drWPsF8r/ZGTlwGDw5WXLyR15as/MPtPw9xC9NPbO158QUBQaqGD8EEBzQUFB2ZQpUzB5sm+ZlczMTOTm5sJsNuPZZ5/FY489htOnT2P37t04cOAA6uvr9wP4Wp5Q0bQdi2v3zq42GY0b09PTkJ6e1iez7CwbsrN83qzD0QGHowMut3t+0bQdm2TRyrmFWIZLw26CQlGmxQA2ANhARN/l7nMxh6KNtz8G/H9VVdWUjIyMkFAEAI/HA6fTic9bjmNomhk5FmNvF5V/l4c5HW60ne3CdXOsvcJzLUYMTTPj85bj+L6zHGaz2Rc/VPoATr/fCAAYXpINABh1Sz4Obz+FyY9f0ytesPSjrkQGAwoLC+FwOJZXVVW9WV5efgAAxt75+rLDr915JCfb+qeMrBxYbdmycvBZpzlDhyNnqG/Z43b7RbS1NKP5YvsjE+bs3iRuT6GB7kp/XV9fv2Pbtm2ugwcP4oYbbsD48eORk5MDvV4PvV6PnJwcVFZWYtu2ba76+vodSijK4LjJ5XaXXGyx2+2tQZfOhb21DRdb7HaX212igKIEwe/L3ONIoCh1skhW53xudUrWZg2AYiI6RETzlf8tLy8/0NbWtrKurg4ejydoHl6vFy6XC3ZnK5zenj4urL9B8+cf+ret91eioDQHo6bk94nv9PTA7myFy+WC1+sNnz4BX731DczpBny64Wt8uuFrOB1ufLXnm4BxlenHoq6uLtTV1aG1tXWZBEUJfxPm7N5SffTc5PNn61tbmhqDdjq1NDXi/Nn61uqj5yZPmLN7C8SSsEKDpI2xGcBft2zZ0lBbW4ucnBykpKT4BwgfPnwYmzZtagDwV4QZ8M0HcRe3tbXv73Y6++zvdjrR1ta+H0BxiAHfNRyGNZFAUQbHNfDN+r0YwDN8K2WMjeJplHCLMhAcVzQ0NKw8depUUIh4vV5fex1RyFu7oDTHv426JR/H9tTh2J66wO45Edxutx+ModJvb+zE6fcbYUo3ov5QM+oPNcPZ7va51xGkHysU6+vrl02dOvVFZdIAvHc/tv/w2q3Hrm86d+6D7o52n7Uo27o72tF07twHa7ceu/7ux/Yfhm/9lB5xewoNZFdaLheAmj179gyfOHEidLpLXN27d68EK1ckCRVN29Fau3f2zq6u7rIUhQvX1dUNADuLpu1oDZNMNXovbYAI4VgDINBA7pe4qw0ORyjfhikvL19RWVmpB7B0zJgx0Ot7t+9JYwwz9GkwG3RQdvRKv2+c17sjP3tMBv75+6O48o7CXuFmgw42Q3qvsYah0v/876cxako+pj93U+/w107ji9dOR5S+SlCUwEgA8NLWr5rn3jPqzQ5H2+QURVNEh6MNjk73my9t/aoZgBuAR1iMQoPFYpQ0fNy4cb7BxUeP4ujRowB8nTEAhkeZlh+KLrcbLrfPsuFhZfEuDA5B+RjHDfxtmV6aOnXqsvr6+hdPnjwZ1MoaZynEuQ4nLnS6ArvTijDrUAucDnevsAudLpzrcGJsyoiI0//qrW9QPHlon/RHTR6KCyfacOF4W0Tph1N3d3c4KEpn2cMtQG96qnGyxZIKEMHV3Q1XdzdABIslFempxslSPDlQhYQGg8UIAMVXXXUVnnnmGWzbtq0ZAH70ox/l/OpXvwKiH7YzKyXFjIstdjgcHdUAkJ6eVpJlywTUeQsmJjhyy2kDt0hrAsWbOnXqssrKSigtR8YYdDodxhtHIs9iw5m2TqTodf6eY8kqqz904ZIZ7nDj01eP48o7Rvj3d7i9ONPWiTyLDVebinq9thcs/a/e+gYEYNz0EX2sv/ShFhRPyccXO06hbNmEkOlHAsUzZ86goaFhRQgoKgFJJqPuLkuqBc3nG3HxYsuXAJCdnXVtdu4QmIy6uxDm1UAhobhxIFooXnPNNdOsVis++ugj+VCcm2+77bbrenp6UFlZuTcYTOSq3Tt7psWSspO7zv6hOLV7Z6+2WFKe4OGziqbtqEhEwXBLsYYxZg8Vr7Ky8oWCggI/HB0OB1paWtDQ0IDNF/Zg3YkduO+KYci1mAAADdXN2LXko15pmNKNGDVlKL6z6GqY0n3DWC50ufCP42exaOxszM2dgeHDhyMrKwsAQqYfqYKlb7VaWYgyITkUy8vLV0aYnf6z7TPuG56ftR0AzjXZ10+Ys/spADj82p2/GZpnWwgADY0t999w/55/IMwazUJCA81iHHbkyBEXfOMH5fD78J133jnL3d9hkYARQFlXV7cdwHw5/PiQnv3wvaJXhktvpMTbcoyoM4dbjnoASyQ4mkwmWCwWTNfdhH22j/HeN02YXpSHNKMewyfkYOG+u0LaVh1uL977phlX2kZguu4mWCwWmEwmv1UaKv1IFC79SCzFKKDIALDUFMOtHY6O1obznYtumff2GxL8JszZvez9Tbe/N3xI6rrUFMOt8I0UYMJyFBpMbYwu+HqdA4Gvhu9zRZiWHb5e5z7g42HF6Pv2yoDU1KlTn6yvr1918uRJGAwGmM1mpKWlIctqw1LbgyBKwdtnzsPh8oZ7VRoOlxdvnzkPohQstT2ILKsNaWlpMJvNMBgMmqcfSjFAUWZtwv63t2rG3zLv7Z0AnPLtlnlv7/zbWzXjiQbH9RYSrrRQlPJ4POR0OtHW1obz58+jsbERp1vrsaZjO47Z63B1djpKcjORyq07JrPiqi+04uhFB66yFeKJtPsxKrMA+fn5GDJkCDIyMnoN8NYqfYPBwDSoYzpces2PuLVIsv162b4eiM4XIQHG5FJPTw95PB50dXXBbrfjwoULOH/+PM5dPI8DlqN4rbESdmcHclNM8BKBMUAHhgvdLtjMaZiTPxVTuq7G0OwhGDJkCHJzc2Gz2WCxWPwWnZbp63Q6USeELnsZRBGo/KRhDHq9HmazGVar1T8xg06nw+12MyZkjkKt6TzqcREdPd1gBKTqU1CAbBS5hiDPbYMt14acnBxkZ2fDarXCbDb7Z9sGoHn6aomIAr0bbwewgDG2k8eZBd8IAOWsRmsYY4tFjRIadBajyssRpHL3qUuFtDL4Z1u8C5R88s+C09XVhfb2drS2tqK1tRVtbW3o7OyEy+XqBTWTyYTU1FRkZGQgMzMTmZmZsFqtsFgsMBqNvYbTaJk+U4mOQaDohyNjLIvHa0Hwqd4EHIUGJRjVXI5AeiWjToW0pNkSjiQCjHJ4SZNKdHZ2wuFwoKOjA11dXb3eTZb3ZKelpSE9PR2pqan+DpFwSxuomb6KYJTaCEulHn4iKgtjbe/n8UoAHFLzeISE4ulKS4Ow1VqnRS0w5icKjHKXWqfT+a0xqTc5PT0dLpcLHo+nF7gMBgNMJhPMZjPMZjOMRmPIxbC0Tl/FcpAPe6qK5EHNp4gTd6fQ4ANj7d7ZJTqDuVj6XjRtR3+WIE0tKSkxAUB1dXUqgM7+uNGFhYWpJpMJJ0+ezEiEOy2Hl7RJ8EpJSfFPBiHd/FK7pHyL5E0UrdNXyXIskcGxPNL/iFtTaLBajPMMJisAwOVxzkOEs9sEUc68eb4VDaqrq3P6CcbC8vJyDBs2DL/97W8L4201CtfPrzXwtTEeCmD9BWxjDBBvjShGoUSoP0sbzDKY0xNpj+gAAAZVSURBVGAwp8ld6pjd6FmzZmHWrFlylzpmN7q8vBz33Xef3KUWir+1vDgI2KSlJyQFWoYCEB0vQomsvxG4zAF7F40WG1LShwIAuh3n4O4K+NLCGkXHTCGAPGWkn/70p1i3bh0AYNGiRfjjH/8YKK0m9G5/vAbAaGWksrIyrFy5EldffTWWLFmCP//5z4HSOhWlJdkSI7DtALKkH0uWLKFA0/SvX79+4/Tp0+cVFhb2msotUrlcLpw9exZr165dAN/Eu+WrVq3qZcEvWbJEWhdn8apVqzbKPdf+1JH169dvXLhw4fz+VsRHHnlk45/+9Kf5kYYLCSXUYuRgm6/TG2FOzUZ6djGsuWORmjEMeoMReoMRqRnDYM0di/TsYphTs6HTGwHfO9DKJ34dgJoJEybg5Zdf9q96J0ERANatW+cPf/nllzFhwgTA97qhslPmCIDqoqIiPPzww9i2bRu2bduGp556Cvn5+UhJScG6detQU1ODvXv34uGHH0ZRURG4yx+tey2tPLgAl1a0C7VJVpBNDsVgYAEwr6mpaVVdXV3UC1JJUGxqalqBS7ORV3EQKqFo43FUkXTs4eIdPHhwSrg4N9544zyeXkThQkIJd6WLpu3Y1ON1lzg7L9pdnS3QMQadXg+9zrfp9HroGIOrswXOzov2Hm/A5QgkNR8+fPjoo48+6l2xYkXQPFesWIFHH33Ue/jw4aMIPiN4XW1t7buvvPKK+91338XNN9+MCRMmIC8vz/9ecV5eHt544w288sor7tra2ncRe6+3ZI09HSbe05LVFikUAWDixIlPRgtHORQnTpy4EpeWjPXDUQFFO/p2gISDfH+h+Hx6evr7Bw8eXBrBKQWDoICj0MADI4fjYQDFru7W/R53Bxj1gDHybdQDj7sDru7W/Qi9HIGkLgBfrFy5sn3//v19du7fvx8rV65sh2+VwXADvtsA7Fu3bl3ziRMnkJeXB4vF4u+t/fjjj7F27dpmAPvQvx7qagClAGbi0izfSm3g+0t5/IigKInD8cVI4BgAiuDucy84KqHI4xxCwBVgQm6HYoFiXl7e8tGjRyMvL+8FAUehpAMjh2MrgJ2e7nZQjxvkdfm2Hjc83e1AZMsRSPICsO/c2Xe1Uh5mR+Tz8rkBNL722mt9gMLTauRx+qsaDh5pALJN5mof4uHSOjTgsGLRWFsTJ05cFg6OTqezDxRl+SnhqIQi+HFGKib/TxRQfCEvL2/5iBEjYDabkZ+fL+AolJxg5CrTGQzo8XTD1WWHq8uOHk83dL4JDsqiTMtaVub7S3V1NaqrffctD7NGmVbOtddeC5fLFSitHBXLzC6zCKUlXKtkFmWfXig5HCMBSyg4Op1ONDY2oqmpaZkSihqJYrAUX8jLy1taWFjon+NRwFEo2cE4S6/XodNxAe32xup2e2N1p+MC9HodEP2wHduMGTOwaNEilJaWdpaWlnYuWrQIM2bMAKLvBc6//vrr8fjjj6O0tLSttLS0TZaWFsN2FsA3YW8V/1wQKnK0i8bL4Si9waKAYsAlBQK0KfZqc9S6QsmhqOxhV8Bxubj9hAaqorpZa/fOnqk3GHcCgNfj7rUcgd5gfIKHR7ocgW3mzJljAKCiokI+FKdw5syZeTz8JCKbrDb/hhtu+FZmZiaqqqrkQ3GumTlz5uienh7s2rXrE+5Sx2o1MbX+F8jyWrhwIQsCmufz8vKW5+fnxwJFqaNF2c54KMJ6oGwfZaGOPRQU5QrUPrp+/XplXpsWLlw4P1i4uHWFBpLFWOb1uO0cfv6hOEXTdiz2etyzvB63PQp32lpRUeHl8JP3FNdVVFScrKio8EbhTud89tln7qqqqk/QeyjOkYqKik927drlVtmd7pf4jb0pQstxRVNT08pTp06FhGIQAFYH6ZBR/dgPHjz4H5FAEfAtzTBs2DDk5eU9H8RyDAY/AUWhAQlGNZcj8MDX62wPks8XPE4kcsPX6xzIImzk+9wDqeCjhaPD4bglDBQB32Qeyo4WZYfMYkQwHEdhTfaKqzx2DsUl0QxQDwFHAUUhoUGiFkQ/vIX4/0Jq/fr1GwO4i/EUxbjPf+w1NTXk9XopFjmdTqqpqaH169dToE6VYOFCQkJJrgTf+OHgHpdjD5aOgKKQkJCQkJCQkJCQkJCQkJDQgNf/B15iiD8I+pS8AAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/glyphs_white.png?");

/***/ }),

/***/ "./img/helix3-green.png":
/*!******************************!*\
  !*** ./img/helix3-green.png ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAAMCAYAAADYpoD3AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAIMSURBVGiB7dhNaxNxEMfx7+6mZrdB2pAEqRTbWBLtQ0whEaUVoVYFD60geJEKgggV8V6tYN6B3rwr9GAJCIIm9yKxOZToRZHGh5qKVolJkzTZdVkPmoB9Ae5lBn6Hmf/nPAx/Zfb8rGO2TGLxGMcnjjF1agrNo5F+nOZlbpXS5xJerxfLshAnTpw4N53yxdp06rU6hXyB1ZU8xbdFDJ9B/0A/Z2ZOEx2NoqoqAOLEiRPnplMrdplfhsnoyWGu3LqMozpsV6sYfp2+kX1sOxUqdhlx4sSJc9tpc7cvpZpOk6bTZC23Rml9kxv358k8zNKwG4QiAdrv4sSJE+em0y4uXEi1nCYtp8lK+gXhxAChwwEOJgd5cu8pgYgfb3APbSNOnDhxbjltZuFc58L6WPiE6lPoiezF6XYw/Aa55Tzh6QP/bEBx4sSJc8P9+e36W116F+aO1emHJsPUvtXYWv+OOHHixLnttGuLV1O6YqArBmbV4n3uA8npBLpiYGjd2KbNj3dlRhLDiBMnTpybTu3Remnn6GSSr8UtlJ9aZzY4FKZSqiJOnDhxbju1V/XTTlAPceLsBM8eZDozHz4US0GcOHHi3Hba4t07KV01aGcsPkYmnWXjzQZ9wf08X84SG48RPzKOOHHixLnplB274bCr6rU6S4+WeFV4TfRQlOs35/F4PLuZOHHixP1X9xvF1M+CXnCISwAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack:///./img/helix3-green.png?");

/***/ }),

/***/ "./img/loops.png":
/*!***********************!*\
  !*** ./img/loops.png ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAANCAYAAAAT+lNSAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKPSURBVGiB7doxaBNhGAbgL7n2ohmqQriok6GFosTBQQIuVqUUQS+DRXDoYpOhLtouIuhgwE7RyUFoDwcXhUPiUFAXN4dk6qCcaBrEXi29miNVg16TvE4tjUnb02R8X7jl/7/vf7jl+A7+AACIjxSLRZmZmZFSqSSxWEzS6bT09/dv7ruNNRlZuSqHFU2m90/Jsd4BP8fSoEGDhm8j6AfI5XKSSCREURRJJpOiKIokEgnJ5XKbNQeCffL24DM5v/e0JJ1rcsOdFqde9v0SNGjQoLGr8avxGzvFcRxomoZCodC0XigUoGkaHMdp6XHrFdxy7yO2eBYPKo9BgwYNGt0w5PjSRTz/+XpbxDRN6Lredk/XdZimuW3vp/XPuOJMgQYNGjS6YfQsHH0jl/FSRAKyJ6CKIkrTCOd5nkxOTrYd7+LxuIyNjcn4+PiOY2BN6jRo0KDRsRFwXRcNaYhZfSXZNUNOqSfk5r60HFK0zaJwOCyqqrY0e54n1Wp1R2AjNGjQoNGxsXXsWq6tIr50AUcWz+CDV9p2POskNGjQoPG/EQCoo44nP15g0B5BevU2FmvLXQM2QoMGDRqdRnpDKoJqEEFVgRpSEQqFWp5MJtO2OZPJtK3/+6FBgwaNbhg9g9aw3OmbED18ru0vo2maTXcktmZ+fl5mZ2dldHS07f5C7YvcrTyU9+tFGjRo0OjY2PUelm3biEQisCyrad2yLEQiEdi23dLzr/czaNCgQcOPIS0VbWIYBqLRKLLZLObm5pDNZhGNRmEYRlPdOmp49P0pBuxhXC/fw0rtm5/jadCgQcOX4euDBQD5fB6pVApDQ0NIpVLI5/NN++V6BSe/XkJyZQLvvI++X4AGDRo0/Bp/AMT5Mv3K5a3AAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/loops.png?");

/***/ }),

/***/ "./img/minus-arrowhead.png":
/*!*********************************!*\
  !*** ./img/minus-arrowhead.png ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAYAAACXU8ZrAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB9wMDA8nC2BFCJ0AAABkSURBVAjXjc6xEYFBFIXR83YVIFKBDvSgBTFtiEW7O2OUKBEINMA8iZ8/dGdOcqNPZspMWOKMzfRNFhER2OMUEave+x1rvz3ggudHllKy1vrVWrtC4IBbRLzGGMfM3M1s/dP0Bo/GRgAG3+LdAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/minus-arrowhead.png?");

/***/ }),

/***/ "./img/minus-cds0.png":
/*!****************************!*\
  !*** ./img/minus-cds0.png ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAKCAYAAACZrsQwAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEVSURBVGiB7do9aoRAHIbxvyhs6xE8QWztPJS1oHVO4VG8iQMeQAe2nlQJ7Gb9iG/QLZ5fO2/xVDIMRp9mwVbMSWLudrOP+31tdhn6NPRp6NPQty5ZOvgOm+L4zJ7d6NPQp6FPQ98+vz7Q7xK2hD4NfRr6NPT9TRRCCGZmzjnr+96ccy+HdV2fGvaMPg19Gvo09B2TbIVdjT4NfRr6NPRpoqqqwjiO5r1fHRZFcVLSI++90XccfRr6NPRpeOL4J/Rp6NPQp3nXvrhpmsbMLE1Ty/PcsiyzaZpsnueHYVmWV/T9oE9Dn4Y+DX3HRG3bvvwP+vnqf9UVfwl9Gvo09Gno2ylsGIYhdF23NbsMfRr6NPRp6Fv3BbJ5vgeijb7BAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/minus-cds0.png?");

/***/ }),

/***/ "./img/minus-cds1.png":
/*!****************************!*\
  !*** ./img/minus-cds1.png ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAKCAYAAACZrsQwAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAEHSURBVGiB7dqxrYMwGEXh64gO5JYFkoIFyBCZihUpI1GyAAzAa0KKhADh6kGK80lukItTGcn+Q1VVg2ZkWaY8z9U0zdy2w9Dnoc9Dn4e+eWEYhskDuus6tW2rvu8lSWVZ7hq2hD4PfR76PPStk7x+eA37NfR56PPQ56HvO4lCkCR1l4va2039+Ty983rdMesdfR76PPR56NsmWQw7GH0e+jz0eejznI4OAABMS+L9rqgVdy/Tb4n/Lj4WfdvQ56HPQ5/n+UgYY1SM8ecuyUf0eejz0Oehb5vwaQ56nP9L01SSVNf1rmFL6PPQ56HPQ986H+egR+MfpSiKvZq+Qp+HPg99Hvrm/QE7fw6VaeG8swAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack:///./img/minus-cds1.png?");

/***/ }),

/***/ "./img/minus-cds2.png":
/*!****************************!*\
  !*** ./img/minus-cds2.png ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAAKCAYAAAAO/2PqAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAETSURBVGiB7da/SsNQGIbxNxg65M9BBAldxI6ZhWxOjt6LizdgLiC35CVkyFgoTsG1SZyEcpwqbfQ0EU6dnmdL+OB3po8vsNZanajve7VtqzzPT415DxcXF3dcUJblrwsrSRJlWaY4jiVJTdN4hV3h4uLiugrGF9Z+Mw7DcDRYFIVXeBwuLi7uVOEUeO5wcXFx5xZUVWUPTzhXvk+78emIi4uLO1XQdZ2dsyF9n3ZzNzMuLi7uvtAYI2PMv592uLi4uH8t3Fzff38sJCWrpYaHO33eLo8GN4/PZ3sELi4u7pwunqKbl8Mf4fZDUb3W4u1du6tUu8tUkpS+1l7hcbi4uLhT/VhYrgdE9dor7AoXFxfX1ReQJsNhfrpUfgAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack:///./img/minus-cds2.png?");

/***/ }),

/***/ "./img/minus-chevron3.png":
/*!********************************!*\
  !*** ./img/minus-chevron3.png ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAIEAYAAACE9rl4AAAABmJLR0T///////8JWPfcAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAACXZwQWcAAAFoAAAACACf27GCAAACwElEQVR42u3aT1LiQBTH8V/+dYCSWICWloIrzuQRvIFncO/eU3gEN+7dskOrtJRQJEDSnXQyi1QKHRfDzKQfU8z7brJJ0cWn3yJpsB4enp6yrCyxZZ5n21kGCGHbUgJCOI6UgO9XV8exLK23/bR/vywrCiEAKbUWAlCqKHwfUEpr3we0LkvHaX5ddmZnE7EzTexMEzvTlGVF4XnffaVk5ybjeaZpM8+Va+38u/Ns3d8/Pkr5/QHadW07z4Eg8LwoAoJAiCjaP8i6PC8K1wUWC6UOD4EoyrIgAIqiLG3b3LrszM4mYmea2Jkmdqapdq59o0ipIDD34Fb3vzrzPJvN9Dy7i8VqVZYb2JOTdvv1FQgCx4kioNpSQKk03TVGk9Wwb29Jcnq6AQYAy/p67/bn87+OndnZROxMEzvTxM40sTNN7EwTtbNrWVkWhsDZ2cHBdAo4jtZ5DqTpPr6PAPO5Ur0eMJ0ul6NR9Sbiul/vaXKA63o9IeZzdv4cO/997EwTO9PEzjSxM03sTNOunN04TpI8B9Zrx0kSwHUtK893zWGu1UrKTgeIovW6KIA8L8uiML+u61YDzM5mY2d2NhE708TONLEzTexM066crevru7vlsiyFsG2lgPG4251MgKOjVuv9vTr2NvHkvuuUqv6sP5nE8XgMfHyk6fFx9V1/PupvMnZmZxOxM03sTBM708TONLEzTdTO1tXV7W0cf6dstRwnTYHhsNOZToHz8+pab8i+laZat1rA8/N6PRoBLy/Vtd4QU7EzO5uInWliZ5rYmSZ2pomdafrsfHFROQ+HzTlbl5c3N4vF9u8i3a7nxTHQ7wsxmwGDge+HIdDv+/5sBrTb1U8G+1IcZ1m3C4ShUoMBMJtJ2e8DYSjlYAAkidbtdvPrsjM7m4idaWJnmtiZJnamiZ3NVp9Eb5xrX6X+xPkH1P61Po1YsFsAAAAielRYdFNvZnR3YXJlAAB42isvL9fLzMsuTk4sSNXLL0oHADbYBlgQU8pcAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/minus-chevron3.png?");

/***/ }),

/***/ "./img/plus-arrowhead.png":
/*!********************************!*\
  !*** ./img/plus-arrowhead.png ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAYAAACXU8ZrAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAABRSURBVAiZjc6xDYBADATBtd0AvdADLZDTBiVYlhAlktAE6Eh4RPjBJBucDkn8ASOwAcPXJE2S5qaqVjO7gRNYACMzj4hQ4+4CBFyvvW+p59MDUFVTAnNg+kgAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack:///./img/plus-arrowhead.png?");

/***/ }),

/***/ "./img/plus-cds0.png":
/*!***************************!*\
  !*** ./img/plus-cds0.png ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAANCAYAAAAT+lNSAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAD0SURBVGiB7dpPioMwGIbxN8VFXCqS6/Uu7rzE0FO58Ajxz9aASLoYGBgYJnYGaVOeZ/+Lrj7Mh+b6cYsiIsqgy7NfgIjoaAwsIsomE2P8uhLGGLUsi7z3WtdVTdPIOSdrbfIgLBaLPduabdt+3GGFEDSOo+Z5lrVWzjlVVSVjTPIlsFgs9gxbdF2XPEj6nISSDj0Yi8Viz7DfroSpQgjy3muaJpVlKeec6ro+PD2xWCz2P5alOxFlU/ILK5dlHBaLfX9btG2bPICI6BXitwYsFpuNLaTXWahhsVjsb5m+7+OjU1GS9n3XMAwPT1QsFov9i5WkO/RI84P0k2TpAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/plus-cds0.png?");

/***/ }),

/***/ "./img/plus-cds1.png":
/*!***************************!*\
  !*** ./img/plus-cds1.png ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAANCAYAAAAT+lNSAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADeSURBVGiB7do7CoNAFEbhf4KFVoLILNgluDgLlzCI2mkjN1UIgRAzgfjinM7ik6kuzGXcMAyW57mcc4ptHEdhsVjsVjap6zoaERHtkTMzm+dZIQR1Xacsy+S9V1EUX01ALBaL3co6M7PHh5mp73uFEDRNk8qylPdeaZquHgCLxWL/bZ30HFhEREfutvcBiIi+jYFFRKcpibkQnm1Bh8Vir2Vflu7vOssyDovFXt8mVVWt/oCI6AjxrAGLxZ7GJtJx7qdYLBb7Kdc0jcVORUlalkVt20ZPVCwWi/3FStId8NDyDFktS48AAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack:///./img/plus-cds1.png?");

/***/ }),

/***/ "./img/plus-cds2.png":
/*!***************************!*\
  !*** ./img/plus-cds2.png ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAANCAYAAAAT+lNSAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAADaSURBVGiB7dq7CoNAEEbhf4OFVoLIPrBtOh/OwkdYRO20kUkVSCBBDcQb53QW32I1TDGu6zpL01TOOa2t73thsVjsVjYqy3I1IiLaI2dmNo6jQghqmkZJksh7ryzLFk1ALBaL3co6M7Pnh5mpbVuFEDQMg/I8l/decRzP/gAWi8X+274NrNfONnmxWOz1bVQUxexDRERH6OuG9akjT14sFnt9e5sVREQHyUn3xRsWEdGesWER0WliYBHRaeJwFIvFnsa6qqps7bGXJE3TpLquVx+KYbFY7C9Wkh6WkMeCMEBT5gAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack:///./img/plus-cds2.png?");

/***/ }),

/***/ "./img/plus-chevron3.png":
/*!*******************************!*\
  !*** ./img/plus-chevron3.png ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAWgAAAAICAYAAADUZmU7AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAHOSURBVGiB7dpBb9MwGMbxx7FjtxUNWgoCifW2j8xH4BPAmdMu3LnutA4JBM3WhDaxE8ccOljVKVsisFGm939M8ko/+eA4Utj559rhKM4sFNeQkYbkGnFUHz/iJes4tFUwVsG0CnUb957lzELemhU3iCPjUXrX35oV13/ctM7dkZnMXT1lM/vwSd/boI/jzCKROZI4h4iaf47tyjqO3CTI6wRNKwbNRqxFEud4LjejMdM694/MYSJzmLrM7N3H6tEN+i6HJM7xavo1KB5gyOsE38rXgxeczEMic5jIHKbxm9nb9+WADXofZw2Wz1Y4kdc+hJ1ZJ7D6ucS1ORk8S+b+kTlMZA7TmM1is2sHDwvWYhtpTGzpgdZd4wSKssFGk9lnZA4TmcM0ZrO42fY/QDM4vJh8x9n8AtIZVJVH4UEODD+ql7gozmBaCYDMPiKzP+dhZPbnPOwpmMWmxwYtI4M3syuczi4x4RWsBkK8T0wr8WW3xNVuicpObq/2W+S9eYXT2YrMj0RmMndF5v9rFjfb+8f+KS+RqjVSmSFVGeZxAQYH1EDl8U+w0k6R6QXWOkVmFijq+cHdhz9PfpsXKkMq15jHxf4GmclMZjKP1PwLAK14ifO/vRgAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack:///./img/plus-chevron3.png?");

/***/ }),

/***/ "./img/red_crosshatch_bg.png":
/*!***********************************!*\
  !*** ./img/red_crosshatch_bg.png ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAAN1wAADdcBQiibeAAAAAd0SU1FB9wLHBMzAC4819sAAABhSURBVEjH1dKxDcAgDAXRm5cJMkEYNHNEposuVJT+hSs/kEBHVfENXAWlmb/9Pg288RB8Di5v4f3SVwfug59p4SOz2R8Ql409idnYk5iNPYnZ2JOYjX1kNvaR2dhHZuP9Aot1l9yqnLmVAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/red_crosshatch_bg.png?");

/***/ }),

/***/ "./img/scroll_zoom_sprites.png":
/*!*************************************!*\
  !*** ./img/scroll_zoom_sprites.png ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAFQCAYAAADjvR3nAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gMbBAU2kZy0sQAAGq5JREFUeNrtnXtUU1faxp99khCgBOUqd62IKEi5BNRBpXZqS6l8tnaWta4ZKypQp7XT6cysNcu2Mzrr+zraWb1hazsQrBSrjrXYSm0dL1VrFauVIKJokYtyVxCEgAGSnP39IaEJJCEBJAnu31quJSfn5Jwn+3Le/Z599gMwGAwGg8GwFmSoB6amps7nOG4mISSO5/kYjuNuU0rPAfiJUnpCJpOVjQnBa9asmaTRaLZxHDff2D6UUh7A262trX/bs2dPj90KTk9PTwXwHiHExZz9eZ6/SCn9bXZ29gW7E5yWlraI47h92r8FAgFmz56NyZMnIygoCHfu3EF1dTUuXLiAq1ev6pZ2fU9PT3hOTs5tWxAsMGenZcuWeYrF4v8SQh4AAD8/P6xduxYJCQnw9/dHa2srHBwcEBMTg/j4eLi6uqKsrAwajQaEEIlAIJhUWFiYZzeC58yZs50QEgsA7u7ueO211+Dh4QEA6OjowIYNG1BcXIzHHnsMADBx4kQEBQXh7Nmzd6sRITNiY2MvFRYWllpbMDfYDkuWLHGhlD7de+FYvnw5HB0dB/3i8PBwzJkzR7dqL7eFEh5UsJubWxQhhAMAf39/TJ8+3ewv15Z4L7G2IFhoxj59Fzpx4kQAwJ49e1BZWQkA0Gg0AIDOzk689dZbfQc9+uijkEqlEIvF6O7uBiHELyUlxScnJ6fR1gWHa//j4+MDAGhsbERVVZXeThqNRm9bW1sbCCHw8fHB9evX755MKAwDYPOC++4xTU1N2naN5OTkvk5ry5YteOCBB7B27dq+g7SdmvYYAOju7i63+SrN8/w5geBuZ64tKW1JA0B7e3vfffnBBx/UO7apqQl37tzRdlrN27dvr7b5TkupVJ7T/r+mpmZAVTbFiRMndP88Zxe99I4dO9oppf/tLW3k5ORApVL9EqoRAicnJzg5OekdV15ejiNHjujut8tuQsvU1NQAQsgljuNcASAkJAQrVqyAp6enwf2Li4vx2WefQaFQaKtzaVZWVrjdRFpyubw9Li6uHsBiAGhpacGpU6egUqmgUqkgFovR2tqK0tJSHDhwAPn5+ejp6dEtXa+YmBgql8u/t6vRUlpa2huEkPWEEKGZh3QBcNTpAP8mk8n+z+ZLWKekT8TExHxNKZ1LCPEepHfPVSqVT4pEokgAwb0l/euYmBiNXC4/YReCe0U3BgcHbxWLxaUAagkhakqpO4BmAMcopZ8BWC+TyTZfuHChMyIi4guhUDhTV7RUKlUVFhb+YFcpHktISUlxFIvF+wA8rjOYeD0rK+ufNl/CQ+H8+fNqAyX9aHR0dLdcLj855gQbE81x3AKpVNpQWFhYaDOBx0iSk5PT1d3d/RSAQzqbF9pUpHWvRPM8/29K6RUAW8BgMBgMBoPBYDAYDCsz7BRPSkqKj4ODwwJCyGOU0qkAfAD4EEIch/O9lNIu3H3w1kgIKaOUHu7p6Tky3KePQxaclpaWTAhZRwiJH80SopQWUEo3ymSy/aMiOC0tLZ4QIiOEhAGAk5MTpk2bhrCwMAQEBEAikUAikUAsFg9LWHd3NxQKBRQKBWpra1FaWoorV65AqVRqhZdSStNkMlnBvRLM6STiOU9PTzz22GOIj4+HSCQaldJVqVQoKCjA4cOH0dzcDEopTyn9R29ynx8xwfPnzxdOnTp1DyHkaUIIkpKSkJycDI7jrNLx8DyP/fv348CBA6CUglL6VVlZ2ZLjx4+rBzt20Kzl+vXrOUdHx1xCyBIXFxe8+OKLmDNnDgixrDV0dHTg4MGD2LFjB06fPo3AwECMHz9+aB0PIQgNDcWUKVNw8eJFqFSqaZ6enlOSk5O/+v777+mwBIeGhq4jhPzRyckJr776KoKDgy26uJaWFuTn5yMnJwdXrlxBZ2cn2tra0NDQoDfLZyh4enpi+vTpOHfuHNRqdYRCoegZ7ImGScGrV6+ewnHcfwghwpdeeskisXV1dcjLy8OOHTtQWVnZN/lFi0Qiwbx584ZdvceNG4eJEyfizJkzADAnKipqd1FRUYux/U0+BeQ4LoMQ4hgfH2/2dKXy8nIcPHgQFy9eBKWGa5eLiwtSUlJGrE1Pnz4d8fHxKCgocOQ4LgMmct1GG+KqVav8hEJhjUgk4jZu3AiJRGLq3oiSkhIcPHgQFRUVRvdzc3PDggULMHfu3GHftvqjUCiwbt06qFQqXq1WB37yySf1FpWwUCh8lhDCRUREGBWr0Whw9uxZHDp0CA0NDUYvxtfXF48//jhmzpwJ7QSZkUYikSAiIgJFRUWcUCh8FsD7llbpRACQSqUGg4KTJ0/iyJEjaG1tNfoFwcHBSExMREREhMW9+lCQSqUoKirSXrtlggkhkwBgwoQJetvr6+vx9ttv901HMkVFRQU++uijeyLOx8cHK1eu7JsdqHut2ms32C+ZaJdBwC8TzLTk5OSYJfZe09jYiF279CcGaa9Ve+0WCTbGaIWR5mDOrF6zBRNCqgHg1q1betuTk5MHzMmyBsHBwVi0aJHeNu21aq/dojZMKb1GCJl248YNBAYG6t3zNm3aZJOd1o0bN/qu3eJISyqVehFCnqCUIjY2tv8tC5MnT8YjjzwCLy8v3Lx5Ex0dHQO+o7W1FT/99BPkcjnEYjH8/Pzu6YDj66+/RmNjIwBsKSws/NEiwZGRkdUcx73a3NxM5s2bZzBQ4DgOgYGBePjhhzFx4kS0tLQYLPGOjg4UFxfj9OnTIITA398fQqFwRMUqFArs3LkTGo2GV6vVqUVFRQqLBBcVFSliYmJmUUpDOjs7ERkZaXL0MmHCBMyZMwfTpk2DQqHQmzaspaurC6WlpTh58iQmTZo04A4wHHbv3o3r16+DUnpg69atmUMaPERHR58lhKTX1tYKg4OD4eXlNeiJ3d3dMXPmTERHR6O7uxuNjY0DYuqenh40NTUhPn5kskOXL1/GF198AUppF8/zi0wNHkwKLioqapFKpZQQ8uiFCxcQHh6OcePGmXURrq6uiI6Oxq9+9SvwPI/6+nq9EdMDDzyAhISEYYutqanBhx9+CLVaDQDrs7Oz9w1rPJycnHyqo6MjRK1WRxQVFSEoKMjoLFpDODk5YcaMGZg3bx5EIhGUSiVcXV2xatUqkwMSc7hy5Qo+/vhjbSC009fX98+DJQDuuxQPS+KxNK1x4fdHIr4/9vaohcFgMBgMBmPUGEqkxa1atSrMwcEhVqPRzCKEPEQIaaSUnuF5/pxSqTy3Y8eOdrsXvHr16ikCgeADAAmEEOdBwsIySulbMpnsE7sUnJ6e/gcAb1kaH/M8/61KpVptS/EvGWRgMEksFn8KYMi5GErpbQAvZWVl7bQFwUZTPKtWrfITiUQXCCGhhj53dHTE5MmTERUVBTc3N/T09PSNVfV+UUIcCSG/iY2NVRQWFp622RJOT08/QAh5ov/2uLg4PPnkk/Dx8RnwNEGhUOD8+fPIy8tDV1eXoeFedFZW1hWbE5yenp5OCNHL7bq4uGDZsmV6z4s7Ozv7hI0bN64vud7S0oLc3FxcuXKlv+hzWVlZs8xNx4xKlV6zZs0kSulXhBAH7TZnZ2e8/vrrAya1fPHFF9i2bRuOHj2KiIgIuLm5QZv2mTVrFpqbm1FXV6dbvf2kUmmPtd4dBgw8PeR5fmP/BcKWLl0Kd3d3y6oOIVi6dKmhuVjrly9f7m0zgvv3yJGRkZg1a9aQvtzZ2RnLly/v/0M4ODo6zrQJwSkpKT6EED/dbYmJicM6QXh4OPz9/ftvjrGWYL1HeGKxOKZ/tdRebE1NzYDbzu3bv6z6Vl1drbegCXB3dSaxWIygoKD+bTnOJgTzPB+r+zTBx8enL7+8Z88elJUZX7mx/3wLAHj99dcRGBiIoKAgnD59Wre3jrWJKs1xnN5qKr6+viNyEt3FinrP45OSkjLe6iVMKa3UDSaam5t/aXQxMQgICNA7+Oeff+6rqrGxsXB1ddX7XPuwrP88EUppi7VWQdQTrNFoftJ9Mq99xCkQCDB//vwBB+/cubNP8KOPPjpgeSnd9t0PuU1UaYFAoLcElFqtRn19/bBPUlNT03/TOZsQnJWVVQ1A7+m5bmczFOrq6gaUMCGk0CYE97avs7p/Hzt2zGTvbAqNRoOcnJwBc6X7n8OqgjUazfrexXS1F4fc3Fx0d3cPONjNzQ0BAQEICAiAg4PDgM+//fbbAdWZUprdW5NsZ7T0wgsvvAngNd1tgYGBSElJMRQ1DUClUuGrr77C0aNH+09oaW5paXlwz549HTaVAJBIJCc8PDwWEUL6bqDt7e0oKCgAx3GYPHmy0Zl1VVVV+OCDD1BSUmIwvHZwcKiRy+XnbKqEezMeM4RCYaHuMFEnBEVAQACCgoLg5+eHtrY21NTUoLq62uRURJ1m8/vs7Ox/21xOKy0tbQEhZBshJGCkT2wt0SanLcnl8spp06ZtFQqFvoSQqCEk8Moppf9DKVVpVy/WCS+To6Ojb4x29bZkQe1kQkhm/+GjEaE8gI/q6+v/un///ju9x3/Mcdwaa5f0UGbxTCWEzAQQB2AmgIcopY2EkLOEkJ8opWfr6+vlWqH9jrW6aDLabcjaogWjLVgul38TExPjY602PeqCrS3aKoIHEy2VSosLCwvvScKegxWRyWS/53neULv966gNHmxEdPmYFawVTSl9BcAVSmk+pfR/wWAwGAwGg8Fg2DbM93AwmO+hCZjvob0IXrZsmadEIrmktSvx8/NDSkoKgoIMrw9y4sQJ5OXl9T1xpJT+Jysra5ktCB6276EhmO8hmO+h1Ri276ExxrzvYX/GrO+hMcas76EpmO+hPfTSg/keGsNWfQ/NevLA83waz/PtwN01qzZv3qw38bQ/xcXFyMzM7JuyRCktzczMzLWbSIv5HjLfQ4PNgPkeakUz30NbLuGhwHwPme+hjQUe90I08z1kMBgMBoPBYDAYDFuC+R6aC/M9ZL6HIw/zPbRl30Nd6uvrkZGRgRMnTqCtrQ3+/v4GF00wWkq27HtoiM2bN6O2thbt7e24evUqjh8/jvb2dvj5+VlkbWRTvoemOHv2LFpaflkfRaPR4Nq1azh+/Dhu3rwJb2/vAev6GMNS30OTgmNjY7dzHDc9Pj4eCxYsGLE26OnpiZKSEr1Hqr09L+rq6vDDDz/g+vXrcHd3N2tpOi8vL7S0tKC2tlYIYIpcLt9pseBVq1b5CQSCj0QiEVm7du2I+hR6eHjg4YcfhkQiQUNDw4AlIQHg5s2bKCgowOXLlyGRSODt7W2y35g8eTKOHTsGnueDIyMjsy22H4qLi1tNCEmKjIwcMdccXUbapEosFqOmpgaNjY2E47haiw2mpFLpekLIlOTkZPj5+eFeMdImVXL53ZWrCgsLdxj8oU10/ZOAgb6HlZWVyMvLM2nZeS9pbW3Fnj17sH//fqSnp+tNhbwnvof5+flWE6uLUqnE/v37B/QNutdukWBjGOpgrIU506fMFmzM93DZsmVmz8S7lzg7Ow+w9L0nvocTJ07Ehg0b7sWwb9iWvub4HpqafnQQwBOFhYUDfA9HkpG09NWZSHDQYsFqtfpzoVD4TklJCadQKIbtb2ZovDuS7pgKhQIlJSWglPJqtfrzIQ0P09LSvuE47sn4+Hg8//zzIya2vr4e7777rsFAQzsamjFjBhITEzFlyhSzvjM3NxcFBQXgef5bmUy2cChVGjzPv0II+XVBQYFjXFycRdP/TZGTk2NQrEAgQGxsLB5//HGzlqLTcvnyZRQUFGh9D18Z8mhpOL6Hpvjxxx/1qrGDgwMSEhKQmpqK+Ph4s0dKgA36HhrC398f1dXVEIvFmD9/PlJTUxETE2OxzS/zPWS+hyxNyxLxFsN8DxkMBoPBYDBGMNJivocGwkLme2gXgpnvoQ7M9xD3ge+hMcas76ExmO+hPsz30GqCme/hIL6HgzGmfQ8NwXwPfzmPffoeDsaY8z00F+Z7yHwPrRh4MN9DE76Hg2GLvocDBg9FRUV1sbGxYgDztNvu3LmDS5cuITg42Kz5FyqVCnv37sWhQ4f6f9Tc2tqaVFpa2mMzgntvJ8z3sF8IynwPh9ChMd9Dq5dwv9Jmvodgvodm/WDM93A02zTzPbQF0cz3cKwINiGa+R4yGAzGfYnZsfTKlSshFArB87zZL3do91Wr1di2bZt9CE5NTQXHcVCpVF5CoXASz/OuHMc5mSlYyXFcu1qtviYSiZp4nkd2drZtCta67lBKH+I4bp+pt67NTAZc43n+KULIha6uLmzfvt0qgoUmfghn3H1Lc05ycjKioqLg5eVllvWQLl1dXWhqasL58+cn5efnFwM4BSARwB0A1CZKeOXKlV4CgeBqcHDwuD/96U8ml41pbm7GrVu3EBISMmjb7unpwbvvvouKioo2jUYTsm3btiarC05LSwOA8vDw8MmvvPIKMVVyMpkMly5dgkajwcKFC/H000+bddKMjAx66dKlSgBTZDLZqArWGx4mJSXB1dX1n+7u7oveeOMNg2KrqqrwySefYOfOnX1vZHd1deG5556Dm5ubWSedPXs2OXXqlLtSqRRPmDDhu/Lycqu1YTHHcesMvSt89epV7N27F6WlpXBycoJarYZEIkFUVBSWLVtm0WpJAPD8889j8+bN6wD8A0C3VQT7+vpGANBzu7t48SJkMlnfsyXtG6BLly7tbxFmEdpz9J7znFUEcxznBtyddQcAn376KU6cOGHwZcrPP/8cu3ZZZrBDCEFCQgJWrFjRdw7tOUcLbpB758j2kISM2puoZpUwz/OtAoEAHR0dcHFxQUpKCmJjY/WqtJZnn312WFVa+0o8z/OtoylYr5f28fG5NW7cuDemTZsGLy8vAIC3tzeSkpIQGhqKxsZGNDQ0QCQSoaSkBMeOHcONGzcQFhZmdKkJY5SXl+PMmTOoq6v7Q3l5ucYqgkNCQjQSiURcVlY2r/+CYR4eHpg7dy6ioqJw8+ZN3L59Gz09PaitrcXevXsRHh5u0u2yP++88w7u3Lmzsb29/dBo3pYE/X91qVT6nVKpXF5ZWek2e/bsAfdiNzc3aFdQq62tRVNTEwQCAVxcXBAWFmZ24FFdXV0J4Kndu3fbZ2g5derUQVdCtMnQUrt9+fLlzo6OjgcppXMWLVo0EoMH5OfngxByqqurK3H79u1WGTwYGy1RAJ0A5gJ4aP/+/fu++eabYQ8PATwFwKrmyywBMNZTPAwGg2FXWNJLD+u2ZI2oaqj34RHNS2dnZ9tk4DFmQ8thDx60mZGysjJ4eHiYXE3NFgYPBkftcXFxF2bMmOHzl7/8hZgzsM/Ly8Nnn32GY8eOoaqqCpGRkQZXBhYIBJg7dy6qqqrEt27d+o1cLt9sdcFpaWkm89IGRyBCIY4ePQqhUIgbN27g4MGD+Pnnn+Hr62swV63NS4eFhYnlcvl3VhOclJQkHj9+/MH09PS+FI85eHh4YOHChWhra0NLSwu6urpw+/ZtHDlyBGVlZZgwYcKAbIifnx/Onj07z9vbe5PVUjwJCQnRAoEgfcmSJRYn1gUCAaKiovDEE0/AyckJly9fhkgkwu3bt3H69GkcPnwYgYGB8Pa++yatk5MTDh06BGdn531FRUX1oyXYZF56586dOHr0KHiet1h8/7bf3d2N9957D/PmzUNKSopt5qVVKtU9yU1bE5N56RUrVmDFihUWf+nhw4eRl5ent00sFmPt2rWYMWMGAOvlpfUENzQ0lAQFBaG6utrsDKTuPXbXrl04f/48FAoFhEIhlEolwsLC8MwzzyAkJERvf+3bag0NDSVWE+zr69vN8/zG3NzcdZs2bTL7S6qqqrB+/Xo4OTmBUgqhUIiQkBA888wzePDBBw0ek5ubC57nN/r6+nZbrQ03NDSA47jXWlpaKjIyMsxuvMXFxRCLxSCEICIiAu+//z7+/Oc/GxWbkZFBW1paKjiOe83UItqjElqmpaVBrVZbFFryPI+rV69aHFoKhcKm0Z4BwAYPvYMHCAQCBAcHo6KiYkSHh8HBwRcqKiqg0Wisksk0Z54WFi1ahC+//HJYCYDFixc39ZYwrDlPy+xE/HADBkopWCKewWAwGMPopZOSksSBgYFfAQgDEEApbSWE1PWu0f6fMSU4PT19FiHkR7VaDW9vb7i5uUGpVKKxsRE8z4NS+nFWVtaLY0bwCy+8QAHgd7/7HebOndu3va2tDX//+9/R3d0Nnuf/KJPJMuxJMGekdHdoNBosXrxYTyxw10ly06ZN2uHgOnsrYc5IGDjd2dkZiYmJuHbtGiorK/v+VVRUoKenB8HBwSCETFiyZImDPQk2NovHV+u6k5GRobc0nEajwXPPPYegoCBcvHgR48aNmwvgqF0LJoQ0tre3+wDAv/71rwGfCwQCbNmyBRzHobu7u2AsVOmyjo4OfP/99xCJRAP+qVQqVFZWglJ6UygUdtm94KtXr/5WKBT2ZSF16ezsxBtvvKGt5p/3GjvZdxsOCQlRU0p/TQg5+uGHHyIgIADjx4+HUqlEQ0ODro3uGpFIdBhAvl3fh+fPn4/Q0FAolUoPR0fHLwGEEkK8KaWdAOoopRkcx9VQSvcRQoharU7aunXrf+22SmszFE5OTrc0Gk2Cr6/vhMzMTG7SpEkuYrE4lOO4jwB8TSmdCwBCofBAWlpasr2Hlujq6urLUhJC+p4zUUrBcZzWviueEHKy95b12NatW7+zyxLOysrS+zszM9NgLeA4roAQshhAt0AgeNauR0uD0fvaXl+CT6PRYOvWrfbZhs1B+9RAK9jSFz3sTrCuaAaDwWAwGIxhhZb3dSLew8MDnZ2ddp+INxr8xsbG1gJ3V2NYuXIlfH19kZiYiEceeQQ//PADNBpNXExMzG25XH7GngSbnYh/8803UVVVdX8k4quqqvomf99Xifjdu3ffP4n4l19+GWvXrkVoaOj9kYjXOnr0T8QDsKtEvLE0rTA0NFQFAGvWrEFU1C+Lh3d2dmLDhg1QKBSglH6YlZX18lgQjKlTpz5CCDmqVquNJuIppWpK6W9kMpl9J+J7b03o6uq6fxLxvWnaW7jroTYhMzOTA+ACIBTA2EvEm0NvmnZsJOLNoTdjaVeJ+JFK0+4D4ATgBTYAZTAY95L/ByGe1hbUagy2AAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/scroll_zoom_sprites.png?");

/***/ }),

/***/ "./img/spinner.gif":
/*!*************************!*\
  !*** ./img/spinner.gif ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/gif;base64,R0lGODlhEAAQAMQAAP///+/v797e3sXFxb29vaysrJycnIyMjHJycmNjY1JSUkJCQjExMSEhIRAQEAAAAP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFBwAQACwAAAAAEAAQAAAFdiAkQgGZKOWoQkIjBM8jkKsoPE3gyMGsCrPD47ADpkSBxRDmUChetpRA6SD4kFBkoMC4IlWHhdNQIwXO4cWCXDufzQTEMaoKEBfennWEaBjsB0ACBSR7LDMCDAQFBgKBXyMBCggQBmQCfzUCCDOWIgRzNQQEZSEAIfkEBQcAEAAsAAAAAA8AEAAABWIgJI4QkogBOS5iIwpOoYoM1Dj2Q8yicRsP1kjhMEAcDNPjkUqJFBCGYESY8oQ8SCGBQOyyEIMikfiCX0aVc1RYQNUC52EhM8her7UoISAUAmYqCEZ+IoEoBimFEFZZAo0jIQAh+QQFBwAQACwAAAAAEAAPAAAFXyAkjpBxkKiYiEsTBEwqOgrUBnUalFDRFiMBQYRgABmLwyEmODweAhWNJDA8H8MRIbHTPk4igtIQRb3OBYRaxu61UYlDt21ADAmE85zUPQj+EAJ7JAZDgAFlKUCBZXshACH5BAUHABAALAAAAAAQABAAAAVhICSOokGeIhJAyiIqBAoxCOsm6Co6RBvjAYHokBAuEAaDK2By6BA0iA5CaMggNZKwGFgZCgVZwkGGJQ3CU+LBZpBiJ4FcoBMcTNcRAQ2R56UiAQRdU1cEQl1/fYGFf4koIQAh+QQFBwAQACwAAAAAEAAOAAAFRyAkjtBxkCjaNGIzpBAbs4wLH+5aNAyKMK+GwrQqFUcyUrBRUCZSwpEANlKseAPTKVW7kqbKKKrQDK/AgjLMiwKjBog2dRQCACH5BAUHABAALAAAAAAQABAAAAVvICSOEEGQKBQU4oGIiJAGCHscEC6nQiLcAgeORCjIDgYTglGCLEQBwoEQGAUEigdjJxKwSIGFoaoSmMkkg0KxOJjPKYPIkQCjBAw52EzyPh5PUAJVAWQOD1gPDmgpBQ8KJV92Iw0PJzN3D3opmCMhACH5BAUHABAALAAAAAAQABAAAAVfICSOkCCQqEiIhsGm7Fm4xgKLRzBDS4GaAR3BZEiIFkaRYJhKOBSowAmV8ImCQVghkYBiA9oFg4G4jRQFrBmygiTAMESiAQkYGTfH4wApL2EBelNTgIICDlaACgxwJCEAIfkEBQcAEAAsAAABABAADwAABV0gJEKCSBBiMa4Q2qJEwq4wmriBmItCCRUIkuIwCgh2KwQjyEKODq7ZjICoqqSjmGKI1d2kRp+xAWGyHo/DYUEmLliHB6LRMECIMwG65AgwsAUPLn0QDVErPhAKUiEAIfkEBQcAEAAsAAAAABAAEAAABWMgJI5QEJCoeEKCIBIrKpwta8Rk4LbB4aIrk4lQEB0MKaAhgUyiDD8nSXCoSkcChLb4ahBQvuni8WiOFo6DyvFguBqGQmIBMTQSIsPXyGAUm1EjDQF9EAoOTg5vDCJ0SStaSSEAIfkEBQcAEAAsAAABABAADwAABVwgJI5QYAYCqYqmSKzq+a6pKtTGDI/FQQS2lQ6ScBgTsIKSwHg4FzCDwYcSGBy1kWEH+Y0CCcZW1CAGGgvlQdFVIESFrEGxIDgKJRgDQocg9kJlEAtQRFkwBwcwIQAh+QQFBwAQACwAAAEAEAAPAAAFXCAkjiQUlOgYCKXAosJJPs9RygHxEvTzjgJdCfEotGSihjIFITgFCocUkXIWXoHCAmUsKUQ/0SHRhTAg1IXCaUiIEAaRMF5AJARnpmNrhxi2MIAJXwFUTCIGcSghACH5BAkHABAALAAAAAAQABAAAAVkICSOZEkSjmCuxNOsq/IUsPhCwvOYQiAKNwNtFOiVDA5CyTc6MBaLg6koUCEaWOmyqoL4CAqTkhRAQFKlwmEMCUsTiGrBgBP+RCjCwZzoMkUBDAkQexAFCH8kg4RmEHQ1hkMlIQA7\"\n\n//# sourceURL=webpack:///./img/spinner.gif?");

/***/ }),

/***/ "./img/spriteArrows.png":
/*!******************************!*\
  !*** ./img/spriteArrows.png ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAAAHCAYAAACWcWqYAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB90DHg8PDWdn2GIAAACnSURBVEjH7ZVLDgAhCEPFU3sEb82sSAzDr+rshh2tLnw20BpWXNSu1BiDK9qtYmauaFH1Q5inHgTz1ENh7niUPJgMKBQAS73owXPO1xnRLGAVL4JBRK8zolnAKl43IEQwkRSz5WkIEUwkxfqe9BpCBBNJsb4nfXeSRUHqGpjoFOrae8B3PsGDuvYe8J1PMGdwkj4G9OM56S2lr+akt5TQxfRv+Ytb/gF3t7Kg6oHn4AAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack:///./img/spriteArrows.png?");

/***/ }),

/***/ "./img/tracklist_bg.png":
/*!******************************!*\
  !*** ./img/tracklist_bg.png ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAPCAYAAACfvC2ZAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAALEwAACxMBAJqcGAAAADhJREFUSMdj/PTp038GGoD///+jYGxipIr/+fOHgYlhiIFRB486eNTBow4edfCog0cdPOrgEeVgAKWCPLGar0uxAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack:///./img/tracklist_bg.png?");

/***/ }),

/***/ "./img/tristate.png":
/*!**************************!*\
  !*** ./img/tristate.png ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAWCAYAAAAisWU6AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gMeFhIajrvb6AAACjJJREFUaN7tmnuMVNUdxz/n3pnZee3s+8GyD5YFBHktD5FHyiOmJrVoiVClWPWvJo3Wmj6wPmr9o7VJU2tjTEgjtbEqYmytiAUEXBDQkoLWJ4i8Ydld2N15z87cmbn3nP6xKwLu7tzdHeAP/SUnmZ3M/X3O99zv+e3JOUfsfHuXAhAorlT0kgRXg9sua7gaUaN1fK30OgCunfHdKwo9+MEmABYt/NYV5e7avQeAFQvqryj3n++e/trpdYwkQTrtQCqBHlXIv1czamojylMG/kois5+5bB03DAOpJETaCa655SKuc8kTuWeyUiPgKkS0ndjaFRdx1YLHL5veWCyKKS209g/Jbv8J5ZMmo9yV4K1Gm/3oZdMbi8WwpETv+BD19s8u4prTHshdsYYFjTrZtOGnRGNQF9rLyrku8JahfJUIvcBWDinlkLmRSIR1658nEo32cSeAt+Q8105OJYc+0NFolJf/8RLRWKxfrp2cw9HbeqaVt1q2ks5kGB3ew02zpoGnEuWtRmiXT29bWxs7d7cMyM2VUxuOqUJBNzu23Utz8yIWzJ9L6prvsf5IBYa7Gt3lQ/WE7K0BlBpS6+zsZMPGfzF9ejML5s/r45ZdxB3s+fMvWA2tdXZ188bmjTQ3zxiQO9jzdvTKTIYzP3+AAxMnk9i6HaUUhw8fZtfuFmbMmMmsmTNxnizhgzta6NqfQHP6UKngiPVamSwdqx/m8NQZJLa1IBUcOXqUd/buGpSbS++QK1Y04mPPznsY1zQXw0gRCAS4ZenN7N1bzisfvMvtkyLoHYdsG8tuhMNhNr+5kcbGRgzDIBAo7Jer2cgph8jd9tYmxo4dOyjXTs7B9J5a/SCxTVsBxanVj+A4fYr3CwuYNGkShmHg3riJqu07MR1+Dv9hK3qBQVF1CEaot+2hR0hs3gYo2h76DbSe5uMSb06unJ7nipU2nITDbkARCAQYM6YRj9vDkoWLsUqn8ur+IFZXZ94rViqVIhiKAhAIFA7IzXfFShlpQuFYTu5IK1b5bSswkSjdgZExCP/xKbTPjqAUFLy7D/PlV1HoCLebdG0de3vcyODJEestWb78Im78yadtcXPpHbKxSgNR6jxraWs/x5iGJlzOAizTIhQOccOShXQULeCNaL3tNZbdVlooaPDuo6397KDcwXIMx1ilhRr1HhtcG8YarG/uOddR+/vHMZ1OTCywklQ8+zSJ9a9i/OkpLM2BKSU0jKZpzZN0VC1hR6x5xHpdc+ZQ/bvHyTpdmEKClbLHzaexzBScO+hi7kQ/rsRf+eij/4GCSCRMxsrQ1d3N3FlTOeRfkNeKlUkGaf1kHXOuOYYr8eygXDsz2JL2mtETou3AS1w/MTd3sDx29ZYsW0rtrx8km0qRSkeocZk0vbgGt9NFJptB1ddQ8ttHSfj9zJgygSO+RXnR6795KVUP9XKNTNgWN5de28bKJgVHW9z4mURd863Mnxihdf/9bNqyBc2hkUgkiITDdHaeo25URd4qlpHo5JOtv8BpbaaueXlObr4qVrqnm8Mtv8TLFnvcEVasL5pr0XisVUn8GgQoRnM68SbaMUeNonrNU6RLS4jFooRCQUZXleVNr3PheOQPkvg1YY+bj4olTTi8zU3juBmMbnCSjh1C9xWyYIpJYegxXt+4jVQySTgcIh6PU1xamhdjZTNJPt5yH/VNIUY3uEjHPkP3+Qfl2hnoXDM4mzU4tP0+Gsfb59qpWIP1zbIk6VSIg2/eyJTZE6itV0RFmogGlj9Do+s99rXswDBSRKNhEokeAkXFI9ZrWpA2IhxruZEp19nn5qVixTp0NMtHUbGBKZ0I93VYZhpTKerKTa71PMGed/5LMtmDy1VAV2dnXowVbtsH1gmKitOY0mGLm48ZHG3fjy6PD407woqllOTcoecoPSNx/uVjPEUagXI/GlmKqy18pJn32mqOvf46qZSBy+UiGOwesV4FBA8/R9lQucOtWMoSvU1B+ISDmnGzQUqggFjXf4if6yZrSIyUoqrEwRixlmAoSldXF62tnw3bWFY2hpWNYlkZuk9sp2bcZJDWJVx1AfdvBEOJPm6rvRms+mlmAsuMY0qT8KltQ+Kebm3tP2dfG0yvmT6DlT6NZSVJ//tZKnc4kKZCxSX+MQrvPQbONGCAswdmbf0z1qefEAwGOX78+PD1ZtqxMmcwpYHcvHbI3Fx6B9zHkp/3rpN0XZBqM6icOh1hWliiie5jr5CxdHAUoDuzdHcnqWk0kMkXONnRzMo7N5w/ZB7qvk766OLz3J52gwnTfowwM1hiXB9XO88NdhdQO2YxJNOc6Mjyw1V329ob6+83zhPzznMzHQaV0wfmdncVUNVwA9mkyemzaW69/UfD5tI5BQXoB6FqAzh8o5AiiygrI3rbcbJlhfSYBXhfDGFqJq6szpR1z7Bl6SrmL102bK4vOL5X70Fw2uA6szqT1z3Dm0tX0fyd7+fkDrxBKhQo0esP1TvgaXMyZvx9nN4KhOkhHAwTSYQQow0qxkgmyhPM8p0kmVS2jGVZVj9cL6jkBVyNtDkFM/4eTm95HzdGJF6DVr2M4vr5XCMlM+f6SCQS/ef8yoZhP4MvvAgb3FC8FqtqOaX1C2mSkqlzfSSTSeycmvTXN6E0hJCYW4EEoEz08jK4tx5HZQlYRUSndxI6EKd0twvNFcBjaSwcXcfpYHD4em1ygwfilO0uQLgCeCyd62uaOBWO5NQ7oLGE+NLpQoP3t76AmUmj6yBdFpZuIkt6cNdaeAoVRgo0DZJJhcslbP8r/CpXoZQOiD7u831cB9JRh6WXYBUup6CiHm9hFclkEk3TUErhcrnsnZ0pBuSqS7ia7kA6GsjqpWQL70CraMBbWI2RSiE0DXqSOF1OOxvg/fbNIXr7o90viJ8F57EkkWUmppHA+NxLyozTmZpGZvEKxvnbqNnwBkfvWkm8th6v2z0CvQNzU597SZkJzqZmklq8ivH+MzRseI2Dd91JvG4sbo8np94BjaU0idBBAuOmO5Ay1VuFBCB1siU96KUSywIhBKLPS5oQaDY3MfqfbR40h6eXOy2AlArwgxAo2U3adxta4bexLKuP2wvWNA1N02zN4H71Ch/C4UUCTdOK+riFfW+gix7/najATUhL9jK/0NvHHa5eXekIoaEEBB4WqGyamqJ0X/5uIulV1Ph+RSaTQZ8jiK28nZrychwuJ7quD19vDm4wczflhY9hZky0edC96i5GVVRQ53Li0HOfBA74C31CcNBzny/vLwiGG/3OtprXuPBbcclnTx5uEPR32S5T3zLoM57cr2pYeo2S41/+UdxnwAvXQpc+UFmRF72JygsuCvSz7ejta+ejumpIekd0H2ukMdx7QiMNTXyj93LHVTXW1QpdqG/0Xm5jZYT3ikOvBvM8V3Oga1cYrDm4auN8lfSK9ds/VenoWVtrhHyFK1CNEIKrwY0YgvYzp3uvNl+hGF1bT6lX+1rp/T+bdjPTjGfqfgAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack:///./img/tristate.png?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./css/genome.scss":
/*!********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./css/genome.scss ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Imports\nexports.i(__webpack_require__(/*! -!../node_modules/css-loader/dist/cjs.js!../node_modules/dijit/themes/tundra/tundra.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/dijit/themes/tundra/tundra.css\"), \"\");\nexports.i(__webpack_require__(/*! -!../node_modules/css-loader/dist/cjs.js!../node_modules/dgrid/css/dgrid.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/dgrid/css/dgrid.css\"), \"\");\nexports.i(__webpack_require__(/*! -!../node_modules/css-loader/dist/cjs.js!../node_modules/dojox/form/resources/UploaderFileList.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/dojox/form/resources/UploaderFileList.css\"), \"\");\nexports.i(__webpack_require__(/*! -!../node_modules/css-loader/dist/cjs.js!../node_modules/dojox/grid/resources/tundraGrid.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/dojox/grid/resources/tundraGrid.css\"), \"\");\nvar urlEscape = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/url-escape.js */ \"./node_modules/css-loader/dist/runtime/url-escape.js\");\nvar ___CSS_LOADER_URL___0___ = urlEscape(__webpack_require__(/*! ../img/commonIconsEnabled.png */ \"./img/commonIconsEnabled.png\"));\nvar ___CSS_LOADER_URL___1___ = urlEscape(__webpack_require__(/*! ../img/commonIconsDisabled.png */ \"./img/commonIconsDisabled.png\"));\nvar ___CSS_LOADER_URL___2___ = urlEscape(__webpack_require__(/*! ../img/spinner.gif */ \"./img/spinner.gif\"));\nvar ___CSS_LOADER_URL___3___ = urlEscape(__webpack_require__(/*! ../node_modules/dijit/themes/tundra/images/titleBar.png */ \"./node_modules/dijit/themes/tundra/images/titleBar.png\"));\nvar ___CSS_LOADER_URL___4___ = urlEscape(__webpack_require__(/*! ../img/spriteArrows.png */ \"./img/spriteArrows.png\"));\nvar ___CSS_LOADER_URL___5___ = urlEscape(__webpack_require__(/*! ../node_modules/dijit/themes/tundra/images/tabClose.png */ \"./node_modules/dijit/themes/tundra/images/tabClose.png\"));\nvar ___CSS_LOADER_URL___6___ = urlEscape(__webpack_require__(/*! ../node_modules/dijit/themes/tundra/images/tabCloseHover.png */ \"./node_modules/dijit/themes/tundra/images/tabCloseHover.png\"));\nvar ___CSS_LOADER_URL___7___ = urlEscape(__webpack_require__(/*! ../img/tracklist_bg.png */ \"./img/tracklist_bg.png\"));\nvar ___CSS_LOADER_URL___8___ = urlEscape(__webpack_require__(/*! ../img/scroll_zoom_sprites.png */ \"./img/scroll_zoom_sprites.png\"));\nvar ___CSS_LOADER_URL___9___ = urlEscape(__webpack_require__(/*! ../img/plus-chevron3.png */ \"./img/plus-chevron3.png\"));\nvar ___CSS_LOADER_URL___10___ = urlEscape(__webpack_require__(/*! ../img/minus-chevron3.png */ \"./img/minus-chevron3.png\"));\nvar ___CSS_LOADER_URL___11___ = urlEscape(__webpack_require__(/*! ../img/red_crosshatch_bg.png */ \"./img/red_crosshatch_bg.png\"));\nvar ___CSS_LOADER_URL___12___ = urlEscape(__webpack_require__(/*! ../img/dark_20x2.png */ \"./img/dark_20x2.png\"));\nvar ___CSS_LOADER_URL___13___ = urlEscape(__webpack_require__(/*! ../img/dblhelix-red.png */ \"./img/dblhelix-red.png\"));\nvar ___CSS_LOADER_URL___14___ = urlEscape(__webpack_require__(/*! ../img/helix3-green.png */ \"./img/helix3-green.png\"));\nvar ___CSS_LOADER_URL___15___ = urlEscape(__webpack_require__(/*! ../img/loops.png */ \"./img/loops.png\"));\nvar ___CSS_LOADER_URL___16___ = urlEscape(__webpack_require__(/*! ../img/glyph-diamond.png */ \"./img/glyph-diamond.png\"));\nvar ___CSS_LOADER_URL___17___ = urlEscape(__webpack_require__(/*! ../img/plus-cds0.png */ \"./img/plus-cds0.png\"));\nvar ___CSS_LOADER_URL___18___ = urlEscape(__webpack_require__(/*! ../img/plus-cds1.png */ \"./img/plus-cds1.png\"));\nvar ___CSS_LOADER_URL___19___ = urlEscape(__webpack_require__(/*! ../img/plus-cds2.png */ \"./img/plus-cds2.png\"));\nvar ___CSS_LOADER_URL___20___ = urlEscape(__webpack_require__(/*! ../img/minus-cds0.png */ \"./img/minus-cds0.png\"));\nvar ___CSS_LOADER_URL___21___ = urlEscape(__webpack_require__(/*! ../img/minus-cds1.png */ \"./img/minus-cds1.png\"));\nvar ___CSS_LOADER_URL___22___ = urlEscape(__webpack_require__(/*! ../img/minus-cds2.png */ \"./img/minus-cds2.png\"));\nvar ___CSS_LOADER_URL___23___ = urlEscape(__webpack_require__(/*! ../img/plus-arrowhead.png */ \"./img/plus-arrowhead.png\"));\nvar ___CSS_LOADER_URL___24___ = urlEscape(__webpack_require__(/*! ../img/minus-arrowhead.png */ \"./img/minus-arrowhead.png\"));\nvar ___CSS_LOADER_URL___25___ = urlEscape(__webpack_require__(/*! ../img/glyphs_white.png */ \"./img/glyphs_white.png\"));\nvar ___CSS_LOADER_URL___26___ = urlEscape(__webpack_require__(/*! ../img/tristate.png */ \"./img/tristate.png\"));\nvar ___CSS_LOADER_URL___27___ = urlEscape(__webpack_require__(/*! ../node_modules/dijit/themes/tundra/images/circleIcon.png */ \"./node_modules/dijit/themes/tundra/images/circleIcon.png\"));\n\n// Module\nexports.push([module.i, \"/* base CSS environment, with dojo and some resetting */\\n.jbrowse, .dijitDialog, .dijitMenu {\\n  color: black;\\n  background: white;\\n  font-size: 12px;\\n  font-family: Univers,Trebuchet MS,Helvetica,Arial,sans-serif;\\n  /*\\n\\tdojo.css\\n\\tBaseline CSS file for general usage.\\n\\n\\tThis file is intended to be a \\\"quick and dirty\\\" stylesheet you can use to give\\n\\ta straight-up web page some basic styling without having to do the dirty work\\n\\tyourself.  It includes a modified version of YUI's reset.css (we pulled some\\n\\tof the list reset definitions, among other things), and then provides some very\\n\\tbasic style rules to be applied to general HTML elements.\\n\\n\\tThis stylesheet is NOT intended to serve as the foundation for more complex things--\\n\\tincluding the use of a TABLE for layout purposes.  The table definitions in this\\n\\tfile make the assumption that you will be using tables for thier declared purpose:\\n\\tdisplaying tabular data.\\n\\n\\tIf you are looking for a baseline stylesheet using tables for grid layout, you will\\n\\tneed to supply your own layout rules to override the ones in this stylesheet.\\n\\n\\tApplications using Dojo will function correctly without including this\\n\\tfile, but it should provide sane defaults for many common things that page\\n\\tauthors often need to set up manually.\\n\\n\\tThe Dojo Core uses this stylesheet to quickly style HTML-based tests and demos.  Feel\\n\\tfree to use it as you will.\\n*/\\n  /*****************************************************************************************/\\n  /*\\n\\tThe below are borrowed from YUI's reset style sheets for pages and fonts.\\n\\tWe've verified w/ the YUI development team that these are entirely\\n\\tcopyright Yahoo, written entirely by Nate Koechley and Matt Sweeney without\\n\\texternal contributions.\\n\\n\\tCopyright (c) 2007, Yahoo! Inc. All rights reserved.\\n\\tCode licensed under the BSD License:\\n\\thttp://developer.yahoo.net/yui/license.txt\\n\\tversion: 2.2.1\\n*/\\n  /* End YUI imported code. */\\n  /*****************************************************************************************/\\n  /*\\n\\tBegin Dojo additions.\\n\\n\\tStyle definitions, based loosely on the Dijit Tundra theme.\\n\\tRelative unit calculations based on \\\"Compose to a Vertical Rhythm\\\",\\n\\tby Richard Rutter (http://24ways.org/2006/compose-to-a-vertical-rhythm)\\n\\n\\tIf changing the font size, make sure you do it in both\\n\\tpercent and px (% for IE, px for everything else).\\n\\t% value based on default size of 16px (in most browsers).\\n\\tSo if you want the default size to be 14px, set the\\n\\t% to 87% (14 / 16 = 0.875).\\n\\n\\tTypical values:\\n\\t10px: 62.5%\\n\\t11px: 69% (68.75)\\n\\t12px: 75%\\n\\t13px: 81.25%\\n\\t14px: 87.5%\\n\\t16px: 100%\\n\\n\\tDefault: 12px\\n*/\\n  /* Headings */\\n  /* paragraphs, quotes and lists */\\n  /* pre and code */\\n  /*\\n\\tTables\\n\\n\\tNote that these table definitions make the assumption that you are using tables\\n\\tto display tabular data, and NOT using tables as layout mechanisms.  If you are\\n\\tusing tables for layout, you will probably want to override these rules with\\n\\tmore specific ones.\\n\\n\\tThese definitions make tabular data look presentable, particularly when presented\\n\\tinline with paragraphs.\\n*/ }\\n  .jbrowse table, .jbrowse tbody, .jbrowse th, .jbrowse tr, .jbrowse td, .dijitDialog table, .dijitDialog tbody, .dijitDialog th, .dijitDialog tr, .dijitDialog td, .dijitMenu table, .dijitMenu tbody, .dijitMenu th, .dijitMenu tr, .dijitMenu td {\\n    background: none;\\n    color: inherit; }\\n  .jbrowse tr, .jbrowse td, .jbrowse table, .dijitDialog tr, .dijitDialog td, .dijitDialog table, .dijitMenu tr, .dijitMenu td, .dijitMenu table {\\n    margin: 0;\\n    border: 0;\\n    padding: 0;\\n    line-height: normal; }\\n  .jbrowse label, .dijitDialog label, .dijitMenu label {\\n    font-weight: inherit; }\\n  .jbrowse body, .dijitDialog body, .dijitMenu body {\\n    margin: 0;\\n    padding: 0; }\\n  .jbrowse h1, .dijitDialog h1, .dijitMenu h1 {\\n    font-size: 1.5em;\\n    font-weight: normal;\\n    line-height: 1em;\\n    margin-top: 1em;\\n    margin-bottom: 0; }\\n  .jbrowse h2, .dijitDialog h2, .dijitMenu h2 {\\n    font-size: 1.1667em;\\n    font-weight: bold;\\n    line-height: 1.286em;\\n    margin-top: 1.929em;\\n    margin-bottom: 0.643em; }\\n  .jbrowse h3, .jbrowse h4, .jbrowse h5, .jbrowse h6, .dijitDialog h3, .dijitDialog h4, .dijitDialog h5, .dijitDialog h6, .dijitMenu h3, .dijitMenu h4, .dijitMenu h5, .dijitMenu h6 {\\n    font-size: 1em;\\n    font-weight: bold;\\n    line-height: 1.5em;\\n    margin-top: 1.5em;\\n    margin-bottom: 0; }\\n  .jbrowse p, .dijitDialog p, .dijitMenu p {\\n    font-size: 1em;\\n    margin-top: 1.5em;\\n    margin-bottom: 1.5em;\\n    line-height: 1.5em; }\\n  .jbrowse blockquote, .dijitDialog blockquote, .dijitMenu blockquote {\\n    font-size: 0.916em;\\n    margin-top: 3.272em;\\n    margin-bottom: 3.272em;\\n    line-height: 1.636em;\\n    padding: 1.636em;\\n    border-top: 1px solid #ccc;\\n    border-bottom: 1px solid #ccc; }\\n  .jbrowse ol li, .jbrowse ul li, .dijitDialog ol li, .dijitDialog ul li, .dijitMenu ol li, .dijitMenu ul li {\\n    font-size: 1em;\\n    line-height: 1.5em;\\n    margin: 0; }\\n  .jbrowse pre, .jbrowse code, .dijitDialog pre, .dijitDialog code, .dijitMenu pre, .dijitMenu code {\\n    font-size: 115%;\\n    *font-size: 100%;\\n    font-family: Courier, \\\"Courier New\\\";\\n    background-color: #efefef;\\n    border: 1px solid #ccc; }\\n  .jbrowse pre, .dijitDialog pre, .dijitMenu pre {\\n    border-width: 1px 0;\\n    padding: 1.5em; }\\n  .jbrowse table, .dijitDialog table, .dijitMenu table {\\n    font-size: 100%; }\\n  .jbrowse .dojoTabular, .dijitDialog .dojoTabular, .dijitMenu .dojoTabular {\\n    border-collapse: collapse;\\n    border-spacing: 0;\\n    border: 1px solid #ccc;\\n    margin: 0 1.5em; }\\n  .jbrowse .dojoTabular th, .dijitDialog .dojoTabular th, .dijitMenu .dojoTabular th {\\n    text-align: center;\\n    font-weight: bold; }\\n  .jbrowse .dojoTabular thead,\\n  .jbrowse .dojoTabular tfoot, .dijitDialog .dojoTabular thead,\\n  .dijitDialog .dojoTabular tfoot, .dijitMenu .dojoTabular thead,\\n  .dijitMenu .dojoTabular tfoot {\\n    background-color: #efefef;\\n    border: 1px solid #ccc;\\n    border-width: 1px 0; }\\n  .jbrowse .dojoTabular th,\\n  .jbrowse .dojoTabular td, .dijitDialog .dojoTabular th,\\n  .dijitDialog .dojoTabular td, .dijitMenu .dojoTabular th,\\n  .dijitMenu .dojoTabular td {\\n    padding: 0.25em 0.5em; }\\n  .jbrowse .jbrowseIconHelp,\\n  .jbrowse .jbrowseIconBusy,\\n  .jbrowse .jbrowseIconLink,\\n  .jbrowse .jbrowseIconCancel,\\n  .jbrowse .jbrowseIconHorizontalResize,\\n  .jbrowse .jbrowseIconVerticalResize, .dijitDialog .jbrowseIconHelp,\\n  .dijitDialog .jbrowseIconBusy,\\n  .dijitDialog .jbrowseIconLink,\\n  .dijitDialog .jbrowseIconCancel,\\n  .dijitDialog .jbrowseIconHorizontalResize,\\n  .dijitDialog .jbrowseIconVerticalResize, .dijitMenu .jbrowseIconHelp,\\n  .dijitMenu .jbrowseIconBusy,\\n  .dijitMenu .jbrowseIconLink,\\n  .dijitMenu .jbrowseIconCancel,\\n  .dijitMenu .jbrowseIconHorizontalResize,\\n  .dijitMenu .jbrowseIconVerticalResize {\\n    background-image: url(\" + ___CSS_LOADER_URL___0___ + \");\\n    width: 16px;\\n    height: 16px; }\\n  .jbrowse .dijitDisabled .jbrowseIconHelp,\\n  .jbrowse .dijitDisabled .jbrowseIconBusy,\\n  .jbrowse .dijitDisabled .jbrowseIconLink,\\n  .jbrowse .dijitDisabled .jbrowseIconCancel,\\n  .jbrowse .dijitDisabled .jbrowseIconHorizontalResize,\\n  .jbrowse .dijitDisabled .jbrowseIconVerticalResize, .dijitDialog .dijitDisabled .jbrowseIconHelp,\\n  .dijitDialog .dijitDisabled .jbrowseIconBusy,\\n  .dijitDialog .dijitDisabled .jbrowseIconLink,\\n  .dijitDialog .dijitDisabled .jbrowseIconCancel,\\n  .dijitDialog .dijitDisabled .jbrowseIconHorizontalResize,\\n  .dijitDialog .dijitDisabled .jbrowseIconVerticalResize, .dijitMenu .dijitDisabled .jbrowseIconHelp,\\n  .dijitMenu .dijitDisabled .jbrowseIconBusy,\\n  .dijitMenu .dijitDisabled .jbrowseIconLink,\\n  .dijitMenu .dijitDisabled .jbrowseIconCancel,\\n  .dijitMenu .dijitDisabled .jbrowseIconHorizontalResize,\\n  .dijitMenu .dijitDisabled .jbrowseIconVerticalResize {\\n    background-image: url(\" + ___CSS_LOADER_URL___1___ + \");\\n    width: 16px;\\n    height: 16px; }\\n  .jbrowse .jbrowseIconHelp, .dijitDialog .jbrowseIconHelp, .dijitMenu .jbrowseIconHelp {\\n    background-position: 0; }\\n  .jbrowse .jbrowseIconLink, .dijitDialog .jbrowseIconLink, .dijitMenu .jbrowseIconLink {\\n    background-position: -152px; }\\n  .jbrowse .jbrowseIconCancel, .dijitDialog .jbrowseIconCancel, .dijitMenu .jbrowseIconCancel {\\n    background-position: -170px; }\\n  .jbrowse .jbrowseIconBusy, .dijitDialog .jbrowseIconBusy, .dijitMenu .jbrowseIconBusy {\\n    background-image: url(\" + ___CSS_LOADER_URL___2___ + \"); }\\n  .jbrowse .jbrowseIconHorizontalResize, .dijitDialog .jbrowseIconHorizontalResize, .dijitMenu .jbrowseIconHorizontalResize {\\n    background-position: -209px; }\\n  .jbrowse .jbrowseIconVerticalResize, .dijitDialog .jbrowseIconVerticalResize, .dijitMenu .jbrowseIconVerticalResize {\\n    background-position: -230px; }\\n\\n.dijitDialog {\\n  line-height: 17px;\\n  /* styles for the about JBrowse dialog */\\n  /* styles for the highlight-setting dialog */\\n  /* location choice dialog */\\n  /* styles dealing with popups launched by clicking on features */\\n  /* styles for popup dialogs */\\n  /* styles for popup feature detail dialogs from tracks */\\n  /* field names that have tooltips */\\n  /*\\n force long sequences in feature and alignment detail dialogs to\\n wrap at 45em\\n*/\\n  /* styles for the autocomplete menu */\\n  /* NOTE: browsers that don't support rgba colors will fall back to all\\n   track labels being #bcbcbc */\\n  /* styles for feature labels */\\n  /*styles for vertical line and BP label*/\\n  /* styles for per-base quality table in alignment detail pages */ }\\n  .dijitDialog .dijitDialogCloseIcon {\\n    height: 25px;\\n    width: 25px;\\n    top: 0px;\\n    right: 0px;\\n    background: url(\" + ___CSS_LOADER_URL___0___ + \") no-repeat -73px 6px;\\n    border-left: 1px inset #fcfcfc; }\\n  .dijitDialog .dijitDialogCloseIcon:hover {\\n    background-position: -93px 6px;\\n    border-left-color: #ccc; }\\n  .dijitDialog .dijitDialogCloseIcon:focus {\\n    outline: none; }\\n  .dijitDialog .dijitDialogPaneActionBar {\\n    text-align: center;\\n    clear: both;\\n    padding-top: 1em; }\\n  .dijitDialog .dijitDialogPaneContent {\\n    border-top: 1px solid #acacac; }\\n  .dijitDialog .dijitDialogTitleBar {\\n    padding-right: 25px; }\\n  .dijitDialog .default_about {\\n    text-align: center; }\\n  .dijitDialog .default_about * {\\n    margin: 0.5em 0; }\\n  .dijitDialog .default_about h1 {\\n    margin-top: 0; }\\n  .dijitDialog div.powered_by {\\n    margin-top: 0.5em;\\n    text-align: center; }\\n  .dijitDialog .setHighlightDialog label {\\n    padding-right: 0.5em; }\\n  .dijitDialog .locationChoiceDialog div.prompt {\\n    margin: 0.3em 1em 1em 1em; }\\n  .dijitDialog .locationChoiceDialog .dgrid-row .dijitButton {\\n    margin: 0 0.5em; }\\n  .dijitDialog .locationChoiceDialog .goButtonColumn,\\n  .dijitDialog .locationChoiceDialog .showButtonColumn {\\n    text-align: center;\\n    white-space: nowrap; }\\n  .dijitDialog .notfound-dialog .message {\\n    margin: 1em;\\n    text-align: center; }\\n  .dijitDialog .help_dialog ul {\\n    padding-left: 0; }\\n  .dijitDialog .help_dialog div.main > dl {\\n    width: 90%;\\n    margin: 0 auto 1em auto; }\\n  .dijitDialog .help_dialog dt {\\n    font-weight: bold;\\n    margin-top: 1em; }\\n  .dijitDialog .help_dialog dd {\\n    margin-left: 2em; }\\n  .dijitDialog .help_dialog dl dl.searchexample dt,\\n  .dijitDialog .help_dialog span.example {\\n    font-weight: normal;\\n    font-family: monospace; }\\n  .dijitDialog .popup-dialog-iframe .dijitDialogPaneContent {\\n    padding: 0; }\\n  .dijitDialog a.dialog-new-window {\\n    padding-left: 1em;\\n    font-size: 90%; }\\n  .dijitDialog .feature-detail {\\n    width: 50em;\\n    color: #333; }\\n  .dijitDialog .feature-detail .genotype_summary {\\n    padding: 1em; }\\n  .dijitDialog .feature-detail .genotype_summary table {\\n    border-collapse: collapse; }\\n  .dijitDialog .feature-detail .genotype_summary td {\\n    padding: 0 1em; }\\n  .dijitDialog .feature-detail .genotype_summary td.total {\\n    font-weight: bold;\\n    border-top: 1px solid #444; }\\n  .dijitDialog .feature-detail .genotype_summary td.count, .dijitDialog .feature-detail .genotype_summary td.pct {\\n    text-align: right; }\\n  .dijitDialog .feature-detail .genotype_summary td.category.level_1 {\\n    padding-left: 2em; }\\n  .dijitDialog .feature-detail .genotype_summary td.category.level_2 {\\n    padding-left: 3em; }\\n  .dijitDialog .feature-detail .genotype_summary td.category.level_3 {\\n    padding-left: 4em; }\\n  .dijitDialog .feature-detail .genotype_summary td.category.level_4 {\\n    padding-left: 5em; }\\n  .dijitDialog .feature-detail .subfeature-detail {\\n    background: #fafafa;\\n    background: rgba(0, 0, 0, 0.1);\\n    border: 1px outset #B9B9B9;\\n    padding: 0.6em;\\n    margin-bottom: 0.8em; }\\n  .dijitDialog .feature-detail .subfeature-load-button {\\n    margin-top: 15px;\\n    margin-left: 10px; }\\n  .dijitDialog .feature-detail .fastaView {\\n    padding: 0;\\n    border: 1px solid #aaa; }\\n  .dijitDialog .feature-detail .fastaView .dijitToolbar {\\n    text-align: right; }\\n  .dijitDialog .feature-detail .fastaView textarea {\\n    padding: 1em 1.5em;\\n    margin: 0;\\n    border: none; }\\n  .dijitDialog .feature-detail div.core {\\n    font-size: 110%; }\\n  .dijitDialog .feature-detail div.core h2.sectiontitle {\\n    margin-top: 0; }\\n  .dijitDialog .feature-detail h2.sectiontitle {\\n    border-bottom: 1px solid rgba(0, 0, 0, 0.1);\\n    margin: 1em 0 0.7em 0; }\\n  .dijitDialog .detail .value_container {\\n    display: inline-block;\\n    max-height: 20em;\\n    overflow-y: auto;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .dijitDialog .detail .value_container.big, .dijitDialog .detail .value_container.dgrid {\\n    border: 1px solid rgba(0, 0, 50, 0.1);\\n    margin-left: 1em;\\n    margin-top: 0.3em; }\\n  .dijitDialog .detail .multi_value .value {\\n    border: 1px solid #ddd;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .dijitDialog .detail .value {\\n    display: inline-block;\\n    vertical-align: top;\\n    padding: 0 0.7em;\\n    line-height: 1.8; }\\n  .dijitDialog .detail .field {\\n    margin: 0;\\n    display: inline-block;\\n    min-width: 90px;\\n    vertical-align: top;\\n    padding: 2px 0.5em;\\n    background: rgba(50, 85, 255, 0.1);\\n    border-bottom: 1px solid #D2D4E4;\\n    border-bottom-color: rgba(0, 0, 0, 0.1);\\n    font-size: 1.1667em; }\\n  .dijitDialog .detail .field[title], .dijitDialog .detail .dgrid-cell[title] {\\n    background: rgba(255, 245, 50, 0.3); }\\n  .dijitDialog .detail .field[title]:hover, .dijitDialog .detail .dgrid-cell[title]:hover {\\n    background: rgba(255, 255, 50, 0.7); }\\n  .dijitDialog .detail .value.long {\\n    word-wrap: break-word;\\n    width: 45em; }\\n  .dijitDialog .detail .field_container {\\n    margin-left: 1em;\\n    margin-bottom: 2px; }\\n  .dijitDialog .detail hr {\\n    margin: 0.8em 4em 0.5em 0.7em; }\\n  .dijitDialog .loaded-plugins {\\n    text-align: left; }\\n  .dijitDialog .loaded-plugins li {\\n    margin: 0em; }\\n  .dijitDialog .plugins-list {\\n    max-height: 100px;\\n    overflow: auto; }\\n  .dijitDialog .dgrid.genotypes table {\\n    margin: 0; }\\n  .dijitDialog .export-view-dialog .dijitDialogPaneContent {\\n    background: #fafafa; }\\n  .dijitDialog .export-view-dialog .save {\\n    display: inline-block;\\n    border: 1px solid #AFAFAF;\\n    padding: 2px 5px 2px 0px; }\\n  .dijitDialog.fileDialog {\\n    color: #333; }\\n    .dijitDialog.fileDialog label {\\n      font-weight: bold;\\n      padding: 0 0.5em;\\n      display: inline; }\\n    .dijitDialog.fileDialog th {\\n      font-weight: bold;\\n      border-bottom: 2px solid black; }\\n    .dijitDialog.fileDialog .dijitDialogPaneContent > div.intro {\\n      width: 27em;\\n      text-align: justify;\\n      position: relative;\\n      left: 12%;\\n      margin: 1.4em 0 1em 0; }\\n    .dijitDialog.fileDialog .connector {\\n      background: #333;\\n      height: 6px;\\n      width: 12px;\\n      position: absolute;\\n      bottom: -6px;\\n      left: 50%;\\n      margin-left: -6px; }\\n    .dijitDialog.fileDialog h2, .dijitDialog.fileDialog h3 {\\n      margin: 0;\\n      padding: 0;\\n      font-size: 125%; }\\n    .dijitDialog.fileDialog .dijitDialogPaneContent > div {\\n      position: relative;\\n      width: 40em;\\n      padding: 0 0 0.75em 0;\\n      margin: 6px 0; }\\n    .dijitDialog.fileDialog div.aux {\\n      text-align: center;\\n      margin-bottom: 1em; }\\n    .dijitDialog.fileDialog .resourceControls {\\n      height: 10em;\\n      position: relative; }\\n    .dijitDialog.fileDialog .resourceControls > div {\\n      width: 19.5em;\\n      box-sizing: border-box;\\n      height: 100%; }\\n    .dijitDialog.fileDialog .resourceControls > div > h3 {\\n      height: 19%; }\\n    .dijitDialog.fileDialog .soleResourceControl {\\n      height: 10em;\\n      position: relative; }\\n    .dijitDialog.fileDialog .soleResourceControl > div {\\n      width: 40em;\\n      box-sizing: border-box;\\n      height: 100%; }\\n    .dijitDialog.fileDialog .soleResourceControl > div > h3 {\\n      height: 19%; }\\n    .dijitDialog.fileDialog .localFilesControl {\\n      position: absolute;\\n      top: 0;\\n      left: 0; }\\n    .dijitDialog.fileDialog .dijitUploader {\\n      position: absolute;\\n      margin: 0; }\\n    .dijitDialog.fileDialog .remoteURLsControl textarea,\\n    .dijitDialog.fileDialog .localFilesControl .dragArea {\\n      height: 81%;\\n      position: relative;\\n      border: 1px solid #b3b3b3;\\n      width: 100%;\\n      box-sizing: border-box; }\\n    .dijitDialog.fileDialog .localFilesControl .dragArea:hover {\\n      border: 1px dashed green; }\\n    .dijitDialog.fileDialog .localFilesControl .dragArea .dragMessage {\\n      height: 2em;\\n      position: absolute;\\n      top: 60%;\\n      font-weight: bold;\\n      margin-top: -1em;\\n      text-align: center;\\n      width: 100%; }\\n    .dijitDialog.fileDialog .remoteURLsControl textarea {\\n      font-size: 10px;\\n      background: #f2f2f2; }\\n    .dijitDialog.fileDialog .remoteURLsControl textarea:hover {\\n      background: white;\\n      border-color: #333; }\\n    .dijitDialog.fileDialog .remoteURLsControl {\\n      position: absolute;\\n      top: 0;\\n      right: 0; }\\n    .dijitDialog.fileDialog .resourceList {\\n      background: #bcd3ef; }\\n    .dijitDialog.fileDialog .dijitSelect td.dijitStretch {\\n      width: 6em; }\\n    .dijitDialog.fileDialog .resourceList > h3, .dijitDialog.fileDialog .trackList > h3 {\\n      padding: 0 0.6em;\\n      line-height: 2.1;\\n      margin-bottom: 0.5em; }\\n    .dijitDialog.fileDialog .emptyMessage {\\n      width: 100%;\\n      font-size: 110%;\\n      color: #686868;\\n      font-weight: bold;\\n      text-align: center;\\n      line-height: 4; }\\n    .dijitDialog.fileDialog .trackList {\\n      background: #8cb1dd; }\\n    .dijitDialog.fileDialog .resourceList > table, .dijitDialog.fileDialog .trackList > table {\\n      width: 95%;\\n      padding: 0 0.75em 0.5em 0.75em;\\n      margin: 0 auto;\\n      border-collapse: collapse; }\\n  .dijitDialog .jbrowseStandaloneDatasetSelector {\\n    margin-left: 2em;\\n    font-size: 120%; }\\n  .dijitDialog .track .global_highlight {\\n    position: absolute;\\n    background: rgba(255, 255, 0, 0.7);\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box;\\n    border: 1px solid #ffb20d;\\n    border-width: 0; }\\n  .dijitDialog .track .global_highlight.left {\\n    border-left-width: 1px; }\\n  .dijitDialog .track .global_highlight.right {\\n    border-right-width: 1px; }\\n  .dijitDialog .track .global_highlight_mod {\\n    position: absolute;\\n    background: rgba(255, 255, 0, 0.7);\\n    box-sizing: border-box;\\n    border: 1px solid black;\\n    border-width: 0; }\\n  .dijitDialog .track .global_highlight_mod.left {\\n    border-left-width: 1px; }\\n  .dijitDialog .track .global_highlight_mod.right {\\n    border-right-width: 1px; }\\n  .dijitDialog input {\\n    outline: none; }\\n  .dijitDialog .ghosted {\\n    color: #aaa; }\\n  .dijitDialog fieldset {\\n    padding-left: 1em;\\n    margin: 0.7em 0.5em; }\\n  .dijitDialog fieldset > legend {\\n    font-weight: bold;\\n    margin-left: -1em; }\\n  .dijitDialog .locString {\\n    font-family: Courier New,monospace; }\\n  .dijitDialog .fasta {\\n    font-family: Courier New,monospace;\\n    font-size: 14px; }\\n  .dijitDialog .verticaltext {\\n    transform: rotate(-90deg);\\n    position: absolute;\\n    border: 1px solid black; }\\n  .dijitDialog .horizontaltext {\\n    position: absolute;\\n    border: 1px solid black; }\\n  .dijitDialog .dijitComboBoxMenu .locString, .dijitDialog .dijitComboBoxMenu .multipleLocations {\\n    margin-left: 1em; }\\n  .dijitDialog .dijitComboBoxMenu .multipleLocations {\\n    color: #333; }\\n  .dijitDialog .nav {\\n    vertical-align: middle;\\n    z-index: 10; }\\n  .dijitDialog input.icon {\\n    display: -moz-inline-stack;\\n    display: inline-block;\\n    zoom: 1; }\\n  .dijitDialog div.container {\\n    position: absolute;\\n    z-index: 0; }\\n  .dijitDialog div.dragWindow {\\n    position: absolute;\\n    overflow: hidden;\\n    z-index: 1; }\\n  .dijitDialog div.vertical_scrollbar {\\n    width: 6px;\\n    background: #eee;\\n    background: rgba(235, 235, 235, 0.62);\\n    border-left: 1px solid #DDD9D9; }\\n  .dijitDialog div.vertical_scrollbar .vertical_position_marker {\\n    background: #555;\\n    opacity: 0.8;\\n    border-radius: 5px;\\n    width: 100%;\\n    border-right: 1px solid #ccc; }\\n  .dijitDialog .draggable {\\n    cursor: move; }\\n  .dijitDialog .rubberBandAvailable {\\n    cursor: crosshair; }\\n  .dijitDialog #navbox {\\n    padding-top: 3px;\\n    position: relative;\\n    text-align: center; }\\n    .dijitDialog #navbox * {\\n      font-size: 12px;\\n      font-family: sans-serif; }\\n    .dijitDialog #navbox .dijitButton, .dijitDialog #navbox .dijitToggleButton, .dijitDialog #navbox .dijitTextBox, .dijitDialog #navbox .dijitSelect, .dijitDialog #navbox .dojoxTriStateCheckBox {\\n      height: 20px;\\n      box-sizing: border-box;\\n      -moz-box-sizing: border-box;\\n      -webkit-box-sizing: border-box;\\n      -ms-box-sizing: border-box; }\\n    .dijitDialog #navbox .dijitSelectLabel {\\n      padding: 0 2px; }\\n    .dijitDialog #navbox .dijitInputField {\\n      padding-left: 3%; }\\n    .dijitDialog #navbox .dijitArrowButton {\\n      width: 15px; }\\n  .dijitDialog .moreMatches {\\n    font-style: italic;\\n    color: #aaa; }\\n  .dijitDialog .moreMatches.dijitMenuItemSelected {\\n    background: none;\\n    color: #ccc;\\n    cursor: default; }\\n  .dijitDialog div.locationTrapContainer {\\n    position: absolute;\\n    z-index: -11;\\n    height: 100%;\\n    width: 100%;\\n    top: 0;\\n    left: 0;\\n    background-color: white; }\\n  .dijitDialog div.locationTrap {\\n    position: absolute;\\n    z-index: -10;\\n    height: 0;\\n    top: 0;\\n    left: 0;\\n    border-color: transparent;\\n    border-style: solid;\\n    border-bottom-color: #A9C6EB;\\n    border-top: 0px dotted transparent;\\n    box-sizing: content-box; }\\n  .dijitDialog div.locationThumb {\\n    position: absolute;\\n    top: 0px;\\n    /* if you change this border from 2px, change GenomeView.showTrap */\\n    border: 2px solid red;\\n    margin: 0px -2px 0px -2px;\\n    height: 23px;\\n    cursor: move;\\n    background: rgba(0, 121, 245, 0.1); }\\n  .dijitDialog div.locationThumb.dojoMoveItem {\\n    cursor: move; }\\n  .dijitDialog div.topLink {\\n    position: absolute;\\n    right: 0;\\n    top: 0;\\n    z-index: 50;\\n    background: white;\\n    border: 1px solid #888;\\n    border-width: 0 0 1px 1px; }\\n  .dijitDialog a.topLink {\\n    padding: 0 0.5ex 0 0.5ex;\\n    text-decoration: none;\\n    color: blue; }\\n  .dijitDialog div.overview {\\n    position: relative;\\n    width: 100%;\\n    padding: 0;\\n    z-index: -5;\\n    display: block;\\n    height: 23px;\\n    background: #FAFAFA url(\" + ___CSS_LOADER_URL___3___ + \") repeat-x top left;\\n    border-style: solid;\\n    border-width: 1px 0px 1px 0px;\\n    border-color: #555;\\n    color: #aaa;\\n    text-align: center;\\n    cursor: crosshair; }\\n  .dijitDialog div.block {\\n    position: absolute;\\n    overflow: visible;\\n    top: 0px;\\n    height: 100%; }\\n  .dijitDialog div.block.height_overflow .height_overflow_message {\\n    position: absolute;\\n    color: #4d4d4d;\\n    border-bottom: 2px solid #4d4d4d;\\n    text-shadow: white 0px 0px 1px;\\n    white-space: nowrap;\\n    width: 100%;\\n    font-weight: bold;\\n    text-align: center;\\n    z-index: 2000;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .dijitDialog div.block.timed_out {\\n    background: #ddd;\\n    background: rgba(0, 0, 0, 0.1); }\\n  .dijitDialog div.track {\\n    position: absolute;\\n    left: 0px;\\n    width: 100%;\\n    padding: 0;\\n    margin: 0;\\n    z-index: 0;\\n    border-top: 1px solid #fafafa;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .dijitDialog div.pin_underlay {\\n    width: 100%;\\n    position: absolute;\\n    background: white;\\n    z-index: 6;\\n    -moz-box-shadow: 0 0 10px 0 rgba(30, 30, 50, 0.9);\\n    -webkit-box-shadow: 0 0 10px 0 rgba(30, 30, 50, 0.9);\\n    box-shadow: 0 0 10px 0 rgba(30, 30, 50, 0.9); }\\n  .dijitDialog div.track.pinned {\\n    z-index: 20; }\\n  .dijitDialog .track.dojoDndItemOver {\\n    cursor: inherit;\\n    background: inherit; }\\n  .dijitDialog .track.dojoDndItemAnchor {\\n    background: inherit; }\\n  .dijitDialog .track.dojoDndItemSelected {\\n    background: inherit; }\\n  .dijitDialog .track.dojoDndItemBefore {\\n    border-top: 3px solid #999;\\n    margin-top: -3px; }\\n  .dijitDialog .track.dojoDndItemAfter {\\n    border-bottom: 3px solid #999;\\n    margin-bottom: -3px; }\\n  .dijitDialog div#static_track {\\n    top: 0px;\\n    position: absolute;\\n    background: #FAFAFA url(\" + ___CSS_LOADER_URL___3___ + \") repeat-x top left;\\n    border-top: 1px solid #999;\\n    border-bottom: 1px solid #444;\\n    z-index: 20; }\\n  .dijitDialog div.gridline {\\n    position: absolute;\\n    left: 0px;\\n    top: 0px;\\n    width: 0px;\\n    height: 100%;\\n    border-style: none none none solid;\\n    border-width: 1px;\\n    border-color: red;\\n    z-index: 0; }\\n  .dijitDialog div.gridline_major {\\n    border-color: #bbb; }\\n  .dijitDialog div.gridline_minor {\\n    border-color: #eee; }\\n  .dijitDialog div.pos-label {\\n    position: absolute;\\n    left: -0.35em;\\n    top: 0px;\\n    z-index: 100;\\n    font-family: sans-serif; }\\n  .dijitDialog div.overview-pos {\\n    position: absolute;\\n    left: 0px;\\n    top: 0.27em;\\n    color: black;\\n    padding-left: 4px;\\n    font-family: sans-serif;\\n    border: 0;\\n    z-index: 10; }\\n  .dijitDialog div.overview-pos:first-child {\\n    margin-left: 1px; }\\n  .dijitDialog div.blank-block {\\n    font-family: sans-serif;\\n    position: absolute;\\n    overflow: visible;\\n    top: 0px;\\n    height: 100%;\\n    background-color: white;\\n    z-index: 19; }\\n  .dijitDialog div.track-border {\\n    background: #eee;\\n    width: 100%;\\n    height: 2px;\\n    top: -8px; }\\n  .dijitDialog div.track-label, .dijitDialog div.tracklist-label {\\n    z-index: 20;\\n    padding: 1px 6px;\\n    overflow: hidden;\\n    cursor: pointer;\\n    border-width: 1px;\\n    border-style: solid;\\n    border-color: #999;\\n    color: #111;\\n    font-weight: bold; }\\n  .dijitDialog div.tracklist-label {\\n    white-space: nowrap;\\n    overflow: hidden;\\n    margin-top: -1px; }\\n  .dijitDialog div.tracklist-label.collapsed {\\n    height: 3px;\\n    padding: 0;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .dijitDialog .track .loading {\\n    background: #fafafa;\\n    color: #777;\\n    margin: 0;\\n    font-weight: bold;\\n    height: 100%;\\n    width: 100%;\\n    z-index: 15;\\n    position: absolute; }\\n  .dijitDialog .track .loading .text {\\n    display: inline;\\n    line-height: 40px;\\n    margin: 1em; }\\n  .dijitDialog div.track-label {\\n    color: black;\\n    margin: -1px 0 0 -1px;\\n    overflow: visible;\\n    background: white;\\n    padding: 0 5px;\\n    height: 23px;\\n    line-height: 23px;\\n    z-index: 20;\\n    border-color: #eee;\\n    opacity: 0.7;\\n    /* setting white-space to \\\"nowrap\\\" prevents Chrome-specific bug with\\n       label text sometimes disappearing after zoom in Chrome was\\n       wrapping track-label text to next line, which falls outside of\\n       track-label fixed height and therefore not seen. see chromium\\n       bug report for more details on underlying issue:\\n       http://code.google.com/p/chromium/issues/detail?id=138918\\n    */\\n    white-space: nowrap; }\\n  .dijitDialog div.track-label .track-label-text {\\n    display: inline-block;\\n    white-space: nowrap; }\\n  .dijitDialog div.track-label .track-close-button {\\n    display: inline-block;\\n    vertical-align: top;\\n    position: relative;\\n    top: 50%;\\n    height: 20px;\\n    width: 25px;\\n    margin: -10px -3px -4px -6px; }\\n  .dijitDialog div.track-label .track-menu-button {\\n    display: inline-block;\\n    position: relative;\\n    vertical-align: top;\\n    right: -5px;\\n    top: 0px;\\n    width: 24px;\\n    height: 100%;\\n    border-radius: 0 6px 6px 0;\\n    border-left: 1px inset transparent; }\\n  .dijitDialog div.track-label .feature-density {\\n    font-size: 90%;\\n    font-weight: normal; }\\n  .dijitDialog div.track-label:hover .track-menu-button div {\\n    height: 8px;\\n    width: 8px;\\n    position: absolute;\\n    left: 8px;\\n    top: 7px;\\n    background: url(\" + ___CSS_LOADER_URL___4___ + \") no-repeat -28px 0; }\\n  .dijitDialog div.track-label:hover .track-menu-button:hover {\\n    background-color: rgba(0, 0, 100, 0.05);\\n    border-left-color: #ccc; }\\n  .dijitDialog div.track-label .track-close-button {\\n    background: url(\" + ___CSS_LOADER_URL___5___ + \") no-repeat 40% 50%; }\\n  .dijitDialog div.track-label .track-close-button:hover {\\n    background-image: url(\" + ___CSS_LOADER_URL___6___ + \"); }\\n  .dijitDialog div.track-label:hover .track-menu-button:hover div {\\n    background-position-x: 0px; }\\n  .dijitDialog div.track-label:hover {\\n    background: #FAFAFA url(\" + ___CSS_LOADER_URL___3___ + \") repeat-x top left;\\n    border-width: 1px;\\n    border-color: #666;\\n    border-color: black;\\n    background-color: #ddd;\\n    opacity: 1.0; }\\n  .dijitDialog div.tracklist-label {\\n    padding: 3px;\\n    background-color: #ddd;\\n    background-color: rgba(220, 220, 220, 0.9); }\\n  .dijitDialog div.tracklist-label:hover {\\n    background-color: #396494;\\n    border: 1px solid black; }\\n  .dijitDialog div.tracklist-container.dojoDndItemSelected {\\n    background-color: #396494;\\n    background-color: #6e849c; }\\n  .dijitDialog div.tracklist-container.dojoDndItemSelected .tracklist-label {\\n    background-color: #b2c3d6; }\\n  .dijitDialog .jbrowseSimpleTrackSelector {\\n    background: #f2f2f2;\\n    background-image: url(\" + ___CSS_LOADER_URL___7___ + \");\\n    background-repeat: repeat-y;\\n    background-position: right; }\\n  .dijitDialog .jbrowseSimpleTrackSelector h2 {\\n    margin: 0.5em 0 0 0.5em; }\\n  .dijitDialog div.textfilter {\\n    margin: 0.5em 0 1em 0.3em; }\\n  .dijitDialog div.textfilter input {\\n    padding: 2px 0 2px 18px;\\n    width: 100%;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .dijitDialog div.textfilter > div.jbrowseIconCancel {\\n    position: absolute;\\n    left: 5px;\\n    margin-top: -6px;\\n    top: 50%; }\\n  .dijitDialog #trackPane_splitter {\\n    background: #dcdcdc;\\n    width: 5px;\\n    border-right: 1px solid #555; }\\n  .dijitDialog div.tracklist-container {\\n    padding: 0 4px; }\\n  .dijitDialog .tracklist-container.dojoDndItemBefore {\\n    border-top: 3px solid #999;\\n    padding-top: 2px; }\\n  .dijitDialog .tracklist-container.dojoDndItemAfter {\\n    border-bottom: 3px solid #999;\\n    padding-bottom: 2px; }\\n  .dijitDialog .feature-label {\\n    position: absolute;\\n    border: 0px;\\n    margin: -2px 0px 0px 0px;\\n    /* padding: 0px 0px 2px 0px; for more space below labels */\\n    padding: 0px 0px 0px 0px;\\n    /* font-size: 80%; */\\n    white-space: nowrap;\\n    z-index: 12;\\n    cursor: pointer; }\\n  .dijitDialog a.feature-label {\\n    color: black; }\\n  .dijitDialog .feature-description {\\n    color: blue;\\n    margin-top: -0.2em; }\\n  .dijitDialog .feature-label.highlighted {\\n    background: rgba(255, 255, 0, 0.7);\\n    font-weight: bold;\\n    border: 1px solid red;\\n    padding: 0 2px; }\\n  .dijitDialog .rubber-highlight {\\n    border: 1px solid black;\\n    height: 100%;\\n    border-color: rgba(0, 0, 0, 0.6);\\n    background-color: #8087ff;\\n    background-color: rgba(128, 136, 255, 0.6);\\n    padding: 0;\\n    margin: 0;\\n    overflow: hidden;\\n    cursor: crosshair; }\\n  .dijitDialog .rubber-highlight div {\\n    color: white;\\n    padding: 0;\\n    margin-top: 30px;\\n    font-size: 160%;\\n    text-align: center;\\n    font-weight: bold;\\n    text-shadow: #6374AB 1px 1px 0; }\\n  .dijitDialog div.overview .rubber-highlight {\\n    font-size: 0;\\n    height: 100%;\\n    border-top: none;\\n    border-bottom: none; }\\n  .dijitDialog div.overview .rubber-highlight * {\\n    display: none; }\\n  .dijitDialog .icon.nav {\\n    height: 30px !important; }\\n  .dijitDialog #moveLeft, .dijitDialog #moveRight, .dijitDialog #bigZoomOut, .dijitDialog #zoomOut, .dijitDialog #bigZoomIn, .dijitDialog #zoomIn, .dijitDialog #moveLeftSmall, .dijitDialog #moveRightSmall, .dijitDialog #zoomInSmall, .dijitDialog #zoomOutSmall {\\n    background: url(\" + ___CSS_LOADER_URL___8___ + \") top left no-repeat;\\n    background-size: 50px 280px;\\n    cursor: pointer; }\\n  .dijitDialog #moveLeft {\\n    background-position: 5px -35px;\\n    width: 55px; }\\n  .dijitDialog #moveLeftSmall {\\n    background-position: 0px -200px;\\n    height: 20px !important;\\n    width: 33px; }\\n  .dijitDialog #moveRight {\\n    background-position: 0px -135px;\\n    width: 55px; }\\n  .dijitDialog #moveRightSmall {\\n    background-position: 0px -220px;\\n    height: 20px !important;\\n    width: 33px; }\\n  .dijitDialog #bigZoomOut {\\n    background-position: 0px -168px;\\n    width: 35px; }\\n  .dijitDialog #zoomOut {\\n    background-position: 0px -100px;\\n    width: 30px; }\\n  .dijitDialog #zoomOutSmall {\\n    background-position: 0px -240px;\\n    height: 20px !important;\\n    width: 20px; }\\n  .dijitDialog #bigZoomIn {\\n    background-position: 0px -69px;\\n    width: 35px; }\\n  .dijitDialog #zoomIn {\\n    background-position: 0px -2.5px;\\n    width: 30px; }\\n  .dijitDialog #zoomInSmall {\\n    background-position: 0px -260px;\\n    height: 20px !important;\\n    width: 20px; }\\n  .dijitDialog input.nav {\\n    font-size: 9px !important; }\\n  .dijitDialog .fatal_error {\\n    font-size: 14px;\\n    margin: 1em; }\\n  .dijitDialog div.error, .dijitDialog div.message {\\n    margin: 1px 1em;\\n    padding: 2px 6px;\\n    border: 1px outset rgba(0, 0, 0, 0.3); }\\n  .dijitDialog div.error {\\n    background: #ff8888; }\\n  .dijitDialog div.track > div.error {\\n    width: 30em;\\n    position: absolute; }\\n  .dijitDialog div.error h2 {\\n    margin-top: 0; }\\n  .dijitDialog div.error .codecaption {\\n    font-size: 90%;\\n    font-weight: bold;\\n    margin-top: 1em;\\n    margin-left: 0.2em; }\\n  .dijitDialog div.error code {\\n    display: block;\\n    font-size: 10px;\\n    padding: 0.4em 1.2em;\\n    margin: 0 0.3em 0.3em 0.3em;\\n    overflow: auto;\\n    max-height: 6em; }\\n  .dijitDialog div.message {\\n    background: #eee; }\\n  .dijitDialog div.block > div.message {\\n    margin: 1em 0;\\n    position: absolute; }\\n  .dijitDialog div.block:hover > div.message {\\n    z-index: 30000; }\\n  .dijitDialog .sharePane input {\\n    padding: 1px 0 2px 1px; }\\n  .dijitDialog .sharePane .copyReminder {\\n    background-color: #396494;\\n    text-align: center;\\n    width: 50%;\\n    margin: 0 auto;\\n    color: white;\\n    padding: 2px;\\n    font-weight: bold; }\\n  .dijitDialog .sharePane input {\\n    border: 1px solid #ccc; }\\n  .dijitDialog .basePairLabel {\\n    color: black;\\n    position: fixed;\\n    font-weight: bold;\\n    font-size: 9px;\\n    display: none;\\n    background: #fefefe;\\n    padding: 0 0.7em;\\n    z-index: 1000;\\n    text-align: center;\\n    cursor: crosshair;\\n    border: 1px solid #888; }\\n  .dijitDialog .basePairLabel.rubber {\\n    z-index: 25; }\\n  .dijitDialog .trackVerticalPositionIndicatorMain {\\n    position: fixed;\\n    display: none;\\n    cursor: crosshair;\\n    left: -2px;\\n    height: 100%;\\n    width: 1px;\\n    background-color: #FF0000;\\n    z-index: 15;\\n    top: 0; }\\n  .dijitDialog .baseQuality {\\n    font-family: Courier New, monospace; }\\n  .dijitDialog table.baseQuality {\\n    margin-bottom: 1em; }\\n  .dijitDialog table.baseQuality td {\\n    padding: 0 0.2em;\\n    line-height: 0.95;\\n    text-align: center; }\\n  .dijitDialog .baseQuality .basePosition {\\n    display: inline-block;\\n    padding: 0 0.3em 0.4em 0.3em; }\\n  .dijitDialog .baseQuality .basePosition:hover {\\n    background: #ccc; }\\n  .dijitDialog .baseQuality span.seq {\\n    display: block;\\n    text-align: center;\\n    font-weight: bold; }\\n  .dijitDialog .baseQuality span.qual {\\n    display: block;\\n    text-align: center; }\\n\\n/* main application CSS styles */\\n.jbrowse {\\n  line-height: 1;\\n  /* styles for the autocomplete menu */\\n  /* NOTE: browsers that don't support rgba colors will fall back to all\\n   track labels being #bcbcbc */\\n  /* styles for feature labels */\\n  /*styles for vertical line and BP label*/\\n  /* styles for per-base quality table in alignment detail pages */\\n  /*\\n  NOTES ON STYLING FEATURES:\\n     - avoid using any margins in feature styles. Layout is done\\n       by JBrowse.\\n\\n     - when possible, make all element heights an odd number of\\n       pixels, so that vertical centering is possible with\\n       pixel-perfect accuracy.\\n*/\\n  /* introns are hidden by default */\\n  /* can also set a class of 'hidden' to hide something */\\n  /* floating score display for wiggle tracks */\\n  /* colors for bases must be specified as hex or rgb/hsl strings, no named colors such as 'red' */\\n  /* added to document.body */\\n  /* Extracted from https://github.com/#008000ify/msa-colorschemes/tree/master/src */\\n  /* styles for the top menu bar */\\n  /* dataset selector */\\n  /* \\n    navbar/toolbar styles\\n    Created on : Jun 19, 2015, 6:37:30 PM\\n    Author     : Eric Y\\n*/\\n  /* location box */\\n  /* highlight button */\\n  /* TriStateCheckBox\\n *\\n * Styling TriStateCheckBox mainly includes:\\n *\\n * 1. Containers\\n * \\t\\t.dojoxTriStateCheckBox|.dojoxTriStateCheckBoxIcon - for border, padding, width|height and background image\\n *\\n * 2. Checked state\\n * \\t\\t.dojoxTriStateCheckBoxChecked - for checked background-color|image\\n * \\t\\t.dojoxTriStateCheckBoxMixed - for mixed background-color|image\\n *\\n * 3. Hover state\\n * \\t\\t.dojoxTriStateCheckBoxHover|.dojoxTriStateCheckBoxCheckedHover|.dojoxTriStateCheckBoxMixedHover - for background image\\n *\\n * 4. Disabled state\\n * \\t\\t.dojoxTriStateCheckBoxDisabled|.dojoxTriStateCheckBoxCheckedDisabled|.dojoxTriStateCheckBoxMixedDisabled - for background image\\n */\\n  /* CSS styles for the various types of feature glyphs */\\n  /* Dojo and Dijit stuff */\\n  /* JBrowse stuff */\\n  /* CSS styles specifically for MAKER output */\\n  /*MAKER CSS with colors for common features*/\\n  /*SNAP*/\\n  /*Augustus*/\\n  /*GeneMark*/\\n  /*FGENESH*/\\n  /*protein2genome*/\\n  /*BLASTN*/\\n  /*BLASTX*/\\n  /*TBLASTX*/\\n  /*est2genome*/\\n  /*repeat*/\\n  /*cdna2genome*/ }\\n  .jbrowse.dijitDialog {\\n    line-height: 17px; }\\n  .jbrowse .jbrowseStandaloneDatasetSelector {\\n    margin-left: 2em;\\n    font-size: 120%; }\\n  .jbrowse .track .global_highlight {\\n    position: absolute;\\n    background: rgba(255, 255, 0, 0.7);\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box;\\n    border: 1px solid #ffb20d;\\n    border-width: 0; }\\n  .jbrowse .track .global_highlight.left {\\n    border-left-width: 1px; }\\n  .jbrowse .track .global_highlight.right {\\n    border-right-width: 1px; }\\n  .jbrowse .track .global_highlight_mod {\\n    position: absolute;\\n    background: rgba(255, 255, 0, 0.7);\\n    box-sizing: border-box;\\n    border: 1px solid black;\\n    border-width: 0; }\\n  .jbrowse .track .global_highlight_mod.left {\\n    border-left-width: 1px; }\\n  .jbrowse .track .global_highlight_mod.right {\\n    border-right-width: 1px; }\\n  .jbrowse input {\\n    outline: none; }\\n  .jbrowse .ghosted {\\n    color: #aaa; }\\n  .jbrowse fieldset {\\n    padding-left: 1em;\\n    margin: 0.7em 0.5em; }\\n  .jbrowse fieldset > legend {\\n    font-weight: bold;\\n    margin-left: -1em; }\\n  .jbrowse .locString {\\n    font-family: Courier New,monospace; }\\n  .jbrowse .fasta {\\n    font-family: Courier New,monospace;\\n    font-size: 14px; }\\n  .jbrowse .verticaltext {\\n    transform: rotate(-90deg);\\n    position: absolute;\\n    border: 1px solid black; }\\n  .jbrowse .horizontaltext {\\n    position: absolute;\\n    border: 1px solid black; }\\n  .jbrowse .dijitComboBoxMenu .locString, .jbrowse .dijitComboBoxMenu .multipleLocations {\\n    margin-left: 1em; }\\n  .jbrowse .dijitComboBoxMenu .multipleLocations {\\n    color: #333; }\\n  .jbrowse .nav {\\n    vertical-align: middle;\\n    z-index: 10; }\\n  .jbrowse input.icon {\\n    display: -moz-inline-stack;\\n    display: inline-block;\\n    zoom: 1; }\\n  .jbrowse div.container {\\n    position: absolute;\\n    z-index: 0; }\\n  .jbrowse div.dragWindow {\\n    position: absolute;\\n    overflow: hidden;\\n    z-index: 1; }\\n  .jbrowse div.vertical_scrollbar {\\n    width: 6px;\\n    background: #eee;\\n    background: rgba(235, 235, 235, 0.62);\\n    border-left: 1px solid #DDD9D9; }\\n  .jbrowse div.vertical_scrollbar .vertical_position_marker {\\n    background: #555;\\n    opacity: 0.8;\\n    border-radius: 5px;\\n    width: 100%;\\n    border-right: 1px solid #ccc; }\\n  .jbrowse .draggable {\\n    cursor: move; }\\n  .jbrowse .rubberBandAvailable {\\n    cursor: crosshair; }\\n  .jbrowse #navbox {\\n    padding-top: 3px;\\n    position: relative;\\n    text-align: center; }\\n    .jbrowse #navbox * {\\n      font-size: 12px;\\n      font-family: sans-serif; }\\n    .jbrowse #navbox .dijitButton, .jbrowse #navbox .dijitToggleButton, .jbrowse #navbox .dijitTextBox, .jbrowse #navbox .dijitSelect, .jbrowse #navbox .dojoxTriStateCheckBox {\\n      height: 20px;\\n      box-sizing: border-box;\\n      -moz-box-sizing: border-box;\\n      -webkit-box-sizing: border-box;\\n      -ms-box-sizing: border-box; }\\n    .jbrowse #navbox .dijitSelectLabel {\\n      padding: 0 2px; }\\n    .jbrowse #navbox .dijitInputField {\\n      padding-left: 3%; }\\n    .jbrowse #navbox .dijitArrowButton {\\n      width: 15px; }\\n  .jbrowse .moreMatches {\\n    font-style: italic;\\n    color: #aaa; }\\n  .jbrowse .moreMatches.dijitMenuItemSelected {\\n    background: none;\\n    color: #ccc;\\n    cursor: default; }\\n  .jbrowse div.locationTrapContainer {\\n    position: absolute;\\n    z-index: -11;\\n    height: 100%;\\n    width: 100%;\\n    top: 0;\\n    left: 0;\\n    background-color: white; }\\n  .jbrowse div.locationTrap {\\n    position: absolute;\\n    z-index: -10;\\n    height: 0;\\n    top: 0;\\n    left: 0;\\n    border-color: transparent;\\n    border-style: solid;\\n    border-bottom-color: #A9C6EB;\\n    border-top: 0px dotted transparent;\\n    box-sizing: content-box; }\\n  .jbrowse div.locationThumb {\\n    position: absolute;\\n    top: 0px;\\n    /* if you change this border from 2px, change GenomeView.showTrap */\\n    border: 2px solid red;\\n    margin: 0px -2px 0px -2px;\\n    height: 23px;\\n    cursor: move;\\n    background: rgba(0, 121, 245, 0.1); }\\n  .jbrowse div.locationThumb.dojoMoveItem {\\n    cursor: move; }\\n  .jbrowse div.topLink {\\n    position: absolute;\\n    right: 0;\\n    top: 0;\\n    z-index: 50;\\n    background: white;\\n    border: 1px solid #888;\\n    border-width: 0 0 1px 1px; }\\n  .jbrowse a.topLink {\\n    padding: 0 0.5ex 0 0.5ex;\\n    text-decoration: none;\\n    color: blue; }\\n  .jbrowse div.overview {\\n    position: relative;\\n    width: 100%;\\n    padding: 0;\\n    z-index: -5;\\n    display: block;\\n    height: 23px;\\n    background: #FAFAFA url(\" + ___CSS_LOADER_URL___3___ + \") repeat-x top left;\\n    border-style: solid;\\n    border-width: 1px 0px 1px 0px;\\n    border-color: #555;\\n    color: #aaa;\\n    text-align: center;\\n    cursor: crosshair; }\\n  .jbrowse div.block {\\n    position: absolute;\\n    overflow: visible;\\n    top: 0px;\\n    height: 100%; }\\n  .jbrowse div.block.height_overflow .height_overflow_message {\\n    position: absolute;\\n    color: #4d4d4d;\\n    border-bottom: 2px solid #4d4d4d;\\n    text-shadow: white 0px 0px 1px;\\n    white-space: nowrap;\\n    width: 100%;\\n    font-weight: bold;\\n    text-align: center;\\n    z-index: 2000;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .jbrowse div.block.timed_out {\\n    background: #ddd;\\n    background: rgba(0, 0, 0, 0.1); }\\n  .jbrowse div.track {\\n    position: absolute;\\n    left: 0px;\\n    width: 100%;\\n    padding: 0;\\n    margin: 0;\\n    z-index: 0;\\n    border-top: 1px solid #fafafa;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .jbrowse div.pin_underlay {\\n    width: 100%;\\n    position: absolute;\\n    background: white;\\n    z-index: 6;\\n    -moz-box-shadow: 0 0 10px 0 rgba(30, 30, 50, 0.9);\\n    -webkit-box-shadow: 0 0 10px 0 rgba(30, 30, 50, 0.9);\\n    box-shadow: 0 0 10px 0 rgba(30, 30, 50, 0.9); }\\n  .jbrowse div.track.pinned {\\n    z-index: 20; }\\n  .jbrowse .track.dojoDndItemOver {\\n    cursor: inherit;\\n    background: inherit; }\\n  .jbrowse .track.dojoDndItemAnchor {\\n    background: inherit; }\\n  .jbrowse .track.dojoDndItemSelected {\\n    background: inherit; }\\n  .jbrowse .track.dojoDndItemBefore {\\n    border-top: 3px solid #999;\\n    margin-top: -3px; }\\n  .jbrowse .track.dojoDndItemAfter {\\n    border-bottom: 3px solid #999;\\n    margin-bottom: -3px; }\\n  .jbrowse div#static_track {\\n    top: 0px;\\n    position: absolute;\\n    background: #FAFAFA url(\" + ___CSS_LOADER_URL___3___ + \") repeat-x top left;\\n    border-top: 1px solid #999;\\n    border-bottom: 1px solid #444;\\n    z-index: 20; }\\n  .jbrowse div.gridline {\\n    position: absolute;\\n    left: 0px;\\n    top: 0px;\\n    width: 0px;\\n    height: 100%;\\n    border-style: none none none solid;\\n    border-width: 1px;\\n    border-color: red;\\n    z-index: 0; }\\n  .jbrowse div.gridline_major {\\n    border-color: #bbb; }\\n  .jbrowse div.gridline_minor {\\n    border-color: #eee; }\\n  .jbrowse div.pos-label {\\n    position: absolute;\\n    left: -0.35em;\\n    top: 0px;\\n    z-index: 100;\\n    font-family: sans-serif; }\\n  .jbrowse div.overview-pos {\\n    position: absolute;\\n    left: 0px;\\n    top: 0.27em;\\n    color: black;\\n    padding-left: 4px;\\n    font-family: sans-serif;\\n    border: 0;\\n    z-index: 10; }\\n  .jbrowse div.overview-pos:first-child {\\n    margin-left: 1px; }\\n  .jbrowse div.blank-block {\\n    font-family: sans-serif;\\n    position: absolute;\\n    overflow: visible;\\n    top: 0px;\\n    height: 100%;\\n    background-color: white;\\n    z-index: 19; }\\n  .jbrowse div.track-border {\\n    background: #eee;\\n    width: 100%;\\n    height: 2px;\\n    top: -8px; }\\n  .jbrowse div.track-label, .jbrowse div.tracklist-label {\\n    z-index: 20;\\n    padding: 1px 6px;\\n    overflow: hidden;\\n    cursor: pointer;\\n    border-width: 1px;\\n    border-style: solid;\\n    border-color: #999;\\n    color: #111;\\n    font-weight: bold; }\\n  .jbrowse div.tracklist-label {\\n    white-space: nowrap;\\n    overflow: hidden;\\n    margin-top: -1px; }\\n  .jbrowse div.tracklist-label.collapsed {\\n    height: 3px;\\n    padding: 0;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .jbrowse .track .loading {\\n    background: #fafafa;\\n    color: #777;\\n    margin: 0;\\n    font-weight: bold;\\n    height: 100%;\\n    width: 100%;\\n    z-index: 15;\\n    position: absolute; }\\n  .jbrowse .track .loading .text {\\n    display: inline;\\n    line-height: 40px;\\n    margin: 1em; }\\n  .jbrowse div.track-label {\\n    color: black;\\n    margin: -1px 0 0 -1px;\\n    overflow: visible;\\n    background: white;\\n    padding: 0 5px;\\n    height: 23px;\\n    line-height: 23px;\\n    z-index: 20;\\n    border-color: #eee;\\n    opacity: 0.7;\\n    /* setting white-space to \\\"nowrap\\\" prevents Chrome-specific bug with\\n       label text sometimes disappearing after zoom in Chrome was\\n       wrapping track-label text to next line, which falls outside of\\n       track-label fixed height and therefore not seen. see chromium\\n       bug report for more details on underlying issue:\\n       http://code.google.com/p/chromium/issues/detail?id=138918\\n    */\\n    white-space: nowrap; }\\n  .jbrowse div.track-label .track-label-text {\\n    display: inline-block;\\n    white-space: nowrap; }\\n  .jbrowse div.track-label .track-close-button {\\n    display: inline-block;\\n    vertical-align: top;\\n    position: relative;\\n    top: 50%;\\n    height: 20px;\\n    width: 25px;\\n    margin: -10px -3px -4px -6px; }\\n  .jbrowse div.track-label .track-menu-button {\\n    display: inline-block;\\n    position: relative;\\n    vertical-align: top;\\n    right: -5px;\\n    top: 0px;\\n    width: 24px;\\n    height: 100%;\\n    border-radius: 0 6px 6px 0;\\n    border-left: 1px inset transparent; }\\n  .jbrowse div.track-label .feature-density {\\n    font-size: 90%;\\n    font-weight: normal; }\\n  .jbrowse div.track-label:hover .track-menu-button div {\\n    height: 8px;\\n    width: 8px;\\n    position: absolute;\\n    left: 8px;\\n    top: 7px;\\n    background: url(\" + ___CSS_LOADER_URL___4___ + \") no-repeat -28px 0; }\\n  .jbrowse div.track-label:hover .track-menu-button:hover {\\n    background-color: rgba(0, 0, 100, 0.05);\\n    border-left-color: #ccc; }\\n  .jbrowse div.track-label .track-close-button {\\n    background: url(\" + ___CSS_LOADER_URL___5___ + \") no-repeat 40% 50%; }\\n  .jbrowse div.track-label .track-close-button:hover {\\n    background-image: url(\" + ___CSS_LOADER_URL___6___ + \"); }\\n  .jbrowse div.track-label:hover .track-menu-button:hover div {\\n    background-position-x: 0px; }\\n  .jbrowse div.track-label:hover {\\n    background: #FAFAFA url(\" + ___CSS_LOADER_URL___3___ + \") repeat-x top left;\\n    border-width: 1px;\\n    border-color: #666;\\n    border-color: black;\\n    background-color: #ddd;\\n    opacity: 1.0; }\\n  .jbrowse div.tracklist-label {\\n    padding: 3px;\\n    background-color: #ddd;\\n    background-color: rgba(220, 220, 220, 0.9); }\\n  .jbrowse div.tracklist-label:hover {\\n    background-color: #396494;\\n    border: 1px solid black; }\\n  .jbrowse div.tracklist-container.dojoDndItemSelected {\\n    background-color: #396494;\\n    background-color: #6e849c; }\\n  .jbrowse div.tracklist-container.dojoDndItemSelected .tracklist-label {\\n    background-color: #b2c3d6; }\\n  .jbrowse .jbrowseSimpleTrackSelector {\\n    background: #f2f2f2;\\n    background-image: url(\" + ___CSS_LOADER_URL___7___ + \");\\n    background-repeat: repeat-y;\\n    background-position: right; }\\n  .jbrowse .jbrowseSimpleTrackSelector h2 {\\n    margin: 0.5em 0 0 0.5em; }\\n  .jbrowse div.textfilter {\\n    margin: 0.5em 0 1em 0.3em; }\\n  .jbrowse div.textfilter input {\\n    padding: 2px 0 2px 18px;\\n    width: 100%;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .jbrowse div.textfilter > div.jbrowseIconCancel {\\n    position: absolute;\\n    left: 5px;\\n    margin-top: -6px;\\n    top: 50%; }\\n  .jbrowse #trackPane_splitter {\\n    background: #dcdcdc;\\n    width: 5px;\\n    border-right: 1px solid #555; }\\n  .jbrowse div.tracklist-container {\\n    padding: 0 4px; }\\n  .jbrowse .tracklist-container.dojoDndItemBefore {\\n    border-top: 3px solid #999;\\n    padding-top: 2px; }\\n  .jbrowse .tracklist-container.dojoDndItemAfter {\\n    border-bottom: 3px solid #999;\\n    padding-bottom: 2px; }\\n  .jbrowse .feature-label {\\n    position: absolute;\\n    border: 0px;\\n    margin: -2px 0px 0px 0px;\\n    /* padding: 0px 0px 2px 0px; for more space below labels */\\n    padding: 0px 0px 0px 0px;\\n    /* font-size: 80%; */\\n    white-space: nowrap;\\n    z-index: 12;\\n    cursor: pointer; }\\n  .jbrowse a.feature-label {\\n    color: black; }\\n  .jbrowse .feature-description {\\n    color: blue;\\n    margin-top: -0.2em; }\\n  .jbrowse .feature-label.highlighted {\\n    background: rgba(255, 255, 0, 0.7);\\n    font-weight: bold;\\n    border: 1px solid red;\\n    padding: 0 2px; }\\n  .jbrowse .rubber-highlight {\\n    border: 1px solid black;\\n    height: 100%;\\n    border-color: rgba(0, 0, 0, 0.6);\\n    background-color: #8087ff;\\n    background-color: rgba(128, 136, 255, 0.6);\\n    padding: 0;\\n    margin: 0;\\n    overflow: hidden;\\n    cursor: crosshair; }\\n  .jbrowse .rubber-highlight div {\\n    color: white;\\n    padding: 0;\\n    margin-top: 30px;\\n    font-size: 160%;\\n    text-align: center;\\n    font-weight: bold;\\n    text-shadow: #6374AB 1px 1px 0; }\\n  .jbrowse div.overview .rubber-highlight {\\n    font-size: 0;\\n    height: 100%;\\n    border-top: none;\\n    border-bottom: none; }\\n  .jbrowse div.overview .rubber-highlight * {\\n    display: none; }\\n  .jbrowse .icon.nav {\\n    height: 30px !important; }\\n  .jbrowse #moveLeft, .jbrowse #moveRight, .jbrowse #bigZoomOut, .jbrowse #zoomOut, .jbrowse #bigZoomIn, .jbrowse #zoomIn, .jbrowse #moveLeftSmall, .jbrowse #moveRightSmall, .jbrowse #zoomInSmall, .jbrowse #zoomOutSmall {\\n    background: url(\" + ___CSS_LOADER_URL___8___ + \") top left no-repeat;\\n    background-size: 50px 280px;\\n    cursor: pointer; }\\n  .jbrowse #moveLeft {\\n    background-position: 5px -35px;\\n    width: 55px; }\\n  .jbrowse #moveLeftSmall {\\n    background-position: 0px -200px;\\n    height: 20px !important;\\n    width: 33px; }\\n  .jbrowse #moveRight {\\n    background-position: 0px -135px;\\n    width: 55px; }\\n  .jbrowse #moveRightSmall {\\n    background-position: 0px -220px;\\n    height: 20px !important;\\n    width: 33px; }\\n  .jbrowse #bigZoomOut {\\n    background-position: 0px -168px;\\n    width: 35px; }\\n  .jbrowse #zoomOut {\\n    background-position: 0px -100px;\\n    width: 30px; }\\n  .jbrowse #zoomOutSmall {\\n    background-position: 0px -240px;\\n    height: 20px !important;\\n    width: 20px; }\\n  .jbrowse #bigZoomIn {\\n    background-position: 0px -69px;\\n    width: 35px; }\\n  .jbrowse #zoomIn {\\n    background-position: 0px -2.5px;\\n    width: 30px; }\\n  .jbrowse #zoomInSmall {\\n    background-position: 0px -260px;\\n    height: 20px !important;\\n    width: 20px; }\\n  .jbrowse input.nav {\\n    font-size: 9px !important; }\\n  .jbrowse .fatal_error {\\n    font-size: 14px;\\n    margin: 1em; }\\n  .jbrowse div.error, .jbrowse div.message {\\n    margin: 1px 1em;\\n    padding: 2px 6px;\\n    border: 1px outset rgba(0, 0, 0, 0.3); }\\n  .jbrowse div.error {\\n    background: #ff8888; }\\n  .jbrowse div.track > div.error {\\n    width: 30em;\\n    position: absolute; }\\n  .jbrowse div.error h2 {\\n    margin-top: 0; }\\n  .jbrowse div.error .codecaption {\\n    font-size: 90%;\\n    font-weight: bold;\\n    margin-top: 1em;\\n    margin-left: 0.2em; }\\n  .jbrowse div.error code {\\n    display: block;\\n    font-size: 10px;\\n    padding: 0.4em 1.2em;\\n    margin: 0 0.3em 0.3em 0.3em;\\n    overflow: auto;\\n    max-height: 6em; }\\n  .jbrowse div.message {\\n    background: #eee; }\\n  .jbrowse div.block > div.message {\\n    margin: 1em 0;\\n    position: absolute; }\\n  .jbrowse div.block:hover > div.message {\\n    z-index: 30000; }\\n  .jbrowse .sharePane input {\\n    padding: 1px 0 2px 1px; }\\n  .jbrowse .sharePane .copyReminder {\\n    background-color: #396494;\\n    text-align: center;\\n    width: 50%;\\n    margin: 0 auto;\\n    color: white;\\n    padding: 2px;\\n    font-weight: bold; }\\n  .jbrowse .sharePane input {\\n    border: 1px solid #ccc; }\\n  .jbrowse .basePairLabel {\\n    color: black;\\n    position: fixed;\\n    font-weight: bold;\\n    font-size: 9px;\\n    display: none;\\n    background: #fefefe;\\n    padding: 0 0.7em;\\n    z-index: 1000;\\n    text-align: center;\\n    cursor: crosshair;\\n    border: 1px solid #888; }\\n  .jbrowse .basePairLabel.rubber {\\n    z-index: 25; }\\n  .jbrowse .trackVerticalPositionIndicatorMain {\\n    position: fixed;\\n    display: none;\\n    cursor: crosshair;\\n    left: -2px;\\n    height: 100%;\\n    width: 1px;\\n    background-color: #FF0000;\\n    z-index: 15;\\n    top: 0; }\\n  .jbrowse .baseQuality {\\n    font-family: Courier New, monospace; }\\n  .jbrowse table.baseQuality {\\n    margin-bottom: 1em; }\\n  .jbrowse table.baseQuality td {\\n    padding: 0 0.2em;\\n    line-height: 0.95;\\n    text-align: center; }\\n  .jbrowse .baseQuality .basePosition {\\n    display: inline-block;\\n    padding: 0 0.3em 0.4em 0.3em; }\\n  .jbrowse .baseQuality .basePosition:hover {\\n    background: #ccc; }\\n  .jbrowse .baseQuality span.seq {\\n    display: block;\\n    text-align: center;\\n    font-weight: bold; }\\n  .jbrowse .baseQuality span.qual {\\n    display: block;\\n    text-align: center; }\\n  .jbrowse .basic,\\n  .jbrowse .plus-basic,\\n  .jbrowse .minus-basic {\\n    position: absolute;\\n    cursor: pointer;\\n    z-index: 10;\\n    min-width: 1px; }\\n  .jbrowse .basicSubfeature {\\n    position: absolute;\\n    cursor: pointer;\\n    z-index: 12;\\n    min-width: 1px; }\\n  .jbrowse div.hist {\\n    position: absolute;\\n    z-index: 10;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .jbrowse .feature,\\n  .jbrowse .plus-feature,\\n  .jbrowse .minus-feature {\\n    position: absolute;\\n    height: 7px;\\n    background-repeat: repeat-x;\\n    cursor: pointer;\\n    min-width: 1px;\\n    z-index: 10;\\n    background-color: #2F4F4F;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .jbrowse .plus-feature {\\n    background-image: url(\" + ___CSS_LOADER_URL___9___ + \"); }\\n  .jbrowse .minus-feature {\\n    background-image: url(\" + ___CSS_LOADER_URL___10___ + \"); }\\n  .jbrowse .subfeature,\\n  .jbrowse .plus-subfeature,\\n  .jbrowse .minus-subfeature {\\n    position: absolute;\\n    background-color: #2F4F4F;\\n    height: 7px;\\n    min-width: 1px;\\n    z-index: 12;\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    -webkit-box-sizing: border-box;\\n    -ms-box-sizing: border-box; }\\n  .jbrowse .alignment,\\n  .jbrowse .plus-alignment,\\n  .jbrowse .minus-alignment {\\n    background-color: #ccc;\\n    /* these should all 3 match */\\n    height: 11px;\\n    line-height: 11px;\\n    font-size: 11px; }\\n  .jbrowse .plus-alignment {\\n    background-color: #EC8B8B; }\\n  .jbrowse .minus-alignment {\\n    background-color: #898FD8; }\\n  .jbrowse .alignment.missing_mate, .jbrowse .plus-alignment.missing_mate, .jbrowse .minus-alignment.missing_mate {\\n    background-image: url(\" + ___CSS_LOADER_URL___11___ + \"); }\\n  .jbrowse .alignment > .mismatch, .jbrowse .minus-alignment > .mismatch, .jbrowse .plus-alignment > .mismatch {\\n    height: 100%; }\\n  .jbrowse .alignment > .deletion, .jbrowse .minus-alignment > .deletion, .jbrowse .plus-alignment > .deletion {\\n    background-color: black;\\n    height: 100%; }\\n  .jbrowse .alignment > .deletion *, .jbrowse .plus-alignment > .deletion *, .jbrowse .minus-alignment > .deletion * {\\n    color: white; }\\n  .jbrowse .alignment > .insertion, .jbrowse .plus-alignment > .insertion, .jbrowse .minus-alignment > .insertion {\\n    background-color: white;\\n    color: black;\\n    height: 100%; }\\n  .jbrowse .alignment > .skip, .jbrowse .plus-alignment > .skip, .jbrowse .minus-alignment > .skip {\\n    background: url(\" + ___CSS_LOADER_URL___12___ + \") repeat-x 0 50% white;\\n    height: 100%;\\n    opacity: 0.7; }\\n  .jbrowse div.feature-hist {\\n    background-color: blue;\\n    border-color: #5858C4; }\\n  .jbrowse .feature2, .jbrowse .plus-feature2, .jbrowse .minus-feature2 {\\n    position: absolute;\\n    height: 7px;\\n    background-repeat: repeat-x;\\n    cursor: pointer;\\n    min-width: 1px;\\n    z-index: 10;\\n    background-color: #62d335; }\\n  .jbrowse .Boolean-transparent {\\n    opacity: 0.6; }\\n  .jbrowse div.feature2-hist {\\n    background-color: #9f9;\\n    border-color: #ada; }\\n  .jbrowse .feature3, .jbrowse .plus-feature3, .jbrowse .minus-feature3 {\\n    position: absolute;\\n    height: 7px;\\n    background-repeat: repeat-x;\\n    cursor: pointer;\\n    min-width: 1px;\\n    z-index: 10;\\n    background-color: goldenrod; }\\n  .jbrowse div.feature3-hist {\\n    background-color: yellow;\\n    border-color: black; }\\n  .jbrowse .feature4, .jbrowse .plus-feature4, .jbrowse .minus-feature4 {\\n    position: absolute;\\n    height: 11px;\\n    background-repeat: repeat-x;\\n    cursor: pointer;\\n    min-width: 1px;\\n    z-index: 10;\\n    background: yellow; }\\n  .jbrowse div.feature4-hist {\\n    background-color: yellow;\\n    border-color: black; }\\n  .jbrowse .feature5, .jbrowse .plus-feature5, .jbrowse .minus-feature5 {\\n    position: absolute;\\n    height: 7px;\\n    background-repeat: repeat-x;\\n    cursor: pointer;\\n    min-width: 1px;\\n    z-index: 10;\\n    background-color: blue; }\\n  .jbrowse div.feature5-hist {\\n    background-color: blue;\\n    border-color: lightblue; }\\n  .jbrowse div.exon-hist {\\n    background-color: #4B76E8;\\n    border-color: #00f; }\\n  .jbrowse .exon,\\n  .jbrowse .plus-exon,\\n  .jbrowse .minus-exon {\\n    position: absolute;\\n    height: 7px;\\n    background-color: #4B76E8;\\n    border-style: solid;\\n    border-color: #00f;\\n    border-width: 1px;\\n    cursor: pointer;\\n    z-index: 10; }\\n  .jbrowse div.est-hist {\\n    background-color: #ED9185;\\n    border-color: #c33; }\\n  .jbrowse .est,\\n  .jbrowse .plus-est,\\n  .jbrowse .minus-est {\\n    position: absolute;\\n    height: 7px;\\n    background-color: #ED9185; }\\n  .jbrowse .dblhelix,\\n  .jbrowse .plus-dblhelix,\\n  .jbrowse .minus-dblhelix {\\n    position: absolute;\\n    height: 11px;\\n    background-image: url(\" + ___CSS_LOADER_URL___13___ + \");\\n    background-repeat: repeat-x;\\n    min-width: 1px;\\n    cursor: pointer;\\n    z-index: 10; }\\n  .jbrowse div.dblhelix-hist {\\n    background-color: #fcc;\\n    border-color: #daa; }\\n  .jbrowse .plus-helix,\\n  .jbrowse .minus-helix {\\n    position: absolute;\\n    height: 11px;\\n    background-image: url(\" + ___CSS_LOADER_URL___14___ + \");\\n    background-repeat: repeat-x;\\n    min-width: 1px;\\n    cursor: pointer;\\n    z-index: 10; }\\n  .jbrowse div.helix-hist {\\n    background-color: #cfc;\\n    border-color: #ada; }\\n  .jbrowse .loops, .jbrowse .minus-loops, .jbrowse .plus-loops {\\n    position: absolute;\\n    height: 13px;\\n    background-image: url(\" + ___CSS_LOADER_URL___15___ + \");\\n    background-repeat: repeat-x;\\n    cursor: pointer; }\\n  .jbrowse .diamonds, .jbrowse .minus-diamonds, .jbrowse .plus-diamonds {\\n    position: absolute;\\n    height: 13px;\\n    background-image: url(\" + ___CSS_LOADER_URL___16___ + \");\\n    background-repeat: repeat-x;\\n    cursor: pointer; }\\n  .jbrowse .plus-cds, .jbrowse .minus-cds {\\n    position: absolute;\\n    height: 13px;\\n    background-repeat: repeat-x;\\n    cursor: pointer;\\n    min-width: 1px; }\\n  .jbrowse .plus-cds_phase0 {\\n    background-image: url(\" + ___CSS_LOADER_URL___17___ + \"); }\\n  .jbrowse .plus-cds_phase1 {\\n    background-image: url(\" + ___CSS_LOADER_URL___18___ + \"); }\\n  .jbrowse .plus-cds_phase2 {\\n    background-image: url(\" + ___CSS_LOADER_URL___19___ + \"); }\\n  .jbrowse .minus-cds_phase0 {\\n    background-image: url(\" + ___CSS_LOADER_URL___20___ + \"); }\\n  .jbrowse .minus-cds_phase1 {\\n    background-image: url(\" + ___CSS_LOADER_URL___21___ + \"); }\\n  .jbrowse .minus-cds_phase2 {\\n    background-image: url(\" + ___CSS_LOADER_URL___22___ + \"); }\\n  .jbrowse div.cds-hist {\\n    background-color: #fcc;\\n    border-color: #daa; }\\n  .jbrowse .topbracket {\\n    position: absolute;\\n    height: 8px;\\n    border-style: solid solid none solid;\\n    border-width: 2px;\\n    border-color: orange;\\n    cursor: pointer; }\\n  .jbrowse .bottombracket {\\n    position: absolute;\\n    height: 8px;\\n    border-style: none solid solid solid;\\n    border-width: 2px;\\n    border-color: green;\\n    cursor: pointer; }\\n  .jbrowse .hourglass, .jbrowse .plus-hourglass, .jbrowse .minus-hourglass {\\n    position: absolute;\\n    height: 0px;\\n    border-style: solid;\\n    border-width: 6px 3px 6px 3px;\\n    cursor: pointer; }\\n  .jbrowse .triangle, .jbrowse .plus-triangle, .jbrowse .minus-triangle {\\n    position: absolute;\\n    height: 0px;\\n    border-style: solid;\\n    border-width: 6px 3px 0px 3px;\\n    cursor: pointer; }\\n  .jbrowse .hgred {\\n    border-color: #f99 white #f99 white; }\\n  .jbrowse div.hgred-hist {\\n    background-color: #daa;\\n    border-color: #d44; }\\n  .jbrowse .hgblue {\\n    border-color: #99f white #99f white; }\\n  .jbrowse div.hgblue-hist {\\n    background-color: #aad;\\n    border-color: #99f; }\\n  .jbrowse .ibeam, .jbrowse .plus-ibeam, .jbrowse .minus-ibeam {\\n    position: absolute;\\n    height: 2px;\\n    background-color: blue;\\n    border-style: solid;\\n    border-width: 8px 4px 8px 4px;\\n    border-color: white blue white blue;\\n    cursor: pointer;\\n    box-sizing: content-box;\\n    -moz-box-sizing: content-box;\\n    -webkit-box-sizing: content-box;\\n    -ms-box-sizing: content-box; }\\n  .jbrowse div.transcript-hist {\\n    background-color: #ddd;\\n    border-color: #FF9185; }\\n  .jbrowse .transcript,\\n  .jbrowse .plus-transcript,\\n  .jbrowse .minus-transcript {\\n    position: absolute;\\n    height: 11px;\\n    background: url(\" + ___CSS_LOADER_URL___12___ + \") repeat-x 0 4px white;\\n    z-index: 6;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .plus-transcript-arrowhead,\\n  .jbrowse .plus-arrowhead {\\n    position: absolute;\\n    width: 9px;\\n    height: 5px;\\n    background-image: url(\" + ___CSS_LOADER_URL___23___ + \");\\n    background-repeat: no-repeat;\\n    z-index: 100; }\\n  .jbrowse .minus-transcript-arrowhead,\\n  .jbrowse .minus-arrowhead {\\n    position: absolute;\\n    width: 9px;\\n    height: 5px;\\n    background-image: url(\" + ___CSS_LOADER_URL___24___ + \");\\n    background-repeat: no-repeat;\\n    z-index: 100; }\\n  .jbrowse .plus-intron, .jbrowse .minus-intron {\\n    display: none; }\\n  .jbrowse .hidden, .jbrowse .plus-hidden, .jbrowse .minus-hidden {\\n    display: none; }\\n  .jbrowse .plus-CDS,\\n  .jbrowse .plus-transcript-CDS,\\n  .jbrowse .minus-CDS,\\n  .jbrowse .minus-transcript-CDS {\\n    position: absolute;\\n    height: 11px;\\n    background: #F09A9A;\\n    cursor: pointer;\\n    z-index: 10;\\n    min-width: 1px; }\\n  .jbrowse .plus-exon,\\n  .jbrowse .minus-exon,\\n  .jbrowse .plus-UTR,\\n  .jbrowse .minus-UTR,\\n  .jbrowse .plus-five_prime_UTR,\\n  .jbrowse .minus-five_prime_UTR,\\n  .jbrowse .plus-three_prime_UTR,\\n  .jbrowse .minus-three_prime_UTR {\\n    position: absolute;\\n    height: 7px;\\n    background-color: #B66;\\n    border-style: solid;\\n    border-color: #D88;\\n    border-width: 2px 0px 2px 0px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .generic_parent,\\n  .jbrowse .plus-generic_parent,\\n  .jbrowse .minus-generic_parent {\\n    position: absolute;\\n    height: 4px;\\n    background-color: #AAA;\\n    z-index: 6;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse div.generic_parent-hist {\\n    background-color: #ddd;\\n    border-color: #555; }\\n  .jbrowse .match_part,\\n  .jbrowse .plus-match_part,\\n  .jbrowse .minus-match_part {\\n    position: absolute;\\n    height: 4px;\\n    background-color: #66B;\\n    border-style: solid;\\n    border-color: #88D;\\n    border-width: 2px 0px 2px 0px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .generic_part_a,\\n  .jbrowse .plus-generic_part_a,\\n  .jbrowse .minus-generic_part_a {\\n    position: absolute;\\n    height: 4px;\\n    background-color: #6B6;\\n    border-style: solid;\\n    border-color: #8D8;\\n    border-width: 2px 0px 2px 0px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .wiggleValueDisplay {\\n    border: 1px solid #aaa;\\n    padding: 2px;\\n    -moz-box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3);\\n    -webkit-box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3);\\n    box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3); }\\n    .jbrowse .wiggleValueDisplay, .jbrowse .wiggleValueDisplay * {\\n      background: #FFFEF0;\\n      font-family: Courier New, monospace;\\n      font-weight: bold;\\n      cursor: default; }\\n    .jbrowse .wiggleValueDisplay table {\\n      border-spacing: 0; }\\n      .jbrowse .wiggleValueDisplay table * {\\n        border: none; }\\n    .jbrowse .wiggleValueDisplay th, .jbrowse .wiggleValueDisplay td {\\n      border: none;\\n      padding: 0.2em 0.4em; }\\n    .jbrowse .wiggleValueDisplay td.count, .jbrowse .wiggleValueDisplay td.pct {\\n      text-align: right; }\\n    .jbrowse .wiggleValueDisplay tr.total > td {\\n      border-top: 1px solid #aaa;\\n      font-weight: bold; }\\n  .jbrowse .wigglePositionIndicator {\\n    background: #333;\\n    border: none;\\n    width: 1px;\\n    cursor: default; }\\n  .jbrowse .base {\\n    color: black;\\n    font-family: Courier New,monospace;\\n    font-weight: bold;\\n    text-shadow: white 0px 0px 1px; }\\n  .jbrowse .base_n {\\n    background-color: #C6C6C6; }\\n  .jbrowse .base_a {\\n    background-color: #00BF00; }\\n  .jbrowse .base_c {\\n    background-color: #4747ff; }\\n  .jbrowse .base_t {\\n    background-color: #f00; }\\n  .jbrowse .base_g {\\n    background-color: #ffa500; }\\n  .jbrowse .base_reference {\\n    background-color: #bbb; }\\n  .jbrowse .base_deletion {\\n    background-color: #999; }\\n  .jbrowse .sequence.nocolor .base {\\n    background-color: #ddd; }\\n  .jbrowse .featureTooltip {\\n    background: #FFFEF0;\\n    border: 1px solid #aaa;\\n    padding: 2px;\\n    font-family: Courier New, monospace;\\n    font-weight: bold;\\n    cursor: default;\\n    -moz-box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3);\\n    -webkit-box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3);\\n    box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3); }\\n  .jbrowse table.sequence {\\n    border-collapse: collapse; }\\n  .jbrowse div.sequence_blur {\\n    /* background: url('../img/sequence_blur.png') #eee repeat-x; */\\n    background: #f5f5f5;\\n    background: rgba(50, 50, 50, 0.16);\\n    border: 0;\\n    color: #575757;\\n    height: 31px;\\n    font-size: 12px;\\n    text-align: center;\\n    position: relative; }\\n  .jbrowse .sequence_blur > span {\\n    top: 50%;\\n    position: absolute;\\n    width: 100%;\\n    display: block;\\n    left: 0;\\n    margin-top: -8px; }\\n  .jbrowse table.sequence .highlighted {\\n    background: #ff0; }\\n  .jbrowse table.sequence .revcom {\\n    color: red; }\\n  .jbrowse table.sequence .base, .jbrowse table.sequence > tr, .jbrowse table.translatedSequence > tr, .jbrowse table.translatedSequence {\\n    height: 14px;\\n    line-height: 14px; }\\n  .jbrowse table.sequence.big .base {\\n    border-right: 1px solid #333; }\\n  .jbrowse .translatedSequence {\\n    position: relative;\\n    border-width: 0px;\\n    border-collapse: collapse;\\n    overflow: visible; }\\n  .jbrowse .translatedSequence table {\\n    z-index: 10; }\\n  .jbrowse .translatedSequence.frame0 {\\n    background-color: #929292; }\\n  .jbrowse .translatedSequence.frame1 {\\n    background-color: #B0B0B0; }\\n  .jbrowse .translatedSequence.frame2 {\\n    background-color: #E0E0E0; }\\n  .jbrowse .translatedSequence td.aminoAcid {\\n    text-align: center;\\n    z-index: 2000;\\n    color: black;\\n    font-family: Courier New,monospace;\\n    font-weight: bold;\\n    text-shadow: white 0px 0px 1px; }\\n  .jbrowse .translatedSequence.big, .jbrowse .translatedSequence.big td.aminoAcid {\\n    border-right: 1px solid #777; }\\n  .jbrowse .translatedSequence.frame2 td.aminoAcid {\\n    border-right-color: #979797; }\\n  .jbrowse .translatedSequence.frame1 td.aminoAcid {\\n    border-right-color: #6d6d6d; }\\n  .jbrowse .translatedSequence.frame0 td.aminoAcid {\\n    border-right-color: #5f5f5f; }\\n  .jbrowse .translatedSequence td.aminoAcid_stop {\\n    background-color: #FF0000; }\\n  .jbrowse .translatedSequence td.aminoAcid_start {\\n    background-color: #00FF00; }\\n  .jbrowse td.base {\\n    text-align: center;\\n    z-index: 2000; }\\n  .jbrowse .aaScheme_buried.base_a {\\n    background-color: #00a35c; }\\n  .jbrowse .aaScheme_buried.base_b {\\n    background-color: #00eb14; }\\n  .jbrowse .aaScheme_buried.base_c {\\n    background-color: #0000ff; }\\n  .jbrowse .aaScheme_buried.base_d {\\n    background-color: #00eb14; }\\n  .jbrowse .aaScheme_buried.base_e {\\n    background-color: #00f10e; }\\n  .jbrowse .aaScheme_buried.base_f {\\n    background-color: #008778; }\\n  .jbrowse .aaScheme_buried.base_g {\\n    background-color: #009d62; }\\n  .jbrowse .aaScheme_buried.base_h {\\n    background-color: #00d52a; }\\n  .jbrowse .aaScheme_buried.base_i {\\n    background-color: #0054ab; }\\n  .jbrowse .aaScheme_buried.base_k {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_buried.base_l {\\n    background-color: #007b84; }\\n  .jbrowse .aaScheme_buried.base_m {\\n    background-color: #009768; }\\n  .jbrowse .aaScheme_buried.base_n {\\n    background-color: #00eb14; }\\n  .jbrowse .aaScheme_buried.base_p {\\n    background-color: #00e01f; }\\n  .jbrowse .aaScheme_buried.base_q {\\n    background-color: #00f10e; }\\n  .jbrowse .aaScheme_buried.base_r {\\n    background-color: #00fc03; }\\n  .jbrowse .aaScheme_buried.base_s {\\n    background-color: #00d52a; }\\n  .jbrowse .aaScheme_buried.base_t {\\n    background-color: #00db24; }\\n  .jbrowse .aaScheme_buried.base_v {\\n    background-color: #005fa0; }\\n  .jbrowse .aaScheme_buried.base_w {\\n    background-color: #00a857; }\\n  .jbrowse .aaScheme_buried.base_x {\\n    background-color: #00b649; }\\n  .jbrowse .aaScheme_buried.base_y {\\n    background-color: #00e619; }\\n  .jbrowse .aaScheme_buried.base_z {\\n    background-color: #00f10e; }\\n  .jbrowse .aaScheme_cinema.base_a {\\n    background-color: #BBBBBB; }\\n  .jbrowse .aaScheme_cinema.base_b {\\n    background-color: #808080; }\\n  .jbrowse .aaScheme_cinema.base_c {\\n    background-color: #ffff00; }\\n  .jbrowse .aaScheme_cinema.base_d {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_cinema.base_e {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_cinema.base_f {\\n    background-color: #FF00FF; }\\n  .jbrowse .aaScheme_cinema.base_g {\\n    background-color: #A52A2A; }\\n  .jbrowse .aaScheme_cinema.base_h {\\n    background-color: #00FFFF; }\\n  .jbrowse .aaScheme_cinema.base_i {\\n    background-color: #BBBBBB; }\\n  .jbrowse .aaScheme_cinema.base_j {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_cinema.base_k {\\n    background-color: #00FFFF; }\\n  .jbrowse .aaScheme_cinema.base_l {\\n    background-color: #BBBBBB; }\\n  .jbrowse .aaScheme_cinema.base_m {\\n    background-color: #BBBBBB; }\\n  .jbrowse .aaScheme_cinema.base_n {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_cinema.base_o {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_cinema.base_p {\\n    background-color: #A52A2A; }\\n  .jbrowse .aaScheme_cinema.base_q {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_cinema.base_r {\\n    background-color: #00FFFF; }\\n  .jbrowse .aaScheme_cinema.base_s {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_cinema.base_t {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_cinema.base_u {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_cinema.base_v {\\n    background-color: #BBBBBB; }\\n  .jbrowse .aaScheme_cinema.base_w {\\n    background-color: #FF00FF; }\\n  .jbrowse .aaScheme_cinema.base_x {\\n    background-color: #808080; }\\n  .jbrowse .aaScheme_cinema.base_y {\\n    background-color: #FF00FF; }\\n  .jbrowse .aaScheme_cinema.base_z {\\n    background-color: #808080; }\\n  .jbrowse .aaScheme_clustal.base_a {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_clustal.base_b {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal.base_c {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_clustal.base_d {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_clustal.base_e {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_clustal.base_f {\\n    background-color: #0000FF; }\\n  .jbrowse .aaScheme_clustal.base_g {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_clustal.base_h {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_clustal.base_i {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_clustal.base_j {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal.base_k {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_clustal.base_l {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_clustal.base_m {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_clustal.base_n {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal.base_o {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal.base_p {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_clustal.base_q {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal.base_r {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_clustal.base_s {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_clustal.base_t {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_clustal.base_u {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal.base_v {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_clustal.base_w {\\n    background-color: #0000FF; }\\n  .jbrowse .aaScheme_clustal.base_x {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal.base_y {\\n    background-color: #0000FF; }\\n  .jbrowse .aaScheme_clustal.base_z {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal2.base_a {\\n    background-color: #80a0f0; }\\n  .jbrowse .aaScheme_clustal2.base_b {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal2.base_c {\\n    background-color: #f08080; }\\n  .jbrowse .aaScheme_clustal2.base_d {\\n    background-color: #c048c0; }\\n  .jbrowse .aaScheme_clustal2.base_e {\\n    background-color: #c048c0; }\\n  .jbrowse .aaScheme_clustal2.base_f {\\n    background-color: #80a0f0; }\\n  .jbrowse .aaScheme_clustal2.base_g {\\n    background-color: #f09048; }\\n  .jbrowse .aaScheme_clustal2.base_h {\\n    background-color: #15a4a4; }\\n  .jbrowse .aaScheme_clustal2.base_i {\\n    background-color: #80a0f0; }\\n  .jbrowse .aaScheme_clustal2.base_k {\\n    background-color: #f01505; }\\n  .jbrowse .aaScheme_clustal2.base_l {\\n    background-color: #80a0f0; }\\n  .jbrowse .aaScheme_clustal2.base_m {\\n    background-color: #80a0f0; }\\n  .jbrowse .aaScheme_clustal2.base_n {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_clustal2.base_p {\\n    background-color: #ffff00; }\\n  .jbrowse .aaScheme_clustal2.base_q {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_clustal2.base_r {\\n    background-color: #f01505; }\\n  .jbrowse .aaScheme_clustal2.base_s {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_clustal2.base_t {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_clustal2.base_v {\\n    background-color: #80a0f0; }\\n  .jbrowse .aaScheme_clustal2.base_w {\\n    background-color: #80a0f0; }\\n  .jbrowse .aaScheme_clustal2.base_x {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_clustal2.base_y {\\n    background-color: #15a4a4; }\\n  .jbrowse .aaScheme_clustal2.base_z {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_helix.base_a {\\n    background-color: #e718e7; }\\n  .jbrowse .aaScheme_helix.base_b {\\n    background-color: #49b649; }\\n  .jbrowse .aaScheme_helix.base_c {\\n    background-color: #23dc23; }\\n  .jbrowse .aaScheme_helix.base_d {\\n    background-color: #778877; }\\n  .jbrowse .aaScheme_helix.base_e {\\n    background-color: #ff00ff; }\\n  .jbrowse .aaScheme_helix.base_f {\\n    background-color: #986798; }\\n  .jbrowse .aaScheme_helix.base_g {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_helix.base_h {\\n    background-color: #758a75; }\\n  .jbrowse .aaScheme_helix.base_i {\\n    background-color: #8a758a; }\\n  .jbrowse .aaScheme_helix.base_k {\\n    background-color: #a05fa0; }\\n  .jbrowse .aaScheme_helix.base_l {\\n    background-color: #ae51ae; }\\n  .jbrowse .aaScheme_helix.base_m {\\n    background-color: #ef10ef; }\\n  .jbrowse .aaScheme_helix.base_n {\\n    background-color: #1be41b; }\\n  .jbrowse .aaScheme_helix.base_p {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_helix.base_q {\\n    background-color: #926d92; }\\n  .jbrowse .aaScheme_helix.base_r {\\n    background-color: #6f906f; }\\n  .jbrowse .aaScheme_helix.base_s {\\n    background-color: #36c936; }\\n  .jbrowse .aaScheme_helix.base_t {\\n    background-color: #47b847; }\\n  .jbrowse .aaScheme_helix.base_v {\\n    background-color: #857a85; }\\n  .jbrowse .aaScheme_helix.base_w {\\n    background-color: #8a758a; }\\n  .jbrowse .aaScheme_helix.base_x {\\n    background-color: #758a75; }\\n  .jbrowse .aaScheme_helix.base_y {\\n    background-color: #21de21; }\\n  .jbrowse .aaScheme_helix.base_z {\\n    background-color: #c936c9; }\\n  .jbrowse .aaScheme_hydrophobicity.base_a {\\n    background-color: #ad0052; }\\n  .jbrowse .aaScheme_hydrophobicity.base_b {\\n    background-color: #0c00f3; }\\n  .jbrowse .aaScheme_hydrophobicity.base_c {\\n    background-color: #c2003d; }\\n  .jbrowse .aaScheme_hydrophobicity.base_d {\\n    background-color: #0c00f3; }\\n  .jbrowse .aaScheme_hydrophobicity.base_e {\\n    background-color: #0c00f3; }\\n  .jbrowse .aaScheme_hydrophobicity.base_f {\\n    background-color: #cb0034; }\\n  .jbrowse .aaScheme_hydrophobicity.base_g {\\n    background-color: #6a0095; }\\n  .jbrowse .aaScheme_hydrophobicity.base_h {\\n    background-color: #1500ea; }\\n  .jbrowse .aaScheme_hydrophobicity.base_i {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_hydrophobicity.base_j {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_hydrophobicity.base_k {\\n    background-color: #0000ff; }\\n  .jbrowse .aaScheme_hydrophobicity.base_l {\\n    background-color: #ea0015; }\\n  .jbrowse .aaScheme_hydrophobicity.base_m {\\n    background-color: #b0004f; }\\n  .jbrowse .aaScheme_hydrophobicity.base_n {\\n    background-color: #0c00f3; }\\n  .jbrowse .aaScheme_hydrophobicity.base_o {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_hydrophobicity.base_p {\\n    background-color: #4600b9; }\\n  .jbrowse .aaScheme_hydrophobicity.base_q {\\n    background-color: #0c00f3; }\\n  .jbrowse .aaScheme_hydrophobicity.base_r {\\n    background-color: #0000ff; }\\n  .jbrowse .aaScheme_hydrophobicity.base_s {\\n    background-color: #5e00a1; }\\n  .jbrowse .aaScheme_hydrophobicity.base_t {\\n    background-color: #61009e; }\\n  .jbrowse .aaScheme_hydrophobicity.base_u {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_hydrophobicity.base_v {\\n    background-color: #f60009; }\\n  .jbrowse .aaScheme_hydrophobicity.base_w {\\n    background-color: #5b00a4; }\\n  .jbrowse .aaScheme_hydrophobicity.base_x {\\n    background-color: #680097; }\\n  .jbrowse .aaScheme_hydrophobicity.base_y {\\n    background-color: #4f00b0; }\\n  .jbrowse .aaScheme_hydrophobicity.base_z {\\n    background-color: #0c00f3; }\\n  .jbrowse .aaScheme_lesk.base_a {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_lesk.base_b {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_lesk.base_c {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_d {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_lesk.base_e {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_lesk.base_f {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_g {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_lesk.base_h {\\n    background-color: #FF00FF; }\\n  .jbrowse .aaScheme_lesk.base_i {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_j {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_lesk.base_k {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_lesk.base_l {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_m {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_n {\\n    background-color: #FF00FF; }\\n  .jbrowse .aaScheme_lesk.base_o {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_lesk.base_p {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_q {\\n    background-color: #FF00FF; }\\n  .jbrowse .aaScheme_lesk.base_r {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_lesk.base_s {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_lesk.base_t {\\n    background-color: #FFA500; }\\n  .jbrowse .aaScheme_lesk.base_u {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_lesk.base_v {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_w {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_x {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_lesk.base_y {\\n    background-color: #008000; }\\n  .jbrowse .aaScheme_lesk.base_z {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_mae.base_a {\\n    background-color: #77dd88; }\\n  .jbrowse .aaScheme_mae.base_b {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_mae.base_c {\\n    background-color: #99ee66; }\\n  .jbrowse .aaScheme_mae.base_d {\\n    background-color: #55bb33; }\\n  .jbrowse .aaScheme_mae.base_e {\\n    background-color: #55bb33; }\\n  .jbrowse .aaScheme_mae.base_f {\\n    background-color: #9999ff; }\\n  .jbrowse .aaScheme_mae.base_g {\\n    background-color: #77dd88; }\\n  .jbrowse .aaScheme_mae.base_h {\\n    background-color: #5555ff; }\\n  .jbrowse .aaScheme_mae.base_i {\\n    background-color: #66bbff; }\\n  .jbrowse .aaScheme_mae.base_j {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_mae.base_k {\\n    background-color: #ffcc77; }\\n  .jbrowse .aaScheme_mae.base_l {\\n    background-color: #66bbff; }\\n  .jbrowse .aaScheme_mae.base_m {\\n    background-color: #66bbff; }\\n  .jbrowse .aaScheme_mae.base_n {\\n    background-color: #55bb33; }\\n  .jbrowse .aaScheme_mae.base_o {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_mae.base_p {\\n    background-color: #eeaaaa; }\\n  .jbrowse .aaScheme_mae.base_q {\\n    background-color: #55bb33; }\\n  .jbrowse .aaScheme_mae.base_r {\\n    background-color: #ffcc77; }\\n  .jbrowse .aaScheme_mae.base_s {\\n    background-color: #ff4455; }\\n  .jbrowse .aaScheme_mae.base_t {\\n    background-color: #ff4455; }\\n  .jbrowse .aaScheme_mae.base_u {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_mae.base_v {\\n    background-color: #66bbff; }\\n  .jbrowse .aaScheme_mae.base_w {\\n    background-color: #9999ff; }\\n  .jbrowse .aaScheme_mae.base_x {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_mae.base_y {\\n    background-color: #9999ff; }\\n  .jbrowse .aaScheme_mae.base_z {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_purine.base_a {\\n    background-color: #FF83FA; }\\n  .jbrowse .aaScheme_purine.base_c {\\n    background-color: #40E0D0; }\\n  .jbrowse .aaScheme_purine.base_g {\\n    background-color: #FF83FA; }\\n  .jbrowse .aaScheme_purine.base_r {\\n    background-color: #FF83FA; }\\n  .jbrowse .aaScheme_purine.base_t {\\n    background-color: #40E0D0; }\\n  .jbrowse .aaScheme_purine.base_u {\\n    background-color: #40E0D0; }\\n  .jbrowse .aaScheme_purine.base_y {\\n    background-color: #40E0D0; }\\n  .jbrowse .aaScheme_strand.base_a {\\n    background-color: #5858a7; }\\n  .jbrowse .aaScheme_strand.base_b {\\n    background-color: #4343bc; }\\n  .jbrowse .aaScheme_strand.base_c {\\n    background-color: #9d9d62; }\\n  .jbrowse .aaScheme_strand.base_d {\\n    background-color: #2121de; }\\n  .jbrowse .aaScheme_strand.base_e {\\n    background-color: #0000ff; }\\n  .jbrowse .aaScheme_strand.base_f {\\n    background-color: #c2c23d; }\\n  .jbrowse .aaScheme_strand.base_g {\\n    background-color: #4949b6; }\\n  .jbrowse .aaScheme_strand.base_h {\\n    background-color: #60609f; }\\n  .jbrowse .aaScheme_strand.base_i {\\n    background-color: #ecec13; }\\n  .jbrowse .aaScheme_strand.base_k {\\n    background-color: #4747b8; }\\n  .jbrowse .aaScheme_strand.base_l {\\n    background-color: #b2b24d; }\\n  .jbrowse .aaScheme_strand.base_m {\\n    background-color: #82827d; }\\n  .jbrowse .aaScheme_strand.base_n {\\n    background-color: #64649b; }\\n  .jbrowse .aaScheme_strand.base_p {\\n    background-color: #2323dc; }\\n  .jbrowse .aaScheme_strand.base_q {\\n    background-color: #8c8c73; }\\n  .jbrowse .aaScheme_strand.base_r {\\n    background-color: #6b6b94; }\\n  .jbrowse .aaScheme_strand.base_s {\\n    background-color: #4949b6; }\\n  .jbrowse .aaScheme_strand.base_t {\\n    background-color: #9d9d62; }\\n  .jbrowse .aaScheme_strand.base_v {\\n    background-color: #ffff00; }\\n  .jbrowse .aaScheme_strand.base_w {\\n    background-color: #c0c03f; }\\n  .jbrowse .aaScheme_strand.base_x {\\n    background-color: #797986; }\\n  .jbrowse .aaScheme_strand.base_y {\\n    background-color: #d3d32c; }\\n  .jbrowse .aaScheme_strand.base_z {\\n    background-color: #4747b8; }\\n  .jbrowse .aaScheme_taylor.base_a {\\n    background-color: #ccff00; }\\n  .jbrowse .aaScheme_taylor.base_b {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_taylor.base_c {\\n    background-color: #ffff00; }\\n  .jbrowse .aaScheme_taylor.base_d {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_taylor.base_e {\\n    background-color: #ff0066; }\\n  .jbrowse .aaScheme_taylor.base_f {\\n    background-color: #00ff66; }\\n  .jbrowse .aaScheme_taylor.base_g {\\n    background-color: #ff9900; }\\n  .jbrowse .aaScheme_taylor.base_h {\\n    background-color: #0066ff; }\\n  .jbrowse .aaScheme_taylor.base_i {\\n    background-color: #66ff00; }\\n  .jbrowse .aaScheme_taylor.base_k {\\n    background-color: #6600ff; }\\n  .jbrowse .aaScheme_taylor.base_l {\\n    background-color: #33ff00; }\\n  .jbrowse .aaScheme_taylor.base_m {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_taylor.base_n {\\n    background-color: #cc00ff; }\\n  .jbrowse .aaScheme_taylor.base_p {\\n    background-color: #ffcc00; }\\n  .jbrowse .aaScheme_taylor.base_q {\\n    background-color: #ff00cc; }\\n  .jbrowse .aaScheme_taylor.base_r {\\n    background-color: #0000ff; }\\n  .jbrowse .aaScheme_taylor.base_s {\\n    background-color: #ff3300; }\\n  .jbrowse .aaScheme_taylor.base_t {\\n    background-color: #ff6600; }\\n  .jbrowse .aaScheme_taylor.base_v {\\n    background-color: #99ff00; }\\n  .jbrowse .aaScheme_taylor.base_w {\\n    background-color: #00ccff; }\\n  .jbrowse .aaScheme_taylor.base_x {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_taylor.base_y {\\n    background-color: #00ffcc; }\\n  .jbrowse .aaScheme_taylor.base_z {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_turn.base_a {\\n    background-color: #2cd3d3; }\\n  .jbrowse .aaScheme_turn.base_b {\\n    background-color: #f30c0c; }\\n  .jbrowse .aaScheme_turn.base_c {\\n    background-color: #a85757; }\\n  .jbrowse .aaScheme_turn.base_d {\\n    background-color: #e81717; }\\n  .jbrowse .aaScheme_turn.base_e {\\n    background-color: #778888; }\\n  .jbrowse .aaScheme_turn.base_f {\\n    background-color: #1ee1e1; }\\n  .jbrowse .aaScheme_turn.base_g {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_turn.base_h {\\n    background-color: #708f8f; }\\n  .jbrowse .aaScheme_turn.base_i {\\n    background-color: #00ffff; }\\n  .jbrowse .aaScheme_turn.base_k {\\n    background-color: #7e8181; }\\n  .jbrowse .aaScheme_turn.base_l {\\n    background-color: #1ce3e3; }\\n  .jbrowse .aaScheme_turn.base_m {\\n    background-color: #1ee1e1; }\\n  .jbrowse .aaScheme_turn.base_n {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_turn.base_p {\\n    background-color: #f60909; }\\n  .jbrowse .aaScheme_turn.base_q {\\n    background-color: #3fc0c0; }\\n  .jbrowse .aaScheme_turn.base_r {\\n    background-color: #708f8f; }\\n  .jbrowse .aaScheme_turn.base_s {\\n    background-color: #e11e1e; }\\n  .jbrowse .aaScheme_turn.base_t {\\n    background-color: #738c8c; }\\n  .jbrowse .aaScheme_turn.base_v {\\n    background-color: #07f8f8; }\\n  .jbrowse .aaScheme_turn.base_w {\\n    background-color: #738c8c; }\\n  .jbrowse .aaScheme_turn.base_x {\\n    background-color: #7c8383; }\\n  .jbrowse .aaScheme_turn.base_y {\\n    background-color: #9d6262; }\\n  .jbrowse .aaScheme_turn.base_z {\\n    background-color: #5ba4a4; }\\n  .jbrowse .aaScheme_zappo.base_a {\\n    background-color: #ffafaf; }\\n  .jbrowse .aaScheme_zappo.base_b {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_zappo.base_c {\\n    background-color: #ffff00; }\\n  .jbrowse .aaScheme_zappo.base_d {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_zappo.base_e {\\n    background-color: #ff0000; }\\n  .jbrowse .aaScheme_zappo.base_f {\\n    background-color: #ffc800; }\\n  .jbrowse .aaScheme_zappo.base_g {\\n    background-color: #ff00ff; }\\n  .jbrowse .aaScheme_zappo.base_h {\\n    background-color: #6464ff; }\\n  .jbrowse .aaScheme_zappo.base_i {\\n    background-color: #ffafaf; }\\n  .jbrowse .aaScheme_zappo.base_k {\\n    background-color: #6464ff; }\\n  .jbrowse .aaScheme_zappo.base_l {\\n    background-color: #ffafaf; }\\n  .jbrowse .aaScheme_zappo.base_m {\\n    background-color: #ffafaf; }\\n  .jbrowse .aaScheme_zappo.base_n {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_zappo.base_p {\\n    background-color: #ff00ff; }\\n  .jbrowse .aaScheme_zappo.base_q {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_zappo.base_r {\\n    background-color: #6464ff; }\\n  .jbrowse .aaScheme_zappo.base_s {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_zappo.base_t {\\n    background-color: #00ff00; }\\n  .jbrowse .aaScheme_zappo.base_v {\\n    background-color: #ffafaf; }\\n  .jbrowse .aaScheme_zappo.base_w {\\n    background-color: #ffc800; }\\n  .jbrowse .aaScheme_zappo.base_x {\\n    background-color: #ffffff; }\\n  .jbrowse .aaScheme_zappo.base_y {\\n    background-color: #ffc800; }\\n  .jbrowse .aaScheme_zappo.base_z {\\n    background-color: #ffffff; }\\n  .jbrowse div.menuBar {\\n    padding: 1px 0;\\n    height: 25px;\\n    background: #396494;\\n    text-align: right;\\n    line-height: 1; }\\n    .jbrowse div.menuBar a {\\n      color: white; }\\n    .jbrowse div.menuBar .dataset-name {\\n      font-size: 13px;\\n      color: white;\\n      font-style: italic;\\n      padding-right: 1em;\\n      padding-top: 7px; }\\n    .jbrowse div.menuBar * {\\n      outline: none;\\n      vertical-align: top; }\\n    .jbrowse div.menuBar .dijitButtonNode {\\n      background: transparent;\\n      border: 2px outset rgba(120, 120, 120, 0.2);\\n      height: 18px; }\\n  .jbrowse div.topLink {\\n    position: absolute;\\n    right: 0;\\n    top: 0;\\n    z-index: 50;\\n    background: white;\\n    border: 1px solid #888;\\n    border-width: 0 0 1px 1px; }\\n  .jbrowse div.menuBar a, .jbrowse .topLink a {\\n    padding: 0 0.8ex;\\n    text-decoration: none; }\\n  .jbrowse .menuBar .powered_by {\\n    float: left;\\n    font-size: 125%;\\n    font-family: 'Helvetica Neue', Arial, Helvetica, 'Nimbus Sans L', sans-serif;\\n    font-weight: bold;\\n    line-height: 25px;\\n    /* note this line-height should be the same as the fixed height of the menuBar */\\n    cursor: pointer; }\\n  .jbrowse .share {\\n    line-height: 18px; }\\n    .jbrowse .share .icon {\\n      height: 8px;\\n      width: 19px;\\n      display: inline;\\n      display: inline-block;\\n      background: url(\" + ___CSS_LOADER_URL___25___ + \") no-repeat -149px -91px;\\n      margin-right: 2px;\\n      margin-top: 2px;\\n      vertical-align: middle; }\\n  .jbrowse a.topLink, .jbrowse a.topLink * {\\n    cursor: pointer; }\\n  .jbrowse .topLink .powered_by {\\n    padding: 0 0.5em;\\n    color: black;\\n    text-decoration: none; }\\n  .jbrowse .menuBar .dijitButtonHover,\\n  .jbrowse .menuBar .dijitDropDownButtonHover {\\n    background: rgba(255, 255, 255, 0.07); }\\n  .jbrowse .menuBar .dijitButtonActive .dijitButtonNode,\\n  .jbrowse .menuBar .dijitDropDownButtonActive .dijitButtonNode {\\n    border: 2px inset rgba(120, 120, 120, 0.2); }\\n  .jbrowse .menuBar .dijitButtonNode {\\n    padding: 0 1em; }\\n  .jbrowse .menuBar .dijitButtonNode * {\\n    color: white; }\\n  .jbrowse .menuBar .config .icon {\\n    height: 16px;\\n    width: 16px;\\n    margin-right: 2px;\\n    margin-top: -2px;\\n    display: inline;\\n    display: inline-block;\\n    background: url(\" + ___CSS_LOADER_URL___25___ + \") no-repeat -168px -27px;\\n    vertical-align: middle; }\\n  .jbrowse .menuBar > .menu, .jbrowse .menuBar > .dijitComboBox {\\n    float: left;\\n    font-size: 120%;\\n    color: white;\\n    background: transparent;\\n    height: 100%;\\n    border: none; }\\n  .jbrowse .menuBar > .dijitComboBox > .dijitInputContainer {\\n    height: 100%; }\\n  .jbrowse .menuBar > .dijitComboBox .dijitArrowButton {\\n    padding: 0 3px 0 2px;\\n    height: 100%; }\\n    .jbrowse .menuBar > .dijitComboBox .dijitArrowButton .dijitArrowButtonInner {\\n      background: url(\" + ___CSS_LOADER_URL___4___ + \") no-repeat scroll -56px center;\\n      margin-top: 4px; }\\n    .jbrowse .menuBar > .dijitComboBox .dijitArrowButton:hover {\\n      background: rgba(255, 255, 255, 0.2); }\\n  .jbrowse .menuBar > .dijitComboBox .dataset_select {\\n    font-weight: bold;\\n    background: transparent;\\n    border: none;\\n    color: inherit;\\n    font-size: inherit;\\n    font-style: italic;\\n    height: 100%;\\n    padding-bottom: 1px;\\n    padding-left: 3px; }\\n    .jbrowse .menuBar > .dijitComboBox .dataset_select .dijitSelectLabel {\\n      padding: 0 0.5em;\\n      vertical-align: middle; }\\n    .jbrowse .menuBar > .dijitComboBox .dataset_select.dijitSelectHover td {\\n      color: white; }\\n    .jbrowse .menuBar > .dijitComboBox .dataset_select .dijitButtonContents {\\n      background: transparent;\\n      border-color: transparent; }\\n  .jbrowse.globalMenu .dijitMenuItem td {\\n    padding: 0.5em 2px 0.5em 5px; }\\n  .jbrowse .menuBar > .menu .dijitButtonNode {\\n    border: none; }\\n  .jbrowse .menuBar > .menu.dijitDropDownButton,\\n  .jbrowse .menuBar > .menu.dijitDropDownButton * {\\n    margin: 0;\\n    padding: 0;\\n    line-height: 25px; }\\n  .jbrowse .menuBar > .menu.dijitDropDownButton .dijitButtonNode {\\n    padding: 0 1em 0 0.7em;\\n    text-align: left; }\\n  .jbrowse .menuBar > .menu .dijitDropDownButtonHover .dijitButtonNode {\\n    background: rgba(255, 255, 255, 0.07); }\\n  .jbrowse .menuBar > .menu .dijitDropDownButtonActive .dijitButtonNode {\\n    border: none; }\\n  .jbrowse .welcome_button {\\n    border: 1px black;\\n    background-color: #396494;\\n    color: white;\\n    padding: 10px;\\n    margin: 2px;\\n    width: 200px; }\\n  .jbrowse .welcome_button:hover {\\n    background-color: #3A8A9A; }\\n  .jbrowse #location-info {\\n    display: inline-block;\\n    border: 0px solid #bbb;\\n    padding: 3px 3px 3px 3px;\\n    background-color: rgba(235, 235, 235, 0.6);\\n    margin-right: 6px;\\n    cursor: default;\\n    position: relative;\\n    top: 2px;\\n    min-width: 40ex; }\\n  .jbrowse #search-box {\\n    margin-right: 10px; }\\n  .jbrowse .separate-location-box {\\n    float: right; }\\n  .jbrowse div[id=widget_location] {\\n    margin-left: 3px !important; }\\n  .jbrowse #widget_location {\\n    /*    width: 18ex !important;*/\\n    padding-top: 2px; }\\n  .jbrowse span1[widgetid=search-go-btn] {\\n    position: relative;\\n    left: -3px; }\\n  .jbrowse div[widgetid=highlight-btn] {\\n    position: relative;\\n    top: 1px; }\\n  .jbrowse .jbrowseIconHelp,\\n  .jbrowse .jbrowseIconBusy,\\n  .jbrowse .jbrowseIconLink,\\n  .jbrowse .jbrowseIconCancel,\\n  .jbrowse .jbrowseIconHorizontalResize,\\n  .jbrowse .jbrowseIconVerticalResize {\\n    background-image: url(\" + ___CSS_LOADER_URL___0___ + \");\\n    width: 16px;\\n    height: 16px; }\\n  .jbrowse .dijitDisabled .jbrowseIconHelp,\\n  .jbrowse .dijitDisabled .jbrowseIconBusy,\\n  .jbrowse .dijitDisabled .jbrowseIconLink,\\n  .jbrowse .dijitDisabled .jbrowseIconCancel,\\n  .jbrowse .dijitDisabled .jbrowseIconHorizontalResize,\\n  .jbrowse .dijitDisabled .jbrowseIconVerticalResize {\\n    background-image: url(\" + ___CSS_LOADER_URL___1___ + \");\\n    width: 16px;\\n    height: 16px; }\\n  .jbrowse .jbrowseIconHelp {\\n    background-position: 0; }\\n  .jbrowse .jbrowseIconLink {\\n    background-position: -152px; }\\n  .jbrowse .jbrowseIconCancel {\\n    background-position: -170px; }\\n  .jbrowse .jbrowseIconBusy {\\n    background-image: url(\" + ___CSS_LOADER_URL___2___ + \"); }\\n  .jbrowse .jbrowseIconHorizontalResize {\\n    background-position: -209px; }\\n  .jbrowse .jbrowseIconVerticalResize {\\n    background-position: -230px; }\\n  .jbrowse .dojoxTriStateCheckBox, .jbrowse .dojoxTriStateCheckBoxIcon {\\n    background-image: url(\" + ___CSS_LOADER_URL___26___ + \");\\n    /* checkbox sprite image */\\n    background-repeat: no-repeat;\\n    width: 30px;\\n    height: 22px !important;\\n    margin: 0 2px 0 0;\\n    padding: 5px 5px 5px 5px; }\\n  .jbrowse .dj_ie6 .dojoxTriStateCheckBox, .jbrowse .dj_ie6 .dojoxTriStateCheckBoxIcon {\\n    background-image: url(\" + ___CSS_LOADER_URL___26___ + \");\\n    /* checkbox sprite image */ }\\n  .jbrowse .dojoxTriStateCheckBox {\\n    /* unchecked */\\n    background-position: -30px; }\\n  .jbrowse .dojoxTriStateCheckBoxChecked {\\n    /* checked */\\n    background-position: 0px; }\\n  .jbrowse .dojoxTriStateCheckBoxMixed {\\n    /* mixed */\\n    background-position: -90px; }\\n  .jbrowse .dojoxTriStateCheckBoxDisabled {\\n    /* disabled and unchecked */\\n    background-position: -30px; }\\n  .jbrowse .dojoxTriStateCheckBoxCheckedDisabled {\\n    /* disabled and checked */\\n    background-position: 0px; }\\n  .jbrowse .dojoxTriStateCheckBoxMixedDisabled {\\n    /* disabled and mixed */\\n    background-position: -90px; }\\n  .jbrowse .dojoxTriStateCheckBoxHover {\\n    /* hovering over and unchecked */\\n    background-position: -60px; }\\n  .jbrowse .dojoxTriStateCheckBoxCheckedHover {\\n    /* hovering over and checked */\\n    background-position: 0px; }\\n  .jbrowse .dojoxTriStateCheckBoxMixedHover {\\n    /* hovering over and mixed */\\n    background-position: -120px; }\\n  .jbrowse .dijit_a11y .dojoxTriStateCheckBoxHover .dojoxTriStateCheckBoxInner,\\n  .jbrowse .dijit_a11y .dojoxTriStateCheckBoxFocused .dojoxTriStateCheckBoxInner {\\n    /* focused or hovering over */\\n    border: dashed; }\\n  .jbrowse .dijit_a11y .dojoxTriStateCheckBoxHover .dojoxTriStateCheckBoxInner,\\n  .jbrowse .dijit_a11y .dojoxTriStateCheckBoxFocused .dojoxTriStateCheckBoxInner {\\n    /* focused or hovering over */\\n    border: solid; }\\n  .jbrowse .dijit_a11y .dojoxTriStateCheckBoxDisabled .dojoxTriStateCheckBoxInner {\\n    /* focused or hovering over */\\n    opacity: 0.5; }\\n  .jbrowse .dj_ie .dijit_a11y .dojoxTriStateCheckBoxDisabled .dojoxTriStateCheckBoxInner {\\n    /* disabled */ }\\n  .jbrowse .dojoxTriStateCheckBoxInner {\\n    /* inner text */\\n    visibility: hidden;\\n    display: none;\\n    position: absolute;\\n    text-align: center; }\\n  .jbrowse .dijit_a11y .dojoxTriStateCheckBoxInner {\\n    /* inner text */\\n    visibility: visible;\\n    display: block; }\\n  .jbrowse .dojoxTriStateCheckBoxInput {\\n    /* place the actual input on top, but all-but-invisible */\\n    opacity: 0.01;\\n    padding: 0;\\n    margin: 0;\\n    border: 0;\\n    width: 30px;\\n    height: 22px;\\n    background-position: center center;\\n    background-repeat: no-repeat; }\\n  .jbrowse .dj_ie .dojoxTriStateCheckBoxInput {\\n    filter: alpha(opacity=0); }\\n  .jbrowse .combination_track.empty, .jbrowse .combination_track.empty.pinned {\\n    background: #aaa;\\n    background: rgba(0, 0, 0, 0.1); }\\n  .jbrowse .combinationDialog .formulaPreview {\\n    text-align: center;\\n    background-color: white;\\n    border: 1px solid black;\\n    padding: 20px 0;\\n    line-height: 25px; }\\n  .jbrowse .formulaPreview .leaf {\\n    /* background: #A1F0A1; */\\n    /* /\\\\* margin: 0 1px; *\\\\/ */\\n    padding: 0 4px;\\n    text-decoration: underline;\\n    /* border: 1px solid #0DCA0D; */\\n    /* white-space: nowrap; */ }\\n  .jbrowse .formulaPreview .leaf.highlighted {\\n    background-color: #BBB; }\\n  .jbrowse .formulaPreview .op {\\n    /* font-weight: bold; */\\n    /* color: #FFF; */\\n    /* background: #000; */\\n    /* /\\\\* padding: 0 7px; *\\\\/ */\\n    /* z-index: 10; */\\n    /* font-size: 120%; */ }\\n  .jbrowse .jbrowseHierarchicalTrackSelector {\\n    background: #fafafa;\\n    overflow: auto; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector > .header > h2.title {\\n    padding: 7px 0 0.5em 6px;\\n    margin: 0; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector .trackCount {\\n    display: inline-block;\\n    float: right; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector > .header > .textfilterContainer {\\n    padding: 0 5px 5px 5px; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector > .header > .textfilterContainer > .textfilter {\\n    margin: 0; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector .dijitTitlePaneTitle {\\n    padding: 0 4px; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector .dijitTitlePaneTitleFocus:focus {\\n    outline: none; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector label.tracklist-label {\\n    display: block; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector > .uncategorized {\\n    background: white;\\n    padding: 10px;\\n    border: 1px solid #bfbfbf; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector label.tracklist-label:hover {\\n    background: #D2E1F1; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector label.tracklist-label.collapsed {\\n    display: none; }\\n  .jbrowse .jbrowseHierarchicalTrackSelector label.tracklist-label input.check {\\n    position: relative;\\n    top: 2px;\\n    margin: 0 4px; }\\n  .jbrowse .dj_safari .jbrowseHierarchicalTrackSelector label.tracklist-label input.check {\\n    top: 0; }\\n  .jbrowse #hierarchicalTrackPane_splitter {\\n    background: #fafafa;\\n    width: 5px;\\n    border-right: 1px solid #555; }\\n  .jbrowse .dojoxGrid table {\\n    margin: 0; }\\n  .jbrowse .dojoxGridRowSelectorStatusText {\\n    display: none; }\\n  .jbrowse#faceted_tracksel {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    height: 100%;\\n    /* Track grid */\\n    /* Track selector title bar */\\n    /* Facet selection controls */\\n    /* styling specifically for the title of the first facet title, which is 'My Tracks' */\\n    /* style the 'empty' and similar messages that show up in the grid master pane */ }\\n    .jbrowse#faceted_tracksel .active {\\n      -moz-box-shadow: 4px 4px 10px 3px rgba(30, 30, 50, 0.3);\\n      -webkit-box-shadow: 4px 4px 10px 3px rgba(30, 30, 50, 0.3);\\n      box-shadow: 4px 4px 10px 3px rgba(30, 30, 50, 0.3); }\\n    .jbrowse#faceted_tracksel button, .jbrowse#faceted_tracksel input {\\n      font-size: 12px; }\\n    .jbrowse#faceted_tracksel div.mainContainer {\\n      height: 100%;\\n      width: 100%; }\\n    .jbrowse#faceted_tracksel div.mainContainer {\\n      border-right: 2px solid #555;\\n      background: #e9e9e9; }\\n    .jbrowse#faceted_tracksel .dojoxGridCellFocus {\\n      border-color: transparent;\\n      border-color: transparent !important; }\\n    .jbrowse#faceted_tracksel .gridPane .gridControls {\\n      padding: 2px 3px;\\n      font-size: 110%; }\\n    .jbrowse#faceted_tracksel .gridPane .gridControls {\\n      background: #e9e9e9;\\n      border: 1px solid #aaa;\\n      border-right: none; }\\n    .jbrowse#faceted_tracksel .gridPane .gridControls > * {\\n      margin: 2px 3px;\\n      display: inline-block;\\n      vertical-align: middle; }\\n    .jbrowse#faceted_tracksel .gridPane .gridControls button {\\n      height: 2.2em;\\n      margin: 4px;\\n      white-space: nowrap; }\\n    .jbrowse#faceted_tracksel .gridPane .gridControls button > * {\\n      display: inline-block;\\n      vertical-align: middle; }\\n    .jbrowse#faceted_tracksel .gridPane .gridControls button img {\\n      padding: 0 0.4em 0 0; }\\n    .jbrowse#faceted_tracksel .busy .gridControls .busy_indicator {\\n      visibility: visible; }\\n    .jbrowse#faceted_tracksel .gridControls .busy_indicator {\\n      z-index: 20;\\n      visibility: hidden; }\\n    .jbrowse#faceted_tracksel label.textFilterControl img.text_filter_clear {\\n      display: none; }\\n    .jbrowse#faceted_tracksel label.textFilterControl.selected img.text_filter_clear {\\n      display: block; }\\n    .jbrowse#faceted_tracksel label.textFilterControl input {\\n      border-top: 3px solid transparent;\\n      font-weight: bold;\\n      padding: 0.2em; }\\n    .jbrowse#faceted_tracksel label.textFilterControl.selected input {\\n      border-top: 3px solid #396494;\\n      background: #D2E1F1; }\\n    .jbrowse#faceted_tracksel #faceted_tracksel_top {\\n      border-bottom: 1px solid #ccc;\\n      padding: 5px; }\\n    .jbrowse#faceted_tracksel #faceted_tracksel_top {\\n      background: #396494; }\\n    .jbrowse#faceted_tracksel #faceted_tracksel_top .topLink {\\n      color: white; }\\n    .jbrowse#faceted_tracksel #faceted_tracksel_top > * {\\n      display: inline-block;\\n      vertical-align: middle;\\n      margin-left: 5px; }\\n    .jbrowse#faceted_tracksel #faceted_tracksel_top .title {\\n      padding: 0;\\n      width: 185px;\\n      font-weight: bold;\\n      color: white;\\n      font-size: 180%; }\\n    .jbrowse#faceted_tracksel .faceted_tracksel_on_off.tab {\\n      position: absolute;\\n      top: 5em;\\n      left: 100%;\\n      z-index: 5;\\n      padding: 5px 0px;\\n      white-space: nowrap;\\n      cursor: pointer;\\n      -moz-box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3);\\n      -webkit-box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3);\\n      box-shadow: 4px 4px 10px 2px rgba(80, 80, 80, 0.3); }\\n    .jbrowse#faceted_tracksel div.faceted_tracksel_on_off.tab > * {\\n      display: inline-block;\\n      vertical-align: middle;\\n      padding: 0 6px; }\\n    .jbrowse#faceted_tracksel .faceted_tracksel_on_off.tab {\\n      background: #e9e9e9 url(\" + ___CSS_LOADER_URL___3___ + \") top repeat-x;\\n      border: 2px solid #666;\\n      border-top-right-radius: 5px;\\n      border-bottom-right-radius: 5px; }\\n    .jbrowse#faceted_tracksel #faceted_tracksel_top div.topLink {\\n      position: absolute;\\n      top: 0;\\n      right: 0;\\n      background: none;\\n      border: none;\\n      color: white;\\n      padding: 3px 0.6em;\\n      font-weight: bold; }\\n    .jbrowse#faceted_tracksel .facetSelect {\\n      width: 100%;\\n      border-spacing: 0; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue {\\n      padding: 0.1em 0.4em;\\n      cursor: pointer; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue > * {\\n      vertical-align: top; }\\n    .jbrowse#faceted_tracksel .facetSelect .disabled {\\n      color: gray; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue.disabled {\\n      display: none; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue.disabled.selected {\\n      display: table-row; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue:hover {\\n      background: #D2E1F1; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue .count {\\n      padding: 0 0.7em 0 0.4em;\\n      color: #333;\\n      text-align: right; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue .value {\\n      width: 80%; }\\n    .jbrowse#faceted_tracksel .facetSelect .selected {\\n      background: #b1d3f6; }\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue.selected,\\n    .jbrowse#faceted_tracksel .facetSelect .facetValue.selected:hover {\\n      background: #AEC7E3; }\\n    .jbrowse#faceted_tracksel .dijitContentPane {\\n      padding: 0; }\\n    .jbrowse#faceted_tracksel .dijitTitlePane .dijitTitlePaneTitle {\\n      padding: 0; }\\n    .jbrowse#faceted_tracksel .dijitTitlePaneTitleFocus {\\n      position: relative; }\\n    .jbrowse#faceted_tracksel .dijitTitlePaneTitleFocus {\\n      border-top: 3px solid transparent;\\n      padding: 2px 2px 2px 0.6em;\\n      color: #1B3047; }\\n    .jbrowse#faceted_tracksel .dijitOpen .facetTitle {\\n      font-weight: bold;\\n      color: black; }\\n    .jbrowse#faceted_tracksel .activeFacet .facetTitle {\\n      font-weight: bold;\\n      color: black; }\\n    .jbrowse#faceted_tracksel .activeFacet {\\n      border-top: 3px solid #396494;\\n      background-color: #AEC7E3; }\\n    .jbrowse#faceted_tracksel .facetTitle a {\\n      position: absolute;\\n      top: 2px;\\n      right: -4px;\\n      visibility: hidden; }\\n    .jbrowse#faceted_tracksel .activeFacet a.clearFacet {\\n      visibility: visible;\\n      padding: 1px 6px; }\\n    .jbrowse#faceted_tracksel .dijitTitlePaneContentInner {\\n      padding: 0px; }\\n    .jbrowse#faceted_tracksel .myTracks .facetTitle:after {\\n      content: url(\" + ___CSS_LOADER_URL___27___ + \");\\n      margin-left: 7px; }\\n    .jbrowse#faceted_tracksel .myTracks .facetTitle {\\n      color: black;\\n      font-weight: bold;\\n      padding-bottom: 6px; }\\n    .jbrowse#faceted_tracksel .dojoxGridMasterMessages {\\n      font-size: 16px; }\\n  .jbrowse .snap-exon,\\n  .jbrowse .plus-snap-exon,\\n  .jbrowse .minus-snap-exon,\\n  .jbrowse .snap-five_prime_UTR,\\n  .jbrowse .plus-snap-five_prime_UTR,\\n  .jbrowse .minus-snap-five_prime_UTR,\\n  .jbrowse .snap-three_prime_UTR,\\n  .jbrowse .plus-snap-three_prime_UTR,\\n  .jbrowse .minus-snap-three_prime_UTR {\\n    position: absolute;\\n    height: 7px;\\n    background-color: #99FFCC;\\n    border-style: solid;\\n    border-color: #D88;\\n    border-width: 2px 0px 2px 0px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .augustus-exon,\\n  .jbrowse .plus-augustus-exon,\\n  .jbrowse .minus-augustus-exon,\\n  .jbrowse .augustus-five_prime_UTR,\\n  .jbrowse .plus-augustus-five_prime_UTR,\\n  .jbrowse .minus-augustus-five_prime_UTR,\\n  .jbrowse .augustus-three_prime_UTR,\\n  .jbrowse .plus-augustus-three_prime_UTR,\\n  .jbrowse .minus-augustus-three_prime_UTR {\\n    position: absolute;\\n    height: 7px;\\n    background-color: #FFCCFF;\\n    border-style: solid;\\n    border-color: #D88;\\n    border-width: 2px 0px 2px 0px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .genemark-exon,\\n  .jbrowse .plus-genemark-exon,\\n  .jbrowse .minus-genemark-exon,\\n  .jbrowse .genemark-five_prime_UTR,\\n  .jbrowse .plus-genemark-five_prime_UTR,\\n  .jbrowse .minus-genemark-five_prime_UTR,\\n  .jbrowse .genemark-three_prime_UTR,\\n  .jbrowse .plus-genemark-three_prime_UTR,\\n  .jbrowse .minus-genemark-three_prime_UTR {\\n    position: absolute;\\n    height: 7px;\\n    background-color: #679B68;\\n    border-style: solid;\\n    border-color: #D88;\\n    border-width: 2px 0px 2px 0px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .fgenesh-exon,\\n  .jbrowse .plus-fgenesh-exon,\\n  .jbrowse .minus-fgenesh-exon,\\n  .jbrowse .fgenesh-five_prime_UTR,\\n  .jbrowse .plus-fgenesh-five_prime_UTR,\\n  .jbrowse .minus-fgenesh-five_prime_UTR,\\n  .jbrowse .fgenesh-three_prime_UTR,\\n  .jbrowse .plus-fgenesh-three_prime_UTR,\\n  .jbrowse .minus-fgenesh-three_prime_UTR {\\n    position: absolute;\\n    height: 7px;\\n    background-color: #FF99FF;\\n    border-style: solid;\\n    border-color: #D88;\\n    border-width: 2px 0px 2px 0px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .protein2genome_part,\\n  .jbrowse .plus-protein2genome_part,\\n  .jbrowse .minus-protein2genome_part {\\n    position: absolute;\\n    height: 4px;\\n    margin-top: -2px;\\n    background-color: #FFFF00;\\n    border-style: solid;\\n    border-color: #6E6E6E;\\n    border-width: 1px 1px 1px 1px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .blastn_part,\\n  .jbrowse .plus-blastn_part,\\n  .jbrowse .minus-blastn_part {\\n    position: absolute;\\n    height: 4px;\\n    margin-top: -2px;\\n    background-color: #66CC00;\\n    border-style: solid;\\n    border-color: #6E6E6E;\\n    border-width: 1px 1px 1px 1px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .blastx_part,\\n  .jbrowse .plus-blastx_part,\\n  .jbrowse .minus-blastx_part {\\n    position: absolute;\\n    height: 4px;\\n    margin-top: -2px;\\n    background-color: #FF00FF;\\n    border-style: solid;\\n    border-color: #6E6E6E;\\n    border-width: 1px 1px 1px 1px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .tblastx_part,\\n  .jbrowse .plus-tblastx_part,\\n  .jbrowse .minus-tblastx_part {\\n    position: absolute;\\n    height: 4px;\\n    margin-top: -2px;\\n    background-color: #663366;\\n    border-style: solid;\\n    border-color: #6E6E6E;\\n    border-width: 1px 1px 1px 1px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .est2genome_part,\\n  .jbrowse .plus-est2genome_part,\\n  .jbrowse .minus-est2genome_part {\\n    position: absolute;\\n    height: 4px;\\n    margin-top: -2px;\\n    background-color: #FAFAD2;\\n    border-style: solid;\\n    border-color: #6E6E6E;\\n    border-width: 1px 1px 1px 1px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .repeat_part,\\n  .jbrowse .plus-repeat_part,\\n  .jbrowse .minus-repeat_part {\\n    position: absolute;\\n    height: 4px;\\n    margin-top: -2px;\\n    background-color: #FF0000;\\n    border-style: solid;\\n    border-color: #6E6E6E;\\n    border-width: 1px 1px 1px 1px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n  .jbrowse .cdna2genome_part,\\n  .jbrowse .plus-cdna2genome_part,\\n  .jbrowse .minus-cdna2genome_part {\\n    position: absolute;\\n    height: 4px;\\n    margin-top: -2px;\\n    background-color: #8C468C;\\n    border-style: solid;\\n    border-color: #6E6E6E;\\n    border-width: 1px 1px 1px 1px;\\n    z-index: 8;\\n    min-width: 1px;\\n    cursor: pointer; }\\n\", \"\"]);\n\n\n\n//# sourceURL=webpack:///./css/genome.scss?./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js");

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/loaders/dojo/loaderProxy/index.js?loader=dojo%2Fquery&name=css2!./":
/*!*************************************************************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/loaders/dojo/loaderProxy?loader=dojo%2Fquery&name=css2 ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"),__webpack_require__(/*! ./node_modules/dojo-webpack-plugin/loaders/dojo/runner.js */ \"./node_modules/dojo-webpack-plugin/loaders/dojo/runner.js\"),__webpack_require__(/*! ./node_modules/dojo-webpack-plugin/lib/NoModule.js */ \"./node_modules/dojo-webpack-plugin/lib/NoModule.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(loader, runner) {\n   return runner(loader, \"css2\", __webpack_require__.dj.c(), false);\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./node_modules/dojo-webpack-plugin/loaders/dojo/loaderProxy?");

/***/ }),

/***/ "./node_modules/style-loader/index.js!./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./css/genome.scss":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader!./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./css/genome.scss ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!../node_modules/sass-loader/lib/loader.js!./genome.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./css/genome.scss\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./css/genome.scss?./node_modules/style-loader!./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js");

/***/ }),

/***/ "./plugins/CategoryUrl/js/main.js":
/*!****************************************!*\
  !*** ./plugins/CategoryUrl/js/main.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* \n * CategoryURL - JBrowse plugin\n * \n * Add URL parameter \"cat\" to specifiy a category of tracks to display.\n * All tracks with the given category will be displayed.\n * \n * Usage: http://myurl.org....&cat=abc\n * Result: all tracts with category \"abc\" will be displayed.\n * \n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, JBrowsePlugin, Util) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            console.log(\"plugin: CategoryUrl\");\n\n            var thisB = this;\n\n            // intercept browser.showTracks\n            this.browser.oldShowTracks = this.browser.showTracks;\n\n            this.browser.showTracks = function (tracksToShow) {\n                //console.log(\"showTracks() intercepted!\");\n                //console.log(tracksToShow);\n                var catCount = 0;\n                var tracks = thisB.browser.config.tracks;\n\n                var cat = thisB.getUrlParam(\"cat\");\n                if (cat != null) {\n                    //console.log(\"has cat=\");\n                    //console.dir (cat);\n                    var catlist = cat.split(\"/\");\n                    for (var i = 0; i < catlist.length; i++) {\n                        catlist[i] = catlist[i].replace(/^[ ]+|[ ]+$/g, '');\n                    } //trim leading/trailing spaces\n                    //console.dir(catlist);\n                    catCount = catlist.length;\n                }\n                // if catCount > 1, it means that cat= was define in url\n                if (catCount) {\n                    // traverse all tracks and display the ones that match\n                    for (var i = 0; i < tracks.length; i++) {\n                        //console.log(\"track \"+i+\" (\"+tracks[i].category+\") \"+tracks[i].label);\n\n                        var t_catlist = [];\n                        var t_catCount = 0;\n\n                        // handle track.metadata.category\n                        if (typeof tracks[i].metadata !== 'undefined' && typeof tracks[i].metadata.category !== 'undefined') {\n                            // separate the category / sub categories \n                            t_catlist = tracks[i].metadata.category.split(\"/\");\n                            t_catCount = t_catlist.length;\n                        }\n\n                        // handle track.category\n                        if (typeof tracks[i].category !== 'undefined') {\n                            // separate the category / sub categories \n                            t_catlist = tracks[i].category.split(\"/\");\n                            t_catCount = t_catlist.length;\n                        }\n\n                        if (catCount <= t_catCount) {\n\n                            for (var j = 0; j < t_catlist.length; j++) {\n                                t_catlist[j] = t_catlist[j].replace(/^[ ]+|[ ]+$/g, '');\n                            } //trim leading/trailing spaces\n\n                            // if any of the category or subcategories do not match, set the match flag to false\n                            var match = true;\n\n                            for (var j = 0; j < catCount; j++) {\n                                if (catlist[j] != t_catlist[j]) match = false;\n                            }\n\n                            // if there's a match, show the track\n                            if (match == true) {\n                                //console.log(\"match!\")\n                                tracksToShow.push(tracks[i].label);\n                            }\n                        }\n                    }\n                    // eliminate duplicate tracks\n                    tracksToShow = Util.uniq(tracksToShow);\n                }\n                //console.log(tracksToShow);\n\n                // call the original showTracks() function\n                thisB.browser.oldShowTracks(tracksToShow);\n            };\n        },\n\n        //value = getUrlParam('q', 'hxxp://example.com/?q=abc')\n        // returns null if not found\n        getUrlParam: function getUrlParam(name, url) {\n            if (!url) url = window.location.href;\n            name = name.replace(/[\\[]/, \"\\\\\\[\").replace(/[\\]]/, \"\\\\\\]\");\n            var regexS = \"[\\\\?&]\" + name + \"=([^&#]*)\";\n            var regex = new RegExp(regexS);\n            var results = regex.exec(url);\n            return results == null ? null : decodeURIComponent(results[1]);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/CategoryUrl/js/main.js?");

/***/ }),

/***/ "./plugins/DebugEvents/js/main.js":
/*!****************************************!*\
  !*** ./plugins/DebugEvents/js/main.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n    DebugEvents - log Publish and Milestone events in console\n    A JBrowse plugin.\n    Created on : Aug 26, 2015, 1:31:00 PM\n    Author     : EY\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            console.log(\"plugin DebugEvents constructor\");\n\n            var thisB = this;\n\n            this.browser.afterMilestone('completely initialized', function () {\n                console.log(\"Milestone: completely initialized\");\n            });\n            this.browser.afterMilestone('initPlugins', function () {\n                console.log(\"Milestone: initPlugins\");\n            });\n            this.browser.afterMilestone('initView', function () {\n                console.log(\"Milestone: initView\");\n            });\n            this.browser.afterMilestone('loadRefSeqs', function () {\n                console.log(\"Milestone: loadRefSeqs\");\n            });\n            this.browser.afterMilestone('loadUserCSS', function () {\n                console.log(\"Milestone: loadUserCSS\");\n            });\n            this.browser.afterMilestone('loadNames', function () {\n                console.log(\"Milestone: loadNames\");\n            });\n            this.browser.afterMilestone('loadConfig', function () {\n                console.log(\"Milestone: loadConfig\");\n            });\n            this.browser.afterMilestone('initTrackMetadata', function () {\n                console.log(\"Milestone: initTrackMetadata\");\n            });\n            this.browser.afterMilestone('createTrack', function () {\n                console.log(\"Milestone: createTrack\");\n            });\n\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/new\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/new\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/show\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/show\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/c/tracks/show\", function (data) {\n                console.log(\"Event: /jbrowse/v1/c/tracks/show\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/hide\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/hide\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/c/tracks/hide\", function (data) {\n                console.log(\"Event: /jbrowse/v1/c/tracks/hide\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/hide\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/hide\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/c/tracks/new\", function (data) {\n                console.log(\"Event: /jbrowse/v1/c/tracks/new\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/new\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/new\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/replace\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/replace\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/c/tracks/replace\", function (data) {\n                console.log(\"Event: /jbrowse/v1/c/tracks/replace\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/replace\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/replace\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/delete\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/delete\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/c/tracks/delete\", function (data) {\n                console.log(\"Event: /jbrowse/v1/c/tracks/delete\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/delete\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/delete\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/pin\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/pin\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/c/tracks/pin\", function (data) {\n                console.log(\"Event: /jbrowse/v1/c/tracks/pin\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/pin\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/pin\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/v/tracks/unpin\", function (data) {\n                console.log(\"Event: /jbrowse/v1/v/tracks/unpin\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/c/tracks/unpin\", function (data) {\n                console.log(\"Event: /jbrowse/v1/c/tracks/unpin\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/unpin\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/unpin\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/visibleChanged\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/visibleChanged\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/navigate\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/navigate\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/globalHighlightChanged\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/globalHighlightChanged\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/redraw\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/redraw\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/redrawFinished\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/redrawFinished\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/focus\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/focus\", data);\n            });\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/unfocus\", function (data) {\n                console.log(\"Event: /jbrowse/v1/n/tracks/unfocus\", data);\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/DebugEvents/js/main.js?");

/***/ }),

/***/ "./plugins/HideTrackLabels/js/main.js":
/*!********************************************!*\
  !*** ./plugins/HideTrackLabels/js/main.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\nHideTrackLabels JBrowse plugin CSS\n*/\n/*\n    Created on : Jul 15, 2015, 7:19:50 PM\n    Author     : EY\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dojo/fx */ \"./node_modules/dojo/fx.js\"), __webpack_require__(/*! dojo/dom */ \"./node_modules/dojo/dom.js\"), __webpack_require__(/*! dojo/dom-style */ \"./node_modules/dojo/dom-style.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! dojo/dom-geometry */ \"./node_modules/dojo/dom-geometry.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, domConstruct, dijitButton, coreFx, dom, style, on, query, domGeom, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            console.log(\"plugin HideTracksButton constructor\");\n\n            var baseUrl = this._defaultConfig().baseUrl;\n            var thisB = this;\n            var queryParams = dojo.queryToObject(window.location.search.slice(1));\n\n            // create the hide/show button after genome view initialization\n            this.browser.afterMilestone('initView', function () {\n\n                var navBox = dojo.byId(\"navbox\");\n\n                thisB.browser.hideTitlesButton = new dijitButton({\n                    title: \"Hide/Show Track Titles\",\n                    id: \"hidetitles-btn\",\n                    width: \"24px\",\n                    onClick: dojo.hitch(thisB, function (event) {\n                        thisB.showTrackLabels(\"toggle\");\n                        dojo.stopEvent(event);\n                    })\n                }, dojo.create('button', {}, navBox));\n\n                if (queryParams.tracklabels == 0 || thisB.browser.config.show_tracklabels == 0) {\n                    query('.track-label').style('visibility', 'hidden');\n                    dojo.attr(thisB.browser.hideTitlesButton.domNode, \"hidden-titles\", \"\");\n                }\n            });\n            if (thisB.browser.config.show_tracklabels == 0) {\n                dojo.subscribe(\"/jbrowse/v1/n/tracks/redraw\", function (data) {\n                    thisB.showTrackLabels(\"hide\");\n                });\n            }\n            dojo.subscribe(\"/jbrowse/v1/n/tracks/redraw\", function (data) {\n                thisB.showTrackLabels(\"hide-if\");\n            });\n        },\n\n        /* show or hide track labels\n         * showTrackLabels(param)\n         * @param {string} function \"show\", \"hide\", \"toggle\", or \"hide-if\"\n         * \"hide-if\" rehides if already hidden.\n         * @returns {undefined}\n         */\n        showTrackLabels: function showTrackLabels(fn) {\n            var direction = 1;\n            var button = dom.byId(\"hidetitles-btn\");\n\n            if (fn == \"show\") {\n                if (button) dojo.removeAttr(button, \"hidden-titles\");\n                direction = 1;\n            }\n            if (fn == \"hide\") {\n                if (button) dojo.attr(button, \"hidden-titles\", \"\");\n                direction = -1;\n            }\n            if (fn == \"hide-if\") {\n                if (button && dojo.hasAttr(button, \"hidden-titles\")) direction = -1;else return;\n            }\n\n            if (fn == \"toggle\") {\n                if (button) {\n                    if (dojo.hasAttr(button, \"hidden-titles\")) {\n                        // if hidden, show\n                        dojo.removeAttr(button, \"hidden-titles\");\n                        direction = 1;\n                    } else {\n                        dojo.attr(button, \"hidden-titles\", \"\"); // if shown, hide\n                        direction = -1;\n                    }\n                }\n            }\n            // protect Hide button from clicks during animation\n            if (button) dojo.attr(button, \"disabled\", \"\");\n            setTimeout(function () {\n                if (button) dojo.removeAttr(button, \"disabled\");\n            }, 200);\n\n            if (direction == -1) {\n                setTimeout(function () {\n                    query('.track-label').style('visibility', 'hidden');\n                }, 200);\n            } else {\n                query('.track-label').style('visibility', 'visible');\n            }\n            // slide em\n            query(\".track-label\").forEach(function (node, index, arr) {\n                var w = domGeom.getMarginBox(node).w;\n                coreFx.slideTo({\n                    node: node,\n                    duration: 200,\n                    top: domGeom.getMarginBox(node).t.toString(),\n                    left: (domGeom.getMarginBox(node).l + w * direction).toString(),\n                    unit: \"px\"\n                }).play();\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/HideTrackLabels/js/main.js?");

/***/ }),

/***/ "./plugins/InteractivePeakAnnotator/js/Store/SeqFeature/Features.js":
/*!**************************************************************************!*\
  !*** ./plugins/InteractivePeakAnnotator/js/Store/SeqFeature/Features.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, SimpleFeature, SeqFeatureStore) {\n    return declare([SeqFeatureStore], {\n        getFeatures: function getFeatures(query, featureCallback, finishedCallback) {\n            var features = localStorage.getItem('ipaFeatures');\n            if (features) {\n                features = JSON.parse(features);\n                features.forEach(function (data) {\n                    featureCallback(new SimpleFeature({ data: data }));\n                });\n                finishedCallback();\n            }\n        },\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.blob.url\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/InteractivePeakAnnotator/js/Store/SeqFeature/Features.js?");

/***/ }),

/***/ "./plugins/InteractivePeakAnnotator/js/View/Track/MultiXYPlot.js":
/*!***********************************************************************!*\
  !*** ./plugins/InteractivePeakAnnotator/js/View/Track/MultiXYPlot.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! WiggleHighlighter/View/Track/MultiXYPlot */ \"./plugins/WiggleHighlighter/js/View/Track/MultiXYPlot.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, XYPlot) {\n    return declare([XYPlot], {\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                onHighlightClick: function onHighlightClick(feature, track) {\n                    var features = JSON.parse(localStorage.getItem('ipaFeatures'));\n                    var states = ['unknown', 'peak', 'nopeak'];\n                    features.forEach(function (f) {\n                        if (f.ref === feature.get('ref') && f.start === feature.get('start') && f.end === feature.get('end')) {\n                            if (f[track.name]) {\n                                f[track.name] = (f[track.name] + 1) % states.length;\n                            } else {\n                                f[track.name] = 1;\n                            }\n                        }\n                    });\n                    localStorage.setItem('ipaFeatures', JSON.stringify(features));\n                    track.redraw();\n                },\n                highlightColor: function highlightColor(feature, track) {\n                    var states = { 0: '#f005', 1: '#0f05', 2: '#ff05' };\n                    return states[feature.get(track.name) || 0];\n                },\n                indicatorColor: function indicatorColor(feature, track) {\n                    var states = { 0: '#f00', 1: '#0f0', 2: '#ff0' };\n                    return states[feature.get(track.name) || 0];\n                }\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/InteractivePeakAnnotator/js/View/Track/MultiXYPlot.js?");

/***/ }),

/***/ "./plugins/InteractivePeakAnnotator/js/View/Track/XYPlot.js":
/*!******************************************************************!*\
  !*** ./plugins/InteractivePeakAnnotator/js/View/Track/XYPlot.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! WiggleHighlighter/View/Track/XYPlot */ \"./plugins/WiggleHighlighter/js/View/Track/XYPlot.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, XYPlot) {\n    return declare([XYPlot], {\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                onHighlightClick: function onHighlightClick(feature, track) {\n                    var features = JSON.parse(localStorage.getItem('ipaFeatures'));\n                    var states = ['unknown', 'peak', 'nopeak'];\n                    features.forEach(function (f) {\n                        if (f.ref === feature.get('ref') && f.start === feature.get('start') && f.end === feature.get('end')) {\n                            if (f[track.name]) {\n                                f[track.name] = (f[track.name] + 1) % states.length;\n                            } else {\n                                f[track.name] = 1;\n                            }\n                        }\n                    });\n                    localStorage.setItem('ipaFeatures', JSON.stringify(features));\n                    track.redraw();\n                },\n                highlightColor: function highlightColor(feature, track) {\n                    var states = { 0: '#f005', 1: '#0f05', 2: '#ff05' };\n                    return states[feature.get(track.name) || 0];\n                },\n                indicatorColor: function indicatorColor(feature, track) {\n                    var states = { 0: '#f00', 1: '#0f0', 2: '#ff0' };\n                    return states[feature.get(track.name) || 0];\n                }\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/InteractivePeakAnnotator/js/View/Track/XYPlot.js?");

/***/ }),

/***/ "./plugins/InteractivePeakAnnotator/js/main.js":
/*!*****************************************************!*\
  !*** ./plugins/InteractivePeakAnnotator/js/main.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            console.log('InteractivePeakAnnotator plugin starting');\n            dojo.subscribe('/jbrowse/v1/n/globalHighlightChanged', function (data) {\n                console.log(data);\n                if (data.length) {\n                    var region = data[0];\n                    var regions = JSON.parse(localStorage.getItem('ipaFeatures') || '[]');\n                    regions.push(region);\n                    localStorage.setItem('ipaFeatures', JSON.stringify(regions));\n                    args.browser.clearHighlight();\n                }\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/InteractivePeakAnnotator/js/main.js?");

/***/ }),

/***/ "./plugins/MultiBigWig/js/Store/SeqFeature/MultiBigWig.js":
/*!****************************************************************!*\
  !*** ./plugins/MultiBigWig/js/Store/SeqFeature/MultiBigWig.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/BigWig */ \"./src/JBrowse/Store/SeqFeature/BigWig.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, all, SeqFeatureStore, BigWig) {\n    return declare([SeqFeatureStore], {\n        constructor: function constructor(args) {\n            var thisB = this;\n            var alreadySeen = {};\n            this.stores = array.map(args.urlTemplates, function (urlTemplate) {\n                if (lang.isObject(urlTemplate)) {\n                    var _name = urlTemplate.name || urlTemplate.url.substr(urlTemplate.url.lastIndexOf('/') + 1);\n                    if (alreadySeen[_name]) {\n                        throw new Error('duplicate name found, please check configuration');\n                    }\n                    alreadySeen[_name] = true;\n\n                    var _c = Object.assign(args, urlTemplate, {\n                        urlTemplate: urlTemplate.url,\n                        name: _name\n                    });\n                    if (urlTemplate.storeClass) {\n                        var CLASS = dojo.global.require(urlTemplate.storeClass);\n                        return new CLASS(Object.assign(_c, { config: _c }));\n                    }\n                    return new BigWig(Object.assign(_c, { config: _c }));\n                }\n                var name = urlTemplate.substr(urlTemplate.lastIndexOf('/') + 1);\n                if (alreadySeen[name]) {\n                    throw new Error('duplicate name found, please check configuration');\n                }\n                alreadySeen[name] = true;\n                var c = Object.assign(args, {\n                    urlTemplate: urlTemplate,\n                    name: urlTemplate.substr(urlTemplate.lastIndexOf('/') + 1)\n                });\n                return new BigWig(Object.assign(c, { config: c }));\n            });\n        },\n\n        getFeatures: function getFeatures(query, featureCallback, endCallback, errorCallback) {\n            var thisB = this;\n            var finished = 0;\n            var finishCallback = function finishCallback() {\n                if (thisB.stores.length === ++finished) {\n                    endCallback();\n                }\n            };\n            array.forEach(this.stores, function (store) {\n                var f = function (name) {\n                    return function (feat) {\n                        if (!feat.data.source) {\n                            feat.data.source = name;\n                        }\n                        featureCallback(feat);\n                    };\n                }(store.name);\n                store.getFeatures(query, f, finishCallback, errorCallback);\n            });\n        },\n\n        getIndividualStats: function getIndividualStats(successCallback, errorCallback) {\n            var thisB = this;\n            var finished = 0;\n            var stats = {};\n\n            array.forEach(this.stores, function (store) {\n                store.getGlobalStats(function (name) {\n                    return function (t) {\n                        stats[name] = t;\n                        if (thisB.stores.length === ++finished) {\n                            successCallback(stats);\n                        }\n                    };\n                }(store.name), errorCallback);\n            });\n        },\n        getGlobalStats: function getGlobalStats(successCallback, errorCallback) {\n            var thisB = this;\n            var finished = 0;\n            var stats = { scoreMin: 100000000, scoreMax: -10000000 };\n\n            var finishCallback = function finishCallback(t) {\n                if (t.scoreMin < stats.scoreMin) {\n                    stats.scoreMin = t.scoreMin;\n                }\n                if (t.scoreMax > stats.scoreMax) {\n                    stats.scoreMax = t.scoreMax;\n                }\n                if (thisB.stores.length === ++finished) {\n                    successCallback(stats);\n                }\n            };\n            array.forEach(this.stores, function (store) {\n                store.getGlobalStats(finishCallback, errorCallback);\n            });\n        },\n        getRegionStats: function getRegionStats(query, successCallback, errorCallback) {\n            var thisB = this;\n            var finished = 0;\n            var stats = { scoreMin: 100000000, scoreMax: -10000000 };\n\n            var finishCallback = function finishCallback(t) {\n                if (!thisB.config.useStdDev) {\n                    if (t.scoreMin < stats.scoreMin) {\n                        stats.scoreMin = t.scoreMin;\n                    }\n                    if (t.scoreMax > stats.scoreMax) {\n                        stats.scoreMax = t.scoreMax;\n                    }\n                } else {\n                    var newMax = t.scoreMean + 3 * t.scoreStdDev;\n                    if (newMax > stats.scoreMax) {\n                        stats.scoreMax = newMax;\n                    }\n                    stats.scoreMin = 0;\n                }\n                if (thisB.stores.length === ++finished) {\n                    successCallback(stats);\n                }\n            };\n            array.forEach(this.stores, function (store) {\n                store.getRegionStats(query, finishCallback, errorCallback);\n            });\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplates: this.config.urlTemplates\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/MultiBigWig/js/Store/SeqFeature/MultiBigWig.js?");

/***/ }),

/***/ "./plugins/MultiBigWig/js/View/Dialog/MaxScoreDialog.js":
/*!**************************************************************!*\
  !*** ./plugins/MultiBigWig/js/View/Dialog/MaxScoreDialog.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! dijit/form/NumberSpinner */ \"./node_modules/dijit/form/NumberSpinner.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, on, focus, NumberSpinner, Button, ActionBarDialog) {\n    return declare(ActionBarDialog, {\n        title: 'Set max score',\n\n        constructor: function constructor(args) {\n            this.maxScore = args.maxScore || 0;\n            this.browser = args.browser;\n            this.setCallback = args.setCallback || function () {};\n            this.cancelCallback = args.cancelCallback || function () {};\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            new Button({\n                label: 'OK',\n                onClick: dojo.hitch(this, function () {\n                    var height = +this.maxScoreSpinner.getValue();\n                    if (isNaN(height)) {\n                        return;\n                    }\n                    this.setCallback && this.setCallback(height);\n                    this.hide();\n                })\n            }).placeAt(actionBar);\n\n            new Button({\n                label: 'Cancel',\n                onClick: dojo.hitch(this, function () {\n                    this.cancelCallback && this.cancelCallback();\n                    this.hide();\n                })\n            }).placeAt(actionBar);\n        },\n\n        show: function show() /* callback */{\n            dojo.addClass(this.domNode, 'maxScoreDialog');\n\n            this.maxScoreSpinner = new NumberSpinner({\n                value: this.maxScore,\n                smallDelta: 2\n            });\n\n            this.set('content', [dom.create('label', { 'for': 'read_depth', innerHTML: '' }), this.maxScoreSpinner.domNode, dom.create('span', { innerHTML: ' max score' })]);\n\n            this.inherited(arguments);\n        },\n\n        hide: function hide() {\n            this.inherited(arguments);\n            window.setTimeout(dojo.hitch(this, 'destroyRecursive'), 500);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/MultiBigWig/js/View/Dialog/MaxScoreDialog.js?");

/***/ }),

/***/ "./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiDensity.js":
/*!***********************************************************************!*\
  !*** ./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiDensity.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/Color */ \"./node_modules/dojo/_base/Color.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! ../MultiWiggleBase */ \"./plugins/MultiBigWig/js/View/Track/MultiWiggleBase.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! dijit/Tooltip */ \"./node_modules/dijit/Tooltip.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Color, on, MultiWiggleBase, Util, Tooltip) {\n    return declare(MultiWiggleBase, {\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                maxExportSpan: 500000,\n                autoscale: 'local',\n                style: {\n                    pos_color: '#00f',\n                    neg_color: '#f00',\n                    bg_color: 'rgba(230,230,230,0.6)',\n                    clip_marker_color: 'black',\n                    height: 100\n                }\n            });\n        },\n        _drawFeatures: function _drawFeatures(scale, leftBase, rightBase, block, canvas, pixels, dataScale) {\n            var thisB = this;\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n            var featureColor = typeof this.config.style.color === 'function' ? this.config.style.color : function () {\n                // default color function uses conf variables\n                var disableClipMarkers = thisB.config.disable_clip_markers;\n                var normOrigin = dataScale.normalize(dataScale.origin);\n\n                return function (p, n) {\n                    var feature = p.feat;\n                    var ret;\n                    // not clipped\n                    if (disableClipMarkers || n <= 1 && n >= 0) {\n                        ret = Color.blendColors(new Color(thisB.getConfForFeature('style.bg_color', feature)), new Color(thisB.getConfForFeature(n >= normOrigin ? 'style.pos_color' : 'style.neg_color', feature)), Math.abs(n - normOrigin)).toString();\n                    } else {\n                        ret = n > 1 ? thisB.getConfForFeature('style.pos_color', feature) : thisB.getConfForFeature('style.neg_color', feature);\n                    }\n                    return ret;\n                };\n            }();\n\n            var resolution = Util.getResolution(context, this.browser.config.highResolutionMode);\n            var kheight = canvasHeight / (this.labels.length * resolution);\n\n            array.forEach(pixels, function (p, i) {\n                if (p) {\n                    array.forEach(p, function (pi, j) {\n                        if (pi) {\n                            var score = pi.score;\n                            var n = dataScale.normalize(score);\n                            context.fillStyle = '' + featureColor(pi, n);\n                            thisB._fillRectMod(context, i, j * kheight, 1, kheight);\n                        }\n                    });\n                }\n            });\n        },\n        makeTrackLabel: function makeTrackLabel() {\n            var canvasHeight = this.config.style.height;\n            var kheight = canvasHeight / this.labels.length;\n            var thisB = this;\n            var c = this.config;\n            this.inherited(arguments);\n            if (this.config.showLabels || this.config.showTooltips) {\n                this.sublabels = array.map(this.labels, function (elt) {\n                    var lw = thisB.config.labelWidth ? thisB.config.labelWidth + 'px' : null;\n\n                    var htmlnode = dojo.create('div', {\n                        className: 'track-sublabel',\n                        id: thisB.config.label + '_' + elt.name,\n                        style: {\n                            position: 'absolute',\n                            height: kheight - 1 + 'px',\n                            width: thisB.config.showLabels ? lw : '10px',\n                            font: thisB.config.labelFont,\n                            backgroundColor: elt.color\n                        },\n                        innerHTML: thisB.config.showLabels ? elt.name : ''\n                    }, thisB.div);\n\n                    on(htmlnode, c.clickTooltips ? 'click' : 'mouseover', function () {\n                        Tooltip.show(elt.name + '<br />' + (elt.description || ''), htmlnode);\n                    });\n                    on(htmlnode, 'mouseleave', function () {\n                        Tooltip.hide(htmlnode);\n                    });\n\n                    return htmlnode;\n                });\n            }\n        },\n        updateStaticElements: function updateStaticElements( /** Object*/coords) {\n            this.inherited(arguments);\n            var height = this.config.style.height - 2;\n            if (this.sublabels && 'x' in coords) {\n                var len = this.sublabels.length;\n                array.forEach(this.sublabels, function (sublabel, i) {\n                    sublabel.style.left = coords.x + 'px';\n                    sublabel.style.top = i * height / len + 'px';\n                }, this);\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiDensity.js?");

/***/ }),

/***/ "./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiXYPlot.js":
/*!**********************************************************************!*\
  !*** ./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiXYPlot.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/Color */ \"./node_modules/dojo/_base/Color.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! ../MultiWiggleBase */ \"./plugins/MultiBigWig/js/View/Track/MultiWiggleBase.js\"), __webpack_require__(/*! JBrowse/View/Track/_YScaleMixin */ \"./src/JBrowse/View/Track/_YScaleMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/Track/Wiggle/_Scale */ \"./src/JBrowse/View/Track/Wiggle/_Scale.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, Color, on, WiggleBase, YScaleMixin, Util, Scale) {\n    return declare([WiggleBase, YScaleMixin], {\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(lang.clone(this.inherited(arguments)), {\n                autoscale: 'local',\n                style: {\n                    pos_color: 'blue',\n                    neg_color: 'red',\n                    origin_color: '#888',\n                    variance_band_color: 'rgba(0,0,0,0.3)'\n                }\n            });\n        },\n        _getScaling: function _getScaling(viewArgs, successCallback, errorCallback) {\n            if (this.config.normalizeEach) {\n                this.store.getIndividualStats(function (stats) {\n                    Object.keys(stats).forEach(function (key) {\n                        stats[key].normalize = function (val) {\n                            return (val - stats[key].scoreMin) / (stats[key].scoreMax - stats[key].scoreMin);\n                        };\n                    });\n                    stats.compare = function () {\n                        return true;\n                    };\n                    successCallback(stats);\n                }, errorCallback);\n            } else {\n                this._getScalingStats(viewArgs, dojo.hitch(this, function (stats) {\n                    if (!this.lastScaling || !this.lastScaling.sameStats(stats) || this.trackHeightChanged) {\n                        var scaling = new Scale(this.config, stats);\n\n                        // bump minDisplayed to 0 if it is within 0.5% of it\n                        if (Math.abs(scaling.min / scaling.max) < 0.005) {\n                            scaling.min = 0;\n                        }\n\n                        // update our track y-scale to reflect it\n                        this.makeYScale({\n                            fixBounds: true,\n                            min: scaling.min,\n                            max: scaling.max\n                        });\n\n                        // and finally adjust the scaling to match the ruler's scale rounding\n                        scaling.min = this.ruler.scaler.bounds.lower;\n                        scaling.max = this.ruler.scaler.bounds.upper;\n                        scaling.range = scaling.max - scaling.min;\n\n                        this.lastScaling = scaling;\n                        this.trackHeightChanged = false; // reset flag\n                    }\n\n                    successCallback(this.lastScaling);\n                }), errorCallback);\n            }\n        },\n\n        updateStaticElements: function updateStaticElements(coords) {\n            this.inherited(arguments);\n            this.updateYScaleFromViewDimensions(coords);\n        },\n\n        _drawFeatures: function _drawFeatures(scale, leftBase, rightBase, block, canvas, pixels, dataScale) {\n            var thisB = this;\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n\n            var ratio = Util.getResolution(context, this.browser.config.highResolutionMode);\n            var toY;\n            var originY;\n            if (this.config.normalizeEach) {\n                toY = lang.hitch(this, function (val, name) {\n                    return canvasHeight * (1 - dataScale[name].normalize(val)) / ratio;\n                });\n                originY = 1;\n            } else {\n                toY = lang.hitch(this, function (val) {\n                    return canvasHeight * (1 - dataScale.normalize(val)) / ratio;\n                });\n                originY = toY(dataScale.origin);\n            }\n            var initMap = {};\n            array.forEach(pixels[0], function (s) {\n                if (!s) {\n                    return;\n                }\n                var f = s.feat;\n                var source = f.get('source');\n                var score = toY(s.score, source);\n                initMap[source] = score;\n            });\n\n            array.forEach(pixels, function (p, i) {\n                array.forEach(p, function (s) {\n                    if (!s) {\n                        return;\n                    }\n\n                    var f = s.feat;\n                    var source = f.get('source');\n                    var score = toY(s.score, source);\n                    var elt = this.labels.find(function (l) {\n                        return l.name === f.get('source');\n                    });\n                    var color = elt.color;\n                    var height = elt.lineWidth || 1;\n                    var nonCont = elt.nonCont;\n                    if (score <= canvasHeight || score > originY) {\n                        // if the rectangle is visible at all\n                        if (score <= originY) {\n                            // bar goes upward\n                            if (nonCont) {\n                                context.fillStyle = color;\n                                if (elt.fill) {\n                                    height = originY - score + 1;\n                                }\n                                thisB._fillRectMod(context, i, score, 1, height);\n                            } else {\n                                context.strokeStyle = color;\n                                context.lineWidth = height;\n                                context.beginPath();\n                                context.moveTo(i, initMap[source]);\n                                context.lineTo(i + 1, score);\n                                context.stroke();\n                                initMap[source] = score;\n                            }\n                        } else if (nonCont) {\n                            context.fillStyle = color;\n\n                            var top = score - 1;\n                            var heightm = 1;\n                            if (elt.fill) {\n                                top = originY;\n                                heightm = score - originY;\n                            }\n                            thisB._fillRectMod(context, i, top, 1, heightm);\n                        } else {\n                            context.strokeStyle = color;\n                            context.lineWidth = height;\n                            context.beginPath();\n                            context.moveTo(i, initMap[source]);\n                            context.lineTo(i + 1, score);\n                            context.stroke();\n                            initMap[source] = score;\n                        }\n                    }\n                }, this);\n            }, this);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiXYPlot.js?");

/***/ }),

/***/ "./plugins/MultiBigWig/js/View/Track/MultiWiggleBase.js":
/*!**************************************************************!*\
  !*** ./plugins/MultiBigWig/js/View/Track/MultiWiggleBase.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/View/Track/WiggleBase */ \"./src/JBrowse/View/Track/WiggleBase.js\"), __webpack_require__(/*! ../Dialog/MaxScoreDialog */ \"./plugins/MultiBigWig/js/View/Dialog/MaxScoreDialog.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, WiggleBase, MaxScoreDialog) {\n    return declare(WiggleBase, {\n\n        constructor: function constructor(args) {\n            this.labels = args.config.urlTemplates.map(function (f) {\n                if (lang.isObject(f)) {\n                    if (f.name) {\n                        return f;\n                    }\n\n                    return Object.assign(f, {\n                        name: f.url.substr(f.url.lastIndexOf('/') + 1)\n                    });\n                }\n                return { name: f };\n            });\n            if (args.config.randomizeColors) {\n                array.forEach(this.labels, function (label) {\n                    label.color = '#' + ('000000' + Math.random().toString(16).slice(2, 8).toUpperCase()).slice(-6);\n                }, this);\n            }\n        },\n        _calculatePixelScores: function _calculatePixelScores(canvasWidth, features, featureRects) {\n            var pixelValues = new Array(canvasWidth);\n            array.forEach(features, function (f, i) {\n                var fRect = featureRects[i];\n                var jEnd = fRect.r;\n                var score = f.get('score');\n                var source = f.get('source');\n                for (var k = 0; k < this.labels.length; k++) {\n                    if (this.labels[k].name === source) {\n                        break;\n                    }\n                }\n                for (var j = Math.round(fRect.l); j < jEnd; j++) {\n                    if (!pixelValues[j]) {\n                        pixelValues[j] = new Array(this.labels.length);\n                    }\n                    if (!pixelValues[j][k]) {\n                        pixelValues[j][k] = { score: score, feat: f };\n                    }\n                }\n            }, this);\n\n            return pixelValues;\n        },\n        _trackMenuOptions: function _trackMenuOptions() {\n            var options = this.inherited(arguments);\n            var track = this;\n            options.push({\n                label: 'Autoscale global',\n                onClick: function onClick() {\n                    track.config.autoscale = 'global';\n                    track.browser.publish('/jbrowse/v1/v/tracks/replace', [track.config]);\n                }\n            });\n            options.push({\n                label: 'Autoscale local',\n                onClick: function onClick() {\n                    track.config.autoscale = 'local';\n                    delete track.config.max_score;\n                    track.browser.publish('/jbrowse/v1/v/tracks/replace', [track.config]);\n                }\n            });\n            options.push({\n                label: 'Set max score for global',\n                onClick: function onClick() {\n                    new MaxScoreDialog({\n                        setCallback: function setCallback(filterInt) {\n                            track.config.max_score = filterInt;\n                            track.config.autoscale = 'global';\n                            track.browser.publish('/jbrowse/v1/c/tracks/replace', [track.config]);\n                        },\n                        maxScore: track.config.max_score || 0\n                    }).show();\n                }\n            });\n\n            return options;\n        },\n        _trackDetailsContent: function _trackDetailsContent() {\n            var old = this.inherited(arguments);\n            var ret = '';\n            if (this.config.colorizeAbout) {\n                array.forEach(this.labels, function (elt) {\n                    ret += '<div style=\"display: block; clear:both;\"><div class=\"colorsquare\" style=\"background: ' + elt.color + '\"></div>' + elt.name;\n                }, this);\n            }\n            return old.then(function (txt) {\n                txt.innerHTML += ret;\n                return txt;\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/MultiBigWig/js/View/Track/MultiWiggleBase.js?");

/***/ }),

/***/ "./plugins/MultiBigWig/js/main.js":
/*!****************************************!*\
  !*** ./plugins/MultiBigWig/js/main.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor() /* args */{\n            if (!Array.prototype.find) {\n                // eslint-disable-next-line no-extend-native\n                Object.defineProperty(Array.prototype, 'find', {\n                    value: function value(predicate) {\n                        // 1. Let O be ? ToObject(this value).\n                        if (this === null) {\n                            throw new TypeError('\"this\" is null or not defined');\n                        }\n\n                        var o = Object(this);\n\n                        // 2. Let len be ? ToLength(? Get(O, \"length\")).\n                        var len = o.length >>> 0;\n\n                        // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n                        if (typeof predicate !== 'function') {\n                            throw new TypeError('predicate must be a function');\n                        }\n\n                        // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n                        var thisArg = arguments[1];\n\n                        // 5. Let k be 0.\n                        var k = 0;\n\n                        // 6. Repeat, while k < len\n                        while (k < len) {\n                            // a. Let Pk be ! ToString(k).\n                            // b. Let kValue be ? Get(O, Pk).\n                            // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n                            // d. If testResult is true, return kValue.\n                            var kValue = o[k];\n                            if (predicate.call(thisArg, kValue, k, o)) {\n                                return kValue;\n                            }\n                            // e. Increase k by 1.\n                            k++;\n                        }\n\n                        // 7. Return undefined.\n                        return undefined;\n                    }\n                });\n            }\n            console.log('MultiBigWig plugin starting');\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/MultiBigWig/js/main.js?");

/***/ }),

/***/ "./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Box.js":
/*!****************************************************************!*\
  !*** ./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Box.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Box */ \"./src/JBrowse/View/FeatureGlyph/Box.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, domConstruct, Box) {\n    return declare(Box, {\n        renderBox: function renderBox(context, viewInfo, feature, top, overallHeight, parentFeature, style) {\n            var left = viewInfo.block.bpToX(feature.get('start'));\n            var width = viewInfo.block.bpToX(feature.get('end')) - left;\n\n            style = style || lang.hitch(this, 'getStyle');\n\n            var height = this._getFeatureHeight(viewInfo, feature);\n            if (!height) {\n                return;\n            }\n            if (height != overallHeight) {\n                top += Math.round((overallHeight - height) / 2);\n            }\n\n            var bgcolor = style(feature, 'color');\n            bgcolor = getColorHex(bgcolor);\n\n            var type = feature.get('type');\n\n            if (typeof type !== 'undefined' && type.indexOf('UTR') > -1) {\n                context.fillStyle = '#fdfdfd';\n                // this.colorShift(bgcolor,4.5);\n            } else {\n                if (this.config.gradient) {\n                    bgcolor = this.colorShift(bgcolor, 0);\n\n                    var grd = context.createLinearGradient(left, top, left, top + height);\n\n                    // Add colors\n                    grd.addColorStop(0.000, bgcolor);\n                    grd.addColorStop(0.500, this.colorShift(bgcolor, 2.5));\n                    grd.addColorStop(0.999, bgcolor);\n\n                    context.fillStyle = grd;\n                } else {\n                    context.fillStyle = bgcolor;\n                }\n            }\n\n            if (bgcolor) {\n                context.fillRect(left, top, Math.max(1, width), height);\n            } else {\n                context.clearRect(left, top, Math.max(1, width), height);\n            }\n\n            var borderColor, lineWidth;\n            if (typeof type !== 'undefined' && type.indexOf('UTR') > -1) {\n                lineWidth = 1;\n                borderColor = '#b0b0b0';\n                if (width > 3) {\n                    context.lineWidth = lineWidth;\n                    context.strokeStyle = bgcolor; // borderColor;\n                    context.strokeRect(left + lineWidth / 2, top + lineWidth / 2, width - lineWidth, height - lineWidth);\n                }\n            } else if ((borderColor = style(feature, 'borderColor')) && (lineWidth = style(feature, 'borderWidth'))) {\n                if (width > 3) {\n                    context.lineWidth = lineWidth;\n                    context.strokeStyle = borderColor;\n\n                    // need to stroke a smaller rectangle to remain within\n                    // the bounds of the feature's overall height and\n                    // width, because of the way stroking is done in\n                    // canvas.  thus the +0.5 and -1 business.\n                    context.strokeRect(left + lineWidth / 2, top + lineWidth / 2, width - lineWidth, height - lineWidth);\n                } else {\n                    context.globalAlpha = lineWidth * 2 / width;\n                    context.fillStyle = borderColor;\n                    context.fillRect(left, top, Math.max(1, width), height);\n                    context.globalAlpha = 1;\n                }\n            }\n        },\n        /**\n         * Given color string in #rrggbb format, shift the color by shift %  ( i.e. .20 is 20% brighter, -.30 is 30% darker.\n         * The new string is returned.\n         * If color is not in #rrggbb format, just return the original value.\n         */\n        colorShift: function colorShift(color, shift) {\n            if (color.substring(0, 1) !== '#' || color.length !== 7) return color;\n\n            var rstr = color.substring(1, 3);\n            var gstr = color.substring(3, 5);\n            var bstr = color.substring(5, 7);\n\n            var r = parseInt(rstr, 16);\n            var g = parseInt(gstr, 16);\n            var b = parseInt(bstr, 16);\n            r += Math.round(r * shift);\n            g += Math.round(g * shift);\n            b += Math.round(b * shift);\n\n            r = Math.min(255, r);\n            g = Math.min(255, g);\n            b = Math.min(255, b);\n\n            rstr = this.zeroPad(r);\n            gstr = this.zeroPad(g);\n            bstr = this.zeroPad(b);\n\n            return '#' + rstr + gstr + bstr;\n        },\n\n        zeroPad: function zeroPad(num) {\n            var num1 = '00' + num.toString(16);\n            var numstr = num1.substr(num1.length - 2);\n            return numstr;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\nfunction componentFromStr(numStr, percent) {\n    var num = Math.max(0, parseInt(numStr, 10));\n    return percent ? Math.floor(255 * Math.min(100, num) / 100) : Math.min(255, num);\n}\n\nfunction getColorHex(color) {\n    if (color.indexOf('#') > -1) return color;\n    if (color.indexOf('rgba') > -1) return rgbToHex(color);\n    if (color.indexOf('rgb') > -1) return rgbaToHex(color);\n    return colourNameToHex(color);\n}\nfunction rgbToHex(rgb) {\n    if (rgb.indexOf('rgba') > -1) {\n        return rgbaToHex(rgb);\n    }\n\n    var rgbRegex = /^rgb\\(\\s*(-?\\d+)(%?)\\s*,\\s*(-?\\d+)(%?)\\s*,\\s*(-?\\d+)(%?)\\s*\\)$/;\n    var result,\n        r,\n        g,\n        b,\n        hex = '';\n    if (result = rgbRegex.exec(rgb)) {\n        r = componentFromStr(result[1], result[2]);\n        g = componentFromStr(result[3], result[4]);\n        b = componentFromStr(result[5], result[6]);\n\n        hex = '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);\n    }\n    return hex;\n}\nfunction rgbaToHex(rgb) {\n    var rgbRegex = /^rgba\\(\\s*(-?\\d+)(%?)\\s*,\\s*(-?\\d+)(%?)\\s*,\\s*(-?\\d+)(%?)\\s*,\\s*(-?\\d+)(%?)\\s*\\)$/;\n    var result,\n        r,\n        g,\n        b,\n        hex = '';\n    if (result = rgbRegex.exec(rgb)) {\n        r = componentFromStr(result[1], result[2]);\n        g = componentFromStr(result[3], result[4]);\n        b = componentFromStr(result[5], result[6]);\n\n        hex = '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);\n    }\n    return hex;\n}\nfunction colourNameToHex(colour) {\n    var colours = {\n        'aliceblue': '#f0f8ff',\n        'antiquewhite': '#faebd7',\n        'aqua': '#00ffff',\n        'aquamarine': '#7fffd4',\n        'azure': '#f0ffff',\n        'beige': '#f5f5dc',\n        'bisque': '#ffe4c4',\n        'black': '#000000',\n        'blanchedalmond': '#ffebcd',\n        'blue': '#0000ff',\n        'blueviolet': '#8a2be2',\n        'brown': '#a52a2a',\n        'burlywood': '#deb887',\n        'cadetblue': '#5f9ea0',\n        'chartreuse': '#7fff00',\n        'chocolate': '#d2691e',\n        'coral': '#ff7f50',\n        'cornflowerblue': '#6495ed',\n        'cornsilk': '#fff8dc',\n        'crimson': '#dc143c',\n        'cyan': '#00ffff',\n        'darkblue': '#00008b',\n        'darkcyan': '#008b8b',\n        'darkgoldenrod': '#b8860b',\n        'darkgray': '#a9a9a9',\n        'darkgreen': '#006400',\n        'darkkhaki': '#bdb76b',\n        'darkmagenta': '#8b008b',\n        'darkolivegreen': '#556b2f',\n        'darkorange': '#ff8c00',\n        'darkorchid': '#9932cc',\n        'darkred': '#8b0000',\n        'darksalmon': '#e9967a',\n        'darkseagreen': '#8fbc8f',\n        'darkslateblue': '#483d8b',\n        'darkslategray': '#2f4f4f',\n        'darkturquoise': '#00ced1',\n        'darkviolet': '#9400d3',\n        'deeppink': '#ff1493',\n        'deepskyblue': '#00bfff',\n        'dimgray': '#696969',\n        'dodgerblue': '#1e90ff',\n        'firebrick': '#b22222',\n        'floralwhite': '#fffaf0',\n        'forestgreen': '#228b22',\n        'fuchsia': '#ff00ff',\n        'gainsboro': '#dcdcdc',\n        'ghostwhite': '#f8f8ff',\n        'gold': '#ffd700',\n        'goldenrod': '#daa520',\n        'gray': '#808080',\n        'green': '#008000',\n        'greenyellow': '#adff2f',\n        'honeydew': '#f0fff0',\n        'hotpink': '#ff69b4',\n        'indianred ': '#cd5c5c',\n        'indigo': '#4b0082',\n        'ivory': '#fffff0',\n        'khaki': '#f0e68c',\n        'lavender': '#e6e6fa',\n        'lavenderblush': '#fff0f5',\n        'lawngreen': '#7cfc00',\n        'lemonchiffon': '#fffacd',\n        'lightblue': '#add8e6',\n        'lightcoral': '#f08080',\n        'lightcyan': '#e0ffff',\n        'lightgoldenrodyellow': '#fafad2',\n        'lightgrey': '#d3d3d3',\n        'lightgreen': '#90ee90',\n        'lightpink': '#ffb6c1',\n        'lightsalmon': '#ffa07a',\n        'lightseagreen': '#20b2aa',\n        'lightskyblue': '#87cefa',\n        'lightslategray': '#778899',\n        'lightsteelblue': '#b0c4de',\n        'lightyellow': '#ffffe0',\n        'lime': '#00ff00',\n        'limegreen': '#32cd32',\n        'linen': '#faf0e6',\n        'magenta': '#ff00ff',\n        'maroon': '#800000',\n        'mediumaquamarine': '#66cdaa',\n        'mediumblue': '#0000cd',\n        'mediumorchid': '#ba55d3',\n        'mediumpurple': '#9370d8',\n        'mediumseagreen': '#3cb371',\n        'mediumslateblue': '#7b68ee',\n        'mediumspringgreen': '#00fa9a',\n        'mediumturquoise': '#48d1cc',\n        'mediumvioletred': '#c71585',\n        'midnightblue': '#191970',\n        'mintcream': '#f5fffa',\n        'mistyrose': '#ffe4e1',\n        'moccasin': '#ffe4b5',\n        'navajowhite': '#ffdead',\n        'navy': '#000080',\n        'oldlace': '#fdf5e6',\n        'olive': '#808000',\n        'olivedrab': '#6b8e23',\n        'orange': '#ffa500',\n        'orangered': '#ff4500',\n        'orchid': '#da70d6',\n        'palegoldenrod': '#eee8aa',\n        'palegreen': '#98fb98',\n        'paleturquoise': '#afeeee',\n        'palevioletred': '#d87093',\n        'papayawhip': '#ffefd5',\n        'peachpuff': '#ffdab9',\n        'peru': '#cd853f',\n        'pink': '#ffc0cb',\n        'plum': '#dda0dd',\n        'powderblue': '#b0e0e6',\n        'purple': '#800080',\n        'red': '#ff0000',\n        'rosybrown': '#bc8f8f',\n        'royalblue': '#4169e1',\n        'saddlebrown': '#8b4513',\n        'salmon': '#fa8072',\n        'sandybrown': '#f4a460',\n        'seagreen': '#2e8b57',\n        'seashell': '#fff5ee',\n        'sienna': '#a0522d',\n        'silver': '#c0c0c0',\n        'skyblue': '#87ceeb',\n        'slateblue': '#6a5acd',\n        'slategray': '#708090',\n        'snow': '#fffafa',\n        'springgreen': '#00ff7f',\n        'steelblue': '#4682b4',\n        'tan': '#d2b48c',\n        'teal': '#008080',\n        'thistle': '#d8bfd8',\n        'tomato': '#ff6347',\n        'turquoise': '#40e0d0',\n        'violet': '#ee82ee',\n        'wheat': '#f5deb3',\n        'white': '#ffffff',\n        'whitesmoke': '#f5f5f5',\n        'yellow': '#ffff00',\n        'yellowgreen': '#9acd32'\n    };\n\n    if (typeof colours[colour.toLowerCase()] !== 'undefined') {\n        return colours[colour.toLowerCase()];\n    }\n\n    return '#000000';\n}\n\n//# sourceURL=webpack:///./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Box.js?");

/***/ }),

/***/ "./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Gene.js":
/*!*****************************************************************!*\
  !*** ./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Gene.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Gene */ \"./src/JBrowse/View/FeatureGlyph/Gene.js\"), __webpack_require__(/*! ./Box */ \"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Box.js\"), __webpack_require__(/*! ./ProcessedTranscript */ \"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/ProcessedTranscript.js\"), __webpack_require__(/*! ./UnprocessedTranscript */ \"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/UnprocessedTranscript.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, Gene, Box, ProcessedTranscript, UnprocessedTranscript) {\n    return declare([Gene, Box], {\n        _boxGlyph: function _boxGlyph() {\n            return this.__boxGlyph || (this.__boxGlyph = new Box({ track: this.track, browser: this.browser, config: this.config }));\n        },\n        _ptGlyph: function _ptGlyph() {\n            return this.__ptGlyph || (this.__ptGlyph = new ProcessedTranscript({ track: this.track, browser: this.browser, config: this.config }));\n        },\n        _ntGlyph: function _ntGlyph() {\n            return this.__ntGlyph || (this.__ntGlyph = new UnprocessedTranscript({ track: this.track, browser: this.browser, config: this.config }));\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Gene.js?");

/***/ }),

/***/ "./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/ProcessedTranscript.js":
/*!********************************************************************************!*\
  !*** ./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/ProcessedTranscript.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojox/color/Palette */ \"./node_modules/dojox/color/Palette.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/ProcessedTranscript */ \"./src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js\"), __webpack_require__(/*! ./Segments */ \"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Segments.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Palette, ProcessedTranscript, Segments) {\n    return declare([ProcessedTranscript, Segments]);\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/ProcessedTranscript.js?");

/***/ }),

/***/ "./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Segments.js":
/*!*********************************************************************!*\
  !*** ./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Segments.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Segments */ \"./src/JBrowse/View/FeatureGlyph/Segments.js\"), __webpack_require__(/*! ./Box */ \"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Box.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, domConstruct, Segments, Box) {\n    return declare([Segments, Box], {\n        renderFeature: function renderFeature(context, fRect) {\n            if (this.track.displayMode != 'collapsed') {\n                context.clearRect(Math.floor(fRect.l), fRect.t, Math.ceil(fRect.w), fRect.h);\n            }\n\n            this.renderSegments(context, fRect);\n            this.renderIntrons(context, fRect);\n            this.renderLabel(context, fRect);\n            this.renderDescription(context, fRect);\n            this.renderArrowhead(context, fRect);\n        },\n        renderIntrons: function renderIntrons(context, fRect) {\n            var subparts = this._getSubparts(fRect.f);\n\n            if (subparts.length <= 1) return;\n\n            subparts.sort(function (a, b) {\n                return a.get('start') - b.get('start');\n            });\n\n            var viewInfo = fRect.viewInfo;\n\n            for (var i = 0; i < subparts.length - 1; ++i) {\n                var gap = subparts[i + 1].get('start') - subparts[i].get('end');\n                if (gap > 2) {\n                    var a_left = viewInfo.block.bpToX(subparts[i].get('start'));\n                    var a_width = viewInfo.block.bpToX(subparts[i].get('end')) - a_left;\n\n                    var b_left = viewInfo.block.bpToX(subparts[i + 1].get('start'));\n                    var b_width = viewInfo.block.bpToX(subparts[i + 1].get('end')) - b_left;\n\n                    var top = fRect.t;\n                    var overallHeight = fRect.rect.h;\n\n                    var _height = this._getFeatureHeight(viewInfo, subparts[i]);\n                    if (!_height) {\n                        return;\n                    }\n                    if (_height != overallHeight) {\n                        top += Math.round((overallHeight - _height) / 2);\n                    }\n\n                    var height = _height / 2;\n                    var left = a_left + a_width;\n                    var width = b_left - left;\n                    var mid = width / 2;\n\n                    context.beginPath();\n                    context.moveTo(left, top + height);\n                    context.lineTo(left + mid, top + 1);\n                    context.lineTo(left + width, top + height);\n                    context.lineWidth = 1;\n                    context.strokeStyle = '#202020';\n                    context.lineCap = 'square';\n                    context.stroke();\n                }\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Segments.js?");

/***/ }),

/***/ "./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/UnprocessedTranscript.js":
/*!**********************************************************************************!*\
  !*** ./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/UnprocessedTranscript.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojox/color/Palette */ \"./node_modules/dojox/color/Palette.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/UnprocessedTranscript */ \"./src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js\"), __webpack_require__(/*! ./Segments */ \"./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/Segments.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Palette, UnprocessedTranscript, Segments) {\n    return declare([Segments, UnprocessedTranscript]);\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatCanvasFeatures/js/View/FeatureGlyph/UnprocessedTranscript.js?");

/***/ }),

/***/ "./plugins/NeatCanvasFeatures/js/View/Track/NeatFeatures.js":
/*!******************************************************************!*\
  !*** ./plugins/NeatCanvasFeatures/js/View/Track/NeatFeatures.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/Track/CanvasFeatures */ \"./src/JBrowse/View/Track/CanvasFeatures.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Util, CanvasFeatures) {\n    return declare(CanvasFeatures, {\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(lang.clone(this.inherited(arguments)), {\n                glyph: lang.hitch(this, 'guessGlyphType')\n            });\n        },\n\n        guessGlyphType: function guessGlyphType(feature) {\n            // first try to guess by its SO type\n            var guess = {\n                'gene': 'Gene',\n                'pseudogene': 'Gene',\n                'mRNA': 'ProcessedTranscript',\n                'transcript': 'ProcessedTranscript',\n                'ncRNA': 'UnprocessedTranscript',\n                'lncRNA': 'UnprocessedTranscript',\n                'lnc_RNA': 'UnprocessedTranscript',\n                'miRNA': 'UnprocessedTranscript'\n            }[feature.get('type')];\n\n            // otherwise, make it Segments if it has children,\n            // a BED if it has block_count/thick_start,\n            // or a Box otherwise\n            if (!guess) {\n                var children = feature.children();\n                if (children && children.length) guess = 'Segments';else guess = 'Box';\n            }\n\n            return 'NeatCanvasFeatures/View/FeatureGlyph/' + guess;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatCanvasFeatures/js/View/Track/NeatFeatures.js?");

/***/ }),

/***/ "./plugins/NeatCanvasFeatures/js/main.js":
/*!***********************************************!*\
  !*** ./plugins/NeatCanvasFeatures/js/main.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            console.log('NeatCanvasFeatures initialized');\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatCanvasFeatures/js/main.js?");

/***/ }),

/***/ "./plugins/NeatHTMLFeatures/js/View/Track/NeatFeatures.js":
/*!****************************************************************!*\
  !*** ./plugins/NeatHTMLFeatures/js/View/Track/NeatFeatures.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! JBrowse/View/Track/HTMLFeatures */ \"./src/JBrowse/View/Track/HTMLFeatures.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, domConstruct, query, HTMLFeatures) {\n    return declare(HTMLFeatures, {\n        renderFeature: function renderFeature(feature, uniqueId, block, scale, labelScale, descriptionScale, containerStart, containerEnd) {\n            var featureNode = this.inherited(arguments);\n            var thisB = this;\n\n            if (featureNode) {\n                // In case the feature was not rendered (too many)\n                thisB.insertIntrons(featureNode);\n                thisB.paintNeatFeatures(featureNode);\n            }\n            return featureNode;\n        },\n        insertIntrons: function insertIntrons(featureNode) {\n            // ignore if we have already processed this node\n            if (!dojo.hasClass(featureNode, 'has-neat-introns')) {\n                // get the subfeatures nodes (only immediate children)\n                var subNodesX = query('> .subfeature', featureNode);\n\n                // filter nodes - eliminate nodes that are splice sites (for Apollo)\n                var subNodes = [];\n                for (var i = 0; i < subNodesX.length; i++) {\n                    var attr = dojo.attr(subNodesX[i], 'class');\n                    if (attr.indexOf('splice-site') === -1 && attr.indexOf('Shine_Dalgarno_sequence') === -1 && attr.indexOf('stop_codon_read_through') === -1 && attr.indexOf('intron') === -1) {\n                        subNodes.push(subNodesX[i]);\n                    }\n                }\n                if (subNodes.length < 2) {\n                    // apply introns to all feature tracks\n                    var subFeatureIntron = query('div.feature-render', featureNode);\n                    // added to handle apollo annotation classes:  https://github.com/GMOD/Apollo/issues/1417\n                    if (subFeatureIntron && subFeatureIntron.length == 1 && subFeatureIntron[0].className.indexOf('annot-apollo') < 0 && subFeatureIntron[0].className.indexOf('annot-render') < 0) {\n                        var left = featureNode.style.left;\n                        var width = featureNode.style.width;\n                        var height = '100%';\n                        var str = '';\n                        str += \"<svg class='jb-intron' viewBox='0 0 100 100' preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' \";\n                        str += \"style='position:absolute;z-index: 15;\"; // this must be here and not in CSS file\n                        str += 'left: ' + left + ';width: ' + width + ';height: ' + height + \"'>\";\n                        str += \"<polyline points='0,50 100,50' style='fill:none;stroke:black;stroke-width:5' shape-rendering='optimizeQuality' />\";\n                        str += '</svg>';\n\n                        // note: dojo.create(\"svg\") does not render due to namespace issue between DOM and SVG\n                        domConstruct.place(str, featureNode);\n                    }\n                } else if (subNodes.length >= 2) {\n                    // identify directionality\n                    var classAttr = dojo.attr(featureNode, 'class');\n                    var direction = 1;\n                    if (classAttr.indexOf('minus') > -1) {\n                        direction = -1;\n                    }\n                    // extract some left & width -  more convient to access\n                    for (var i = 0; i < subNodes.length; i++) {\n                        subNodes[i].left = dojo.getStyle(subNodes[i], 'left');\n                        subNodes[i].width = dojo.getStyle(subNodes[i], 'width');\n                    }\n                    // sort the subfeatures\n                    if (subNodes.length >= 2) {\n                        subNodes.sort(function (a, b) {\n                            return a.left - b.left;\n                        });\n                    }\n\n                    // insert introns between subfeature gaps\n                    for (var i = 0; i < subNodes.length - 1; ++i) {\n                        var gap = subNodes[i + 1].left - (subNodes[i].left + subNodes[i].width);\n                        if (gap > 0.02) {\n                            var subLeft = subNodes[i].left + subNodes[i].width;\n                            var subWidth = subNodes[i + 1].left - (subNodes[i].left + subNodes[i].width);\n\n                            var left = subLeft;\n                            var width = subWidth;\n                            var height = '100%';\n\n                            // invert hat if reverse direction\n                            var dir = '50,5';\n                            if (direction == -1) dir = '50,95';\n\n                            var str = '';\n                            str += \"<svg class='jb-intron' viewBox='0 0 100 100' preserveAspectRatio='none' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' \";\n                            str += \"style='position:absolute;z-index: 15;\"; // this must be here and not in CSS file\n                            str += 'left: ' + left + '%;width: ' + width + '%;height: ' + height + \"'>\";\n                            str += \"<polyline class='neat-intron' points='0,50 \" + dir + \" 100,50' shape-rendering='optimizeQuality' />\";\n                            str += '</svg>';\n\n                            // note: dojo.create(\"svg\") does not render due to namespace issue between DOM and SVG\n                            domConstruct.place(str, featureNode);\n                        }\n                    }\n                }\n            }\n        },\n        /*\n         * Paint neat features and subfeatures\n         */\n        paintNeatFeatures: function paintNeatFeatures(featureNode) {\n            // get the subfeature nodes (only immediate children)\n            var subNodesX = query('> .subfeature', featureNode);\n            var thisB = this;\n\n            // filter nodes - eliminate nodes that are splice sites (for Apollo)\n            var subNodes = [];\n            for (var i = 0; i < subNodesX.length; i++) {\n                var attr = dojo.attr(subNodesX[i], 'class');\n                if (attr.indexOf('splice-site') === -1) {\n                    subNodes.push(subNodesX[i]);\n                }\n            }\n\n            // if feature has subfeatures\n            if (subNodes.length) {\n                dojo.setStyle(featureNode, {\n                    'background': 'none',\n                    'background-color': 'transparent',\n                    'border-width': '0px'\n                });\n\n                // paint subfeatures\n                for (var i = 0; i < subNodes.length; i++) {\n                    // if this is Apollo, we have another subfeature level to traverse\n                    if (subNodes[i].childElementCount) {\n                        // get the subfeature nodes (only immediate children)\n                        var childNodes = query('> .subfeature', subNodes[i]);\n\n                        for (var j = 0; j < childNodes.length; j++) {\n                            thisB.paintSubNode(childNodes[j]);\n                        }\n                    }\n                    // handle the first level subfeature\n                    else {\n                            thisB.paintSubNode(subNodes[i]);\n                        }\n                }\n            }\n            // paint features that have no subfeatures\n            else {\n                    // ignore if we have already processed node\n                    if (!dojo.hasClass(featureNode, 'neat-feature')) {\n                        var classAttr = dojo.attr(featureNode, 'class');\n                        var color = dojo.getStyle(featureNode, 'background-color');\n\n                        // update the element with new styling\n                        // if(dojo.hasClass(featureNode,'neat-linear-shading')){\n                        if (this.config.gradient == 1) {\n                            dojo.setStyle(featureNode, {\n                                'background': 'linear-gradient(to bottom,  ' + color + ' 0%,#e5e5e5 50%,' + color + ' 100%)'\n                            });\n                        }\n                        dojo.addClass(featureNode, 'neat-feature');\n                    }\n                }\n        },\n        /*\n         * apply neat modifications to feature sub-nodes\n         */\n        paintSubNode: function paintSubNode(subNode) {\n            var classAttr = dojo.attr(subNode, 'class');\n            var color = dojo.getStyle(subNode, 'background-color');\n\n            // ignore if we have already processed node\n            if (!dojo.hasClass(subNode, 'neat-subfeature')) {\n                // restyle UTR\n                if (classAttr.indexOf('UTR') > -1) {\n                    dojo.setStyle(subNode, {\n                        'top': '0px',\n                        'border': '1px solid ' + color\n                    });\n                    // mark as neat subfeature\n                    dojo.addClass(subNode, 'neat-UTR');\n                } else {\n                    // if(classAttr.indexOf('CDS') > -1 || classAttr.indexOf('exon') > -1) {\n                    if (this.config.gradient == 1) {\n                        dojo.setStyle(subNode, {\n                            'top': '0px',\n                            'background': 'linear-gradient(to bottom,  ' + color + ' 0%,#e5e5e5 50%,' + color + ' 100%)'\n                        });\n                    }\n                }\n                // mark that we have processed the node\n                dojo.addClass(subNode, 'neat-subfeature');\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatHTMLFeatures/js/View/Track/NeatFeatures.js?");

/***/ }),

/***/ "./plugins/NeatHTMLFeatures/js/main.js":
/*!*********************************************!*\
  !*** ./plugins/NeatHTMLFeatures/js/main.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * Extended Neat Features Plugin\n * Draws introns and paints gradient subfeatures.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, domConstruct, query, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            console.log('plugin: NeatHTMLFeatures');\n            var thisB = this;\n            var browser = this.browser;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/NeatHTMLFeatures/js/main.js?");

/***/ }),

/***/ "./plugins/RegexSequenceSearch/js/Store/SeqFeature/RegexSearch.js":
/*!************************************************************************!*\
  !*** ./plugins/RegexSequenceSearch/js/Store/SeqFeature/RegexSearch.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/CodonTable */ \"./src/JBrowse/CodonTable.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, SeqFeatureStore, SimpleFeature, JBrowseErrors, Util, CodonTable) {\n\n    return declare(SeqFeatureStore, {\n\n        constructor: function constructor(args) {\n            this.searchParams = args.searchParams;\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                regionSizeLimit: 200000 // 200kb\n            });\n        },\n\n        getFeatures: function getFeatures(query, featCallback, doneCallback, errorCallback) {\n            var searchParams = lang.mixin(\n            // store the original query bounds - this helps prevent features from randomly disappearing\n            { orig: { start: query.start, end: query.end } }, this.searchParams, query.searchParams);\n\n            var regionSize = query.end - query.start;\n            if (regionSize > this.config.regionSizeLimit) throw new JBrowseErrors.DataOverflow('Region too large to search');\n\n            var thisB = this;\n            this.browser.getStore('refseqs', function (refSeqStore) {\n                if (refSeqStore) refSeqStore.getReferenceSequence(query, function (sequence) {\n                    thisB.doSearch(query, sequence, searchParams, featCallback);\n                    doneCallback();\n                }, errorCallback);else doneCallback();\n            });\n        },\n\n        doSearch: function doSearch(query, sequence, params, featCallback) {\n            var expr = new RegExp(params.regex ? params.expr : this.escapeString(params.expr), params.caseIgnore ? \"gi\" : \"g\");\n\n            var sequences = [];\n            if (params.fwdStrand) sequences.push([sequence, 1]);\n            if (params.revStrand) sequences.push([Util.revcom(sequence), -1]);\n\n            array.forEach(sequences, function (r) {\n                if (params.translate) {\n                    for (var frameOffset = 0; frameOffset < 3; frameOffset++) {\n                        this._searchSequence(query, r[0], expr, r[1], featCallback, true, frameOffset);\n                    }\n                } else {\n                    this._searchSequence(query, r[0], expr, r[1], featCallback);\n                }\n            }, this);\n        },\n\n        _searchSequence: function _searchSequence(query, sequence, expr, strand, featCallback, translated, frameOffset) {\n            if (translated) sequence = this.translateSequence(sequence, frameOffset);\n\n            frameOffset = frameOffset || 0;\n            var multiplier = translated ? 3 : 1;\n\n            var start = query.start,\n                end = query.end;\n\n            var features = [];\n            var match;\n            while ((match = expr.exec(sequence)) !== null && match.length) {\n                expr.lastIndex = match.index + 1;\n\n                var result = match[0];\n\n                var newStart = strand > 0 ? start + frameOffset + multiplier * match.index : end - frameOffset - multiplier * (match.index + result.length);\n                var newEnd = strand > 0 ? start + frameOffset + multiplier * (match.index + result.length) : end - frameOffset - multiplier * match.index;\n\n                var newFeat = new SimpleFeature({\n                    data: {\n                        type: \"SEARCH\",\n                        start: newStart,\n                        end: newEnd,\n                        searchMatch: result,\n                        strand: strand\n                    },\n                    id: [newStart, newEnd, result].join(',')\n                });\n                featCallback(newFeat);\n            }\n        },\n        translateSequence: function translateSequence(sequence, frameOffset) {\n            var slicedSeq = sequence.slice(frameOffset);\n            slicedSeq = slicedSeq.slice(0, Math.floor(slicedSeq.length / 3) * 3);\n\n            var translated = \"\";\n            var codontable = new CodonTable();\n            var codons = codontable.generateCodonTable(codontable.defaultCodonTable);\n            for (var i = 0; i < slicedSeq.length; i += 3) {\n                var nextCodon = slicedSeq.slice(i, i + 3);\n                translated = translated + codons[nextCodon];\n            }\n\n            return translated;\n        },\n\n        escapeString: function escapeString(str) {\n            return (str + '').replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n        },\n\n        saveStore: function saveStore() {\n            return {\n                searchParams: this.config.searchParams,\n                regionSizeLimit: this.config.regionSizeLimit\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/RegexSequenceSearch/js/Store/SeqFeature/RegexSearch.js?");

/***/ }),

/***/ "./plugins/RegexSequenceSearch/js/View/SearchSeqDialog.js":
/*!****************************************************************!*\
  !*** ./plugins/RegexSequenceSearch/js/View/SearchSeqDialog.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dijit/form/RadioButton */ \"./node_modules/dijit/form/RadioButton.js\"), __webpack_require__(/*! dijit/form/CheckBox */ \"./node_modules/dijit/form/CheckBox.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, aspect, focus, dButton, dRButton, dCheckBox, dTextBox, ActionBarDialog) {\n\n    return declare(ActionBarDialog, {\n\n        constructor: function constructor() {\n            var thisB = this;\n            aspect.after(this, 'hide', function () {\n                focus.curNode && focus.curNode.blur();\n                setTimeout(function () {\n                    thisB.destroyRecursive();\n                }, 500);\n            });\n        },\n\n        _dialogContent: function _dialogContent() {\n            var content = this.content = {};\n\n            var container = dom.create('div', { className: 'search-dialog' });\n\n            var introdiv = dom.create('div', {\n                className: 'search-dialog intro',\n                innerHTML: 'This tool creates tracks showing regions of the reference sequence (or its translations) that match a given DNA or amino acid sequence.'\n            }, container);\n\n            // Render text box\n            var searchBoxDiv = dom.create('div', {\n                className: \"section\"\n            }, container);\n            dom.create('span', {\n                className: \"header\",\n                innerHTML: \"Search for\"\n            }, searchBoxDiv);\n            var translateDiv = dom.create(\"div\", {\n                className: \"translateContainer\"\n            }, searchBoxDiv);\n            function makeRadio(args, parent) {\n                var label = dom.create('label', {}, parent);\n                var radio = new dRButton(args).placeAt(label);\n                dom.create('span', { innerHTML: args.label }, label);\n                return radio;\n            }\n            makeRadio({ name: 'translate', value: 'no', label: 'DNA', checked: true }, translateDiv);\n            content.translate = makeRadio({ name: 'translate', value: 'yes', label: 'AA' }, translateDiv);\n\n            content.searchBox = new dTextBox({}).placeAt(searchBoxDiv);\n\n            // Render 'ignore case' checkbox\n            var textOptionsDiv = dom.create('div', {\n                className: \"section\"\n            }, container);\n\n            var caseDiv = dom.create(\"div\", {\n                className: \"checkboxdiv\"\n            }, textOptionsDiv);\n            content.caseIgnore = new dCheckBox({ label: \"Ignore case\",\n                id: \"search_ignore_case\",\n                checked: true\n            });\n            caseDiv.appendChild(content.caseIgnore.domNode);\n            dom.create(\"label\", { \"for\": \"search_ignore_case\", innerHTML: \"Ignore Case\" }, caseDiv);\n\n            // Render 'treat as regex' checkbox\n            var regexDiv = dom.create(\"div\", {\n                className: \"checkboxdiv\"\n            }, textOptionsDiv);\n            content.regex = new dCheckBox({\n                label: \"Treat as regular expression\",\n                id: \"search_as_regex\"\n            }).placeAt(regexDiv);\n            dom.create(\"label\", { \"for\": \"search_as_regex\", innerHTML: \"Treat as regular expression\" }, regexDiv);\n\n            // Render 'forward strand' and 'reverse strand' checkboxes\n            var strandsDiv = dom.create('div', {\n                className: \"section\"\n            }, container);\n            dom.create(\"span\", {\n                className: \"header\",\n                innerHTML: \"Search strands\"\n            }, strandsDiv);\n\n            var fwdDiv = dom.create(\"div\", {\n                className: \"checkboxdiv\"\n            });\n            content.fwdStrand = new dCheckBox({\n                id: \"search_fwdstrand\",\n                checked: true\n            });\n            var revDiv = dom.create(\"div\", {\n                className: \"checkboxdiv\"\n            });\n            content.revStrand = new dCheckBox({\n                id: \"search_revstrand\",\n                checked: true\n            });\n            fwdDiv.appendChild(content.fwdStrand.domNode);\n            dom.create(\"label\", { \"for\": \"search_fwdstrand\", innerHTML: \"Forward\" }, fwdDiv);\n            revDiv.appendChild(content.revStrand.domNode);\n            dom.create(\"label\", { \"for\": \"search_revstrand\", innerHTML: \"Reverse\" }, revDiv);\n            strandsDiv.appendChild(fwdDiv);\n            strandsDiv.appendChild(revDiv);\n\n            return container;\n        },\n\n        _getSearchParams: function _getSearchParams() {\n            var content = this.content;\n            return {\n                expr: content.searchBox.get('value'),\n                regex: content.regex.checked,\n                caseIgnore: content.caseIgnore.checked,\n                translate: content.translate.checked,\n                fwdStrand: content.fwdStrand.checked,\n                revStrand: content.revStrand.checked,\n                maxLen: 100\n            };\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            var thisB = this;\n\n            new dButton({\n                label: 'Search',\n                iconClass: 'dijitIconBookmark',\n                onClick: function onClick() {\n                    var searchParams = thisB._getSearchParams();\n                    thisB.callback(searchParams);\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n            new dButton({\n                label: 'Cancel',\n                iconClass: 'dijitIconDelete',\n                onClick: function onClick() {\n                    thisB.callback(false);\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n        },\n\n        show: function show(callback) {\n            this.callback = callback || function () {};\n            this.set('title', \"Add sequence search track\");\n            this.set('content', this._dialogContent());\n            this.inherited(arguments);\n            focus.focus(this.closeButtonNode);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/RegexSequenceSearch/js/View/SearchSeqDialog.js?");

/***/ }),

/***/ "./plugins/RegexSequenceSearch/js/main.js":
/*!************************************************!*\
  !*** ./plugins/RegexSequenceSearch/js/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dijit/MenuItem */ \"./node_modules/dijit/MenuItem.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\"), __webpack_require__(/*! ./View/SearchSeqDialog */ \"./plugins/RegexSequenceSearch/js/View/SearchSeqDialog.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, dijitMenuItem, JBrowsePlugin, SearchSeqDialog) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            this._searchTrackCount = 0;\n\n            var thisB = this;\n            this.browser.afterMilestone('initView', function () {\n                this.browser.addGlobalMenuItem('file', new dijitMenuItem({\n                    label: 'Add sequence search track',\n                    iconClass: 'dijitIconSearch',\n                    onClick: lang.hitch(this, 'createSearchTrack')\n                }));\n            }, this);\n        },\n\n        createSearchTrack: function createSearchTrack() {\n\n            var searchDialog = new SearchSeqDialog();\n            var thisB = this;\n            searchDialog.show(function (searchParams) {\n                if (!searchParams) return;\n\n                var storeConf = {\n                    browser: thisB.browser,\n                    refSeq: thisB.browser.refSeq,\n                    type: 'RegexSequenceSearch/Store/SeqFeature/RegexSearch',\n                    searchParams: searchParams\n                };\n                var storeName = thisB.browser.addStoreConfig(undefined, storeConf);\n                storeConf.name = storeName;\n                var searchTrackConfig = {\n                    type: 'JBrowse/View/Track/CanvasFeatures',\n                    label: 'search_track_' + thisB._searchTrackCount++,\n                    key: \"Search reference sequence for '\" + searchParams.expr + \"'\",\n                    metadata: {\n                        category: 'Local tracks',\n                        Description: \"Contains all matches of the text string/regular expression '\" + storeConf.searchExpr + \"'\"\n                    },\n                    store: storeName\n                };\n\n                // send out a message about how the user wants to create the new track\n                thisB.browser.publish('/jbrowse/v1/v/tracks/new', [searchTrackConfig]);\n\n                // Open the track immediately\n                thisB.browser.publish('/jbrowse/v1/v/tracks/show', [searchTrackConfig]);\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/RegexSequenceSearch/js/main.js?");

/***/ }),

/***/ "./plugins/WiggleHighlighter/js/View/Track/Base.js":
/*!*********************************************************!*\
  !*** ./plugins/WiggleHighlighter/js/View/Track/Base.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/mouse */ \"./node_modules/dojo/mouse.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/BigBed */ \"./src/JBrowse/Store/SeqFeature/BigBed.js\"), __webpack_require__(/*! JBrowse/View/Track/_FeatureDetailMixin */ \"./src/JBrowse/View/Track/_FeatureDetailMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, on, mouse, Dialog, Util, BigBed, FeatureDetailMixin) {\n    return declare(FeatureDetailMixin, {\n        constructor: function constructor(args) {\n            if (this.config.bigbed) {\n                this.highlightStore = new BigBed(Object.assign({}, this.config.bigbed, args));\n            } else {\n                var conf = this.config.storeConf;\n                var CLASS = dojo.global.require(conf.storeClass);\n                var newConf = Object.assign({}, args, conf);\n                newConf.config = Object.assign({}, args.config, conf);\n                this.highlightStore = new CLASS(newConf);\n            }\n        },\n        _defaultConfig: function _defaultConfig() {\n            var _this = this;\n\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                highlightColor: '#f0f2',\n                indicatorColor: '#f0f',\n                indicatorHeight: 3,\n                broaden: 0,\n                onHighlightClick: function onHighlightClick(feature) {\n                    return new Dialog({ content: _this.defaultFeatureDetail(_this, feature, null, null, null) }).show();\n                },\n                onHighlightRightClick: function onHighlightRightClick() {}\n            });\n        },\n\n        _postDraw: function _postDraw(scale, leftBase, rightBase, block, canvas) {\n            var _this2 = this;\n\n            this.highlightStore.getFeatures({ ref: this.browser.refSeq.name, start: leftBase, end: rightBase }, function (feature) {\n                var s = block.bpToX(Math.max(feature.get('start') - _this2.config.broaden, block.startBase));\n                var e = block.bpToX(Math.min(feature.get('end') + _this2.config.broaden, block.endBase));\n                var ret = dojo.create('div', {\n                    style: {\n                        left: s + 'px',\n                        width: e - s + 'px',\n                        height: canvas.style.height,\n                        top: 0,\n                        zIndex: 10000,\n                        position: 'absolute',\n                        backgroundColor: _this2.getConf('highlightColor', [feature, _this2])\n                    }\n                }, block.domNode);\n                var indicator = dojo.create('div', {\n                    style: {\n                        left: s + 'px',\n                        width: e - s + 'px',\n                        height: _this2.config.indicatorHeight + 'px',\n                        zIndex: 10000,\n                        top: canvas.style.height,\n                        position: 'absolute',\n                        backgroundColor: _this2.getConf('indicatorColor', [feature, _this2])\n                    }\n                }, block.domNode);\n\n                var effectiveCallback = function effectiveCallback(event) {\n                    event.stopPropagation();\n                    if (mouse.isRight(event)) {\n                        console.log('here');\n                        _this2.getConf('onHighlightRightClick', [feature, _this2]);\n                    } else {\n                        console.log('here2');\n                        _this2.getConf('onHighlightClick', [feature, _this2]);\n                    }\n                };\n                on(indicator, 'mousedown', effectiveCallback);\n                on(ret, 'mousedown', effectiveCallback);\n            }, function () {}, function (error) {\n                console.error(error);\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/WiggleHighlighter/js/View/Track/Base.js?");

/***/ }),

/***/ "./plugins/WiggleHighlighter/js/View/Track/Density.js":
/*!************************************************************!*\
  !*** ./plugins/WiggleHighlighter/js/View/Track/Density.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/Track/Wiggle/Density */ \"./src/JBrowse/View/Track/Wiggle/Density.js\"), __webpack_require__(/*! ./Base */ \"./plugins/WiggleHighlighter/js/View/Track/Base.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Density, Base) {\n    return declare([Density, Base], {});\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/WiggleHighlighter/js/View/Track/Density.js?");

/***/ }),

/***/ "./plugins/WiggleHighlighter/js/View/Track/MultiDensity.js":
/*!*****************************************************************!*\
  !*** ./plugins/WiggleHighlighter/js/View/Track/MultiDensity.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;try {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! MultiBigWig/View/Track/MultiWiggle/MultiDensity */ \"./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiDensity.js\"), __webpack_require__(/*! ./Base */ \"./plugins/WiggleHighlighter/js/View/Track/Base.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Density, Base) {\n        return declare([Density, Base], {});\n    }).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} catch (e) {}\n\n//# sourceURL=webpack:///./plugins/WiggleHighlighter/js/View/Track/MultiDensity.js?");

/***/ }),

/***/ "./plugins/WiggleHighlighter/js/View/Track/MultiXYPlot.js":
/*!****************************************************************!*\
  !*** ./plugins/WiggleHighlighter/js/View/Track/MultiXYPlot.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;try {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! MultiBigWig/View/Track/MultiWiggle/MultiXYPlot */ \"./plugins/MultiBigWig/js/View/Track/MultiWiggle/MultiXYPlot.js\"), __webpack_require__(/*! ./Base */ \"./plugins/WiggleHighlighter/js/View/Track/Base.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, XYPlot, Base) {\n        return declare([XYPlot, Base], {});\n    }).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} catch (e) {}\n\n//# sourceURL=webpack:///./plugins/WiggleHighlighter/js/View/Track/MultiXYPlot.js?");

/***/ }),

/***/ "./plugins/WiggleHighlighter/js/View/Track/XYPlot.js":
/*!***********************************************************!*\
  !*** ./plugins/WiggleHighlighter/js/View/Track/XYPlot.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/Track/Wiggle/XYPlot */ \"./src/JBrowse/View/Track/Wiggle/XYPlot.js\"), __webpack_require__(/*! ./Base */ \"./plugins/WiggleHighlighter/js/View/Track/Base.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, XYPlot, Base) {\n    return declare([XYPlot, Base], {});\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/WiggleHighlighter/js/View/Track/XYPlot.js?");

/***/ }),

/***/ "./plugins/WiggleHighlighter/js/main.js":
/*!**********************************************!*\
  !*** ./plugins/WiggleHighlighter/js/main.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor() /* args */{\n            console.log('WiggleHighlighter plugin starting');\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/WiggleHighlighter/js/main.js?");

/***/ }),

/***/ "./plugins/vcfview/js/Store/SeqFeature/Segmentation.js":
/*!*************************************************************!*\
  !*** ./plugins/vcfview/js/Store/SeqFeature/Segmentation.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Store/LRUCache */ \"./src/JBrowse/Store/LRUCache.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, LRUCache, SeqFeatureStore, SimpleFeature) {\n    return declare([SeqFeatureStore], {\n        constructor: function constructor(args) {\n            // examples ['DP', 'mutect_DP', 'strelka_DP', 'lofreq_DP'];\n            this.dpField = args.dpField || 'DP';\n            this.binSize = args.binSize || 100000;\n            this.store = args.store;\n            this.featureCache = new LRUCache({\n                name: 'vcfFeatureCache',\n                fillCallback: dojo.hitch(this, '_readChunk'),\n                sizeFunction: function sizeFunction(features) {\n                    return features.length;\n                },\n                maxSize: 100000\n            });\n        },\n\n        getFeatures: function getFeatures(query, featCallback, finishCallback, errorCallback) {\n            var _this = this;\n\n            var chunkSize = this.binSize;\n\n            var s = query.start - query.start % chunkSize;\n            var e = query.end + (chunkSize - query.end % chunkSize);\n            var chunks = [];\n\n            var chunksProcessed = 0;\n            for (var start = s; start < e; start += chunkSize) {\n                var chunk = { ref: query.ref, start: start, end: start + chunkSize };\n                chunk.toString = function () {\n                    return query.ref + ',' + query.start + ',' + query.end;\n                };\n                chunks.push(chunk);\n            }\n\n            chunks.forEach(function (c) {\n                _this.featureCache.get(c, function (f, err) {\n                    if (err) {\n                        errorCallback(err);\n                    } else {\n                        if (f) {\n                            featCallback(f);\n                        }\n                        if (++chunksProcessed === chunks.length) {\n                            finishCallback();\n                        }\n                    }\n                });\n            });\n        },\n        _readChunk: function _readChunk(params, callback) {\n            var score = 0;\n            var numFeatures = 0;\n            var ref = params.ref,\n                start = params.start,\n                end = params.end;\n\n\n            this.store.getFeatures({ ref: ref, start: start, end: end }, function (feature) {\n                var genotype = feature.get('genotypes');\n                var samples = Object.keys(genotype);\n\n                var sample_position = samples.length - 1;\n                var sample_name = feature.get('genotypes')[samples[sample_position]];\n\n                //score += sample_name[this.dpField].values[0];\n\n                var sample_score = 0;\n                var field_list = ['DP', 'mutect_DP', 'strelka_DP', 'lofreq_DP'];\n                field_list.forEach(function (val) {\n                    if (typeof sample_name[val] != \"undefined\") {\n                        sample_score = sample_name[val].values[0];\n                    }\n                });\n                score += sample_score;\n\n                numFeatures++;\n            }, function () {\n                if (numFeatures) {\n                    //console.log(start, end, end-start)\n                    callback(new SimpleFeature({ id: start + '_' + end, data: { start: start, end: end, score: score / numFeatures } }));\n                } else {\n                    callback(null);\n                }\n            }, function (error) {\n                callback(null, error);\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/vcfview/js/Store/SeqFeature/Segmentation.js?");

/***/ }),

/***/ "./plugins/vcfview/js/Store/SeqFeature/SegmentationMultiBin.js":
/*!*********************************************************************!*\
  !*** ./plugins/vcfview/js/Store/SeqFeature/SegmentationMultiBin.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Store/LRUCache */ \"./src/JBrowse/Store/LRUCache.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, LRUCache, SeqFeatureStore, SimpleFeature) {\n    return declare([SeqFeatureStore], {\n        constructor: function constructor(args) {\n            this.store = args.store;\n            this.dpField = args.dpField || 'DP';\n            this.binSize = args.binSize || 100000;\n            this.featureCache = new LRUCache({\n                name: 'vcfFeatureCache',\n                fillCallback: dojo.hitch(this, '_readChunk'),\n                sizeFunction: function sizeFunction(features) {\n                    return features.length;\n                },\n                maxSize: 100000\n            });\n        },\n\n        getFeatures: function getFeatures(query, featCallback, finishCallback, errorCallback) {\n            var _this = this;\n\n            var chunkSize = \"undefined\";\n            if (typeof this.binSize == \"number\") {\n                chunkSize = this.binSize;\n            } else {\n                var bin_array = this.binSize;\n                var zoom = query.basesPerSpan * 10;\n                chunkSize = bin_array.reduce(function (prev, curr) {\n                    return Math.abs(curr - zoom) < Math.abs(prev - zoom) ? curr : prev;\n                });\n            }\n\n            var s = query.start - query.start % chunkSize;\n            var e = query.end + (chunkSize - query.end % chunkSize);\n            var chunks = [];\n\n            var chunksProcessed = 0;\n            for (var start = s; start < e; start += chunkSize) {\n                var chunk = { ref: query.ref, start: start, end: start + chunkSize };\n                chunk.toString = function () {\n                    return query.ref + ',' + query.start + ',' + query.end;\n                };\n                chunks.push(chunk);\n            }\n\n            chunks.forEach(function (c) {\n                _this.featureCache.get(c, function (f, err) {\n                    if (err) {\n                        errorCallback(err);\n                    } else {\n                        if (f) {\n                            featCallback(f);\n                        }\n                        if (++chunksProcessed === chunks.length) {\n                            finishCallback();\n                        }\n                    }\n                });\n            });\n        },\n        _readChunk: function _readChunk(params, callback) {\n            var score = 0;\n            var numFeatures = 0;\n            var ref = params.ref,\n                start = params.start,\n                end = params.end;\n\n\n            this.store.getFeatures({ ref: ref, start: start, end: end }, function (feature) {\n                var genotype = feature.get('genotypes');\n                var samples = Object.keys(genotype);\n\n                var sample_position = samples.length - 1;\n                var sample_name = feature.get('genotypes')[samples[sample_position]];\n\n                //score += sample_name[this.dpField].values[0];\n\n                var sample_score = 0;\n                var field_list = ['DP', 'mutect_DP', 'strelka_DP', 'lofreq_DP'];\n                field_list.forEach(function (val) {\n                    if (typeof sample_name[val] != \"undefined\") {\n                        sample_score = sample_name[val].values[0];\n                    }\n                });\n                score += sample_score;\n\n                numFeatures++;\n            }, function () {\n                if (numFeatures) {\n                    //console.log(start, end, end-start)\n                    callback(new SimpleFeature({ id: start + '_' + end, data: { start: start, end: end, score: score / numFeatures } }));\n                } else {\n                    callback(null);\n                }\n            }, function (error) {\n                callback(null, error);\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/vcfview/js/Store/SeqFeature/SegmentationMultiBin.js?");

/***/ }),

/***/ "./plugins/vcfview/js/Store/SeqFeature/vcfview.js":
/*!********************************************************!*\
  !*** ./plugins/vcfview/js/Store/SeqFeature/vcfview.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/VCFTabix */ \"./src/JBrowse/Store/SeqFeature/VCFTabix.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, VCFTabix, SimpleFeature) {\n    return declare(VCFTabix, {\n        constructor: function constructor(args) {\n            this.urlTemplate = args.urlTemplate;\n\n            this.BinSize = 1;\n            if (typeof args.BinSize != \"undefined\") {\n                this.BinSize = args.BinSize;\n            }\n        },\n\n        getFeatures: function getFeatures(query, featureCallback, finishCallback, errorCallback) {\n            var _this = this;\n\n            this.inherited(arguments, [query, function (feature) {\n\n                var thisB = _this;\n                var genotype = feature.get('genotypes');\n                var samples = Object.keys(genotype);\n\n                var sample_position = samples.length - 1;\n                var sample_name = feature.get('genotypes')[samples[sample_position]];\n\n                var sample_score = 0;\n                var field_list = ['DP', 'mutect_DP', 'strelka_DP', 'lofreq_DP'];\n                field_list.forEach(function (val) {\n                    if (typeof sample_name[val] != \"undefined\") {\n                        sample_score = sample_name[val].values[0];\n                    }\n                });\n                //console.log(query)\n                var span_len = (query.end - query.start) * query.basesPerSpan * query.scale;\n                //console.log(span_len)\n                // console.log(feature.get('start'), feature.get('end'))\n                // console.log(sample_score)\n                var sample_data = new SimpleFeature({ id: feature.get('id'), data: { start: feature.get('start'),\n                        end: feature.get('end'), score: sample_score } });\n                featureCallback(sample_data);\n            }, finishCallback, errorCallback]);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/vcfview/js/Store/SeqFeature/vcfview.js?");

/***/ }),

/***/ "./plugins/vcfview/js/View/Track/SegmentationMultiBin.js":
/*!***************************************************************!*\
  !*** ./plugins/vcfview/js/View/Track/SegmentationMultiBin.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/Track/Wiggle/XYPlot */ \"./src/JBrowse/View/Track/Wiggle/XYPlot.js\"), __webpack_require__(/*! vcfview/Store/SeqFeature/SegmentationMultiBin */ \"./plugins/vcfview/js/Store/SeqFeature/SegmentationMultiBin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, XYPlot, SegmentationMultiBin) {\n    return declare(XYPlot, {\n        constructor: function constructor(args) {\n            this.store = new SegmentationMultiBin(Object.assign(args, {\n                store: this.store,\n                config: this.config,\n                browser: this.browser\n            }));\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/vcfview/js/View/Track/SegmentationMultiBin.js?");

/***/ }),

/***/ "./plugins/vcfview/js/View/Track/SegmentationTrack.js":
/*!************************************************************!*\
  !*** ./plugins/vcfview/js/View/Track/SegmentationTrack.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/Track/Wiggle/XYPlot */ \"./src/JBrowse/View/Track/Wiggle/XYPlot.js\"), __webpack_require__(/*! vcfview/Store/SeqFeature/Segmentation */ \"./plugins/vcfview/js/Store/SeqFeature/Segmentation.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, XYPlot, Segmentation) {\n    return declare(XYPlot, {\n        constructor: function constructor(args) {\n            console.log(\"testing web integration\", args);\n            this.store = new Segmentation(Object.assign(args, {\n                store: this.store,\n                config: this.config,\n                browser: this.browser\n            }));\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/vcfview/js/View/Track/SegmentationTrack.js?");

/***/ }),

/***/ "./plugins/vcfview/js/main.js":
/*!************************************!*\
  !*** ./plugins/vcfview/js/main.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Plugin */ \"./src/JBrowse/Plugin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, JBrowsePlugin) {\n    return declare(JBrowsePlugin, {\n        constructor: function constructor(args) {\n            var browser = args.browser;\n            console.log('VcfView plugin starting');\n\n            browser.registerTrackType({\n                label: 'VCFSegmentationMultiBin',\n                type: 'vcfview/View/Track/SegmentationMultiBin'\n            });\n\n            browser.registerTrackType({\n                label: 'SegmentationTrack',\n                type: 'vcfview/View/Track/SegmentationTrack'\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./plugins/vcfview/js/main.js?");

/***/ }),

/***/ "./src/JBrowse/BehaviorManager.js":
/*!****************************************!*\
  !*** ./src/JBrowse/BehaviorManager.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    /**\n    * Stores, applies, and removes a named set of behaviors.  A behavior\n    * is a set of event handlers that need to be connected and then\n    * disconnected repeatedly as a group.\n    * @constructor\n    * @class\n    * @param {Object} args.behaviors object containing the behaviors to be managed, as:\n    * <pre>\n    *     {\n    *        behavior_name: {\n    *          apply_on_init: true if this behavior should be applied when the manager is initialized,\n    *          apply: function( manager_object, handles_array ) {\n    *            // required function that returns an array of dojo event handles.  for example:\n    *            return [\n    *                dojo.connect(document.body, \"mouseup\",   this, 'rubberExecute'  ),\n    *                dojo.connect(document.body, \"mousemove\", this, 'rubberMove'     )\n    *            ];\n    *          },\n    *          remove: function( manager_object, handles_array ) {\n    *              // optional function that removes the behavior.  by\n    *              // default dojo.disconnect() is just called on each\n    *              // of the event handles that were returned by the\n    *              // apply function\n    *          }\n    *        },\n    *        ...\n    *     }\n    * </pre>\n    * @param {Object} [args.context=BehaviorManager itself] context\n    *    (i.e. <code>this</code>) in which each of the behavior\n    *    <code>apply()</code> and <code>remove()</code> functions will be\n    *    called.\n    * @lends JBrowse.BehaviorManager\n    */\n    function BehaviorManager(args) {\n        this.context = args.context;\n        this.behaviors = args.behaviors;\n    };\n\n    /**\n     * Apply the behaviors that have <code>apply_on_init</code> true.\n     */\n    BehaviorManager.prototype.initialize = function () {\n        this.removeAll();\n        for (var bname in this.behaviors) {\n            var b = this.behaviors[bname];\n            if (b.apply_on_init) {\n                this.applyBehaviors(bname);\n            }\n        }\n    };\n\n    /**\n     * Apply each of the behaviors named as arguments to this function.\n     * @param {String} [...] Zero or more string behavior names to apply.\n     */\n    BehaviorManager.prototype.applyBehaviors = function () {\n        dojo.forEach(arguments, function (name) {\n            var b = this._get(name);\n            if (!b.applied) {\n                b.handles = b.handles || [];\n                b.handles = b.apply.call(this.context || this, this, b.handles);\n                b.applied = true;\n            }\n        }, this);\n    };\n\n    /**\n     * Look up a behavior by name, throw an exception if it's not there.\n     * @private\n     */\n    BehaviorManager.prototype._get = function (name) {\n        var b = this.behaviors[name];\n        if (!b) throw \"no behavior registed with name '\" + \"'name\";\n        return b;\n    };\n\n    /**\n     * Given two behavior names, remove the first one and apply the second\n     * one.  For convenience.\n     */\n    BehaviorManager.prototype.swapBehaviors = function (off, on) {\n        this.removeBehaviors(off);\n        this.applyBehaviors(on);\n    };\n\n    /**\n     * Remove each of the behaviors named as arguments to this function.\n     * @param {String} [...] Zero or more string behavior names to remove.\n     */\n    BehaviorManager.prototype.removeBehaviors = function () {\n        dojo.forEach(arguments, function (name) {\n            var b = this._get(name);\n            if (b.applied) {\n                var remove = b.remove || function (m, h) {\n                    dojo.forEach(h, dojo.disconnect, dojo);\n                };\n                remove.call(this.context || this, this, b.handles);\n                b.applied = false;\n            }\n        }, this);\n    };\n\n    /**\n     * Remove all behaviors that are currently applied.\n     */\n    BehaviorManager.prototype.removeAll = function () {\n        for (var bname in this.behaviors) {\n            this.removeBehaviors(bname);\n        }\n    };\n\n    return BehaviorManager;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/BehaviorManager.js?");

/***/ }),

/***/ "./src/JBrowse/Browser.js":
/*!********************************!*\
  !*** ./src/JBrowse/Browser.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _package = __webpack_require__(/*! ./package.json */ \"./src/JBrowse/package.json\");\n\nvar _package2 = _interopRequireDefault(_package);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar url = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/html */ \"./node_modules/dojo/html.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/keys */ \"./node_modules/dojo/keys.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/DeferredList */ \"./node_modules/dojo/DeferredList.js\"), __webpack_require__(/*! dojo/topic */ \"./node_modules/dojo/topic.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dojo/request */ \"./node_modules/dojo/request.js\"), __webpack_require__(/*! dojo/io-query */ \"./node_modules/dojo/io-query.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dijit/layout/ContentPane */ \"./node_modules/dijit/layout/ContentPane.js\"), __webpack_require__(/*! dijit/layout/BorderContainer */ \"./node_modules/dijit/layout/BorderContainer.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dijit/form/ComboBox */ \"./node_modules/dijit/form/ComboBox.js\"), __webpack_require__(/*! dojo/store/Memory */ \"./node_modules/dojo/store/Memory.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dijit/form/Select */ \"./node_modules/dijit/form/Select.js\"), __webpack_require__(/*! dijit/form/ToggleButton */ \"./node_modules/dijit/form/ToggleButton.js\"), __webpack_require__(/*! dijit/form/DropDownButton */ \"./node_modules/dijit/form/DropDownButton.js\"), __webpack_require__(/*! dijit/DropDownMenu */ \"./node_modules/dijit/DropDownMenu.js\"), __webpack_require__(/*! dijit/CheckedMenuItem */ \"./node_modules/dijit/CheckedMenuItem.js\"), __webpack_require__(/*! dijit/MenuItem */ \"./node_modules/dijit/MenuItem.js\"), __webpack_require__(/*! dijit/MenuSeparator */ \"./node_modules/dijit/MenuSeparator.js\"), __webpack_require__(/*! dojox/form/TriStateCheckBox */ \"./node_modules/dojox/form/TriStateCheckBox.js\"), __webpack_require__(/*! dojox/html/entities */ \"./node_modules/dojox/html/entities.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store/LazyTrie */ \"./src/JBrowse/Store/LazyTrie.js\"), __webpack_require__(/*! JBrowse/Store/Names/LazyTrieDojoData */ \"./src/JBrowse/Store/Names/LazyTrieDojoData.js\"), __webpack_require__(/*! dojo/store/DataStore */ \"./node_modules/dojo/store/DataStore.js\"), __webpack_require__(/*! JBrowse/FeatureFiltererMixin */ \"./src/JBrowse/FeatureFiltererMixin.js\"), __webpack_require__(/*! JBrowse/GenomeView */ \"./src/JBrowse/GenomeView.js\"), __webpack_require__(/*! JBrowse/TouchScreenSupport */ \"./src/JBrowse/TouchScreenSupport.js\"), __webpack_require__(/*! JBrowse/ConfigManager */ \"./src/JBrowse/ConfigManager.js\"), __webpack_require__(/*! JBrowse/View/InfoDialog */ \"./src/JBrowse/View/InfoDialog.js\"), __webpack_require__(/*! JBrowse/View/FileDialog */ \"./src/JBrowse/View/FileDialog.js\"), __webpack_require__(/*! JBrowse/View/FastaFileDialog */ \"./src/JBrowse/View/FastaFileDialog.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\"), __webpack_require__(/*! JBrowse/View/LocationChoiceDialog */ \"./src/JBrowse/View/LocationChoiceDialog.js\"), __webpack_require__(/*! JBrowse/View/Dialog/SetHighlight */ \"./src/JBrowse/View/Dialog/SetHighlight.js\"), __webpack_require__(/*! JBrowse/View/Dialog/Preferences */ \"./src/JBrowse/View/Dialog/Preferences.js\"), __webpack_require__(/*! JBrowse/View/Dialog/OpenDirectory */ \"./src/JBrowse/View/Dialog/OpenDirectory.js\"), __webpack_require__(/*! JBrowse/View/Dialog/SetTrackHeight */ \"./src/JBrowse/View/Dialog/SetTrackHeight.js\"), __webpack_require__(/*! JBrowse/View/Dialog/QuickHelp */ \"./src/JBrowse/View/Dialog/QuickHelp.js\"), __webpack_require__(/*! JBrowse/View/StandaloneDatasetList */ \"./src/JBrowse/View/StandaloneDatasetList.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/ChromSizes */ \"./src/JBrowse/Store/SeqFeature/ChromSizes.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/UnindexedFasta */ \"./src/JBrowse/Store/SeqFeature/UnindexedFasta.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/IndexedFasta */ \"./src/JBrowse/Store/SeqFeature/IndexedFasta.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/BgzipIndexedFasta */ \"./src/JBrowse/Store/SeqFeature/BgzipIndexedFasta.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/TwoBit */ \"./src/JBrowse/Store/SeqFeature/TwoBit.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! ../lazyload.js */ \"./src/lazyload.js\"), // for dynamic CSS loading\n\n// extras for webpack\n__webpack_require__(/*! dojox/data/CsvStore */ \"./node_modules/dojox/data/CsvStore.js\"), __webpack_require__(/*! dojox/data/JsonRestStore */ \"./node_modules/dojox/data/JsonRestStore.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, on, html, query, domConstruct, keys, Deferred, DeferredList, topic, aspect, request, ioQuery, has, array, dijitContentPane, dijitBorderContainer, dijitDialog, dijitComboBox, dojoMemoryStore, dijitButton, dijitSelectBox, dijitToggleButton, dijitDropDownButton, dijitDropDownMenu, dijitCheckedMenuItem, dijitMenuItem, dijitMenuSeparator, dojoxTriStateCheckBox, dojoxHtmlEntities, Util, LazyTrie, NamesLazyTrieDojoDataStore, DojoDataStore, FeatureFiltererMixin, GenomeView, Touch, ConfigManager, InfoDialog, FileDialog, FastaFileDialog, Location, LocationChoiceDialog, SetHighlightDialog, PreferencesDialog, OpenDirectoryDialog, SetTrackHeightDialog, HelpDialog, StandaloneDatasetList, ChromSizes, UnindexedFasta, IndexedFasta, BgzipIndexedFasta, TwoBit, dijitFocus, LazyLoad) {\n\n    var dojof = Util.dojof;\n\n    require.on('error', function (error) {\n        var errString = error.info && error.info[0] && error.info[0].mid ? error.info.map(function (_ref) {\n            var mid = _ref.mid;\n            return mid;\n        }).join(', ') : error;\n        window.JBrowse.fatalError('Failed to load resource: ' + errString);\n    });\n\n    /**\n     * Construct a new Browser object.\n     * @class This class is the main interface between JBrowse and embedders\n     * @constructor\n     * @param params an object with the following properties:<br>\n     * <ul>\n     * <li><code>config</code> - list of objects with \"url\" property that points to a config JSON file</li>\n     * <li><code>containerID</code> - ID of the HTML element that contains the browser</li>\n     * <li><code>refSeqs</code> - object with \"url\" property that is the URL to list of reference sequence information items</li>\n     * <li><code>browserRoot</code> - (optional) URL prefix for the browser code</li>\n     * <li><code>tracks</code> - (optional) comma-delimited string containing initial list of tracks to view</li>\n     * <li><code>location</code> - (optional) string describing the initial location</li>\n     * <li><code>defaultTracks</code> - (optional) comma-delimited string containing initial list of tracks to view if there are no cookies and no \"tracks\" parameter</li>\n     * <li><code>defaultLocation</code> - (optional) string describing the initial location if there are no cookies and no \"location\" parameter</li>\n     * <li><code>show_nav</code> - (optional) string describing the on/off state of navigation box</li>\n     * <li><code>show_tracklist</code> - (optional) string describing the on/off state of track bar</li>\n     * <li><code>show_overview</code> - (optional) string describing the on/off state of overview</li>\n     * </ul>\n     */\n\n    return declare(FeatureFiltererMixin, {\n\n        constructor: function constructor(params) {\n            this.globalKeyboardShortcuts = {};\n\n            this.config = params || {};\n\n            // if we're in the unit tests, stop here and don't do any more initialization\n            if (this.config.unitTestMode) return;\n\n            // hook for externally applied initialization that can be setup in index.html\n            if (typeof this.config.initExtra === 'function') this.config.initExtra(this, params);\n\n            this.startTime = new Date();\n\n            // start the initialization process\n            var thisB = this;\n\n            dojo.addOnLoad(function () {\n                if (Util.isElectron() && !thisB.config.dataRoot) {\n                    dojo.addClass(document.body, \"jbrowse\");\n                    dojo.addClass(document.body, thisB.config.theme || \"tundra\");\n                    thisB.welcomeScreen(document.body);\n                    return;\n                }\n                thisB.loadConfig().then(function () {\n\n                    thisB.container = dojo.byId(thisB.config.containerID);\n                    thisB.container.onselectstart = function () {\n                        return false;\n                    };\n\n                    // initialize our highlight if one was set in the config\n                    if (thisB.config.initialHighlight && thisB.config.initialHighlight != \"/\") thisB.setHighlight(new Location(thisB.config.initialHighlight));\n\n                    thisB.initPlugins().then(function () {\n                        thisB.loadNames();\n                        thisB.loadUserCSS().then(function () {\n\n                            thisB.initTrackMetadata();\n                            thisB.loadRefSeqs().then(function () {\n\n                                // figure out our initial location\n                                var initialLocString = thisB._initialLocation();\n                                var initialLoc = Util.parseLocString(initialLocString);\n                                if (initialLoc && initialLoc.ref && thisB.allRefs[initialLoc.ref]) {\n                                    thisB.refSeq = thisB.allRefs[initialLoc.ref];\n                                }\n\n                                // before we init the view, make sure that our container has nonzero height and width\n                                thisB.ensureNonzeroContainerDimensions();\n\n                                thisB.initView().then(function () {\n                                    Touch.loadTouch(); // init touch device support\n                                    if (initialLocString) {\n                                        thisB.navigateTo(initialLocString, true);\n                                    }\n\n                                    // figure out what initial track list we will use:\n                                    var tracksToShow = [];\n                                    // always add alwaysOnTracks, regardless of any other track params\n                                    if (thisB.config.alwaysOnTracks) {\n                                        tracksToShow = tracksToShow.concat(thisB.config.alwaysOnTracks.split(\",\"));\n                                    }\n                                    // add tracks specified in URL track param,\n                                    //    if no URL track param then add last viewed tracks via tracks cookie\n                                    //    if no URL param and no tracks cookie, then use defaultTracks\n                                    if (thisB.config.forceTracks) {\n                                        tracksToShow = tracksToShow.concat(thisB.config.forceTracks.split(\",\"));\n                                    } else if (thisB.cookie(\"tracks\")) {\n                                        tracksToShow = tracksToShow.concat(thisB.cookie(\"tracks\").split(\",\"));\n                                    } else if (thisB.config.defaultTracks) {\n                                        // In rare cases thisB.config.defaultTracks already contained an array that appeared to\n                                        // have been split in a previous invocation of this function. Thus, we only try and split\n                                        // it if it isn't already split.\n                                        if (!(thisB.config.defaultTracks instanceof Array)) {\n                                            tracksToShow = tracksToShow.concat(thisB.config.defaultTracks.split(\",\"));\n                                        }\n                                    }\n                                    // currently, force \"DNA\" _only_ if no other guides as to what to show?\n                                    //    or should this be changed to always force DNA to show?\n                                    if (tracksToShow.length == 0) {\n                                        tracksToShow.push(\"DNA\");\n                                    }\n                                    // eliminate track duplicates (may have specified in both alwaysOnTracks and defaultTracks)\n                                    tracksToShow = Util.uniq(tracksToShow);\n                                    thisB.showTracks(tracksToShow);\n\n                                    thisB.passMilestone('completely initialized', { success: true });\n                                });\n                                thisB.reportUsageStats();\n                            });\n                        });\n                    });\n                });\n            });\n        },\n\n        _initialLocation: function _initialLocation() {\n            var oldLocMap = dojo.fromJson(this.cookie('location')) || {};\n            if (this.config.location) {\n                return this.config.location;\n            } else if (oldLocMap[this.refSeq.name]) {\n                return oldLocMap[this.refSeq.name].l || oldLocMap[this.refSeq.name];\n            } else if (this.config.defaultLocation) {\n                return this.config.defaultLocation;\n            } else {\n                return Util.assembleLocString({\n                    ref: this.refSeq.name,\n                    start: 0.4 * (this.refSeq.start + this.refSeq.end),\n                    end: 0.6 * (this.refSeq.start + this.refSeq.end)\n                });\n            }\n        },\n\n        version: function () {\n            // when a build is put together, the build system assigns a string\n            // to the variable below.\n            return _package2.default.version;\n        }.call(),\n\n        /**\n         * Get a plugin, if it is present.  Note that, if plugin\n         * initialization is not yet complete, it may be a while before the\n         * callback is called.\n         *\n         * Callback is called with one parameter, the desired plugin object,\n         * or undefined if it does not exist.\n         */\n        getPlugin: function getPlugin(name, callback) {\n            this.afterMilestone('initPlugins', dojo.hitch(this, function () {\n                callback(this.plugins[name]);\n            }));\n        },\n\n        _corePlugins: function _corePlugins() {\n            return ['RegexSequenceSearch'];\n        },\n\n        /**\n         * Load and instantiate any plugins defined in the configuration.\n         */\n        initPlugins: function initPlugins() {\n            return this._milestoneFunction('initPlugins', function (deferred) {\n                var _this = this;\n\n                this.plugins = {};\n\n                var plugins = this.config.plugins || this.config.Plugins || {};\n\n                // coerce plugins to array of objects\n                if (!lang.isArray(plugins) && !plugins.name) {\n                    // plugins like  { Foo: {...}, Bar: {...} }\n                    plugins = function () {\n                        var newplugins = [];\n                        for (var pname in plugins) {\n                            if (lang.isObject(plugins[pname]) && !('name' in plugins[pname])) {\n                                plugins[pname].name = pname;\n                            }\n                            newplugins.push(plugins[pname]);\n                        }\n                        return newplugins;\n                    }.call(this);\n                }\n                if (!lang.isArray(plugins)) plugins = [plugins];\n\n                plugins.unshift.apply(plugins, this._corePlugins());\n\n                // coerce string plugin names to {name: 'Name'}\n                plugins = array.map(plugins, function (p) {\n                    return (typeof p === 'undefined' ? 'undefined' : _typeof(p)) == 'object' ? p : { 'name': p };\n                });\n\n                if (!plugins.length) {\n                    deferred.resolve({ success: true });\n                    return;\n                }\n\n                // set default locations for each plugin\n                plugins.forEach(function (p) {\n                    // find the entry in the dojoConfig for this plugin\n                    var configEntry = dojoConfig.packages.find(function (c) {\n                        return c.name === p.name;\n                    });\n                    if (configEntry) {\n                        p.css = configEntry.css ? configEntry.pluginDir + '/' + configEntry.css : false;\n                        p.js = configEntry.location;\n                    } else {\n                        _this.fatalError('plugin ' + p.name + ' not found. You can rebuild JBrowse with a -dev release or github clone with this plugin in the plugin folder');\n                    }\n                });\n\n                var pluginDeferreds = array.map(plugins, function (p) {\n                    return new Deferred();\n                });\n\n                // fire the \"all plugins done\" deferred when all of the plugins are done loading\n                new DeferredList(pluginDeferreds).then(function () {\n                    deferred.resolve({ success: true });\n                });\n\n                dojo.global.require(array.map(plugins, function (p) {\n                    return p.name + '/main';\n                }), dojo.hitch(this, function () {\n                    array.forEach(arguments, function (pluginClass, i) {\n                        var plugin = plugins[i];\n                        var thisPluginDone = pluginDeferreds[i];\n                        if (typeof pluginClass == 'string') {\n                            console.error(\"could not load plugin \" + plugin.name + \": \" + pluginClass);\n                        } else {\n                            // make the plugin's arguments out of\n                            // its little obj in 'plugins', and\n                            // also anything in the top-level\n                            // conf under its plugin name\n                            var args = dojo.mixin(dojo.clone(plugins[i]), { config: this.config[plugin.name] || {} });\n                            args.browser = this;\n                            args = dojo.mixin(args, { browser: this });\n\n                            // load its css\n                            var cssLoaded;\n                            if (plugin.css) {\n                                cssLoaded = this._loadCSS({\n                                    url: this.resolveUrl(plugin.css + '/main.css')\n                                });\n                            } else {\n                                cssLoaded = new Deferred();\n                                cssLoaded.resolve();\n                            }\n                            cssLoaded.then(function () {\n                                thisPluginDone.resolve({ success: true });\n                            });\n\n                            // give the plugin access to the CSS\n                            // promise so it can know when its\n                            // CSS is ready\n                            args.cssLoaded = cssLoaded;\n\n                            // instantiate the plugin\n                            this.plugins[plugin.name] = new pluginClass(args);\n                        }\n                    }, this);\n                }));\n            });\n        },\n\n        /**\n         * Resolve a URL relative to the browserRoot.\n         */\n        resolveUrl: function resolveUrl(url) {\n            var browserRoot = this.config.browserRoot || this.config.baseUrl || \"\";\n\n            return Util.resolveUrl(browserRoot, url);\n        },\n\n        welcomeScreen: function welcomeScreen(container, error) {\n            var thisB = this;\n            __webpack_require__.e(/*! AMD require */ 14).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! dojo/text!JBrowse/View/Resource/Welcome.html */ \"./node_modules/raw-loader/index.js!./src/JBrowse/View/Resource/Welcome.html\")]; (function (Welcome) {\n                container.innerHTML = Welcome;\n                var topPane = dojo.create('div', { style: { overflow: 'hidden' } }, thisB.container);\n                dojo.byId('welcome').innerHTML = \"Welcome! To get started with <i>JBrowse-\" + thisB.version + \"</i>, select a sequence file or an existing data directory\";\n\n                on(dojo.byId('newOpen'), 'click', dojo.hitch(thisB, 'openFastaElectron'));\n                on(dojo.byId('newOpenDirectory'), 'click', function () {\n                    new OpenDirectoryDialog({\n                        browser: thisB,\n                        setCallback: dojo.hitch(thisB, 'openDirectoryElectron')\n                    }).show();\n                });\n\n                try {\n                    thisB.loadSessions();\n                } catch (e) {\n                    console.error(e);\n                }\n\n                if (error) {\n                    console.log(error);\n                    var errors_div = dojo.byId('fatal_error_list');\n                    dojo.create('div', { className: 'error', innerHTML: error }, errors_div);\n                }\n\n                request(thisB.resolveUrl('sample_data/json/volvox/successfully_run')).then(function () {\n                    try {\n                        document.getElementById('volvox_data_placeholder').innerHTML = 'The example dataset is also available. View <a href=\"?data=sample_data/json/volvox\">Volvox test data here</a>.';\n                    } catch (e) {}\n                });\n            }).apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);}).catch(__webpack_require__.oe);\n        },\n\n        /**\n         * Make sure the browser container has nonzero container dimensions.  If not,\n         * set some hardcoded dimensions and log a warning.\n         */\n        ensureNonzeroContainerDimensions: function ensureNonzeroContainerDimensions() {\n            var containerWidth = this.container.offsetWidth;\n            var containerHeight = this.container.offsetHeight;\n            if (!containerWidth) {\n                console.warn('JBrowse container element #' + this.config.containerID + ' has no width, please set one with CSS. Setting fallback width of 640 pixels');\n                this.container.style.width = '640px';\n            }\n            if (!containerHeight) {\n                console.warn('JBrowse container element #' + this.config.containerID + ' has no height, please set one with CSS. Setting fallback height of 480 pixels');\n                this.container.style.height = '480px';\n            }\n        },\n\n\n        /**\n         * Main error handler.  Displays links to configuration help or a\n         * dataset selector in the main window.  Called when the main browser\n         * cannot run at all, because of configuration errors or whatever.\n         */\n        fatalError: function fatalError(error) {\n\n            function formatError(error) {\n                if (error) {\n                    if (error.status) {\n                        error = error.status + ' (' + error.statusText + ') when attempting to fetch ' + error.url;\n                    }\n                    console.error(error.stack || '' + error);\n                    error = error + '';\n                    if (!/\\.$/.exec(error)) error = error + '.';\n\n                    error = dojoxHtmlEntities.encode(error);\n                }\n                return error;\n            }\n\n            if (!this.renderedFatalErrors) {\n                // if the error is just that there are no ref seqs defined,\n                // and there are datasets defined in the conf file, then just\n                // show a little HTML list of available datasets\n                if (/^Could not load reference sequence/.test(error) && this.config.datasets && !this.config.datasets._DEFAULT_EXAMPLES) {\n                    dojo.empty(this.container);\n                    new StandaloneDatasetList({ datasets: this.config.datasets }).placeAt(this.container);\n                } else {\n                    var container = this.container || document.body;\n                    var thisB = this;\n\n                    dojo.addClass(document.body, this.config.theme || \"tundra\"); //< tundra dijit theme\n\n                    if (!Util.isElectron()) {\n                        __webpack_require__.e(/*! AMD require */ 15).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(/*! dojo/text!JBrowse/View/Resource/Welcome_old.html */ \"./node_modules/raw-loader/index.js!./src/JBrowse/View/Resource/Welcome_old.html\")]; (function (Welcome_old) {\n                            container.innerHTML = Welcome_old;\n                            if (error) {\n                                var errors_div = dojo.byId('fatal_error_list');\n                                dojo.create('div', { className: 'error', innerHTML: formatError(error) + '' }, errors_div);\n                            }\n                            request(thisB.resolveUrl('sample_data/json/volvox/successfully_run')).then(function () {\n                                try {\n                                    dojo.byId('volvox_data_placeholder').innerHTML = 'However, it appears you have successfully run <code>./setup.sh</code>, so you can see the <a href=\"?data=sample_data/json/volvox\">Volvox test data here</a>.';\n                                } catch (e) {}\n                            });\n                        }).apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__);}).catch(__webpack_require__.oe);\n                    } else {\n                        this.welcomeScreen(container, formatError(error));\n                    }\n\n                    this.renderedFatalErrors = true;\n                }\n            } else {\n                var errors_div = dojo.byId('fatal_error_list') || document.body;\n                dojo.create('div', { className: 'error', innerHTML: formatError(error) + '' }, errors_div);\n            }\n        },\n        loadSessions: function loadSessions() {\n            var fs = electronRequire('fs');\n            var app = electronRequire('electron').remote.app;\n            var path = this.config.electronData + '/sessions.json';\n\n            var obj = JSON.parse(fs.readFileSync(path, 'utf8'));\n            var table = dojo.create('table', { id: 'previousSessionsTable', style: { overflow: 'hidden', width: '90%' } }, dojo.byId('previousSessions'));\n            var thisB = this;\n\n            if (!obj.length) {\n                var tr = dojo.create('tr', {}, table);\n                dojo.create('div', { 'innerHTML': '<ul><li>No sessions yet!</li></ul>' }, tr);\n            }\n            array.forEach(obj, function (session) {\n                var tr = dojo.create('tr', {}, table);\n                var url = window.location.href.split('?')[0] + \"?data=\" + Util.replacePath(session.session);\n                dojo.create('div', {\n                    \"class\": \"dijitIconDelete\",\n                    onclick: function onclick(e) {\n                        if (confirm(\"This will simply delete your session from the list, it won't remove any data files. Are you sure you want to continue?\")) {\n                            dojo.empty(table);\n                            var index = obj.indexOf(session);\n                            if (index != -1) {\n                                obj.splice(index, 1);\n                            }\n                            fs.writeFileSync(path, JSON.stringify(obj, null, 2), 'utf8');\n                            thisB.loadSessions();\n                        }\n                    }\n                }, tr);\n                dojo.create('td', { 'innerHTML': '<a href=\"' + url + '\">' + session.session + '</a>' }, tr);\n            });\n        },\n        loadRefSeqs: function loadRefSeqs() {\n            var thisB = this;\n            return this._milestoneFunction('loadRefSeqs', function (deferred) {\n                var _this2 = this;\n\n                // load our ref seqs\n                if (typeof this.config.refSeqs == 'string') {\n                    // assume this.config.refSeqs is a url if it is string\n                    this.config.refSeqs = {\n                        url: this.config.refSeqs\n                    };\n                }\n\n                if (this.config.refSeqs.storeClass) {\n                    dojo.global.require([this.config.refSeqs.storeClass], function (CLASS) {\n                        var r = new CLASS(Object.assign({ browser: _this2 }, _this2.config.refSeqs));\n                        r.getRefSeqs(function (refSeqs) {\n                            thisB.addRefseqs(refSeqs);\n                            deferred.resolve({ success: true });\n                        }, function (error) {\n                            deferred.reject(error);\n                        });\n                    });\n                } else {\n                    // check refseq urls\n                    if (this.config.refSeqs.url && this.config.refSeqs.url.match(/.fai$/)) {\n                        new IndexedFasta({ browser: this, faiUrlTemplate: this.config.refSeqs.url }).getRefSeqs(function (refSeqs) {\n                            thisB.addRefseqs(refSeqs);\n                            deferred.resolve({ success: true });\n                        }, function (error) {\n                            deferred.reject(error);\n                        });\n                        return;\n                    } else if (this.config.refSeqs.url && this.config.refSeqs.url.match(/.2bit$/)) {\n                        new TwoBit({ browser: this, urlTemplate: this.config.refSeqs.url }).getRefSeqs(function (refSeqs) {\n                            thisB.addRefseqs(refSeqs);\n                            deferred.resolve({ success: true });\n                        }, function (error) {\n                            deferred.reject(error);\n                        });\n                    } else if (this.config.refSeqs.url && (this.config.refSeqs.url.match(/.fa$/) || this.config.refSeqs.url.match(/.fasta$/))) {\n                        new UnindexedFasta({ browser: this, urlTemplate: this.config.refSeqs.url }).getRefSeqs(function (refSeqs) {\n                            thisB.addRefseqs(refSeqs);\n                            deferred.resolve({ success: true });\n                        }, function (error) {\n                            deferred.reject(error);\n                        });\n                    } else if (this.config.refSeqs.url && this.config.refSeqs.url.match(/.sizes/)) {\n                        new ChromSizes({ browser: this, urlTemplate: this.config.refSeqs.url }).getRefSeqs(function (refSeqs) {\n                            thisB.addRefseqs(refSeqs);\n                            deferred.resolve({ success: true });\n                        }, function (error) {\n                            deferred.reject(error);\n                        });\n                    } else if ('data' in this.config.refSeqs) {\n                        this.addRefseqs(this.config.refSeqs.data);\n                        deferred.resolve({ success: true });\n                    } else {\n                        request(this.resolveUrl(this.config.refSeqs.url), {\n                            handleAs: 'text',\n                            headers: {\n                                'X-Requested-With': null\n                            }\n                        }).then(function (o) {\n                            thisB.addRefseqs(dojo.fromJson(o));\n                            deferred.resolve({ success: true });\n                        }, function (e) {\n                            deferred.reject('Could not load reference sequence definitions. ' + e);\n                        });\n                    }\n                }\n            });\n        },\n\n        loadUserCSS: function loadUserCSS() {\n            return this._milestoneFunction('loadUserCSS', function (deferred) {\n                if (this.config.css && !lang.isArray(this.config.css)) this.config.css = [this.config.css];\n\n                var css = this.config.css || [];\n                if (!css.length) {\n                    deferred.resolve({ success: true });\n                    return;\n                }\n\n                var that = this;\n                var cssDeferreds = array.map(css, function (css) {\n                    return that._loadCSS(css);\n                });\n\n                new DeferredList(cssDeferreds).then(function () {\n                    deferred.resolve({ success: true });\n                });\n            });\n        },\n\n        _loadCSS: function _loadCSS(css) {\n            var deferred = new Deferred();\n            if (typeof css == 'string') {\n                // if it has '{' in it, it probably is not a URL, but is a string of CSS statements\n                if (css.indexOf('{') > -1) {\n                    dojo.create('style', { \"data-from\": 'JBrowse Config', type: 'text/css', innerHTML: css }, document.head);\n                    deferred.resolve(true);\n                }\n                // otherwise, it must be a URL\n                else {\n                        css = { url: css };\n                    }\n            }\n            if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) == 'object') {\n                LazyLoad.css(css.url, function () {\n                    deferred.resolve(true);\n                });\n            }\n            return deferred;\n        },\n\n        /**\n         * Load our name index.\n         */\n        loadNames: function loadNames() {\n            return this._milestoneFunction('loadNames', function (deferred) {\n                var conf = dojo.mixin(dojo.clone(this.config.names || {}), this.config.autocomplete || {});\n                if (!conf.url) conf.url = this.config.nameUrl || 'data/names/';\n\n                if (conf.baseUrl) conf.url = Util.resolveUrl(conf.baseUrl, conf.url);\n\n                var type;\n                if (type = conf.type) {\n                    var thisB = this;\n                    if (type.indexOf('/') == -1) type = 'JBrowse/Store/Names/' + type;\n                    dojo.global.require([type], function (CLASS) {\n                        thisB.nameStore = new CLASS(dojo.mixin({ browser: thisB }, conf));\n                        deferred.resolve({ success: true });\n                    });\n                }\n                // no name type setting, must be the legacy store\n                else {\n                        // wrap the older LazyTrieDojoDataStore with\n                        // dojo.store.DataStore to conform with the dojo/store API\n                        this.nameStore = new DojoDataStore({\n                            store: new NamesLazyTrieDojoDataStore({\n                                browser: this,\n                                namesTrie: new LazyTrie(conf.url, \"lazy-{Chunk}.json\"),\n                                stopPrefixes: conf.stopPrefixes,\n                                resultLimit: conf.resultLimit || 15,\n                                tooManyMatchesMessage: conf.tooManyMatchesMessage\n                            })\n                        });\n                        deferred.resolve({ success: true });\n                    }\n            });\n        },\n\n        /**\n         * Compare two reference sequence names, returning -1, 0, or 1\n         * depending on the result.  Case insensitive, insensitive to the\n         * presence or absence of prefixes like 'chr', 'chrom', 'ctg',\n         * 'contig', 'scaffold', etc\n         */\n        compareReferenceNames: function compareReferenceNames(a, b) {\n            return this.regularizeReferenceName(a).localeCompare(this.regularizeReferenceName(b));\n        },\n\n        /**\n         * Regularize the reference sequence name in a location.\n         */\n        regularizeLocation: function regularizeLocation(location) {\n            var ref = this.findReferenceSequence(location.ref || location.objectName);\n            if (ref) location.ref = ref.name;\n            return location;\n        },\n\n        regularizeReferenceName: function regularizeReferenceName(refname) {\n\n            if (this.config.exactReferenceSequenceNames) return refname;\n\n            refname = refname.toLowerCase();\n\n            // special case of double regularizing behaving badly\n            if (refname.match(/^chrm/)) {\n                return 'chrm';\n            }\n\n            refname = refname.replace(/^chro?m?(osome)?/, 'chr').replace(/^co?n?ti?g/, 'ctg').replace(/^scaff?o?l?d?/, 'scaffold').replace(/^([a-z]*)0+/, '$1').replace(/^(\\d+l?r?|x|y)$/, 'chr$1').replace(/^(x?)(ix|iv|v?i{0,3})$/, 'chr$1$2').replace(/^mt?(dna)?$/, 'chrm');\n\n            return refname;\n        },\n\n        initView: function initView() {\n            var thisObj = this;\n            return this._milestoneFunction('initView', function (deferred) {\n                var _this3 = this;\n\n                //set up top nav/overview pane and main GenomeView pane\n                dojo.addClass(this.container, \"jbrowse\"); // browser container has an overall .jbrowse class\n                dojo.addClass(document.body, this.config.theme || \"tundra\"); //< tundra dijit theme\n\n                var topPane = dojo.create('div', { style: { overflow: 'hidden' } }, this.container);\n\n                var about = this.browserMeta();\n                var aboutDialog = new InfoDialog({\n                    title: 'About ' + about.title,\n                    content: about.description,\n                    className: 'about-dialog'\n                });\n\n                // make our top menu bar\n                var menuBar = dojo.create('div', {\n                    className: this.config.show_nav ? 'menuBar' : 'topLink'\n                });\n                thisObj.menuBar = menuBar;\n                if (this.config.show_menu) {\n                    (this.config.show_nav ? topPane : this.container).appendChild(menuBar);\n                }\n\n                var overview = dojo.create('div', { className: 'overview', id: 'overview' }, topPane);\n                this.overviewDiv = overview;\n                // overview=0 hides the overview, but we still need it to exist\n                if (!this.config.show_overview) overview.style.cssText = \"display: none\";\n\n                if (Util.isElectron() && !this.config.hideGenomeOptions) {\n                    this.addGlobalMenuItem(this.config.classicMenu ? 'file' : 'dataset', new dijitMenuItem({\n                        id: 'menubar_dataset_file',\n                        label: \"Open sequence file\",\n                        iconClass: 'dijitIconFolderOpen',\n                        onClick: dojo.hitch(this, 'openFastaElectron')\n                    }));\n                    this.addGlobalMenuItem(this.config.classicMenu ? 'file' : 'dataset', new dijitMenuItem({\n                        id: 'menubar_dataset_directory',\n                        label: \"Open data directory\",\n                        iconClass: 'dijitIconFolderOpen',\n                        onClick: function onClick() {\n                            new OpenDirectoryDialog({\n                                browser: thisObj,\n                                setCallback: dojo.hitch(thisObj, 'openDirectoryElectron')\n                            }).show();\n                        }\n                    }));\n                    this.addGlobalMenuItem(this.config.classicMenu ? 'file' : 'dataset', new dijitMenuItem({\n                        id: 'menubar_dataset_save',\n                        label: \"Save session\",\n                        iconClass: 'dijitIconSave',\n                        onClick: dojo.hitch(this, 'saveData')\n                    }));\n                    this.addGlobalMenuItem(this.config.classicMenu ? 'file' : 'dataset', new dijitMenuItem({\n                        id: 'menubar_dataset_home',\n                        label: \"Return to main menu\",\n                        iconClass: 'dijitIconTask',\n                        onClick: dojo.hitch(this, function () {\n                            var container = thisObj.container || document.body;thisObj.welcomeScreen(container);\n                        })\n                    }));\n                } else if (!this.config.hideGenomeOptions) {\n                    this.addGlobalMenuItem(this.config.classicMenu ? 'file' : 'dataset', new dijitMenuItem({\n                        id: 'menubar_dataset_open',\n                        label: \"Open sequence file\",\n                        iconClass: 'dijitIconFolderOpen',\n                        onClick: dojo.hitch(this, 'openFasta')\n                    }));\n                }\n\n                if (this.config.show_nav) {\n                    this.navbox = this.createNavBox(topPane);\n\n                    // make the dataset menu\n                    if (this.config.classicMenu) {\n                        if (this.config.datasets && !this.config.dataset_id) {\n                            console.warn(\"In JBrowse configuration, datasets specified, but dataset_id not set.  Dataset selector will not be shown.\");\n                        }\n                        if (this.config.datasets && this.config.dataset_id) {\n                            this.renderDatasetSelect(menuBar);\n                        } else {\n\n                            this.poweredByLink = dojo.create('a', {\n                                className: 'powered_by',\n                                innerHTML: this.browserMeta().title,\n                                title: 'powered by JBrowse'\n                            }, menuBar);\n                            thisObj.poweredBy_clickHandle = dojo.connect(this.poweredByLink, \"onclick\", dojo.hitch(aboutDialog, 'show'));\n                        }\n                    } else this.renderDatasetSelect(menuBar);\n\n                    // make the file menu\n                    this.addGlobalMenuItem('file', new dijitMenuItem({\n                        id: 'menubar_fileopen',\n                        label: 'Open track file or URL',\n                        iconClass: 'dijitIconFolderOpen',\n                        onClick: dojo.hitch(this, 'openFileDialog')\n                    }));\n\n                    this.addGlobalMenuItem('file', new dijitMenuSeparator());\n\n                    this.fileDialog = new FileDialog({ browser: this });\n\n                    this.addGlobalMenuItem('file', new dijitMenuItem({\n                        id: 'menubar_combotrack',\n                        label: 'Add combination track',\n                        iconClass: 'dijitIconSample',\n                        onClick: dojo.hitch(this, 'createCombinationTrack')\n                    }));\n\n                    this.renderGlobalMenu('file', { text: this.config.classicMenu ? 'File' : 'Track' }, menuBar);\n\n                    // make the view menu\n                    this.addGlobalMenuItem('view', new dijitMenuItem({\n                        id: 'menubar_sethighlight',\n                        label: 'Set highlight',\n                        iconClass: 'dijitIconFilter',\n                        onClick: function onClick() {\n                            new SetHighlightDialog({\n                                browser: thisObj,\n                                setCallback: dojo.hitch(thisObj, 'setHighlightAndRedraw')\n                            }).show();\n                        }\n                    }));\n                    // make the menu item for clearing the current highlight\n                    this._highlightClearButton = new dijitMenuItem({\n                        id: 'menubar_clearhighlight',\n                        label: 'Clear highlight',\n                        iconClass: 'dijitIconFilter',\n                        onClick: dojo.hitch(this, function () {\n                            var h = this.getHighlight();\n                            if (h) {\n                                this.clearHighlight();\n                                this.view.redrawRegion(h);\n                            }\n                        })\n                    });\n                    this._updateHighlightClearButton(); //< sets the label and disabled status\n                    // update it every time the highlight changes\n                    this.subscribe('/jbrowse/v1/n/globalHighlightChanged', dojo.hitch(this, '_updateHighlightClearButton'));\n\n                    this.addGlobalMenuItem('view', this._highlightClearButton);\n\n                    // add a global menu item for resizing all visible quantitative tracks\n                    this.addGlobalMenuItem('view', new dijitMenuItem({\n                        label: 'Resize quant. tracks',\n                        id: 'menubar_settrackheight',\n                        title: 'Set all visible quantitative tracks to a new height',\n                        iconClass: 'jbrowseIconVerticalResize',\n                        onClick: function onClick() {\n                            new SetTrackHeightDialog({\n                                setCallback: function setCallback(height) {\n                                    var tracks = thisObj.view.visibleTracks();\n                                    array.forEach(tracks, function (track) {\n                                        // operate only on XYPlot or Density tracks\n                                        if (!/\\b(XYPlot|Density)/.test(track.config.type)) return;\n\n                                        track.trackHeightChanged = true;\n                                        track.updateUserStyles({ height: height });\n                                    });\n                                }\n                            }).show();\n                        }\n                    }));\n\n                    if (!this.config.disableSearch) {\n                        this.addGlobalMenuItem('view', new dijitMenuItem({\n                            label: 'Search features',\n                            id: 'menubar_search',\n                            title: 'Search for features',\n                            onClick: function onClick() {\n                                var conf = dojo.mixin(dojo.clone(_this3.config.names || {}), _this3.config.autocomplete || {});\n\n                                var type = conf.dialog || 'JBrowse/View/Dialog/Search';\n                                dojo.global.require([type], function (CLASS) {\n                                    new CLASS(dojo.mixin({ browser: _this3 }, conf)).show();\n                                });\n                            }\n                        }));\n                    }\n\n                    if (!this.config.disableReset) {\n                        this.addGlobalMenuItem('view', new dijitMenuItem({\n                            label: 'Reset to defaults',\n                            id: 'menubar_reset_button',\n                            title: 'Reset view and tracks to defaults',\n\n                            onClick: function onClick() {\n                                // resets zoom and location to default\n                                thisObj.navigateToLocation({\n                                    ref: thisObj.refSeq.name,\n                                    start: 0.4 * (thisObj.refSeq.start + thisObj.refSeq.end),\n                                    end: 0.6 * (thisObj.refSeq.start + thisObj.refSeq.end)\n                                });\n\n                                // hide all tracks\n                                thisObj.publish('/jbrowse/v1/v/tracks/hide', thisObj.config.tracks);\n\n                                var tracksToShow = [];\n\n                                // the below code mainly follows the code that decides the default tracks in the constructor,\n                                // but it's different enough that it doesn't easily make a reusable function. Good idea for future refactor?\n\n                                // always add alwaysOnTracks, regardless of any other track params\n                                if (thisObj.config.alwaysOnTracks) {\n                                    tracksToShow = tracksToShow.concat(thisObj.config.alwaysOnTracks.split(\",\"));\n                                }\n                                if (tracksToShow.length == 0) {\n                                    tracksToShow.push(\"DNA\");\n                                }\n                                if (thisObj.config.defaultTracks) {\n                                    // In rare cases thisObj.config.defaultTracks already contained an array that appeared to\n                                    // have been split in a previous invocation of this function. Thus, we only try and split\n                                    // it if it isn't already split.\n                                    if (!(thisObj.config.defaultTracks instanceof Array)) {\n                                        tracksToShow = tracksToShow.concat(thisObj.config.defaultTracks.split(\",\"));\n                                    }\n                                }\n                                tracksToShow = Util.uniq(tracksToShow);\n\n                                thisObj.showTracks(tracksToShow);\n                            }\n                        }));\n                    }\n\n                    this.renderGlobalMenu('view', { text: 'View' }, menuBar);\n\n                    // make the options menu\n                    this.renderGlobalMenu('options', { text: 'Options', title: 'configure JBrowse' }, menuBar);\n                }\n                function showHelp() {\n                    new HelpDialog(lang.mixin(thisObj.config.quickHelp || {}, { browser: thisObj })).show();\n                }\n                if (this.config.show_nav) {\n                    // make the help menu\n                    this.addGlobalMenuItem('help', new dijitMenuItem({\n                        id: 'menubar_about',\n                        label: 'About',\n                        //iconClass: 'dijitIconFolderOpen',\n                        onClick: dojo.hitch(aboutDialog, 'show')\n                    }));\n\n                    this.setGlobalKeyboardShortcut('?', showHelp);\n                    this.addGlobalMenuItem('help', new dijitMenuItem({\n                        id: 'menubar_generalhelp',\n                        label: 'General',\n                        iconClass: 'jbrowseIconHelp',\n                        onClick: showHelp\n                    }));\n\n                    this.renderGlobalMenu('help', {}, menuBar);\n\n                    if (!this.config.classicMenu) {\n                        var datasetName = lang.getObject('config.datasets.' + this.config.dataset_id + '.name', false, this);\n                        this.menuBarDatasetName = dojo.create('div', {\n                            className: 'dataset-name',\n                            innerHTML: datasetName,\n                            title: 'name of current dataset',\n                            style: {\n                                display: datasetName ? 'inline-block' : 'none'\n                            }\n                        }, menuBar);\n                    }\n                }\n\n                if (this.config.show_nav && this.config.show_tracklist && this.config.show_overview && !Util.isElectron()) {\n                    var shareLink = this.makeShareLink();\n                    if (shareLink) {\n                        menuBar.appendChild(shareLink);\n                    }\n                } else if (Util.isElectron()) {\n                    var snapLink = this.makeSnapLink();\n                    if (snapLink) {\n                        menuBar.appendChild(snapLink);\n                    }\n                } else {\n                    if (this.config.show_fullviewlink) menuBar.appendChild(this.makeFullViewLink());\n                }\n\n                this.viewElem = document.createElement(\"div\");\n                this.viewElem.className = \"dragWindow\";\n                this.container.appendChild(this.viewElem);\n\n                this.containerWidget = new dijitBorderContainer({\n                    liveSplitters: false,\n                    design: \"sidebar\",\n                    gutters: false\n                }, this.container);\n                var contentWidget = new dijitContentPane({ region: \"top\" }, topPane);\n\n                // hook up GenomeView\n                this.view = this.viewElem.view = new GenomeView({ browser: this,\n                    elem: this.viewElem,\n                    config: this.config.view,\n                    stripeWidth: 250,\n                    refSeq: this.refSeq\n                });\n\n                dojo.connect(this.view, \"onFineMove\", this, \"onFineMove\");\n                dojo.connect(this.view, \"onCoarseMove\", this, \"onCoarseMove\");\n\n                this.browserWidget = new dijitContentPane({ region: \"center\" }, this.viewElem);\n                dojo.connect(this.browserWidget, \"resize\", this, 'onResize');\n                dojo.connect(this.browserWidget, \"resize\", this.view, 'onResize');\n\n                //connect events to update the URL in the location bar\n                function updateLocationBar() {\n                    var shareURL = thisObj.makeCurrentViewURL();\n                    if (thisObj.config.updateBrowserURL && window.history && window.history.replaceState) window.history.replaceState({}, \"\", shareURL);\n                    if (thisObj.config.update_browser_title) document.title = thisObj.browserMeta().title + ' ' + thisObj.view.visibleRegionLocString();\n                };\n                dojo.connect(this, \"onCoarseMove\", updateLocationBar);\n                this.subscribe('/jbrowse/v1/n/tracks/visibleChanged', updateLocationBar);\n                this.subscribe('/jbrowse/v1/n/globalHighlightChanged', updateLocationBar);\n\n                //set initial location\n                this.afterMilestone('loadRefSeqs', dojo.hitch(this, function () {\n                    this.afterMilestone('initTrackMetadata', dojo.hitch(this, function () {\n                        this.createTrackList().then(dojo.hitch(this, function () {\n\n                            this.containerWidget.startup();\n                            this.onResize();\n\n                            // make our global keyboard shortcut handler\n                            on(document.body, 'keypress', dojo.hitch(this, 'globalKeyHandler'));\n\n                            // configure our event routing\n                            this._initEventRouting();\n\n                            // done with initView\n                            deferred.resolve({ success: true });\n                        }));\n                    }));\n                }));\n            });\n        },\n\n        createCombinationTrack: function createCombinationTrack() {\n            if (this._combinationTrackCount === undefined) this._combinationTrackCount = 0;\n            var d = new Deferred();\n            var storeConf = {\n                browser: this,\n                refSeq: this.refSeq,\n                type: 'JBrowse/Store/SeqFeature/Combination'\n            };\n            var storeName = this.addStoreConfig(undefined, storeConf);\n            storeConf.name = storeName;\n            this.getStore(storeName, function (store) {\n                d.resolve(true);\n            });\n            var thisB = this;\n            d.promise.then(function () {\n                var combTrackConfig = {\n                    type: 'JBrowse/View/Track/Combination',\n                    label: \"combination_track\" + thisB._combinationTrackCount++,\n                    key: \"Combination Track \" + thisB._combinationTrackCount,\n                    metadata: { Description: \"Drag-and-drop interface that creates a track out of combinations of other tracks.\" },\n                    store: storeName\n                };\n                // send out a message about how the user wants to create the new tracks\n                thisB.publish('/jbrowse/v1/v/tracks/new', [combTrackConfig]);\n\n                // Open the track immediately\n                thisB.publish('/jbrowse/v1/v/tracks/show', [combTrackConfig]);\n            });\n        },\n\n        renderDatasetSelect: function renderDatasetSelect(parent) {\n            var _this4 = this;\n\n            var thisB = this;\n\n            if (this.config.classicMenu) {\n                var dsconfig = this.config.datasets || {};\n                var datasetChoices = [];\n                for (var id in dsconfig) {\n                    if (!/^_/.test(id)) datasetChoices.push(Object.assign({ id: id }, dsconfig[id]));\n                }\n\n                var combobox = new dijitComboBox({\n                    name: 'dataset',\n                    className: 'dataset_select',\n                    value: this.config.datasets[this.config.dataset_id].name,\n                    store: new dojoMemoryStore({\n                        data: datasetChoices\n                    }),\n                    onChange: function onChange(dsName) {\n                        if (!dsName) return false;\n                        var dsID = datasetChoices.find(function (d) {\n                            return d.name === dsName;\n                        }).id;\n                        var ds = (_this4.config.datasets || {})[dsID];\n                        var conf = _this4.config;\n                        if (ds) {\n                            var link2Parent = conf.datasetLinkToParentIframe || false;\n                            if (link2Parent) window.parent.location = ds.url;else window.location = ds.url;\n                        }\n                        return false;\n                    }\n                });\n                combobox.placeAt(parent);\n                combobox.focusNode.onclick = function () {\n                    this.select();\n                };\n                if (this.config.datasetSelectorWidth) {\n                    combobox.domNode.style.width = this.config.datasetSelectorWidth;\n                    combobox.focusNode.style.width = this.config.datasetSelectorWidth;\n                }\n            } else {\n                var id;\n                var dataset;\n\n                (function () {\n                    var conf = _this4.config;\n                    if (_this4.config.datasets && _this4.config.dataset_id) {\n                        _this4.addGlobalMenuItem('dataset', new dijitMenuSeparator());\n\n                        for (id in _this4.config.datasets) {\n                            if (!/^_/.test(id)) {\n                                dataset = _this4.config.datasets[id];\n\n\n                                _this4.addGlobalMenuItem('dataset', new dijitMenuItem({\n                                    id: 'menubar_dataset_bookmark_' + id,\n                                    label: id == _this4.config.dataset_id ? '<b>' + dataset.name + '</b>' : dataset.name,\n                                    iconClass: 'dijitIconBookmark',\n                                    onClick: dojo.hitch(dataset, function () {\n\n                                        // if datasetLinkToParentIframe=true, link to parent of iframe.\n                                        var link2Parent = conf.datasetLinkToParentIframe || false;\n                                        if (link2Parent) window.parent.location = this.url;else window.location = this.url;\n                                    })\n                                }));\n                            }\n                        }\n                    }\n                    _this4.renderGlobalMenu('dataset', { text: 'Genome' }, parent);\n                })();\n            }\n        },\n\n        saveSessionDir: function saveSessionDir(directory) {\n            var fs = electronRequire('fs');\n            var path = this.config.electronData + '/sessions.json';\n            var obj = [];\n\n            try {\n                var obj = JSON.parse(fs.readFileSync(path, 'utf8'));\n            } catch (e) {\n                console.error(e);\n            }\n\n            var dir = Util.replacePath(directory);\n            if (array.every(obj, function (elt) {\n                return elt.session != dir;\n            })) obj.push({ session: dir });\n\n            fs.writeFileSync(path, JSON.stringify(obj, null, 2), 'utf8');\n        },\n\n        openDirectoryElectron: function openDirectoryElectron(directory) {\n            this.saveSessionDir(directory);\n            window.location = \"?data=\" + Util.replacePath(directory);\n        },\n\n        openConfig: function openConfig(plugins) {\n            if (!confirm(\"If you have opened any new tracks, please save them before continuing. Are you sure you want to continue?\")) return;\n            var fs = electronRequire('fs');\n\n            var dir = this.config.dataRoot;\n            var trackList = JSON.parse(fs.readFileSync(dir + \"/trackList.json\", 'utf8'));\n\n            //remap existing plugins to object form\n            trackList.plugins = trackList.plugins || {};\n            if (lang.isArray(trackList.plugins)) {\n                var temp = {};\n                array.forEach(trackList.plugins, function (p) {\n                    temp[p] = { 'name': p, 'location': dir + '/' + p };\n                });\n                trackList.plugins = temp;\n            }\n\n            // add new plugins\n            array.forEach(plugins, function (plugin) {\n                var name = plugin.match(/\\/(\\w+)$/)[1];\n                trackList.plugins[name] = { location: plugin, name: name };\n            });\n\n            try {\n                fs.writeFileSync(dir + \"/trackList.json\", JSON.stringify(trackList, null, 2));\n            } catch (e) {\n                console.error(\"Failed to save trackList.json\", e);\n            }\n            window.location.reload();\n        },\n\n        saveData: function saveData() {\n            if (!confirm(\"This will overwrite tracks and config data in your data directory. Are you sure you want to continue?\")) return;\n\n            var fs = electronRequire('fs');\n            var dir = this.config.dataRoot;\n\n            // use getstore to access the files that were loaded from local files, and create standard configs\n            var trackConfs = array.map(this.config.tracks, function (trackConfig) {\n                var temp = lang.clone(trackConfig);\n                this.getStore(temp.store, lang.hitch(this, function (obj) {\n                    temp.storeClass = obj.config.type;\n                    if (!temp.urlTemplate) {\n                        lang.mixin(temp, obj.saveStore());\n\n                        if (temp.histograms && temp.histograms.store) {\n                            this.getStore(temp.histograms.store, function (obj) {\n                                lang.mixin(temp.histograms, obj.saveStore());\n                            });\n                        }\n                    }\n                    delete temp.store;\n                }));\n                return temp;\n            }, this);\n\n            var plugins = array.filter(Util.uniq(this.config.plugins), function (elt) {\n                return elt != \"RegexSequenceSearch\";\n            });\n            var tmp = {};\n\n            if (lang.isArray(this.config.plugins)) {\n                array.forEach(this.config.plugins, function (p) {\n                    tmp[p] = (typeof p === 'undefined' ? 'undefined' : _typeof(p)) == 'object' ? p : { 'name': p };\n                });\n            } else tmp = this.config.plugins;\n            var minTrackList = {\n                tracks: trackConfs,\n                refSeqs: this.config.refSeqs,\n                refSeqOrder: this.config.refSeqOrder,\n                plugins: tmp\n            };\n            try {\n                fs.writeFileSync(Util.unReplacePath(dir) + \"/trackList.json\", JSON.stringify(minTrackList, null, 2));\n            } catch (e) {\n                alert('Unable to save track data');\n                console.error(e);\n            }\n        },\n\n        openFastaElectron: function openFastaElectron() {\n            this.fastaFileDialog = this.fastaFileDialog || new FastaFileDialog({ browser: this });\n\n            var app = electronRequire('electron').remote.app;\n            var fs = electronRequire('fs');\n            var path = electronRequire('path');\n\n            this.fastaFileDialog.show({\n                openCallback: dojo.hitch(this, function (results) {\n                    var confs = results.trackConfs || [];\n                    if (confs.length) {\n                        var trackList = {\n                            tracks: [{\n                                label: confs[0].label,\n                                key: confs[0].key,\n                                type: \"SequenceTrack\",\n                                category: \"Reference sequence\",\n                                useAsRefSeqStore: true,\n                                chunkSize: 20000\n                            }],\n                            refSeqs: fai,\n                            refSeqOrder: results.refSeqOrder\n                        };\n\n                        if (confs[0].store.bgzfa && confs[0].store.fai && confs[0].store.gzi) {\n                            var fasta = Util.replacePath(confs[0].store.bgzfa.url);\n                            var fai = Util.replacePath(confs[0].store.fai.url);\n                            var gzi = Util.replacePath(confs[0].store.gzi.url);\n                            trackList.tracks[0].storeClass = 'JBrowse/Store/SeqFeature/BgzipIndexedFasta';\n                            trackList.tracks[0].urlTemplate = fasta;\n                            trackList.tracks[0].faiUrlTemplate = fai;\n                            trackList.tracks[0].gziUrlTemplate = gzi;\n                            trackList.refSeqs = { faiUrlTemplate: fai, storeClass: 'JBrowse/Store/SeqFeature/BgzipIndexedFasta', gziUrlTemplate: gzi };\n                        } else if (confs[0].store.fasta && confs[0].store.fai) {\n                            var fasta = Util.replacePath(confs[0].store.fasta.url);\n                            var fai = Util.replacePath(confs[0].store.fai.url);\n                            trackList.tracks[0].storeClass = 'JBrowse/Store/SeqFeature/IndexedFasta';\n                            trackList.tracks[0].urlTemplate = fasta;\n                            trackList.tracks[0].faiUrlTemplate = fai;\n                            trackList.refSeqs = { faiUrlTemplate: fai, storeClass: 'JBrowse/Store/SeqFeature/IndexedFasta' };\n                        } else if (confs[0].store.type == 'JBrowse/Store/SeqFeature/TwoBit') {\n                            var f2bit = Util.replacePath(confs[0].store.blob.url);\n                            trackList.tracks[0].storeClass = 'JBrowse/Store/SeqFeature/TwoBit';\n                            trackList.tracks[0].urlTemplate = f2bit;\n                            trackList.refSeqs = f2bit;\n                            trackList.refSeqs = { urlTemplate: f2bit, storeClass: 'JBrowse/Store/SeqFeature/TwoBit' };\n                        } else if (confs[0].store.type == 'JBrowse/Store/SeqFeature/ChromSizes') {\n                            var sizes = Util.replacePath(confs[0].store.blob.url);\n                            delete trackList.tracks;\n                            trackList.refSeqs = sizes;\n                            trackList.refSeqs = { urlTemplate: sizes, storeClass: 'JBrowse/Store/SeqFeature/ChromSizes' };\n                        } else {\n                            var fasta = Util.replacePath(confs[0].store.fasta.url);\n                            try {\n                                var stats = fs.statSync(fasta);\n                                if (stats.size > 100000000) {\n                                    alert('Unindexed file too large. You must have an index file (.fai) for sequence files larger than 100 MB.');\n                                    return;\n                                }\n                            } catch (e) {\n                                console.error(e);\n                            }\n                            trackList.tracks[0].storeClass = 'JBrowse/Store/SeqFeature/UnindexedFasta';\n                            trackList.tracks[0].urlTemplate = fasta;\n                            trackList.refSeqs = { urlTemplate: fasta, storeClass: 'JBrowse/Store/SeqFeature/UnindexedFasta' };\n                        }\n\n                        // fix dir to be user data if we are accessing a url for fasta\n                        var dir = this.config.electronData;\n                        fs.existsSync(dir) || fs.mkdirSync(dir); // make base folder exist first before subdir\n                        dir += '/' + confs[0].label;\n\n                        try {\n                            fs.existsSync(dir) || fs.mkdirSync(dir);\n                            fs.writeFileSync(dir + \"/trackList.json\", JSON.stringify(trackList, null, 2));\n                            fs.closeSync(fs.openSync(dir + \"/tracks.conf\", 'w'));\n                            this.saveSessionDir(dir);\n                            window.location = window.location.href.split('?')[0] + \"?data=\" + Util.replacePath(dir);\n                        } catch (e) {\n                            alert('Failed to save session');\n                            console.error(e);\n                        }\n                    }\n                })\n            });\n        },\n\n        openFasta: function openFasta() {\n            var _this5 = this;\n\n            this.fastaFileDialog = this.fastaFileDialog || new FastaFileDialog({ browser: this });\n\n            this.fastaFileDialog.show({\n                openCallback: function openCallback(results) {\n                    return new Promise(function (resolve, reject) {\n                        var trackConfigs = results.trackConfs || [];\n\n                        var _trackConfigs = _slicedToArray(trackConfigs, 1),\n                            conf = _trackConfigs[0];\n\n                        if (!conf) return reject('no track configs');\n                        var storeConf = conf.store;\n                        if (!storeConf) return reject('no store config');\n\n                        dojo.global.require([storeConf.type], function (storeClass) {\n                            if (/\\/Unindexed/i.test(storeConf.type) && storeConf.fasta && storeConf.fasta.size > 100000000) {\n                                alert('Unindexed file too large. You must have an index file (.fai) for sequence files larger than 100 MB.');\n                                return reject('sequence file too large');\n                            }\n\n                            var store = new storeClass(Object.assign({ browser: _this5 }, storeConf)).getRefSeqs(function (refSeqs) {\n                                _this5.teardown();\n                                var newBrowser = new _this5.constructor({\n                                    refSeqs: { data: refSeqs },\n                                    refSeqOrder: results.refSeqOrder,\n                                    dataRoot: null\n                                });\n                                newBrowser.afterMilestone('completely initialized', function () {\n                                    storeConf.name = 'refseqs'; // important to make it the refseq store\n                                    newBrowser.addStoreConfig(storeConf.name, storeConf);\n                                    conf.store = 'refseqs';\n                                    if (storeConf.type !== 'JBrowse/Store/SeqFeature/ChromSizes') {\n                                        newBrowser.publish('/jbrowse/v1/v/tracks/new', [conf]);\n                                    }\n                                });\n                                resolve();\n                            }, function (error) {\n                                _this5.fatalError('Error getting refSeq: ' + error);\n                                reject(error);\n                            });\n                        });\n                    });\n                }\n            });\n        },\n\n        /**\n         * Get object like { title: \"title\", description: \"description\", ... }\n         * that contains metadata describing this browser.\n         */\n        browserMeta: function browserMeta() {\n            var about = this.config.aboutThisBrowser || {};\n            about.title = about.title || 'JBrowse';\n\n            var verstring = this.version;\n\n            if (about.description) {\n                about.description += '<div class=\"powered_by\">' + 'Powered by <a target=\"_blank\" href=\"http://jbrowse.org\">JBrowse ' + verstring + '</a>.' + '</div>';\n            } else {\n                about.description = '<div class=\"default_about\">' + '  <img class=\"logo\" src=\"' + this.resolveUrl('img/JBrowseLogo_small.png') + '\">' + '  <h1>JBrowse ' + verstring + '</h1>' + '  <div class=\"tagline\">A next-generation genome browser<br> built with JavaScript and HTML5.</div>' + '  <a class=\"mainsite\" target=\"_blank\" href=\"http://jbrowse.org\">JBrowse website</a>' + '  <div class=\"gmod\">JBrowse is a <a target=\"_blank\" href=\"http://gmod.org\">GMOD</a> project.</div>' + '  <div class=\"copyright\">' + _package2.default.copyright + '</div>' + (Object.keys(this.plugins).length > 1 && !this.config.noPluginsForAboutBox ? '  <div class=\"loaded-plugins\">Loaded plugins<ul class=\"plugins-list\">' + array.map(Object.keys(this.plugins), function (elt) {\n                    var p = this.plugins[elt];\n                    return '<li>' + (p.url ? '<a href=\"' + p.url + '\">' : '') + p.name + (p.url ? '</a>' : '') + (p.author ? ' (' + p.author + ')' : '') + '</li>';\n                }, this).join('') + '  </ul></div>' : '') + '</div>';\n            }\n            return about;\n        },\n\n        /**\n         * Track type registry, used by GUI elements that need to offer\n         * options regarding selecting track types.  Can register a track\n         * type, and get the data structure describing what track types are\n         * known.\n         */\n        registerTrackType: function registerTrackType(args) {\n\n            var types = this.getTrackTypes();\n            var typeName = args.type;\n            var defaultFor = args.defaultForStoreTypes || [];\n            var humanLabel = args.label;\n\n            // add it to known track types\n            types.knownTrackTypes.push(typeName);\n\n            // add its label\n            if (args.label) types.trackTypeLabels[typeName] = args.label;\n\n            // uniqify knownTrackTypes\n            var seen = {};\n            types.knownTrackTypes = array.filter(types.knownTrackTypes, function (type) {\n                var s = seen[type];\n                seen[type] = true;\n                return !s;\n            });\n\n            // set it as default for the indicated types, if any\n            array.forEach(defaultFor, function (storeName) {\n                types.trackTypeDefaults[storeName] = typeName;\n            });\n\n            // store the whole structure in this object\n            this._knownTrackTypes = types;\n        },\n        getTrackTypes: function getTrackTypes() {\n            // create the default types if necessary\n            if (!this._knownTrackTypes) this._knownTrackTypes = {\n                // map of store type -> default track type to use for the store\n                trackTypeDefaults: {\n                    'JBrowse/Store/SeqFeature/BAM': 'JBrowse/View/Track/Alignments2',\n                    'JBrowse/Store/SeqFeature/CRAM': 'JBrowse/View/Track/Alignments2',\n                    'JBrowse/Store/SeqFeature/NCList': 'JBrowse/View/Track/CanvasFeatures',\n                    'JBrowse/Store/SeqFeature/BigWig': 'JBrowse/View/Track/Wiggle/XYPlot',\n                    'JBrowse/Store/SeqFeature/VCFTabix': 'JBrowse/View/Track/CanvasVariants',\n                    'JBrowse/Store/SeqFeature/VCFTribble': 'JBrowse/View/Track/CanvasVariants',\n                    'JBrowse/Store/SeqFeature/GFF3': 'JBrowse/View/Track/CanvasFeatures',\n                    'JBrowse/Store/SeqFeature/BigBed': 'JBrowse/View/Track/CanvasFeatures',\n                    'JBrowse/Store/SeqFeature/GFF3Tabix': 'JBrowse/View/Track/CanvasFeatures',\n                    'JBrowse/Store/SeqFeature/BED': 'JBrowse/View/Track/CanvasFeatures',\n                    'JBrowse/Store/SeqFeature/BEDTabix': 'JBrowse/View/Track/CanvasFeatures',\n                    'JBrowse/Store/SeqFeature/GTF': 'JBrowse/View/Track/CanvasFeatures',\n                    'JBrowse/Store/SeqFeature/StaticChunked': 'JBrowse/View/Track/Sequence',\n                    'JBrowse/Store/SeqFeature/UnindexedFasta': 'JBrowse/View/Track/Sequence',\n                    'JBrowse/Store/SeqFeature/IndexedFasta': 'JBrowse/View/Track/Sequence',\n                    'JBrowse/Store/SeqFeature/BgzipIndexedFasta': 'JBrowse/View/Track/Sequence',\n                    'JBrowse/Store/SeqFeature/TwoBit': 'JBrowse/View/Track/Sequence'\n                },\n\n                knownTrackTypes: ['JBrowse/View/Track/Alignments', 'JBrowse/View/Track/Alignments2', 'JBrowse/View/Track/FeatureCoverage', 'JBrowse/View/Track/SNPCoverage', 'JBrowse/View/Track/HTMLFeatures', 'JBrowse/View/Track/CanvasFeatures', 'JBrowse/View/Track/HTMLVariants', 'JBrowse/View/Track/CanvasVariants', 'JBrowse/View/Track/Wiggle/XYPlot', 'JBrowse/View/Track/Wiggle/Density', 'JBrowse/View/Track/Sequence'],\n\n                trackTypeLabels: {}\n            };\n\n            return this._knownTrackTypes;\n        },\n\n        openFileDialog: function openFileDialog() {\n            this.fileDialog.show({\n                openCallback: dojo.hitch(this, function (results) {\n                    var confs = results.trackConfs || [];\n                    if (confs.length) {\n\n                        // tuck away each of the store configurations in\n                        // our store configuration, and replace them with\n                        // their names.\n                        array.forEach(confs, function (conf) {\n                            // do it for conf.store\n                            var storeConf = conf.store;\n                            if (storeConf && (typeof storeConf === 'undefined' ? 'undefined' : _typeof(storeConf)) == 'object') {\n                                delete conf.store;\n                                var name = this.addStoreConfig(storeConf.name, storeConf);\n                                conf.store = name;\n                            }\n\n                            // do it for conf.histograms.store, if it exists\n                            storeConf = conf.histograms && conf.histograms.store;\n                            if (storeConf && (typeof storeConf === 'undefined' ? 'undefined' : _typeof(storeConf)) == 'object') {\n                                delete conf.histograms.store;\n                                var name = this.addStoreConfig(storeConf.name, storeConf);\n                                conf.histograms.store = name;\n                            }\n                        }, this);\n\n                        // send out a message about how the user wants to create the new tracks\n                        this.publish('/jbrowse/v1/v/tracks/new', confs);\n\n                        // if requested, send out another message that the user wants to show them\n                        if (results.trackDisposition == 'openImmediately') this.publish('/jbrowse/v1/v/tracks/show', confs);\n                    }\n                })\n            });\n        },\n\n        addTracks: function addTracks(confs) {\n            // just register the track configurations right now\n            this._addTrackConfigs(confs);\n        },\n        replaceTracks: function replaceTracks(confs) {\n            // just add-or-replace the track configurations\n            this._replaceTrackConfigs(confs);\n        },\n        deleteTracks: function deleteTracks(confs) {\n            // de-register the track configurations\n            this._deleteTrackConfigs(confs);\n        },\n\n        renderGlobalMenu: function renderGlobalMenu(menuName, args, parent) {\n            this.afterMilestone('initView', function () {\n                var menu = this.makeGlobalMenu(menuName);\n                if (menu) {\n                    args = dojo.mixin({\n                        className: menuName,\n                        innerHTML: '<span class=\"icon\"></span> ' + (args.text || Util.ucFirst(menuName)),\n                        dropDown: menu,\n                        id: 'dropdownbutton_' + menuName\n                    }, args || {});\n\n                    var menuButton = new dijitDropDownButton(args);\n                    dojo.addClass(menuButton.domNode, 'menu');\n                    parent.appendChild(menuButton.domNode);\n                }\n            }, this);\n        },\n\n        makeGlobalMenu: function makeGlobalMenu(menuName) {\n            var items = (this._globalMenuItems || {})[menuName] || [];\n            if (!items.length) return null;\n\n            var menu = new dijitDropDownMenu({ id: 'dropdownmenu_' + menuName, leftClickToOpen: true });\n            dojo.forEach(items, function (item) {\n                menu.addChild(item);\n            });\n            dojo.addClass(menu.domNode, 'jbrowse globalMenu');\n            dojo.addClass(menu.domNode, menuName);\n            menu.startup();\n            return menu;\n        },\n\n        addGlobalMenuItem: function addGlobalMenuItem(menuName, item) {\n            if (!this._globalMenuItems) this._globalMenuItems = {};\n            if (!this._globalMenuItems[menuName]) this._globalMenuItems[menuName] = [];\n            this._globalMenuItems[menuName].push(item);\n        },\n\n        /**\n         * Initialize our message routing, subscribing to messages, forwarding\n         * them around, and so forth.\n         *\n         * \"v\" (view)\n         *   Requests from the user.  These go only to the browser, which is\n         *   the central point forx deciding what to do about them.  This is\n         *   usually just forwarding the command as one or more \"c\" messages.\n         *\n         * \"c\" (command)\n         *   Commands from authority, like the Browser object.  These cause\n         *   things to actually happen in the UI: things to be shown or\n         *   hidden, actions taken, and so forth.\n         *\n         * \"n\" (notification)\n         *   Notification that something just happened.\n         *\n         * @private\n         */\n        _initEventRouting: function _initEventRouting() {\n            var that = this;\n\n            that.subscribe('/jbrowse/v1/v/store/new', function (storeConfigs) {\n                array.forEach(storeConfigs, function (storeConfig) {\n                    storeConfig = lang.mixin({}, storeConfig);\n                    var name = storeConfig.name;\n                    delete storeConfig.name;\n                    that.addStoreConfig(name, storeConfig);\n                });\n            });\n\n            that.subscribe('/jbrowse/v1/v/tracks/hide', function (trackConfigs) {\n                that.publish('/jbrowse/v1/c/tracks/hide', trackConfigs);\n            });\n            that.subscribe('/jbrowse/v1/v/tracks/show', function (trackConfigs) {\n                that.addRecentlyUsedTracks(dojo.map(trackConfigs, function (c) {\n                    return c.label;\n                }));\n                that.publish('/jbrowse/v1/c/tracks/show', trackConfigs);\n            });\n\n            that.subscribe('/jbrowse/v1/v/tracks/new', function (trackConfigs) {\n                that.addTracks(trackConfigs);\n                that.publish('/jbrowse/v1/c/tracks/new', trackConfigs);\n                that.publish('/jbrowse/v1/n/tracks/new', trackConfigs);\n            });\n            that.subscribe('/jbrowse/v1/v/tracks/replace', function (trackConfigs) {\n                that.replaceTracks(trackConfigs);\n                that.publish('/jbrowse/v1/c/tracks/replace', trackConfigs);\n                that.publish('/jbrowse/v1/n/tracks/replace', trackConfigs);\n            });\n            that.subscribe('/jbrowse/v1/v/tracks/delete', function (trackConfigs) {\n                that.deleteTracks(trackConfigs);\n                that.publish('/jbrowse/v1/c/tracks/delete', trackConfigs);\n                that.publish('/jbrowse/v1/n/tracks/delete', trackConfigs);\n            });\n\n            that.subscribe('/jbrowse/v1/v/tracks/pin', function (trackNames) {\n                that.publish('/jbrowse/v1/c/tracks/pin', trackNames);\n                that.publish('/jbrowse/v1/n/tracks/pin', trackNames);\n            });\n\n            that.subscribe('/jbrowse/v1/v/tracks/unpin', function (trackNames) {\n                that.publish('/jbrowse/v1/c/tracks/unpin', trackNames);\n                that.publish('/jbrowse/v1/n/tracks/unpin', trackNames);\n            });\n        },\n\n        /**\n         * Reports some anonymous usage statistics about this browsing\n         * instance.  Currently reports the number of tracks in the instance\n         * and their type (feature, wiggle, etc), and the number of reference\n         * sequences and their average length.\n         */\n        reportUsageStats: function reportUsageStats() {\n            if (this.config.suppressUsageStatistics) return;\n\n            var stats = this._calculateClientStats();\n            this._reportGoogleUsageStats(stats);\n            this._reportCustomUsageStats(stats);\n        },\n\n        // phones home to google analytics\n        _reportGoogleUsageStats: function _reportGoogleUsageStats(stats) {\n            var thisB = this;\n            // jbrowse.org account always\n            var jbrowseUser = 'UA-7115575-2';\n            var accounts = [jbrowseUser];\n\n            // add any custom Google Analytics accounts from config (comma-separated or array)\n            if (this.config.googleAnalytics) {\n                var userAccounts = this.config.googleAnalytics.accounts;\n                if (accounts && !lang.isArray(userAccounts)) {\n                    userAccounts = userAccounts.replace(/^\\s*|\\s*$/, '').split(/\\s*,\\s*/);\n                }\n                accounts.push.apply(accounts, userAccounts);\n            }\n\n            var analyticsScript = \"(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ \";\n            analyticsScript += \"(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), \";\n            analyticsScript += \"m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) \";\n            analyticsScript += \"})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\";\n\n            // set up users\n            accounts.forEach(function (user, trackerNum) {\n                // if we're adding jbrowse.org user, also include new dimension references (replacing ga.js custom variables)\n                if (user == jbrowseUser) {\n                    analyticsScript += \"ga('create', '\" + user + \"', 'auto', 'jbrowseTracker');\";\n                } else {\n                    analyticsScript += \"ga('create', '\" + user + \"', 'auto', 'customTracker\" + trackerNum + \"');\";\n                }\n            });\n\n            // send pageviews and custom variables\n            accounts.forEach(function (user, viewerNum) {\n                if (user == jbrowseUser) {\n                    var gaData = {};\n                    var googleDimensions = 'tracks-count refSeqs-count refSeqs-avgLen ver loadTime electron plugins';\n                    var googleMetrics = 'loadTime';\n\n                    googleDimensions.split(/\\s+/).forEach(function (key, index) {\n                        gaData['dimension' + (index + 1)] = stats[key];\n                    });\n\n                    gaData.metric1 = Math.round(stats.loadTime * 1000);\n\n                    analyticsScript += \"ga('jbrowseTracker.send', 'pageview',\" + JSON.stringify(gaData) + \");\";\n                } else {\n                    analyticsScript += \"ga('customTracker\" + viewerNum + \".send', 'pageview');\";\n                }\n            });\n\n            var analyticsScriptNode = document.createElement('script');\n            analyticsScriptNode.innerHTML = analyticsScript;\n\n            document.getElementsByTagName('head')[0].appendChild(analyticsScriptNode);\n        },\n\n        // phones home to custom analytics at jbrowse.org\n        _reportCustomUsageStats: function _reportCustomUsageStats(stats) {\n            var protocol = \"https\";\n\n            // overridable protocol\n            if (typeof this.config.clientReport != \"undefined\" && typeof this.config.clientReport.protocol != \"undefined\") protocol = this.config.clientReport.protocol;\n\n            // phone home with a GET request made by a script tag\n            var clientReport = protocol + '://jbrowse.org/analytics/clientReport?' + dojo.objectToQuery(stats);\n\n            dojo.create('img', { style: {\n                    display: 'none'\n                },\n                src: clientReport\n            }, document.body);\n        },\n\n        /**\n         * Get a store object from the store registry, loading its code and\n         * instantiating it if necessary.\n         */\n        getStore: function getStore(storeName, callback) {\n            if (!callback) throw 'invalid arguments';\n\n            var storeCache = this._storeCache || {};\n            this._storeCache = storeCache;\n\n            var storeRecord = storeCache[storeName];\n            if (storeRecord) {\n                storeRecord.refCount++;\n                callback(storeRecord.store);\n                return;\n            }\n\n            var conf = this.config.stores[storeName];\n            if (!conf) {\n                console.warn(\"store '\" + storeName + \"' not found\");\n                callback(null);\n                return;\n            }\n\n            var storeClassName = conf.type;\n            if (!storeClassName) {\n                console.warn(\"store \" + storeName + \" has no type defined\");\n                callback(null);\n                return;\n            }\n\n            dojo.global.require([storeClassName], dojo.hitch(this, function (storeClass) {\n                var storeArgs = {};\n                dojo.mixin(storeArgs, conf);\n                dojo.mixin(storeArgs, {\n                    config: conf,\n                    browser: this,\n                    refSeq: this.refSeq\n                });\n\n                var store = new storeClass(storeArgs);\n\n                var cache = typeof storeArgs.storeCache === 'undefined' || storeArgs.storeCache !== false;\n\n                if (cache) this._storeCache[storeName] = { refCount: 1, store: store };\n\n                callback(store);\n                // release the callback because apparently require\n                // doesn't release this function\n                callback = undefined;\n\n                //if (cache)\n                //    delete store;\n            }));\n        },\n\n        /**\n         * Add a store configuration to the browser.  If name is falsy, will\n         * autogenerate one.\n         * @private\n         */\n        uniqCounter: 0,\n        addStoreConfig: function addStoreConfig( /**String*/name, /**Object*/storeConfig) {\n            name = name || 'addStore' + this.uniqCounter++;\n\n            if (!this.config.stores) this.config.stores = {};\n            if (!this._storeCache) this._storeCache = {};\n\n            if (this.config.stores[name] || this._storeCache[name]) {\n                throw \"store \" + name + \" already exists!\";\n            }\n\n            this.config.stores[name] = storeConfig;\n            return name;\n        },\n\n        clearStores: function clearStores() {\n            this._storeCache = {};\n        },\n\n        /**\n         * Notifies the browser that the given named store is no longer being\n         * used by the calling component.  Decrements the store's reference\n         * count, and if the store's reference count reaches zero, the store\n         * object will be discarded, to be recreated again later if needed.\n         */\n        // not actually being used yet\n        releaseStore: function releaseStore(storeName) {\n            var storeRecord = this._storeCache[storeName];\n            if (storeRecord && ! --storeRecord.refCount) delete this._storeCache[storeName];\n        },\n\n        _calculateClientStats: function _calculateClientStats() {\n\n            var scn = screen || window.screen;\n\n            // make a flat (i.e. non-nested) object for the stats, so that it\n            // encodes compactly in the query string\n            var date = new Date();\n            var stats = {\n                ver: this.version || 'dev',\n                'refSeqs-count': this.refSeqOrder.length,\n                'refSeqs-avgLen': !this.refSeqOrder.length ? null : dojof.reduce(dojo.map(this.refSeqOrder, function (name) {\n                    var ref = this.allRefs[name];\n                    if (!ref) return 0;\n                    return ref.end - ref.start;\n                }, this), '+'),\n                'tracks-count': this.config.tracks.length,\n                'plugins': dojof.keys(this.plugins).sort().join(','),\n\n                // screen geometry\n                'scn-h': scn ? scn.height : null,\n                'scn-w': scn ? scn.width : null,\n                // window geometry\n                'win-h': document.body.offsetHeight,\n                'win-w': document.body.offsetWidth,\n                // container geometry\n                'el-h': this.container.offsetHeight,\n                'el-w': this.container.offsetWidth,\n\n                // time param to prevent caching\n                t: date.getTime() / 1000,\n                electron: Util.isElectron(),\n\n                // also get local time zone offset\n                tzoffset: date.getTimezoneOffset(),\n\n                loadTime: (date.getTime() - this.startTime) / 1000\n            };\n\n            // count the number and types of tracks\n            dojo.forEach(this.config.tracks, function (trackConfig) {\n                var typeKey = 'track-types-' + trackConfig.type || false;\n                stats[typeKey] = (stats[typeKey] || 0) + 1;\n            });\n\n            return stats;\n        },\n\n        publish: function publish() {\n            if (this.config.logMessages) console.log(arguments);\n\n            return topic.publish.apply(topic, arguments);\n        },\n\n        subscribe: function subscribe() {\n            this._uniqueSubscriptionId = this._uniqueSubscriptionId || 0;\n            this._subscription = this._subscription || {};\n            var uniqId = ++this._uniqueSubscriptionId;\n            var unsubber = topic.subscribe.apply(topic, arguments);\n            var thisB = this;\n            this._subscription[uniqId] = unsubber;\n            return function (id) {\n                return { remove: function remove() {\n                        delete thisB._subscription[id];\n                        unsubber.remove();\n                    }\n                };\n            }(uniqId);\n        },\n\n        onResize: function onResize() {\n            if (this.navbox) this.view.locationTrapHeight = dojo.marginBox(this.navbox).h;\n        },\n\n        /**\n         * Get the list of the most recently used tracks, stored for this user\n         * in a cookie.\n         * @returns {Array[Object]} as <code>[{ time: (integer), label: (track label)}]</code>\n         */\n        getRecentlyUsedTracks: function getRecentlyUsedTracks() {\n            return dojo.fromJson(this.cookie('recentTracks') || '[]');\n        },\n\n        /**\n         * Add the given list of tracks as being recently used.\n         * @param trackLabels {Array[String]} array of track labels to add\n         */\n        addRecentlyUsedTracks: function addRecentlyUsedTracks(trackLabels) {\n            var seen = {};\n            var newRecent = Util.uniq(dojo.map(trackLabels, function (label) {\n                return {\n                    label: label,\n                    time: Math.round(new Date() / 1000) // secs since epoch\n                };\n            }, this).concat(dojo.fromJson(this.cookie('recentTracks')) || []), function (entry) {\n                return entry.label;\n            })\n            // limit by default to 20 recent tracks\n            .slice(0, this.config.maxRecentTracks || 10);\n\n            // set the recentTracks cookie, good for one year\n            this.cookie('recentTracks', newRecent, { expires: 365 });\n\n            return newRecent;\n        },\n\n        /**\n         * Run a function that will eventually resolve the named Deferred\n         * (milestone).\n         * @param {String} name the name of the Deferred\n         */\n        _milestoneFunction: function _milestoneFunction( /**String*/name, func) {\n\n            var thisB = this;\n            var args = Array.prototype.slice.call(arguments, 2);\n\n            var d = thisB._getDeferred(name);\n            args.unshift(d);\n            try {\n                func.apply(thisB, args);\n            } catch (e) {\n                console.error(e, e.stack);\n                d.reject(e);\n            }\n\n            return d;\n        },\n\n        /**\n         * Fetch or create a named Deferred, which is how milestones are implemented.\n         */\n        _getDeferred: function _getDeferred(name) {\n            if (!this._deferred) this._deferred = {};\n            return this._deferred[name] || (this._deferred[name] = function () {\n                var d = new Deferred();\n                d.then(null, lang.hitch(this, 'fatalError'));\n                return d;\n            }.call(this));\n        },\n        /**\n         * Attach a callback to a milestone.\n         */\n        afterMilestone: function afterMilestone(name, func, ctx) {\n            return this._getDeferred(name).then(function () {\n                try {\n                    func.call(ctx || this);\n                } catch (e) {\n                    console.error(e instanceof Error ? e : String(e), e.stack);\n                }\n            });\n        },\n        /**\n         * Indicate that we've reached a milestone in the initalization\n         * process.  Will run all the callbacks associated with that\n         * milestone.\n         */\n        passMilestone: function passMilestone(name, result) {\n            return this._getDeferred(name).resolve(result);\n        },\n        /**\n         * Return true if we have reached the named milestone, false otherwise.\n         */\n        reachedMilestone: function reachedMilestone(name) {\n            return this._getDeferred(name).isResolved();\n        },\n\n        /**\n         *  Load our configuration file(s) based on the parameters the\n         *  constructor was passed.  Does not return until all files are\n         *  loaded and merged in.\n         *  @returns nothing meaningful\n         */\n        loadConfig: function loadConfig() {\n            return this._milestoneFunction('loadConfig', function (deferred) {\n\n                // check the config.dataRoot parameter before loading, unless allowCrossSiteDataRoot is on.\n                // this prevents an XSS attack served from a malicious server that has CORS enabled. thanks to @cmdcolin\n                // for noticing this.\n                if (this.config.dataRoot && this.config.dataRoot !== 'data' && !this.config.allowCrossOriginDataRoot) {\n                    var parsedDataRoot = url.parse(url.resolve(window.location.href, this.config.dataRoot));\n                    if (parsedDataRoot.host) {\n                        var currentParsed = url.parse(window.location.href);\n                        if (!Util.isElectron() && (parsedDataRoot.host !== currentParsed.host || parsedDataRoot.protocol !== currentParsed.protocol)) throw new Error('Invalid JBrowse dataRoot setting. For security, absolute URLs are not allowed. Set `allowCrossOriginDataRoot` to true to disable this security check.');\n                    }\n                }\n\n                var c = new ConfigManager({ bootConfig: this.config, defaults: this._configDefaults(), browser: this });\n                c.getFinalConfig().then(dojo.hitch(this, function (finishedConfig) {\n                    var _this6 = this;\n\n                    this.config = finishedConfig;\n\n                    //apply document.domain from a loaded conf file\n                    if (this.config.documentDomain) document.domain = this.config.documentDomain;\n\n                    // pass the tracks configurations through\n                    // addTrackConfigs so that it will be indexed and such\n                    var tracks = finishedConfig.tracks || [];\n                    delete finishedConfig.tracks;\n                    this._addTrackConfigs(tracks);\n\n                    // coerce some config keys to boolean\n                    ['show_tracklist', 'show_nav', 'show_overview', 'show_menu', 'show_fullviewlink', 'show_tracklabels', 'update_browser_title'].forEach(function (v) {\n                        _this6.config[v] = Util.coerceBoolean(_this6.config[v]);\n                    });\n\n                    // set empty tracks array if we have none\n                    if (!this.config.tracks) this.config.tracks = [];\n\n                    deferred.resolve({ success: true });\n                }), deferred.reject);\n            });\n        },\n\n        /**\n         * Add new track configurations.\n         * @private\n         */\n        _addTrackConfigs: function _addTrackConfigs( /**Array*/configs) {\n\n            if (!this.config.tracks) this.config.tracks = [];\n            if (!this.trackConfigsByName) this.trackConfigsByName = {};\n\n            array.forEach(configs, function (conf) {\n\n                // if( this.trackConfigsByName[ conf.label ] ) {\n                //     console.warn(\"track with label \"+conf.label+\" already exists, skipping\");\n                //     return;\n                // }\n\n                this.trackConfigsByName[conf.label] = conf;\n                this.config.tracks.push(conf);\n            }, this);\n\n            return configs;\n        },\n        /**\n         * Replace existing track configurations.\n         * @private\n         */\n        _replaceTrackConfigs: function _replaceTrackConfigs( /**Array*/newConfigs) {\n            if (!this.trackConfigsByName) this.trackConfigsByName = {};\n\n            array.forEach(newConfigs, function (conf) {\n                if (!this.trackConfigsByName[conf.label]) {\n                    console.warn(\"track with label \" + conf.label + \" does not exist yet.  creating a new one.\");\n                }\n\n                this.trackConfigsByName[conf.label] = dojo.mixin(this.trackConfigsByName[conf.label] || {}, conf);\n            }, this);\n        },\n        /**\n         * Delete existing track configs.\n         * @private\n         */\n        _deleteTrackConfigs: function _deleteTrackConfigs(configsToDelete) {\n            // remove from this.config.tracks\n            this.config.tracks = array.filter(this.config.tracks || [], function (conf) {\n                return !array.some(configsToDelete, function (toDelete) {\n                    return toDelete.label == conf.label;\n                });\n            });\n\n            // remove from trackConfigsByName\n            array.forEach(configsToDelete, function (toDelete) {\n                if (!this.trackConfigsByName[toDelete.label]) {\n                    console.warn(\"track \" + toDelete.label + \" does not exist, cannot delete\");\n                    return;\n                }\n\n                delete this.trackConfigsByName[toDelete.label];\n            }, this);\n        },\n\n        _configDefaults: function _configDefaults() {\n            return {\n                tracks: [],\n\n                containerID: 'GenomeBrowser',\n                dataRoot: 'data',\n                show_tracklist: true,\n                show_nav: true,\n                show_menu: true,\n                show_overview: true,\n                show_fullviewlink: true,\n                update_browser_title: true,\n                updateBrowserURL: true,\n\n                refSeqs: \"{dataRoot}/seq/refSeqs.json\",\n                include: ['jbrowse.conf', 'jbrowse_conf.json'],\n                nameUrl: \"{dataRoot}/names/root.json\",\n\n                datasets: {\n                    _DEFAULT_EXAMPLES: true,\n                    volvox: { url: '?data=sample_data/json/volvox', name: 'Volvox Example' },\n                    modencode: { url: '?data=sample_data/json/modencode', name: 'MODEncode Example' },\n                    yeast: { url: '?data=sample_data/json/yeast', name: 'Yeast Example' }\n                },\n\n                highlightSearchedRegions: false,\n                highResolutionMode: 'auto'\n            };\n        },\n\n        /**\n         * get the numerical ID number of the given reference sequence name.  required for CRAM files, which\n         * only operate on reference sequence ID numbers.\n         * @param {string} refSeqName\n         */\n        getRefSeqNumber: function getRefSeqNumber(refSeqName) {\n            return this.allRefs[refSeqName].id;\n        },\n\n\n        /**\n         * get a reference sequence by its numerical id number. used mostly by CRAM stores.\n         * @param {number} id\n         */\n        getRefSeqById: function getRefSeqById(id) {\n            return this.refSeqsById[id];\n        },\n\n\n        /**\n         * @param refSeqs {Array} array of refseq records to add to the browser\n         */\n        addRefseqs: function addRefseqs(refSeqs) {\n            var _this7 = this;\n\n            if (!this.allRefs) this.allRefs = {};\n\n            refSeqs.forEach(function (r, id) {\n                // save the original index of the reference for\n                // use with CRAM and other numerical-refseq-id stores\n                r.id = id;\n                _this7.allRefs[r.name] = r;\n            });\n\n            this.refSeqsById = refSeqs;\n\n            // generate refSeqOrder\n            this.refSeqOrder = function () {\n                var order;\n                if (!this.config.refSeqOrder) {\n                    order = refSeqs;\n                } else {\n                    // if refSeqOrder 'by_list' and config parameter refSeqOrderList exists,\n                    // split that into an array as an override to default refSeqs.json order\n                    if (this.config.refSeqOrder == 'by_list' && this.config.refSeqOrderList) {\n                        if (lang.isArray(this.config.refSeqOrderList)) {\n                            return this.config.refSeqOrderList;\n                        } else if (typeof this.config.refSeqOrderList === 'string') {\n                            return this.config.refSeqOrderList.split(/\\s*,\\s*/);\n                        }\n                    }\n                    order = refSeqs.slice(0);\n                    order.sort(this.config.refSeqOrder == 'length' || this.config.refSeqOrder == 'length ascending' ? function (a, b) {\n                        return a.length - b.length;\n                    } : this.config.refSeqOrder == 'length descending' ? function (a, b) {\n                        return b.length - a.length;\n                    } : this.config.refSeqOrder == 'name descending' ? function (a, b) {\n                        return b.name.localeCompare(a.name);\n                    } : function (a, b) {\n                        return a.name.localeCompare(b.name);\n                    });\n                }\n                return array.map(order, function (r) {\n                    return r.name;\n                });\n            }.call(this);\n\n            var refCookie = this.cookie('refseq');\n            this.refSeq = this.refSeq || this.allRefs[refCookie] || this.allRefs[this.refSeqOrder[0]];\n        },\n\n        /**\n         * Get the refseq object { name, start, end, .. } with the given name,\n         * or the currently shown ref seq if no name is given.\n         */\n        getRefSeq: function getRefSeq(name) {\n            if (typeof name != 'string') return this.refSeq || undefined;\n\n            return this.allRefs[name];\n        },\n\n        /**\n         * @private\n         */\n        onFineMove: function onFineMove(startbp, endbp) {\n\n            if (this.locationTrap) {\n                var length = this.view.ref.end - this.view.ref.start;\n                var trapLeft = Math.round((startbp - this.view.ref.start) / length * this.view.overviewBox.w + this.view.overviewBox.l);\n                var trapRight = Math.round((endbp - this.view.ref.start) / length * this.view.overviewBox.w + this.view.overviewBox.l);\n                dojo.style(this.locationTrap, {\n                    width: trapRight - trapLeft + \"px\",\n                    borderBottomWidth: this.view.locationTrapHeight + \"px\",\n                    borderLeftWidth: trapLeft + \"px\",\n                    borderRightWidth: this.view.overviewBox.w - trapRight + \"px\"\n                });\n            }\n        },\n\n        /**\n         * Asynchronously initialize our track metadata.\n         */\n        initTrackMetadata: function initTrackMetadata(callback) {\n            var thisB = this;\n            return this._milestoneFunction('initTrackMetadata', function (deferred) {\n                var metaDataSourceClasses = dojo.map((this.config.trackMetadata || {}).sources || [], function (sourceDef) {\n                    var url = sourceDef.relativeUrl ? Util.resolveUrl(thisB.config.dataRoot + '/', sourceDef.relativeUrl) : sourceDef.url || 'trackMeta.csv';\n                    var type = sourceDef.type || (/\\.csv$/i.test(url) ? 'csv' : /\\.js(on)?$/i.test(url) ? 'json' : 'csv');\n                    var storeClass = sourceDef['class'] || { csv: 'dojox/data/CsvStore', json: 'dojox/data/JsonRestStore' }[type];\n                    if (!storeClass) {\n                        console.error(\"No store class found for type '\" + type + \"', cannot load track metadata from URL \" + url);\n                        return null;\n                    }\n                    return { class_: storeClass, url: url };\n                });\n\n                dojo.global.require(Array.prototype.concat.apply(['JBrowse/Store/TrackMetaData'], dojo.map(metaDataSourceClasses, function (c) {\n                    return c.class_;\n                })), dojo.hitch(this, function (MetaDataStore) {\n                    var mdStores = [];\n                    for (var i = 1; i < arguments.length; i++) {\n                        mdStores.push(new arguments[i]({ url: metaDataSourceClasses[i - 1].url }));\n                    }\n\n                    this.trackMetaDataStore = new MetaDataStore(dojo.mixin(dojo.clone(this.config.trackMetadata || {}), {\n                        trackConfigs: this.config.tracks,\n                        browser: this,\n                        metadataStores: mdStores\n                    }));\n\n                    deferred.resolve({ success: true });\n                }));\n            });\n        },\n\n        /**\n         * Asynchronously create the track list.\n         * @private\n         */\n        createTrackList: function createTrackList() {\n            return this._milestoneFunction('createTrack', function (deferred) {\n                // find the tracklist class to use\n                var tl_class = !this.config.show_tracklist ? 'Null' : (this.config.trackSelector || {}).type ? this.config.trackSelector.type : 'Hierarchical';\n                if (!/\\//.test(tl_class)) tl_class = 'JBrowse/View/TrackList/' + tl_class;\n\n                // load all the classes we need\n                dojo.global.require([tl_class], dojo.hitch(this, function (trackListClass) {\n                    // instantiate the tracklist and the track metadata object\n                    this.trackListView = new trackListClass(dojo.mixin(dojo.clone(this.config.trackSelector) || {}, {\n                        trackConfigs: this.config.tracks,\n                        browser: this,\n                        trackMetaData: this.trackMetaDataStore\n                    }));\n\n                    // bind the 't' key as a global keyboard shortcut\n                    this.setGlobalKeyboardShortcut('t', this.trackListView, 'toggle');\n\n                    // listen for track-visibility-changing messages from\n                    // views and update our tracks cookie\n                    this.subscribe('/jbrowse/v1/n/tracks/visibleChanged', dojo.hitch(this, function () {\n                        this.cookie(\"tracks\", this.view.visibleTrackNames().join(','), { expires: 60 });\n                    }));\n\n                    deferred.resolve({ success: true });\n                }));\n            });\n        },\n\n        /**\n         * @private\n         */\n\n        onVisibleTracksChanged: function onVisibleTracksChanged() {},\n\n        /**\n         * Like <code>navigateToLocation()</code>, except it attempts to display the given\n         * location with a little bit of flanking sequence to each side, if\n         * possible.\n         */\n        showRegion: function showRegion(location) {\n            var flank = Math.round((location.end - location.start) * 0.2);\n            //go to location, with some flanking region\n            this.navigateToLocation({ ref: location.ref,\n                start: location.start - flank,\n                end: location.end + flank\n            });\n\n            // if the location has a track associated with it, show it\n            if (location.tracks) {\n                this.showTracks(array.map(location.tracks, function (t) {\n                    return t && (t.label || t.name) || t;\n                }));\n            }\n        },\n\n        /**\n         * navigate to a given location\n         * @example\n         * gb=dojo.byId(\"GenomeBrowser\").genomeBrowser\n         * gb.navigateTo(\"ctgA:100..200\")\n         * gb.navigateTo(\"f14\")\n         * @param loc can be either:<br>\n         * &lt;chromosome&gt;:&lt;start&gt; .. &lt;end&gt;<br>\n         * &lt;start&gt; .. &lt;end&gt;<br>\n         * &lt;center base&gt;<br>\n         * &lt;feature name/ID&gt;\n         */\n\n        navigateTo: function navigateTo(loc, initial) {\n            var thisB = this;\n            this.afterMilestone('initView', function () {\n                // lastly, try to search our feature names for it\n                var ret = thisB.searchNames(loc).then(function (found) {\n                    if (found) return;\n\n                    // First check if loc is the name of a ref seq before attempting to parse the locstring for basepair location info\n                    var ref = thisB.findReferenceSequence(loc);\n\n                    if (ref) {\n                        thisB.navigateToLocation({ ref: ref.name });\n                        return;\n                    }\n\n                    // Not a known ref seq name - now lets parse the loc string\n                    // if it's a foo:123..456 location, go there\n                    var location = typeof loc == 'string' ? Util.parseLocString(loc) : loc;\n                    // only call navigateToLocation() directly if location has start and end, otherwise try and fill in start/end from 'location' cookie\n                    if (location && \"start\" in location && \"end\" in location) {\n                        location.initial = initial;\n                        thisB.navigateToLocation(location);\n                        return;\n                    }\n\n                    new InfoDialog({\n                        title: 'Not found',\n                        content: 'Not found: <span class=\"locString\">' + loc + '</span>',\n                        className: 'notfound-dialog'\n                    }).show();\n                    if (!thisB.view.pxPerBp) {\n                        thisB.navigateToLocation(thisB.refSeq);\n                    }\n                });\n            });\n        },\n\n        findReferenceSequence: function findReferenceSequence(name) {\n            for (var n in this.allRefs) {\n                if (!this.compareReferenceNames(n, name)) return this.allRefs[n];\n            }\n            return null;\n        },\n\n        // given an object like { ref: 'foo', start: 2, end: 100 }, set the\n        // browser's view to that location.  any of ref, start, or end may be\n        // missing, in which case the function will try set the view to\n        // something that seems intelligent\n        navigateToLocation: function navigateToLocation(location) {\n            this.afterMilestone('initView', dojo.hitch(this, function () {\n\n                // regularize the ref seq name we were passed\n                var ref = location.ref ? this.findReferenceSequence(location.ref.name || location.ref) : this.refSeq;\n                if (location.initial && !ref) {\n                    new InfoDialog({\n                        title: 'Not found',\n                        content: 'Not found: <span class=\"locString\">' + Util.assembleLocString(location, false) + '</span>',\n                        className: 'notfound-dialog'\n                    }).show();\n                    ref = this.refSeq;\n                }\n                if (!ref) {\n                    return;\n                }\n                location.ref = ref.name;\n\n                if ('ref' in location && !('start' in location && 'end' in location)) {\n                    // see if we have a stored location for this ref seq in a\n                    // cookie, and go there if we do\n                    var oldLoc;\n                    try {\n                        oldLoc = Util.parseLocString(dojo.fromJson(this.cookie(\"location\"))[location.ref].l);\n                        oldLoc.ref = location.ref; // force the refseq name; older cookies don't have it\n                    } catch (x) {}\n                    if (oldLoc) {\n                        location = oldLoc;\n                    } else {\n                        // if we don't have a previous location, just go to\n                        // the middle 80% of that refseq,\n                        // based on range that can be viewed (start to end)\n                        // rather than total length, in case start != 0 || end != length\n                        // this.navigateToLocation({ref: ref.name, start: ref.end*0.1, end: ref.end*0.9 });\n                        var visibleLength = ref.end - ref.start;\n                        location.start = ref.start + visibleLength * 0.1;\n                        location.end = ref.start + visibleLength * 0.9;\n                    }\n                }\n\n                // clamp the start and end to the size of the ref seq\n                location.start = Math.max(0, location.start || 0);\n                location.end = Math.max(location.start, Math.min(ref.end, location.end || ref.end));\n\n                // if it's the same sequence, just go there\n                if (location.ref == this.refSeq.name) {\n                    this.view.setLocation(this.refSeq, location.start, location.end);\n                    this._updateLocationCookies(location);\n                }\n                // if different, we need to poke some other things before going there\n                else {\n                        // record names of open tracks and re-open on new refseq\n                        var curTracks = this.view.visibleTrackNames();\n\n                        this.refSeq = this.allRefs[location.ref];\n                        this.clearStores();\n\n                        this.view.setLocation(this.refSeq, location.start, location.end);\n                        this._updateLocationCookies(location);\n\n                        this.showTracks(curTracks);\n                    }\n            }));\n        },\n\n        /**\n         * Given a string name, search for matching feature names and set the\n         * view location to any that match.\n         */\n        searchNames: function searchNames( /**String*/loc) {\n            var _this8 = this;\n\n            return this._getDeferred('loadNames').then(function () {\n                return _this8.nameStore.query({ name: loc }).then(function (nameMatches) {\n                    // if we have no matches, pop up a dialog saying so, and\n                    // do nothing more\n                    if (!nameMatches.length) {\n                        return false;\n                    }\n\n                    var goingTo;\n\n                    //first check for exact case match\n                    for (var i = 0; i < nameMatches.length; i++) {\n                        if (nameMatches[i].name == loc) goingTo = nameMatches[i];\n                    }\n                    //if no exact case match, try a case-insentitive match\n                    if (!goingTo) {\n                        for (i = 0; i < nameMatches.length; i++) {\n                            if (nameMatches[i].name.toLowerCase() == loc.toLowerCase()) goingTo = nameMatches[i];\n                        }\n                    }\n                    //else just pick a match\n                    if (!goingTo) goingTo = nameMatches[0];\n\n                    // if it has one location, go to it\n                    if (goingTo.location) {\n                        //go to location, with some flanking region\n                        _this8.showRegionAfterSearch(goingTo.location);\n                    }\n                    // otherwise, pop up a dialog with a list of the locations to choose from\n                    else if (goingTo.multipleLocations) {\n                            if (!_this8.view.pxPerBp) {\n                                _this8.navigateToLocation(_this8.refSeq);\n                            }\n                            new LocationChoiceDialog({\n                                browser: _this8,\n                                locationChoices: goingTo.multipleLocations,\n                                title: 'Choose ' + goingTo.name + ' location',\n                                prompt: '\"' + goingTo.name + '\" is found in multiple locations.  Please choose a location to view.'\n                            }).show();\n                        }\n                    return true;\n                }, function (e) {\n                    console.error(e);\n                    new InfoDialog({\n                        title: 'Error',\n                        content: 'Error reading from name store.'\n                    }).show();\n                    return false;\n                });\n            });\n        },\n\n        /**\n         * load and display the given tracks\n         * @example\n         * gb=dojo.byId(\"GenomeBrowser\").genomeBrowser\n         * gb.showTracks([\"DNA\",\"gene\",\"mRNA\",\"noncodingRNA\"])\n         * @param trackNameList {Array|String} array or comma-separated string\n         * of track names, each of which should correspond to the \"label\"\n         * element of the track information\n         */\n\n        showTracks: function showTracks(trackNames) {\n            this.afterMilestone('initView', dojo.hitch(this, function () {\n                if (typeof trackNames == 'string') trackNames = trackNames.split(',');\n\n                if (!trackNames) return;\n\n                var trackConfs = dojo.filter(dojo.map(trackNames, function (n) {\n                    return this.trackConfigsByName[n];\n                }, this), function (c) {\n                    return c;\n                } // filter out confs that are missing\n                );\n\n                // publish some events with the tracks to instruct the views to show them.\n                this.publish('/jbrowse/v1/c/tracks/show', trackConfs);\n                this.publish('/jbrowse/v1/n/tracks/visibleChanged');\n            }));\n        },\n\n        /**\n         * Create a global keyboard shortcut.\n         * @param keychar the character of the key that is typed\n         * @param [...] additional arguments passed to dojo.hitch for making the handler\n         */\n        setGlobalKeyboardShortcut: function setGlobalKeyboardShortcut(keychar) {\n            // warn if redefining\n            if (this.globalKeyboardShortcuts[keychar]) console.warn(\"WARNING: JBrowse global keyboard shortcut '\" + keychar + \"' redefined\");\n\n            // make the wrapped handler func\n            var func = dojo.hitch.apply(dojo, Array.prototype.slice.call(arguments, 1));\n\n            // remember it\n            this.globalKeyboardShortcuts[keychar] = func;\n        },\n\n        /**\n         * Key event handler that implements all global keyboard shortcuts.\n         */\n        globalKeyHandler: function globalKeyHandler(evt) {\n            // if some digit widget is focused, don't process any global keyboard shortcuts\n            if (dijitFocus.curNode) return;\n\n            var shortcut = this.globalKeyboardShortcuts[evt.keyChar || String.fromCharCode(evt.charCode || evt.keyCode)];\n            if (shortcut) {\n                shortcut.call(this);\n                evt.stopPropagation();\n            }\n        },\n        makeSnapLink: function makeSnapLink() {\n            var browser = this;\n            var shareURL = '#';\n            var dataRoot = this.config.dataRoot;\n\n            // make the share link\n            var button = new dijitButton({\n                className: 'share',\n                innerHTML: 'Screenshot',\n                title: 'share this view',\n                onClick: function onClick() {\n                    var fs = electronRequire('fs');\n                    var remote = electronRequire('electron').remote;\n                    remote.dialog.showSaveDialog({ defaultPath: \"*/screenshot.png\" }, function (fileName) {\n                        if (fileName) {\n                            remote.getCurrentWindow().capturePage(function (img) {\n                                return fs.writeFileSync(fileName, img.toPNG());\n                            });\n                        }\n                    });\n                }\n            });\n\n            return button.domNode;\n        },\n\n        makeShareLink: function makeShareLink() {\n            // don't make the link if we were explicitly configured not to\n            if ('share_link' in this.config && !this.config.share_link) return null;\n\n            var browser = this;\n            var shareURL = '#';\n\n            // make the share link\n            var button = new dijitButton({\n                className: 'share',\n                innerHTML: '<span class=\"icon\"></span> Share',\n                title: 'share this view',\n                onClick: function onClick() {\n                    URLinput.value = shareURL;\n                    previewLink.href = shareURL;\n\n                    sharePane.show();\n                    URLinput.focus();\n                    URLinput.select();\n                    copyReminder.style.display = 'block';\n\n                    return false;\n                }\n            });\n\n            // make the 'share' popup\n            var container = dojo.create('div', {\n                innerHTML: 'Paste this link in <b>email</b> or <b>IM</b>'\n            });\n            var copyReminder = dojo.create('div', {\n                className: 'copyReminder',\n                innerHTML: 'Press CTRL-C to copy'\n            });\n            var URLinput = dojo.create('input', {\n                type: 'text',\n                value: shareURL,\n                size: 50,\n                readonly: 'readonly',\n                onclick: function onclick() {\n                    this.select();copyReminder.style.display = 'block';\n                },\n                onblur: function onblur() {\n                    copyReminder.style.display = 'none';\n                }\n            });\n            var previewLink = dojo.create('a', {\n                innerHTML: 'Preview',\n                target: '_blank',\n                href: shareURL,\n                style: { display: 'block', \"float\": 'right' }\n            }, container);\n            var sharePane = new dijitDialog({\n                className: 'sharePane',\n                title: 'Share this view',\n                draggable: false,\n                content: [container, URLinput, copyReminder],\n                autofocus: false\n            });\n\n            // connect moving and track-changing events to update it\n            var updateShareURL = function updateShareURL() {\n                shareURL = browser.makeCurrentViewURL();\n            };\n            dojo.connect(this, \"onCoarseMove\", updateShareURL);\n            this.subscribe('/jbrowse/v1/n/tracks/visibleChanged', updateShareURL);\n            this.subscribe('/jbrowse/v1/n/globalHighlightChanged', updateShareURL);\n\n            return button.domNode;\n        },\n\n        /**\n         * Return a string URL that encodes the complete viewing state of the\n         * browser.  Currently just data dir, visible tracks, and visible\n         * region.\n         * @param {Object} overrides optional key-value object containing\n         *                           components of the query string to override\n         */\n        makeCurrentViewURL: function makeCurrentViewURL(overrides) {\n            var t = _typeof(this.config.shareURL);\n\n            if (t == 'function') {\n                return this.config.shareURL.call(this, this);\n            } else if (t == 'string') {\n                return this.config.shareURL;\n            }\n\n            return \"\".concat(window.location.protocol, \"//\", window.location.host, window.location.pathname, \"?\", dojo.objectToQuery(dojo.mixin(dojo.mixin({}, this.config.queryParams || {}), dojo.mixin({\n                loc: this.view.visibleRegionLocString(),\n                tracks: this.view.visibleTrackNames().join(','),\n                highlight: (this.getHighlight() || '').toString()\n            }, overrides || {}))));\n        },\n\n        makeFullViewLink: function makeFullViewLink() {\n            var thisB = this;\n            // make the link\n            var link = dojo.create('a', {\n                className: 'topLink',\n                href: window.location.href,\n                target: '_blank',\n                title: 'View in full-screen browser',\n                innerHTML: 'Full-screen view'\n            });\n\n            var makeURL = this.config.makeFullViewURL || this.makeCurrentViewURL;\n\n            // update it when the view is moved or tracks are changed\n            var update_link = function update_link() {\n                link.href = makeURL.call(thisB, thisB);\n            };\n            dojo.connect(this, \"onCoarseMove\", update_link);\n            this.subscribe('/jbrowse/v1/n/tracks/visibleChanged', update_link);\n            this.subscribe('/jbrowse/v1/n/globalHighlightChanged', update_link);\n\n            return link;\n        },\n\n        /**\n         * @private\n         */\n\n        onCoarseMove: function onCoarseMove(startbp, endbp) {\n            var currRegion = { start: startbp, end: endbp, ref: this.refSeq.name };\n            var searchVal = \"\"; // the feature that was typed into the search field\n\n            // update the location box with our current location (in this case locationBox is the legacy search box)\n            if (this.locationBox) {\n                //this.searchVal = searchVal;\n                var searchVal = this.locationBox.get('value');\n                if (searchVal.length) searchVal = ' \"' + searchVal + '\"';\n                var locationVal = Util.assembleLocStringWithLength(currRegion);\n\n                this.locationBox.set('value', locationVal, false //< don't fire any onchange handlers\n                );\n                this.locationBox.set('placeholder', \"search features, IDs\");\n                this.goButton.set('disabled', true);\n            }\n            // update the id=location-box if it exists\n            var node = dojo.byId(\"location-info\");\n            if (node) {\n                var location = Util.assembleLocStringWithLength(currRegion);\n                html.set(node, location + searchVal);\n                this.locationBox.set('value', \"\", false);\n            }\n\n            // also update the refseq selection dropdown if present\n            this._updateRefSeqSelectBox();\n\n            if (this.reachedMilestone('completely initialized')) {\n                this._updateLocationCookies(currRegion);\n            }\n\n            // send out a message notifying of the move\n            this.publish('/jbrowse/v1/n/navigate', currRegion);\n        },\n\n        _updateRefSeqSelectBox: function _updateRefSeqSelectBox() {\n            if (this.refSeqSelectBox) {\n\n                // if none of the options in the select box match this\n                // reference sequence, add another one to the end for it\n                if (!array.some(this.refSeqSelectBox.getOptions(), function (option) {\n                    return option.value == this.refSeq.name;\n                }, this)) {\n                    this.refSeqSelectBox.set('options', this.refSeqSelectBox.getOptions().concat({ label: this.refSeq.name, value: this.refSeq.name }));\n                }\n\n                // set its value to the current ref seq\n                this.refSeqSelectBox.set('value', this.refSeq.name, false);\n            }\n        },\n\n        /**\n         * update the location and refseq cookies\n         */\n        _updateLocationCookies: function _updateLocationCookies(location) {\n            var locString = typeof location == 'string' ? location : Util.assembleLocString(location, false);\n            var oldLocMap = dojo.fromJson(this.cookie('location')) || { \"_version\": 1 };\n            if (!oldLocMap[\"_version\"]) oldLocMap = this._migrateLocMap(oldLocMap);\n            oldLocMap[this.refSeq.name] = { l: locString, t: Math.round(new Date().getTime() / 1000) - 1340211510 };\n            oldLocMap = this._limitLocMap(oldLocMap, this.config.maxSavedLocations || 10);\n            this.cookie('location', dojo.toJson(oldLocMap), { expires: 60 });\n            this.cookie('refseq', this.refSeq.name);\n        },\n\n        /**\n         * Migrate an old location map cookie to the new format that includes timestamps.\n         * @private\n         */\n        _migrateLocMap: function _migrateLocMap(locMap) {\n            var newLoc = { \"_version\": 1 };\n            for (var loc in locMap) {\n                newLoc[loc] = { l: locMap[loc], t: 0 };\n            }\n            return newLoc;\n        },\n\n        /**\n         * Limit the size of the saved location map, removing the least recently used.\n         * @private\n         */\n        _limitLocMap: function _limitLocMap(locMap, maxEntries) {\n            // don't do anything if the loc map has fewer than the max\n            var locRefs = dojof.keys(locMap);\n            if (locRefs.length <= maxEntries) return locMap;\n\n            // otherwise, calculate the least recently used that we need to\n            // get rid of to be under the size limit\n            locMap = dojo.clone(locMap);\n            var deleteLocs = locRefs.sort(function (a, b) {\n                return locMap[b].t - locMap[a].t;\n            }).slice(maxEntries - 1);\n\n            // and delete them from the locmap\n            dojo.forEach(deleteLocs, function (locRef) {\n                delete locMap[locRef];\n            });\n\n            return locMap;\n        },\n\n        /**\n         * Wrapper for dojo.cookie that namespaces our cookie names by\n         * prefixing them with this.config.containerID.\n         *\n         * Has one additional bit of smarts: if an object or array is passed\n         * instead of a string to set as the cookie contents, will serialize\n         * it with dojo.toJson before storing.\n         *\n         * @param [...] same as dojo.cookie\n         * @returns the new value of the cookie, same as dojo.cookie\n         */\n        cookie: function cookie(keyWithoutId, value) {\n            keyWithoutId = this.config.containerID + '-' + keyWithoutId;\n            var keyWithId = keyWithoutId + '-' + (this.config.dataset_id || '');\n            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') value = dojo.toJson(value);\n\n            var sizeLimit = this.config.cookieSizeLimit || 1200;\n            if (value != null && value.length > sizeLimit) {\n                console.warn(\"not setting cookie '\" + keyWithId + \"', value too big (\" + value.length + \" > \" + sizeLimit + \")\");\n                return localStorage.getItem(keyWithId);\n            } else if (value != null) {\n                try {\n                    return localStorage.setItem(keyWithId, value);\n                } catch (e) {}\n            }\n\n            return localStorage.getItem(keyWithId) || dojo.cookie(keyWithoutId);\n        },\n        /**\n         * @private\n         */\n\n        createNavBox: function createNavBox(parent) {\n            var thisB = this;\n            var align = 'center';\n            var navbox = dojo.create('div', { id: 'navbox', style: { 'text-align': align } }, parent);\n\n            // container adds a white backdrop to the locationTrap.\n            var locationTrapContainer = dojo.create('div', { className: 'locationTrapContainer' }, navbox);\n\n            this.locationTrap = dojo.create('div', { className: 'locationTrap' }, locationTrapContainer);\n\n            var four_nbsp = String.fromCharCode(160);four_nbsp = four_nbsp + four_nbsp + four_nbsp + four_nbsp;\n            navbox.appendChild(document.createTextNode(four_nbsp));\n\n            var moveLeft = document.createElement(\"img\");\n            //moveLeft.type = \"image\";\n            moveLeft.src = this.resolveUrl(\"img/Empty.png\");\n            moveLeft.id = \"moveLeft\";\n            moveLeft.className = \"icon nav\";\n            navbox.appendChild(moveLeft);\n            dojo.connect(moveLeft, \"click\", this, function (event) {\n                dojo.stopEvent(event);\n                this.view.slide(0.9);\n            });\n\n            var moveRight = document.createElement(\"img\");\n            //moveRight.type = \"image\";\n            moveRight.src = this.resolveUrl(\"img/Empty.png\");\n            moveRight.id = \"moveRight\";\n            moveRight.className = \"icon nav\";\n            navbox.appendChild(moveRight);\n            dojo.connect(moveRight, \"click\", this, function (event) {\n                dojo.stopEvent(event);\n                this.view.slide(-0.9);\n            });\n\n            navbox.appendChild(document.createTextNode(four_nbsp));\n\n            var bigZoomOut = document.createElement(\"img\");\n            //bigZoomOut.type = \"image\";\n            bigZoomOut.src = this.resolveUrl(\"img/Empty.png\");\n            bigZoomOut.id = \"bigZoomOut\";\n            bigZoomOut.className = \"icon nav\";\n            navbox.appendChild(bigZoomOut);\n            dojo.connect(bigZoomOut, \"click\", this, function (event) {\n                dojo.stopEvent(event);\n                this.view.zoomOut(undefined, undefined, 2);\n            });\n\n            var zoomOut = document.createElement(\"img\");\n            //zoomOut.type = \"image\";\n            zoomOut.src = this.resolveUrl(\"img/Empty.png\");\n            zoomOut.id = \"zoomOut\";\n            zoomOut.className = \"icon nav\";\n            navbox.appendChild(zoomOut);\n            dojo.connect(zoomOut, \"click\", this, function (event) {\n                dojo.stopEvent(event);\n                this.view.zoomOut();\n            });\n\n            var zoomIn = document.createElement(\"img\");\n            //zoomIn.type = \"image\";\n            zoomIn.src = this.resolveUrl(\"img/Empty.png\");\n            zoomIn.id = \"zoomIn\";\n            zoomIn.className = \"icon nav\";\n            navbox.appendChild(zoomIn);\n            dojo.connect(zoomIn, \"click\", this, function (event) {\n                dojo.stopEvent(event);\n                this.view.zoomIn();\n            });\n\n            var bigZoomIn = document.createElement(\"img\");\n            //bigZoomIn.type = \"image\";\n            bigZoomIn.src = this.resolveUrl(\"img/Empty.png\");\n            bigZoomIn.id = \"bigZoomIn\";\n            bigZoomIn.className = \"icon nav\";\n            navbox.appendChild(bigZoomIn);\n            dojo.connect(bigZoomIn, \"click\", this, function (event) {\n                dojo.stopEvent(event);\n                this.view.zoomIn(undefined, undefined, 2);\n            });\n\n            navbox.appendChild(document.createTextNode(four_nbsp));\n\n            // default search box is location box\n            var locationMode = \"\";\n            var locationWidth = '40ex';\n            if (this.config.locationBox === \"separate\") {\n                // separate location box\n                locationMode = \"separate-location-box\";\n                locationWidth = '25ex';\n            }\n\n            var searchbox = dojo.create('span', {\n                'id': 'search-box',\n                'class': locationMode\n            }, navbox);\n\n            // if we have fewer than 30 ref seqs, or `refSeqDropdown: true` is\n            // set in the config, then put in a dropdown box for selecting\n            // reference sequences\n            var refSeqSelectBoxPlaceHolder = dojo.create('span', { id: 'search-refseq' }, searchbox);\n\n            // make the location search box\n            this.locationBox = new dijitComboBox({\n                id: \"location\",\n                name: \"location\",\n                style: { width: locationWidth },\n                maxLength: 400,\n                searchAttr: \"name\",\n                title: 'Enter a chromosomal position, symbol or ID to search'\n            }, dojo.create('input', {}, searchbox));\n\n            this.afterMilestone('loadNames', dojo.hitch(this, function () {\n                if (this.nameStore) {\n                    this.locationBox.set('store', this.nameStore);\n                }\n            }));\n\n            this.locationBox.focusNode.spellcheck = false;\n            dojo.query('div.dijitArrowButton', this.locationBox.domNode).orphan();\n            dojo.connect(this.locationBox.focusNode, \"keydown\", this, function (event) {\n                if (event.keyCode == keys.ESCAPE) {\n                    this.locationBox.set('value', '');\n                } else if (event.keyCode == keys.ENTER) {\n                    this.locationBox.closeDropDown(false);\n                    this.navigateTo(this.locationBox.get('value'));\n                    this.goButton.set('disabled', true);\n                    dojo.stopEvent(event);\n                } else {\n                    this.goButton.set('disabled', false);\n                }\n            });\n            dojo.connect(navbox, 'onselectstart', function (evt) {\n                evt.stopPropagation();return true;\n            });\n\n            // monkey-patch the combobox code to make a few modifications\n            (function () {\n                var PatchedDropDownClass = dojo.declare(this.locationBox.dropDownClass, {\n                    // add a moreMatches class to our hacked-in \"more options\" option\n                    _createOption: function _createOption(item) {\n                        var option = this.inherited(arguments);\n                        if (item.hitLimit) dojo.addClass(option, 'moreMatches');\n                        return option;\n                    },\n                    // prevent the \"more matches\" option from being clicked\n                    onClick: function onClick(node) {\n                        if (dojo.hasClass(node, 'moreMatches')) return null;\n\n                        var ret = this.inherited(arguments);\n                        thisB.navigateTo(thisB.locationBox.get('value'));\n                        return ret;\n                    }\n                });\n                this.locationBox.dropDownClass = PatchedDropDownClass;\n            }).call(this);\n\n            // make the 'Go' button\n            this.goButton = new dijitButton({\n                label: 'Go',\n                onClick: dojo.hitch(this, function (event) {\n                    this.navigateTo(this.locationBox.get('value'));\n                    this.goButton.set('disabled', true);\n                    dojo.stopEvent(event);\n                }),\n                id: 'search-go-btn'\n            }, dojo.create('button', {}, searchbox));\n\n            this.highlightButtonPreviousState = false;\n\n            // create location box\n            // if in config \"locationBox\": \"separate\", then the search box will be the location box.\n            if (this.config.locationBox === \"separate\") {\n                this.locationInfoBox = domConstruct.place(\"<div id='location-info'>location</div>\", navbox);\n            }\n\n            // make the highligher button\n            this.highlightButton = new dojoxTriStateCheckBox({\n                //label: 'Highlight',\n                title: 'Highlight a Region',\n                id: 'highlight-btn',\n                states: [false, true, \"mixed\"],\n                onChange: function onChange() {\n                    if (this.get('checked') == true) {\n                        thisB.view._rubberStop();\n                        thisB.view.behaviorManager.swapBehaviors('normalMouse', 'highlightingMouse');\n                    } else if (this.get('checked') == false) {\n                        var h = thisB.getHighlight();\n                        if (h) {\n                            thisB.clearHighlight();\n                            thisB.view.redrawRegion(h);\n                        }\n                    } else {\n                        // mixed\n                        // Uncheck since user is cycling three-state instead\n                        // of programmatically landing in mixed state\n                        if (thisB.highlightButtonPreviousState != true) {\n                            thisB.highlightButton.set('checked', false);\n                        } else {\n                            thisB.highlightButtonPreviousState = false;\n                        }\n                        thisB.view._rubberStop();\n                        thisB.view.behaviorManager.swapBehaviors('highlightingMouse', 'normalMouse');\n                    }\n                }\n            }, dojo.create('button', { id: 'highlight-btn' }, navbox));\n\n            this.subscribe('/jbrowse/v1/n/globalHighlightChanged', function () {\n                thisB.highlightButton.set('checked', false);\n            });\n\n            this.afterMilestone('loadRefSeqs', dojo.hitch(this, function () {\n\n                // make the refseq selection dropdown\n                if (this.refSeqOrder && this.refSeqOrder.length) {\n                    var max = this.config.refSeqSelectorMaxSize || 30;\n                    var numrefs = Math.min(max, this.refSeqOrder.length);\n                    var options = [];\n                    for (var i = 0; i < numrefs; i++) {\n                        options.push({ label: this.refSeqOrder[i], value: this.refSeqOrder[i] });\n                    }\n                    var tooManyMessage = '(first ' + numrefs + ' ref seqs)';\n                    if (this.refSeqOrder.length > max) {\n                        options.push({ label: tooManyMessage, value: tooManyMessage, disabled: true });\n                    }\n                    this.refSeqSelectBox = new dijitSelectBox({\n                        name: 'refseq',\n                        value: this.refSeq ? this.refSeq.name : null,\n                        options: options,\n                        onChange: dojo.hitch(this, function (newRefName) {\n                            // don't trigger nav if it's the too-many message\n                            if (newRefName == tooManyMessage) {\n                                this.refSeqSelectBox.set('value', this.refSeq.name);\n                                return;\n                            }\n\n                            // only trigger navigation if actually switching sequences\n                            if (newRefName != this.refSeq.name) {\n                                this.navigateToLocation({ ref: newRefName });\n                            }\n                        })\n                    }).placeAt(refSeqSelectBoxPlaceHolder);\n                }\n\n                // calculate how big to make the location box:  make it big enough to hold the\n                var locLength = this.config.locationBoxLength || function () {\n\n                    // if we have no refseqs, just use 20 chars\n                    if (!this.refSeqOrder.length) return 20;\n\n                    // if there are not tons of refseqs, pick the longest-named\n                    // one.  otherwise just pick the last one\n                    var ref = this.refSeqOrder.length < 1000 && function () {\n                        var longestNamedRef;\n                        array.forEach(this.refSeqOrder, function (name) {\n                            var ref = this.allRefs[name];\n                            if (!ref.length) ref.length = ref.end - ref.start + 1;\n                            if (!longestNamedRef || longestNamedRef.length < ref.length) longestNamedRef = ref;\n                        }, this);\n                        return longestNamedRef;\n                    }.call(this) || this.refSeqOrder.length && this.allRefs[this.refSeqOrder[this.refSeqOrder.length - 1]] || 20;\n\n                    var locstring = Util.assembleLocStringWithLength({ ref: ref.name, start: ref.end - 1, end: ref.end, length: ref.length });\n                    //console.log( locstring, locstring.length );\n                    return locstring.length;\n                }.call(this) || 20;\n\n                this.locationBox.domNode.style.width = locLength + 'ex';\n            }));\n\n            return navbox;\n        },\n        /**\n         * Return the current highlight region, or null if none.\n         */\n        getHighlight: function getHighlight() {\n            return this._highlight || null;\n        },\n\n        getBookmarks: function getBookmarks() {\n            if (this.config.bookmarkService) {\n                return request(this.config.bookmarkService + \"?\" + ioQuery.objectToQuery({ sequence: this.refSeq.name, organism: this.config.dataset_id }), {\n                    handleAs: \"json\"\n                });\n            } else return this.config.bookmarks;\n        },\n\n        /**\n         * Set a new highlight.  Returns the new highlight.\n         */\n        setHighlight: function setHighlight(newHighlight) {\n\n            if (newHighlight && newHighlight instanceof Location) this._highlight = newHighlight;else if (newHighlight) this._highlight = new Location(newHighlight);\n\n            this.publish('/jbrowse/v1/n/globalHighlightChanged', [this._highlight]);\n\n            return this.getHighlight();\n        },\n\n        _updateHighlightClearButton: function _updateHighlightClearButton() {\n            var isHighlightSet = !!this._highlight;\n            if (this._highlightClearButton) {\n                this._highlightClearButton.set('disabled', !isHighlightSet);\n                //this._highlightClearButton.set( 'label', 'Clear highlight' + ( this._highlight ? ' - ' + this._highlight : '' ));\n            }\n            if (this.highlightButton) {\n                this.highlightButton.set('checked', isHighlightSet ? 'mixed' : false);\n                this.highlightButtonPreviousState = isHighlightSet;\n            }\n        },\n\n        clearHighlight: function clearHighlight() {\n            if (this._highlight) {\n                delete this._highlight;\n                this.publish('/jbrowse/v1/n/globalHighlightChanged', []);\n            }\n        },\n\n        setHighlightAndRedraw: function setHighlightAndRedraw(location) {\n            location = this.regularizeLocation(location);\n\n            var oldHighlight = this.getHighlight();\n            if (oldHighlight) this.view.hideRegion(oldHighlight);\n            this.view.hideRegion(location);\n            this.setHighlight(location);\n            this.view.showVisibleBlocks(false);\n        },\n\n        /**\n         * Shows a region that has been searched for someplace else in the UI.\n         * Highlights it if this.config.highlightSearchedRegions is true.\n         */\n        showRegionAfterSearch: function showRegionAfterSearch(location) {\n            location = this.regularizeLocation(location);\n\n            if (this.config.highlightSearchedRegions) {\n                var oldHighlight = this.getHighlight();\n                if (oldHighlight) this.view.hideRegion(oldHighlight);\n                this.view.hideRegion(location);\n                this.setHighlight(location);\n            }\n            this.showRegion(location);\n        },\n        showRegionWithHighlight: function showRegionWithHighlight() {\n            // backcompat\n            return this.showRegionAfterSearch.apply(this, arguments);\n        },\n\n        /**\n         * Tear it all down: remove all subscriptions, destroy widgets and DOM\n         */\n        teardown: function teardown() {\n            for (var id in this._subscription) {\n                this._subscription[id].remove();\n            }\n\n            if (this.containerWidget) this.containerWidget.destroyRecursive(true);\n\n            while (this.container && this.container.firstChild) {\n                this.container.removeChild(this.container.firstChild);\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n\n//# sourceURL=webpack:///./src/JBrowse/Browser.js?");

/***/ }),

/***/ "./src/JBrowse/CodonTable.js":
/*!***********************************!*\
  !*** ./src/JBrowse/CodonTable.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare) {\n\n    return declare(null, {\n\n        defaultStarts: ['ATG'],\n        defaultStops: ['TAA', 'TAG', 'TGA'],\n        defaultCodonTable: {\n\n            \"TCA\": \"S\",\n            \"TCC\": \"S\",\n            \"TCG\": \"S\",\n            \"TCT\": \"S\",\n            \"TTC\": \"F\",\n            \"TTT\": \"F\",\n            \"TTA\": \"L\",\n            \"TTG\": \"L\",\n            \"TAC\": \"Y\",\n            \"TAT\": \"Y\",\n            \"TAA\": \"*\",\n            \"TAG\": \"*\",\n            \"TGC\": \"C\",\n            \"TGT\": \"C\",\n            \"TGA\": \"*\",\n            \"TGG\": \"W\",\n            \"CTA\": \"L\",\n            \"CTC\": \"L\",\n            \"CTG\": \"L\",\n            \"CTT\": \"L\",\n            \"CCA\": \"P\",\n            \"CCC\": \"P\",\n            \"CCG\": \"P\",\n            \"CCT\": \"P\",\n            \"CAC\": \"H\",\n            \"CAT\": \"H\",\n            \"CAA\": \"Q\",\n            \"CAG\": \"Q\",\n            \"CGA\": \"R\",\n            \"CGC\": \"R\",\n            \"CGG\": \"R\",\n            \"CGT\": \"R\",\n            \"ATA\": \"I\",\n            \"ATC\": \"I\",\n            \"ATT\": \"I\",\n            \"ATG\": \"M\",\n            \"ACA\": \"T\",\n            \"ACC\": \"T\",\n            \"ACG\": \"T\",\n            \"ACT\": \"T\",\n            \"AAC\": \"N\",\n            \"AAT\": \"N\",\n            \"AAA\": \"K\",\n            \"AAG\": \"K\",\n            \"AGC\": \"S\",\n            \"AGT\": \"S\",\n            \"AGA\": \"R\",\n            \"AGG\": \"R\",\n            \"GTA\": \"V\",\n            \"GTC\": \"V\",\n            \"GTG\": \"V\",\n            \"GTT\": \"V\",\n            \"GCA\": \"A\",\n            \"GCC\": \"A\",\n            \"GCG\": \"A\",\n            \"GCT\": \"A\",\n            \"GAC\": \"D\",\n            \"GAT\": \"D\",\n            \"GAA\": \"E\",\n            \"GAG\": \"E\",\n            \"GGA\": \"G\",\n            \"GGC\": \"G\",\n            \"GGG\": \"G\",\n            \"GGT\": \"G\"\n        },\n\n        generateCodonTable: function generateCodonTable(table) {\n            /**\n            *  take CodonTable above and generate larger codon table that includes\n            *  all permutations of upper and lower case nucleotides\n            */\n            var tempCodonTable = {};\n            for (var codon in table) {\n                // looping through codon table, make sure not hitting generic properties...\n                if (table.hasOwnProperty(codon)) {\n                    var aa = table[codon];\n                    // console.log(\"Codon: \", codon, \", aa: \", aa);\n                    var nucs = [];\n                    for (var i = 0; i < 3; i++) {\n                        var nuc = codon.charAt(i);\n                        nucs[i] = [];\n                        nucs[i][0] = nuc.toUpperCase();\n                        nucs[i][1] = nuc.toLowerCase();\n                    }\n                    for (var i = 0; i < 2; i++) {\n                        var n0 = nucs[0][i];\n                        for (var j = 0; j < 2; j++) {\n                            var n1 = nucs[1][j];\n                            for (var k = 0; k < 2; k++) {\n                                var n2 = nucs[2][k];\n                                var triplet = n0 + n1 + n2;\n                                tempCodonTable[triplet] = aa;\n                            }\n                        }\n                    }\n                }\n            }\n            return tempCodonTable;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/CodonTable.js?");

/***/ }),

/***/ "./src/JBrowse/ConfigAdaptor/JB_json_v0.js":
/*!*************************************************!*\
  !*** ./src/JBrowse/ConfigAdaptor/JB_json_v0.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/ConfigAdaptor/JB_json_v1 */ \"./src/JBrowse/ConfigAdaptor/JB_json_v1.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, JB_json_v1) {\n    return declare('JBrowse.ConfigAdaptor.JB_json_v0', JB_json_v1,\n\n    /**\n     * @lends JBrowse.ConfigAdaptor.JB_json_v0.prototype\n     */\n    {\n\n        /**\n         * Configuration adaptor for JBrowse JSON version 0\n         * <code>trackInfo.js</code> files.\n         * @constructs\n         * @extends JBrowse.ConfigAdaptor.JB_json_v1\n         */\n        constructor: function constructor() {},\n\n        /**\n         * Munge the v0 configuration to conform to v1.\n         *\n         * @param {Object} o the object containing the configuration, which it\n         *                   modifies in-place\n         * @param {Object} load_args the arguments that were passed to <code>load()</code>\n         * @returns {Object} v1-compliant configuration\n         */\n        regularize_conf: function regularize_conf(o, load_args) {\n\n            // transform Ye Olde Confige to conform to format version 1\n            o = { tracks: o };\n            dojo.forEach(o.tracks, function (trackdef) {\n                if ('url' in trackdef) {\n                    trackdef.urlTemplate = trackdef.url;\n                    //trackdef.urlTemplate = trackdef.url.replace(/\\{refseq\\}\\/([^/]+)/, \"$1/{refseq}\");\n                    delete trackdef.url;\n\n                    // TODO: this backendVersion thing is a stopgap until we\n                    // refactor far enough to have real pluggable datasources\n                    trackdef.backendVersion = 0;\n                }\n            });\n\n            return this.inherited(arguments, [o, load_args]);\n        },\n\n        /**\n         * Parse the trackInfo.js configuration text into JSON.\n         *\n         * @param {String} conf_text the text in the conf file\n         * @returns {Object} parsed JSON\n         */\n        parse_conf: function parse_conf(conf_text) {\n            conf_text.replace(/^[^\\{]+/, '');\n            return this.inherited(arguments, [conf_text]);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/ConfigAdaptor/JB_json_v0.js?");

/***/ }),

/***/ "./src/JBrowse/Errors.js":
/*!*******************************!*\
  !*** ./src/JBrowse/Errors.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * All of the different JBrowse Error objects.  This amounts to a\n * taxonomy of the different errors that JBrowse code can reason\n * about.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare) {\n\n    var Base = declare(Error, {\n        constructor: function constructor(args) {\n            if ((typeof args === 'undefined' ? 'undefined' : _typeof(args)) == 'object') {\n                if (args instanceof Error) {\n                    this._originalError = args;\n                    this.message = '' + args;\n                    this.stack = args.stack;\n                } else dojo.mixin(this, args);\n            } else if (typeof args == 'string') {\n                this._originalError = new Error();\n                this.message = args;\n                this.stack = this._originalError.stack;\n            }\n\n            if (!this.message) this.message = this._defaultMessage;\n        }\n    });\n\n    var Errors = {};\n\n    Errors.Fatal = declare(Base, {\n        _defaultMessage: 'Unknown fatal error.'\n    });\n\n    /**\n     * Took too long to handle data.\n     */\n    Errors.TimeOut = declare(Base, {\n        _defaultMessage: 'Data took too long to fetch.'\n    });\n\n    /**\n     * Too much data to handle.\n     */\n    Errors.DataOverflow = declare(Base, {\n        _defaultMessage: 'Too much data to show.'\n    });\n\n    return Errors;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Errors.js?");

/***/ }),

/***/ "./src/JBrowse/FeatureFiltererMixin.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/FeatureFiltererMixin.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Mixin that dynamically defines and redefines a filterFeature()\n * method, and supports a filtering hierarchy, and filter chaining at\n * each level of the hierarchy.  Designed to be really fast, because\n * filterFeature() is going to be called many, many times.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array) {\n\n    var serialNumber = 0;\n\n    return declare(null, {\n        filterFeature: function filterFeature(feature) {\n            return true;\n        },\n\n        _featureFilterChain: [],\n\n        addFeatureFilter: function addFeatureFilter(filter, uniqName) {\n            uniqName = this._getFeatureFilterName(uniqName);\n            this._featureFilterChain.push({ name: uniqName, filter: filter });\n            this._buildFeatureFilter();\n            return uniqName;\n        },\n\n        // need to have a unique name for every function we're passed so\n        // that we can tell them apart.  stringification and strict\n        // equality don't always work.\n        _getFeatureFilterName: function _getFeatureFilterName(uniqName) {\n            if (uniqName === undefined) return 'featureFilter_' + ++serialNumber;\n            return uniqName;\n        },\n\n        removeFeatureFilter: function removeFeatureFilter(uniqName) {\n            var newchain = [];\n            for (var i = 0; i < this._featureFilterChain.length; i++) {\n                if (this._featureFilterChain[i].name !== uniqName) newchain.push(this._featureFilterChain[i]);\n            }\n            this._featureFilterChain = newchain;\n            this._buildFeatureFilter();\n        },\n\n        _buildFeatureFilter: function _buildFeatureFilter() {\n\n            var filterChain = this._featureFilterChain.slice();\n\n            if (!filterChain.length) this.filterFeature = function (feat) {\n                return this.featureFilterParentComponent.filterFeature(feat);\n            };else if (filterChain.length == 1) {\n                var single = filterChain[0].filter;\n                this.filterFeature = function (feat) {\n                    return single.call(this, feat) && this.featureFilterParentComponent.filterFeature(feat);\n                };\n            } else this.filterFeature = function (feat) {\n                for (var i = 0; i < filterChain.length; i++) {\n                    if (!filterChain[i].filter.call(this, feat)) return false;\n                }if (!this.featureFilterParentComponent.filterFeature(feat)) return false;\n\n                return true;\n            };\n        },\n\n        featureFilterParentComponent: { filterFeature: function filterFeature() {\n                return true;\n            } },\n\n        setFeatureFilter: function setFeatureFilter(filter, uniqName) {\n            this._featureFilterChain = [];\n            this.addFeatureFilter(filter, uniqName);\n        },\n\n        clearFeatureFilter: function clearFeatureFilter() {\n            this._featureFilterChain = [];\n            this._buildFeatureFilter();\n        },\n\n        setFeatureFilterParentComponent: function setFeatureFilterParentComponent(parent) {\n            this.featureFilterParentComponent = parent;\n            this._buildFeatureFilter();\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/FeatureFiltererMixin.js?");

/***/ }),

/***/ "./src/JBrowse/GenomeView.js":
/*!***********************************!*\
  !*** ./src/JBrowse/GenomeView.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _normalizeWheel2 = __webpack_require__(/*! normalize-wheel */ \"./node_modules/normalize-wheel/index.js\");\n\nvar _normalizeWheel3 = _interopRequireDefault(_normalizeWheel2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! dojo/dnd/move */ \"./node_modules/dojo/dnd/move.js\"), __webpack_require__(/*! dojo/dnd/Source */ \"./node_modules/dojo/dnd/Source.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! JBrowse/Component */ \"./src/JBrowse/Component.js\"), __webpack_require__(/*! JBrowse/FeatureFiltererMixin */ \"./src/JBrowse/FeatureFiltererMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/LocationScale */ \"./src/JBrowse/View/Track/LocationScale.js\"), __webpack_require__(/*! JBrowse/View/Track/GridLines */ \"./src/JBrowse/View/Track/GridLines.js\"), __webpack_require__(/*! JBrowse/BehaviorManager */ \"./src/JBrowse/BehaviorManager.js\"), __webpack_require__(/*! JBrowse/View/Animation/Zoomer */ \"./src/JBrowse/View/Animation/Zoomer.js\"), __webpack_require__(/*! JBrowse/View/Animation/Slider */ \"./src/JBrowse/View/Animation/Slider.js\"), __webpack_require__(/*! JBrowse/View/InfoDialog */ \"./src/JBrowse/View/InfoDialog.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, domConstruct, Util, has, dndMove, dndSource, dijitFocus, Component, FeatureFiltererMixin, LocationScaleTrack, GridLinesTrack, BehaviorManager, Zoomer, Slider, InfoDialog) {\n\n    var dojof = Util.dojof;\n\n    // weird subclass of dojo dnd constrained mover to make the location\n    // thumb behave better\n    var locationThumbMover = declare(dndMove.constrainedMoveable, {\n        constructor: function constructor(node, params) {\n            this.constraints = function () {\n                var n = this.node.parentNode,\n                    mb = dojo.marginBox(n);\n                mb.t = 0;\n                return mb;\n            };\n        }\n    });\n\n    /**\n     * Main view class, shows a scrollable, horizontal view of annotation\n     * tracks.  NOTE: All coordinates are interbase.\n     * @class\n     * @constructor\n     */\n\n    return declare([Component, FeatureFiltererMixin], {\n\n        constructor: function constructor(args) {\n            var browser = args.browser;\n            var elem = args.elem;\n            var stripeWidth = args.stripeWidth;\n            var refseq = args.refSeq;\n            var zoomLevel = args.zoomLevel;\n            this.desiredTracks = {};\n            // keep a reference to the main browser object\n            this.browser = browser;\n            this.setFeatureFilterParentComponent(this.browser);\n\n            this.focusTrack = null;\n\n            //the page element that the GenomeView lives in\n            this.elem = elem;\n\n            this.posHeight = this.calculatePositionLabelHeight(elem);\n            // Add an arbitrary 50% padding between the position labels and the\n            // topmost track\n            this.topSpace = this.posHeight * 1.5;\n\n            // handle trackLabels option\n            if (typeof browser.config.trackLabels !== 'undefined' && browser.config.trackLabels === \"no-block\") {\n                this.config.trackPadding = 35;\n                this.topSpace = this.posHeight * 3;\n            }\n\n            // WebApollo needs max zoom level to be sequence residues char width\n            this.maxPxPerBp = this.config.maxPxPerBp;\n\n            //the reference sequence\n            this.ref = refseq;\n            //current scale, in pixels per bp\n            this.pxPerBp = zoomLevel;\n\n            //width, in pixels, of the vertical stripes\n            this.stripeWidth = stripeWidth;\n\n            // the scrollContainer is the element that changes position\n            // when the user scrolls\n            this.scrollContainer = dojo.create('div', {\n                id: 'container',\n                style: { position: 'absolute',\n                    left: '0px',\n                    top: '0px'\n                }\n            }, elem);\n\n            this._renderVerticalScrollBar();\n\n            // we have a separate zoomContainer as a child of the scrollContainer.\n            // they used to be the same element, but making zoomContainer separate\n            // enables it to be narrower than this.elem.\n            this.zoomContainer = document.createElement(\"div\");\n            this.zoomContainer.id = \"zoomContainer\";\n            this.zoomContainer.style.cssText = \"position: absolute; left: 0px; top: 0px; height: 100%;\";\n            this.scrollContainer.appendChild(this.zoomContainer);\n\n            this.outerTrackContainer = document.createElement(\"div\");\n            this.outerTrackContainer.className = \"trackContainer outerTrackContainer\";\n            this.outerTrackContainer.style.cssText = \"height: 100%;\";\n            this.zoomContainer.appendChild(this.outerTrackContainer);\n\n            this.trackContainer = document.createElement(\"div\");\n            this.trackContainer.className = \"trackContainer innerTrackContainer draggable\";\n            this.trackContainer.style.cssText = \"height: 100%;\";\n            this.outerTrackContainer.appendChild(this.trackContainer);\n\n            //width, in pixels of the \"regular\" (not min or max zoom) stripe\n            this.regularStripe = stripeWidth;\n\n            this.overview = this.browser.overviewDiv;\n            this.overviewBox = dojo.marginBox(this.overview);\n\n            this.tracks = [];\n            this.uiTracks = [];\n            this.trackIndices = {};\n\n            //set up size state (zoom levels, stripe percentage, etc.)\n            this.sizeInit();\n\n            //distance, in pixels, from the beginning of the reference sequence\n            //to the beginning of the first active stripe\n            //  should always be a multiple of stripeWidth\n            this.offset = 0;\n            //largest value for the sum of this.offset and this.getX()\n            //this prevents us from scrolling off the right end of the ref seq\n            this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth();\n            //smallest value for the sum of this.offset and this.getX()\n            //this prevents us from scrolling off the left end of the ref seq\n            this.minLeft = this.bpToPx(this.ref.start);\n            //extra margin to draw around the visible area, in multiples of the visible area\n            //0: draw only the visible area; 0.1: draw an extra 10% around the visible area, etc.\n            this.drawMargin = 0.2;\n            //slide distance (pixels) * slideTimeMultiple + 200 = milliseconds for slide\n            //1=1 pixel per millisecond average slide speed, larger numbers are slower\n            this.slideTimeMultiple = 0.8;\n            this.trackHeights = [];\n            this.trackTops = [];\n            this.waitElems = dojo.filter([dojo.byId(\"moveLeft\"), dojo.byId(\"moveRight\"), dojo.byId(\"zoomIn\"), dojo.byId(\"zoomOut\"), dojo.byId(\"bigZoomIn\"), dojo.byId(\"bigZoomOut\"), document.body, elem], function (e) {\n                return e;\n            });\n            this.prevCursors = [];\n            this.locationThumb = document.createElement(\"div\");\n            this.locationThumb.className = \"locationThumb\";\n            this.overview.appendChild(this.locationThumb);\n            this.locationThumbMover = new locationThumbMover(this.locationThumb, { area: \"content\", within: true });\n\n            this.x = this.elem.scrollLeft;\n            this.y = 0;\n\n            var scaleTrackDiv = document.createElement(\"div\");\n            scaleTrackDiv.className = \"track static_track rubberBandAvailable\";\n            scaleTrackDiv.style.height = this.posHeight + \"px\";\n            scaleTrackDiv.id = \"static_track\";\n\n            this.scaleTrackDiv = scaleTrackDiv;\n            this.staticTrack = new LocationScaleTrack({\n                label: \"static_track\",\n                labelClass: \"pos-label\",\n                posHeight: this.posHeight,\n                browser: this.browser,\n                refSeq: this.ref\n            });\n            this.staticTrack.setViewInfo(this, function (height) {}, this.stripeCount, this.scaleTrackDiv, this.stripePercent, this.stripeWidth, this.pxPerBp, this.config.trackPadding);\n            this.zoomContainer.appendChild(this.scaleTrackDiv);\n            this.waitElems.push(this.scaleTrackDiv);\n\n            var gridTrackDiv = document.createElement(\"div\");\n            gridTrackDiv.className = \"track\";\n            gridTrackDiv.style.cssText = \"top: 0px; height: 100%;\";\n            gridTrackDiv.id = \"gridtrack\";\n            var gridTrack = new GridLinesTrack({\n                browser: this.browser,\n                refSeq: this.ref\n            });\n            gridTrack.setViewInfo(this, function (height) {}, this.stripeCount, gridTrackDiv, this.stripePercent, this.stripeWidth, this.pxPerBp, this.config.trackPadding);\n            this.trackContainer.appendChild(gridTrackDiv);\n            this.uiTracks = [this.staticTrack, gridTrack];\n\n            // accept tracks being dragged into this\n            this.trackDndWidget = new dndSource(this.trackContainer, {\n                accept: [\"track\"], //accepts only tracks into the viewing field\n                withHandles: true,\n                creator: dojo.hitch(this, function (trackConfig, hint) {\n                    return {\n                        data: trackConfig,\n                        type: [\"track\"],\n                        node: hint == 'avatar' ? dojo.create('div', { innerHTML: trackConfig.key || trackConfig.label, className: 'track-label dragging' }) : this.renderTrack(trackConfig)\n                    };\n                })\n            });\n\n            // subscribe to showTracks commands\n            this.browser.subscribe('/dnd/drop', dojo.hitch(this, function (source, nodes, copy, target) {\n                this.updateTrackList();\n                if (target.node === this.trackContainer) {\n                    // if dragging into the trackcontainer, we are showing some tracks\n                    // get the configs from the tracks being dragged in\n                    var confs = dojo.filter(dojo.map(nodes, function (n) {\n                        return n.track && n.track.config;\n                    }), function (c) {\n                        return c;\n                    });\n                    this.browser.publish('/jbrowse/v1/v/tracks/show', confs);\n                }\n            }));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/show', dojo.hitch(this, 'showTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/hide', dojo.hitch(this, 'hideTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/replace', dojo.hitch(this, 'replaceTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/delete', dojo.hitch(this, 'hideTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/pin', dojo.hitch(this, 'pinTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/unpin', dojo.hitch(this, 'unpinTracks'));\n\n            // render our UI tracks (horizontal scale tracks, grid lines, and so forth)\n            dojo.forEach(this.uiTracks, function (track) {\n                track.showRange(0, this.stripeCount - 1, Math.round(this.pxToBp(this.offset)), Math.round(this.stripeWidth / this.pxPerBp), this.pxPerBp);\n            }, this);\n\n            this.addOverviewTrack(new LocationScaleTrack({\n                label: \"overview_loc_track\",\n                labelClass: \"overview-pos\",\n                posHeight: this.overviewPosHeight,\n                browser: this.browser,\n                refSeq: this.ref\n            }));\n            this.showFine();\n            this.showCoarse();\n\n            // initialize the behavior manager used for setting what this view\n            // does (i.e. the behavior it has) for mouse and keyboard events\n            this.behaviorManager = new BehaviorManager({ context: this, behaviors: this._behaviors() });\n            this.behaviorManager.initialize();\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return {\n                maxPxPerBp: 20,\n                trackPadding: 20 // distance in pixels between each track\n            };\n        },\n\n        /**\n         * @returns {Object} containing ref, start, and end members for the currently displayed location\n         */\n        visibleRegion: function visibleRegion() {\n            return {\n                ref: this.ref.name,\n                start: this.minVisible(),\n                end: this.maxVisible()\n            };\n        },\n\n        /**\n         * @returns {String} locstring representation of the current location<br>\n         * (suitable for passing to the browser's navigateTo)\n         */\n        visibleRegionLocString: function visibleRegionLocString() {\n            return Util.assembleLocString(this.visibleRegion());\n        },\n\n        /**\n         * Create and place the elements for the vertical scrollbar.\n         * @private\n         */\n        _renderVerticalScrollBar: function _renderVerticalScrollBar() {\n            var container = dojo.create('div', {\n                className: 'vertical_scrollbar',\n                style: { position: 'absolute',\n                    right: '0px',\n                    bottom: '0px',\n                    height: '100%',\n                    width: '10px',\n                    zIndex: 1000\n                }\n            }, this.browser.container);\n\n            var positionMarker = dojo.create('div', {\n                className: 'vertical_position_marker',\n                style: {\n                    position: 'absolute',\n                    height: '100%'\n                }\n            }, container);\n            this.verticalScrollBar = { container: container, positionMarker: positionMarker, width: container.offsetWidth };\n        },\n\n        /**\n         * Update the position and look of the vertical scroll bar as our\n         * y-scroll offset changes.\n         * @private\n         */\n        _updateVerticalScrollBar: function _updateVerticalScrollBar(newDims) {\n            if (typeof newDims.height == 'number') {\n                var heightAdjust = this.staticTrack ? -this.staticTrack.div.offsetHeight : 0;\n                var trackPaneHeight = newDims.height + heightAdjust;\n                this.verticalScrollBar.container.style.height = trackPaneHeight - (this.pinUnderlay ? this.pinUnderlay.offsetHeight + heightAdjust : 0) + 'px';\n                var markerHeight = newDims.height / (this.containerHeight || 1) * 100;\n                this.verticalScrollBar.positionMarker.style.height = markerHeight > 0.5 ? markerHeight + '%' : '1px';\n                if (newDims.height / (this.containerHeight || 1) > 0.98) {\n                    this.verticalScrollBar.container.style.display = 'none';\n                    this.verticalScrollBar.visible = false;\n                } else {\n                    this.verticalScrollBar.container.style.display = 'block';\n                    this.verticalScrollBar.visible = true;\n                }\n            }\n\n            if (typeof newDims.y == 'number' || typeof newDims.height == 'number') {\n                this.verticalScrollBar.positionMarker.style.top = ((newDims.y || this.getY() || 0) / (this.containerHeight || 1) * 100 || 0) + '%';\n            }\n        },\n\n        verticalScrollBarVisibleWidth: function verticalScrollBarVisibleWidth() {\n            return this.verticalScrollBar.visible && this.verticalScrollBar.width || 0;\n        },\n\n        /**\n         * @returns {Array[Track]} of the tracks that are currently visible in\n         * this genomeview\n         */\n        visibleTracks: function visibleTracks() {\n            return this.tracks;\n        },\n\n        /**\n         *  @returns {Array[String]} of the names of tracks that are currently visible in this genomeview\n         */\n        visibleTrackNames: function visibleTrackNames() {\n            return dojo.map(this.visibleTracks(), function (t) {\n                return t.name;\n            });\n        },\n\n        /**\n         * Called in response to a keyboard or mouse event to slide the view\n         * left or right.\n         */\n        keySlideX: function keySlideX(offset) {\n            this.setX(this.getX() + offset);\n\n            var thisB = this;\n            if (!this._keySlideTimeout) this._keySlideTimeout = window.setTimeout(function () {\n                thisB.afterSlide();\n                delete thisB._keySlideTimeout;\n            }, 300);\n        },\n\n        /**\n         * Behaviors (event handler bundles) for various states that the\n         * GenomeView might be in.\n         * @private\n         * @returns {Object} description of behaviors\n         */\n        _behaviors: function _behaviors() {\n            return {\n\n                // behaviors that don't change\n                always: {\n                    apply_on_init: true,\n                    apply: function apply() {\n                        var handles = [];\n                        handles.push(dojo.connect(this.overview, 'mousedown', dojo.hitch(this, 'startRubberZoom', dojo.hitch(this, 'overview_absXtoBp'), this.overview, this.overview)));\n                        var wheelevent = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : document.onmousewheel !== undefined ? \"mousewheel\" : \"DOMMouseScroll\";\n                        handles.push(dojo.connect(this.scrollContainer, wheelevent, this, 'wheelScroll', false), dojo.connect(this.verticalScrollBar.container, 'onclick', this, 'scrollBarClickScroll', false), dojo.connect(this.scaleTrackDiv, \"mousedown\", dojo.hitch(this, 'startRubberZoom', dojo.hitch(this, 'absXtoBp'), this.scrollContainer, this.scaleTrackDiv)), dojo.connect(this.outerTrackContainer, \"dblclick\", this, 'doubleClickZoom'), dojo.connect(this.locationThumbMover, \"onMoveStop\", this, 'thumbMoved'), dojo.connect(this.overview, \"onclick\", this, 'overviewClicked'), dojo.connect(this.scaleTrackDiv, \"onclick\", this, 'scaleClicked'), dojo.connect(this.scaleTrackDiv, \"mouseover\", this, 'scaleMouseOver'), dojo.connect(this.scaleTrackDiv, \"mouseout\", this, 'scaleMouseOut'), dojo.connect(this.scaleTrackDiv, \"mousemove\", this, 'scaleMouseMove'), dojo.connect(document.body, 'onkeyup', this, function (evt) {\n                            if (evt.keyCode == dojo.keys.SHIFT) // shift\n                                this.behaviorManager.swapBehaviors('shiftMouse', 'normalMouse');\n                        }), dojo.connect(window, 'blur', this, function (evt) {\n                            // Simulate releasing shift if user switches tabs with ctrl+shift+tab\n                            this.behaviorManager.swapBehaviors('shiftMouse', 'normalMouse');\n                        }), dojo.connect(document.body, 'onkeydown', this, function (evt) {\n                            if (evt.keyCode == dojo.keys.SHIFT) // shift\n                                this.behaviorManager.swapBehaviors('normalMouse', 'shiftMouse');\n                        }),\n\n                        // scroll the view around in response to keyboard arrow keys\n                        dojo.connect(document.body, 'onkeypress', this, function (evt) {\n\n                            // if some digit widget is focused, don't move the\n                            // genome view with arrow keys\n                            if (dijitFocus.curNode) return;\n\n                            var that = this;\n                            if (evt.keyCode == dojo.keys.LEFT_ARROW || evt.keyCode == dojo.keys.RIGHT_ARROW) {\n                                var offset = evt.keyCode == dojo.keys.LEFT_ARROW ? -40 : 40;\n                                if (evt.shiftKey) offset *= 5;\n                                this.keySlideX(offset);\n                            } else if (evt.keyCode == dojo.keys.DOWN_ARROW || evt.keyCode == dojo.keys.UP_ARROW) {\n                                // shift-up/down zooms in and out\n                                if (evt.shiftKey) {\n                                    this[evt.keyCode == dojo.keys.UP_ARROW ? 'zoomIn' : 'zoomOut'](evt, 0.5, evt.altKey ? 2 : 1);\n                                }\n                                // without shift, scrolls up and down\n                                else {\n                                        var offset = evt.keyCode == dojo.keys.UP_ARROW ? -40 : 40;\n                                        this.setY(this.getY() + offset);\n                                    }\n                            }\n                        }),\n\n                        // when the track pane is clicked, unfocus any dijit\n                        // widgets that would otherwise not give up the focus\n                        dojo.connect(this.scrollContainer, 'onclick', this, function (evt) {\n                            dijitFocus.curNode && dijitFocus.curNode.blur();\n                        }));\n                        return handles;\n                    }\n                },\n\n                // mouse events connected for \"normal\" behavior\n                normalMouse: {\n                    apply_on_init: true,\n                    apply: function apply() {\n                        return [dojo.connect(this.outerTrackContainer, \"mousedown\", this, 'startMouseDragScroll'), dojo.connect(this.verticalScrollBar.container, \"mousedown\", this, 'startVerticalMouseDragScroll')];\n                    }\n                },\n\n                // mouse events connected when we are in 'highlighting' mode,\n                // where dragging the mouse sets the global highlight\n                highlightingMouse: {\n                    apply: function apply() {\n                        dojo.removeClass(this.trackContainer, 'draggable');\n                        dojo.addClass(this.trackContainer, 'highlightingAvailable');\n                        return [dojo.connect(this.outerTrackContainer, \"mousedown\", dojo.hitch(this, 'startMouseHighlight', dojo.hitch(this, 'absXtoBp'), this.scrollContainer, this.scaleTrackDiv)), dojo.connect(this.outerTrackContainer, \"mouseover\", this, 'maybeDrawVerticalPositionLine'), dojo.connect(this.outerTrackContainer, \"mousemove\", this, 'maybeDrawVerticalPositionLine')];\n                    },\n                    remove: function remove(mgr, handles) {\n                        dojo.forEach(handles, dojo.disconnect, dojo);\n                        dojo.removeClass(this.trackContainer, 'highlightingAvailable');\n                        dojo.addClass(this.trackContainer, 'draggable');\n                    }\n                },\n\n                // mouse events connected when the shift button is being held down\n                shiftMouse: {\n                    apply: function apply() {\n                        if (!dojo.hasClass(this.trackContainer, 'highlightingAvailable')) {\n                            dojo.removeClass(this.trackContainer, 'draggable');\n                            dojo.addClass(this.trackContainer, 'rubberBandAvailable');\n                            return [dojo.connect(this.outerTrackContainer, \"mousedown\", dojo.hitch(this, 'startRubberZoom', dojo.hitch(this, 'absXtoBp'), this.scrollContainer, this.scaleTrackDiv)), dojo.connect(this.outerTrackContainer, \"onclick\", this, 'scaleClicked'), dojo.connect(this.outerTrackContainer, \"mouseover\", this, 'maybeDrawVerticalPositionLine'), dojo.connect(this.outerTrackContainer, \"mousemove\", this, 'maybeDrawVerticalPositionLine')];\n                        }\n                    },\n                    remove: function remove(mgr, handles) {\n                        this.clearBasePairLabels();\n                        this.clearVerticalPositionLine();\n                        dojo.forEach(handles, dojo.disconnect, dojo);\n                        dojo.removeClass(this.trackContainer, 'rubberBandAvailable');\n                        dojo.addClass(this.trackContainer, 'draggable');\n                    }\n                },\n\n                // mouse events that are connected when we are in the middle of a\n                // drag-scrolling operation\n                mouseDragScrolling: {\n                    apply: function apply() {\n                        return [dojo.connect(document.body, \"mouseup\", this, 'dragEnd'), dojo.connect(document.body, \"mousemove\", this, 'dragMove'), dojo.connect(document.body, \"mouseout\", this, 'checkDragOut')];\n                    }\n                },\n\n                // mouse events that are connected when we are in the middle of a\n                // vertical-drag-scrolling operation\n                verticalMouseDragScrolling: {\n                    apply: function apply() {\n                        return [dojo.connect(document.body, \"mouseup\", this, 'dragEnd'), dojo.connect(document.body, \"mousemove\", this, 'verticalDragMove'), dojo.connect(document.body, \"mouseout\", this, 'checkDragOut')];\n                    }\n                },\n\n                // mouse events that are connected when we are in the middle of a\n                // rubber-band zooming operation\n                mouseRubberBanding: {\n                    apply: function apply() {\n                        return [dojo.connect(document.body, \"mouseup\", this, 'rubberExecute'), dojo.connect(document.body, \"mousemove\", this, 'rubberMove'), dojo.connect(document.body, \"mouseout\", this, 'rubberCancel'), dojo.connect(window, \"onkeydown\", this, function (e) {\n                            if (e.keyCode !== dojo.keys.SHIFT) this.rubberCancel(e);\n                        })];\n                    }\n                }\n            };\n        },\n\n        /**\n         * Conduct a DOM test to calculate the height of div.pos-label\n         * elements with a line of text in them.\n         */\n        calculatePositionLabelHeight: function calculatePositionLabelHeight(containerElement) {\n            // measure the height of some arbitrary text in whatever font this\n            // shows up in (set by an external CSS file)\n            var heightTest = document.createElement(\"div\");\n            heightTest.className = \"pos-label\";\n            heightTest.style.visibility = \"hidden\";\n            heightTest.appendChild(document.createTextNode(\"42\"));\n            containerElement.appendChild(heightTest);\n            var h = heightTest.clientHeight;\n            containerElement.removeChild(heightTest);\n            return h;\n        },\n\n        scrollBarClickScroll: function scrollBarClickScroll(event) {\n\n            if (!event) event = window.event;\n\n            var containerHeight = parseInt(this.verticalScrollBar.container.style.height, 10);\n            var markerHeight = parseInt(this.verticalScrollBar.positionMarker.style.height, 10);\n            var trackContainerHeight = this.trackContainer.clientHeight;\n            var absY = this.getY() * (trackContainerHeight / containerHeight);\n            if (absY > event.clientY) this.setY(this.getY() - 300);else if (absY + markerHeight < event.clientY) this.setY(this.getY() + 300);\n\n            //the timeout is so that we don't have to run showVisibleBlocks\n            //for every scroll wheel click (we just wait until so many ms\n            //after the last one).\n\n            if (this.wheelScrollTimeout) window.clearTimeout(this.wheelScrollTimeout);\n\n            // 100 milliseconds since the last scroll event is an arbitrary\n            // cutoff for deciding when the user is done scrolling\n            // (set by a bit of experimentation)\n            this.wheelScrollTimeout = window.setTimeout(dojo.hitch(this, function () {\n                this.showVisibleBlocks(true);\n                this.wheelScrollTimeout = null;\n            }, 100));\n\n            dojo.stopEvent(event);\n        },\n\n        wheelScroll: function wheelScroll(event) {\n\n            if (!event) event = window.event;\n\n            var _normalizeWheel = (0, _normalizeWheel3.default)(event),\n                x = _normalizeWheel.pixelX,\n                y = _normalizeWheel.pixelY;\n\n            var didScroll = false;\n\n            if (x) {\n                this.keySlideX(x);\n                didScroll = true;\n            }\n            if (y) {\n                y = -y;\n                // 60 pixels per mouse wheel event\n                var prevY = this.getY();\n                var currY = this.setY(prevY - y);\n                // check if clamping happened\n                if (currY !== prevY) {\n                    didScroll = true;\n                }\n            }\n\n            //the timeout is so that we don't have to run showVisibleBlocks\n            //for every scroll wheel click (we just wait until so many ms\n            //after the last one).\n            if (this.wheelScrollTimeout) window.clearTimeout(this.wheelScrollTimeout);\n\n            // 100 milliseconds since the last scroll event is an arbitrary\n            // cutoff for deciding when the user is done scrolling\n            // (set by a bit of experimentation)\n            this.wheelScrollTimeout = window.setTimeout(dojo.hitch(this, function () {\n                this.showVisibleBlocks(true);\n                this.wheelScrollTimeout = null;\n            }, 100));\n\n            // allow event to bubble out of iframe for example\n            if (didScroll || this.browser.config.alwaysStopScrollBubble) dojo.stopEvent(event);\n        },\n\n        getX: function getX() {\n            return this.x || 0;\n        },\n\n        getY: function getY() {\n            return this.y || 0;\n        },\n\n        getHeight: function getHeight() {\n            return this.elemBox.h;\n        },\n        getWidth: function getWidth() {\n            return this.elemBox.w;\n        },\n\n        clampX: function clampX(x) {\n            return Math.round(Math.max(Math.min(this.maxLeft - this.offset, x || 0), this.minLeft - this.offset));\n        },\n\n        clampY: function clampY(y) {\n            return Math.round(Math.min(Math.max(0, y || 0), this.containerHeight - this.getHeight()));\n        },\n\n        rawSetX: function rawSetX(x) {\n            this.elem.scrollLeft = x;\n            this.x = x;\n        },\n\n        /**\n         * @returns the new x value that was set\n         */\n        setX: function setX(x) {\n            x = this.clampX(x);\n            this.rawSetX(x);\n            this.updateStaticElements({ x: x });\n            this.showFine();\n            return x;\n        },\n\n        rawSetY: function rawSetY(y) {\n            this.y = y;\n            this.layoutTracks();\n        },\n\n        /**\n         * @returns the new y value that was set\n         */\n        setY: function setY(y) {\n            y = this.clampY(y);\n            this.rawSetY(y);\n            this.updateStaticElements({ y: y });\n            return y;\n        },\n\n        /**\n         * @private\n         */\n        rawSetPosition: function rawSetPosition(pos) {\n            this.rawSetX(pos.x);\n            this.rawSetY(pos.y);\n            return pos;\n        },\n\n        /**\n         * @param pos.x new x position\n         * @param pos.y new y position\n         */\n        setPosition: function setPosition(pos) {\n            var x = this.clampX(pos.x);\n            var y = this.clampY(pos.y);\n            this.updateStaticElements({ x: x, y: y });\n            this.rawSetX(x);\n            this.rawSetY(y);\n            this.showFine();\n        },\n\n        /**\n         * @returns {Object} as <code>{ x: 123, y: 456 }</code>\n         */\n        getPosition: function getPosition() {\n            return { x: this.x, y: this.y };\n        },\n\n        zoomCallback: function zoomCallback() {\n            this.zoomUpdate();\n        },\n\n        afterSlide: function afterSlide() {\n            this.showCoarse();\n            this.scrollUpdate();\n            this.showVisibleBlocks(true);\n        },\n\n        /**\n         * Suppress double-click events in the genome view for a certain amount of time, default 100 ms.\n         */\n        suppressDoubleClick: function suppressDoubleClick( /** Number */time) {\n\n            if (this._noDoubleClick) {\n                window.clearTimeout(this._noDoubleClick);\n            }\n\n            var thisB = this;\n            this._noDoubleClick = window.setTimeout(function () {\n                delete thisB._noDoubleClick;\n            }, time || 100);\n        },\n\n        doubleClickZoom: function doubleClickZoom(event) {\n            if (this._noDoubleClick) return;\n            if (this.dragging) return;\n            if (\"animation\" in this) return;\n\n            // if we have a timeout in flight from a scaleClicked click,\n            // cancel it, cause it looks now like the user has actually\n            // double-clicked\n            if (this.scaleClickedTimeout) window.clearTimeout(this.scaleClickedTimeout);\n\n            var zoomLoc = (event.pageX - dojo.position(this.elem, true).x) / this.getWidth();\n            if (event.shiftKey) {\n                this.zoomOut(event, zoomLoc, 2);\n            } else {\n                this.zoomIn(event, zoomLoc, 2);\n            }\n            dojo.stopEvent(event);\n        },\n\n        /** @private */\n        _beforeMouseDrag: function _beforeMouseDrag(event) {\n            if (this.animation) {\n                if (this.animation instanceof Zoomer) {\n                    dojo.stopEvent(event);\n                    return 0;\n                } else {\n                    this.animation.stop();\n                }\n            }\n            if (Util.isRightButton(event)) return 0;\n            dojo.stopEvent(event);\n            return 1;\n        },\n\n        /**\n         * Event fired when a user's mouse button goes down inside the main\n         * element of the genomeview.\n         */\n        startMouseDragScroll: function startMouseDragScroll(event) {\n            if (!this._beforeMouseDrag(event)) return;\n\n            this.behaviorManager.applyBehaviors('mouseDragScrolling');\n\n            this.dragStartPos = { x: event.clientX,\n                y: event.clientY };\n            this.winStartPos = this.getPosition();\n        },\n\n        /**\n         * Event fired when a user's mouse button goes down inside the vertical\n         * scroll bar element of the genomeview.\n         */\n        startVerticalMouseDragScroll: function startVerticalMouseDragScroll(event) {\n            if (!this._beforeMouseDrag(event)) return; // not sure what this is for.\n\n            this.behaviorManager.applyBehaviors('verticalMouseDragScrolling');\n\n            this.dragStartPos = { x: event.clientX,\n                y: event.clientY };\n            this.winStartPos = this.getPosition();\n        },\n\n        startMouseHighlight: function startMouseHighlight(absToBp, container, scaleDiv, event) {\n            if (!this._beforeMouseDrag(event)) return;\n\n            this.behaviorManager.applyBehaviors('mouseRubberBanding');\n\n            this.rubberbanding = {\n                absFunc: absToBp,\n                container: container,\n                scaleDiv: scaleDiv,\n                message: 'Highlight region',\n                start: { x: event.clientX, y: event.clientY },\n                execute: function execute(start, end) {\n                    this.browser.setHighlightAndRedraw({ ref: this.ref.name, start: start, end: end });\n                }\n            };\n\n            this.winStartPos = this.getPosition();\n        },\n\n        /**\n         * Start a rubber-band dynamic zoom.\n         *\n         * @param {Function} absToBp function to convert page X coordinates to\n         *   base pair positions on the reference sequence.  Called in the\n         *   context of the GenomeView object.\n         * @param {HTMLElement} container element in which to draw the\n         *   rubberbanding highlight\n         * @param {Event} event the mouse event that's starting the zoom\n         */\n        startRubberZoom: function startRubberZoom(absToBp, container, scaleDiv, event) {\n            if (!this._beforeMouseDrag(event)) return;\n\n            this.behaviorManager.applyBehaviors('mouseRubberBanding');\n\n            this.rubberbanding = {\n                absFunc: absToBp,\n                container: container,\n                scaleDiv: scaleDiv,\n                message: 'Zoom to region',\n                start: { x: event.clientX, y: event.clientY },\n                execute: function execute(h_start_bp, h_end_bp) {\n                    this.setLocation(this.ref, h_start_bp, h_end_bp);\n                }\n            };\n\n            this.winStartPos = this.getPosition();\n            this.clearVerticalPositionLine();\n            this.clearBasePairLabels();\n        },\n\n        _rubberStop: function _rubberStop(event) {\n            this.behaviorManager.removeBehaviors('mouseRubberBanding');\n            this.hideRubberHighlight();\n            this.clearBasePairLabels();\n            if (event) dojo.stopEvent(event);\n            delete this.rubberbanding;\n        },\n\n        rubberCancel: function rubberCancel(event) {\n            var htmlNode = document.body.parentNode;\n            var bodyNode = document.body;\n\n            if (!event || !(event.relatedTarget || event.toElement) || htmlNode === (event.relatedTarget || event.toElement) || bodyNode === (event.relatedTarget || event.toElement)) {\n                this._rubberStop(event);\n            }\n        },\n\n        rubberMove: function rubberMove(event) {\n            this.setRubberHighlight(this.rubberbanding.start, { x: event.clientX, y: event.clientY });\n        },\n\n        rubberExecute: function rubberExecute(event) {\n            var start = this.rubberbanding.start;\n            var end = { x: event.clientX, y: event.clientY };\n\n            var h_start_bp = Math.floor(this.rubberbanding.absFunc(Math.min(start.x, end.x)));\n            var h_end_bp = Math.ceil(this.rubberbanding.absFunc(Math.max(start.x, end.x)));\n\n            var exec = this.rubberbanding.execute;\n\n            this._rubberStop(event);\n\n            // cancel the rubber-zoom if the user has moved less than 3 pixels\n            if (Math.abs(start.x - end.x) < 3) {\n                return;\n            }\n\n            exec.call(this, h_start_bp, h_end_bp);\n        },\n\n        // draws the rubber-banding highlight region from start.x to end.x\n        setRubberHighlight: function setRubberHighlight(start, end) {\n            var container = this.rubberbanding.container,\n                container_coords = dojo.position(container, true);\n\n            var h = this.rubberHighlight || function () {\n                var main = this.rubberHighlight = document.createElement(\"div\");\n                main.className = 'rubber-highlight';\n                main.style.position = 'absolute';\n                main.style.zIndex = 20;\n                var text = document.createElement('div');\n                text.appendChild(document.createTextNode(this.rubberbanding.message));\n                main.appendChild(text);\n                text.style.position = 'relative';\n                text.style.top = 50 - container_coords.y + \"px\";\n\n                container.appendChild(main);\n                return main;\n            }.call(this);\n\n            h.style.visibility = 'visible';\n            h.style.left = Math.min(start.x, end.x) - container_coords.x + 'px';\n            h.style.width = Math.abs(end.x - start.x) + 'px';\n\n            // draw basepair-position labels for the start and end of the highlight\n            this.drawBasePairLabel({ name: 'rubberLeft',\n                xToBp: this.rubberbanding.absFunc,\n                scaleDiv: this.rubberbanding.scaleDiv,\n                offset: 0,\n                x: Math.min(start.x, end.x),\n                parent: container,\n                className: 'rubber'\n            });\n            this.drawBasePairLabel({ name: 'rubberRight',\n                xToBp: this.rubberbanding.absFunc,\n                scaleDiv: this.rubberbanding.scaleDiv,\n                offset: 0,\n                x: Math.max(start.x, end.x) + 1,\n                parent: container,\n                className: 'rubber'\n            });\n\n            // turn off the red position line if it's on\n            this.clearVerticalPositionLine();\n        },\n\n        dragEnd: function dragEnd(event) {\n            this.behaviorManager.removeBehaviors('mouseDragScrolling', 'verticalMouseDragScrolling');\n\n            dojo.stopEvent(event);\n            this.showCoarse();\n\n            this.scrollUpdate();\n            this.showVisibleBlocks(true);\n\n            // wait 100 ms before releasing our drag indication, since onclick\n            // events from during the drag might fire after the dragEnd event\n            window.setTimeout(dojo.hitch(this, function () {\n                this.dragging = false;\n            }), 100);\n        },\n\n        /** stop the drag if we mouse out of the view */\n        checkDragOut: function checkDragOut(event) {\n            var htmlNode = document.body.parentNode;\n            var bodyNode = document.body;\n\n            if (!(event.relatedTarget || event.toElement) || htmlNode === (event.relatedTarget || event.toElement) || bodyNode === (event.relatedTarget || event.toElement)) {\n                this.dragEnd(event);\n            }\n        },\n\n        dragMove: function dragMove(event) {\n            this.dragging = true;\n            this.setPosition({\n                x: this.winStartPos.x - (event.clientX - this.dragStartPos.x),\n                y: this.winStartPos.y - (event.clientY - this.dragStartPos.y)\n            });\n            dojo.stopEvent(event);\n        },\n\n        // Similar to \"dragMove\". Consider merging.\n        verticalDragMove: function verticalDragMove(event) {\n            this.dragging = true;\n            var containerHeight = parseInt(this.verticalScrollBar.container.style.height, 10);\n            var trackContainerHeight = this.trackContainer.clientHeight;\n            this.setPosition({\n                x: this.winStartPos.x,\n                y: this.winStartPos.y + (event.clientY - this.dragStartPos.y) * (trackContainerHeight / containerHeight)\n            });\n            dojo.stopEvent(event);\n        },\n\n        hideRubberHighlight: function hideRubberHighlight(start, end) {\n            if (this.rubberHighlight) {\n                this.rubberHighlight.parentNode.removeChild(this.rubberHighlight);\n                delete this.rubberHighlight;\n            }\n        },\n\n        /* moves the view by (distance times the width of the view) pixels */\n        slide: function slide(distance) {\n            if (this.animation) this.animation.stop();\n            this.trimVertical();\n            // slide for an amount of time that's a function of the distance being\n            // traveled plus an arbitrary extra 200 milliseconds so that\n            // short slides aren't too fast (200 chosen by experimentation)\n            new Slider(this, this.afterSlide, Math.abs(distance) * this.getWidth() * this.slideTimeMultiple + 200, distance * this.getWidth());\n        },\n\n        setLocation: function setLocation(refseq, startbp, endbp) {\n            if (startbp === undefined) startbp = this.minVisible();\n            if (endbp === undefined) endbp = this.maxVisible();\n            if (typeof refseq == 'string') {\n                // if a string was passed, need to get the refseq object for it\n                refseq = this.browser.getRefSeq(refseq);\n            }\n            if (!refseq) refseq = this.ref;\n\n            if (startbp < refseq.start || startbp > refseq.end) startbp = refseq.start;\n            if (endbp < refseq.start || endbp > refseq.end) endbp = refseq.end;\n\n            function removeTrack(track) {\n                delete thisB.desiredTracks[track.name];\n                if (track.div && track.div.parentNode) track.div.parentNode.removeChild(track.div);\n            };\n\n            if (this.ref !== refseq) {\n                var thisB = this;\n                this.ref = refseq;\n                this._unsetPosBeforeZoom(); // if switching to different sequence, flush zoom position tracking\n\n\n                array.forEach(this.tracks, removeTrack);\n\n                this.tracks = [];\n                this.trackIndices = {};\n                this.trackHeights = [];\n                this.trackTops = [];\n\n                array.forEach(this.uiTracks, function (track) {\n                    track.refSeq = thisB.ref;\n                    track.clear();\n                });\n\n                this.overviewTrackIterate(removeTrack);\n\n                this.addOverviewTrack(new LocationScaleTrack({\n                    label: \"overview_loc_track\",\n                    labelClass: \"overview-pos\",\n                    posHeight: this.overviewPosHeight,\n                    browser: this.browser,\n                    refSeq: this.ref\n                }));\n                this.sizeInit();\n                this.setY(0);\n                this.behaviorManager.initialize();\n            }\n\n            this.pxPerBp = Math.min(this.getWidth() / (endbp - startbp), this.maxPxPerBp);\n            this.curZoom = Util.findNearest(this.zoomLevels, this.pxPerBp);\n\n            if (Math.abs(this.pxPerBp - this.zoomLevels[this.zoomLevels.length - 1]) < 0.2) {\n                //the cookie-saved location is in round bases, so if the saved\n                //location was at the highest zoom level, the new zoom level probably\n                //won't be exactly at the highest zoom (which is necessary to trigger\n                //the sequence track), so we nudge the zoom level to be exactly at\n                //the highest level if it's close.\n                //Exactly how close is arbitrary; 0.2 was chosen to be close\n                //enough that people wouldn't notice if we fudged that much.\n                //console.log(\"nudging zoom level from %d to %d\", this.pxPerBp, this.zoomLevels[this.zoomLevels.length - 1]);\n                this.pxPerBp = this.zoomLevels[this.zoomLevels.length - 1];\n            }\n            this.stripeWidth = this.stripeWidthForZoom(this.curZoom) / this.zoomLevels[this.curZoom] * this.pxPerBp;\n            this.instantZoomUpdate();\n\n            this.centerAtBase((startbp + endbp) / 2, true);\n        },\n\n        stripeWidthForZoom: function stripeWidthForZoom(zoomLevel) {\n            if (this.zoomLevels.length - 1 == zoomLevel) {\n                // width, in pixels, of stripes at full zoom, is 10bp\n                return this.regularStripe / 10 * this.maxPxPerBp;\n            } else if (0 == zoomLevel) {\n                return this.minZoomStripe;\n            } else {\n                return this.regularStripe;\n            }\n        },\n\n        instantZoomUpdate: function instantZoomUpdate() {\n            this.scrollContainer.style.width = this.stripeCount * this.stripeWidth + \"px\";\n            this.zoomContainer.style.width = this.stripeCount * this.stripeWidth + \"px\";\n            this.maxOffset = this.bpToPx(this.ref.end) - this.stripeCount * this.stripeWidth;\n            this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth();\n            this.minLeft = this.bpToPx(this.ref.start);\n        },\n\n        centerAtBase: function centerAtBase(base, instantly) {\n            base = Math.min(Math.max(base, this.ref.start), this.ref.end);\n            if (instantly) {\n                var pxDist = this.bpToPx(base);\n                var containerWidth = this.stripeCount * this.stripeWidth;\n                var stripesLeft = Math.floor((pxDist - containerWidth / 2) / this.stripeWidth);\n                this.offset = stripesLeft * this.stripeWidth;\n                this.setX(pxDist - this.offset - this.getWidth() / 2);\n                this.trackIterate(function (track) {\n                    track.clear();\n                });\n                this.showVisibleBlocks(true);\n                this.showCoarse();\n            } else {\n                var startbp = this.pxToBp(this.x + this.offset);\n                var halfWidth = this.getWidth() / this.pxPerBp / 2;\n                var endbp = startbp + halfWidth + halfWidth;\n                var center = startbp + halfWidth;\n                if (base >= startbp - halfWidth && base <= endbp + halfWidth) {\n                    //we're moving somewhere nearby, so move smoothly\n                    if (this.animation) this.animation.stop();\n                    var distance = (center - base) * this.pxPerBp;\n                    this.trimVertical();\n                    // slide for an amount of time that's a function of the\n                    // distance being traveled plus an arbitrary extra 200\n                    // milliseconds so that short slides aren't too fast\n                    // (200 chosen by experimentation)\n                    new Slider(this, this.afterSlide, Math.abs(distance) * this.slideTimeMultiple + 200, distance);\n                } else {\n                    //we're moving far away, move instantly\n                    this.centerAtBase(base, true);\n                }\n            }\n        },\n\n        /**\n         * @returns {Number} minimum basepair coordinate of the current\n         * reference sequence visible in the genome view\n         */\n        minVisible: function minVisible() {\n            var mv = this.pxToBp(this.x + this.offset);\n\n            // if we are less than one pixel from the beginning of the ref\n            // seq, just say we are at the beginning.\n            if (mv < this.pxToBp(1)) return 0;else return Math.round(mv);\n        },\n\n        /**\n         * @returns {Number} maximum basepair coordinate of the current\n         * reference sequence visible in the genome view\n         */\n        maxVisible: function maxVisible() {\n            var mv = this.pxToBp(this.x + this.offset + this.getWidth());\n            var scrollbar = Math.round(this.pxToBp(this.verticalScrollBarVisibleWidth()));\n            // if we are less than one pixel from the end of the ref\n            // seq, just say we are at the end.\n            if (mv > this.ref.end - this.pxToBp(1)) return this.ref.end - scrollbar;else return Math.round(mv) - scrollbar;\n        },\n\n        showFine: function showFine() {\n            this.onFineMove(this.minVisible(), this.maxVisible());\n        },\n        showCoarse: function showCoarse() {\n            this.onCoarseMove(this.minVisible(), this.maxVisible());\n        },\n\n        /**\n         * Hook for other components to dojo.connect to.\n         */\n        onFineMove: function onFineMove(startbp, endbp) {\n            this.updateLocationThumb();\n        },\n\n        /**\n         * Hook for other components to dojo.connect to.\n         */\n        onCoarseMove: function onCoarseMove(startbp, endbp) {\n            this.updateLocationThumb();\n        },\n\n        /**\n         * Hook to be called on a window resize.\n         */\n        onResize: function onResize() {\n            this.sizeInit();\n            this.showVisibleBlocks();\n            this.showFine();\n            this.showCoarse();\n        },\n\n        /**\n         * Event handler fired when the overview bar is single-clicked.\n         */\n        overviewClicked: function overviewClicked(evt) {\n            this.centerAtBase(this.overview_absXtoBp(evt.clientX));\n        },\n\n        /**\n         * Event handler fired when mouse is over the scale bar.\n         */\n        scaleMouseOver: function scaleMouseOver(evt) {\n            if (!this.rubberbanding) this.drawVerticalPositionLine(this.scaleTrackDiv, evt);\n        },\n\n        /**\n         * Event handler fired when mouse moves over the scale bar.\n         */\n        scaleMouseMove: function scaleMouseMove(evt) {\n            if (!this.rubberbanding) this.drawVerticalPositionLine(this.scaleTrackDiv, evt);\n        },\n\n        /**\n         * Event handler fired when mouse leaves the scale bar.\n         */\n        scaleMouseOut: function scaleMouseOut(evt) {\n            this.clearVerticalPositionLine();\n            this.clearBasePairLabels();\n        },\n\n        /**\n         *  draws the vertical position line only if\n         *  we are not rubberbanding\n         */\n        maybeDrawVerticalPositionLine: function maybeDrawVerticalPositionLine(evt) {\n            if (this.rubberbanding) return;\n            this.drawVerticalPositionLine(this.scaleTrackDiv, evt);\n        },\n\n        /**\n         * Draws the red line across the work area, or updates it if it already exists.\n         */\n        drawVerticalPositionLine: function drawVerticalPositionLine(parent, evt) {\n            var numX = evt.pageX + 2;\n\n            if (!this.verticalPositionLine) {\n                // if line does not exist, create it\n                this.verticalPositionLine = dojo.create('div', {\n                    className: 'trackVerticalPositionIndicatorMain'\n                }, this.staticTrack.div);\n            }\n\n            var line = this.verticalPositionLine;\n            line.style.display = 'block'; //make line visible\n            line.style.left = numX + 'px'; //set location on screen\n            var scaleTrackPos = dojo.position(this.scaleTrackDiv);\n            line.style.top = scaleTrackPos.y + 'px';\n\n            this.drawBasePairLabel({ name: 'single', offset: 0, x: numX, parent: parent, scaleDiv: parent });\n        },\n\n        /**\n         * Draws the label for the line.\n         * @param {Number} args.numX X-coordinate at which to draw the label's origin\n         * @param {Number} args.name unique name used to cache this label\n         * @param {Number} args.offset offset in pixels from numX at which the label should actually be drawn\n         * @param {HTMLElement} args.scaleDiv\n         * @param {Function} args.xToBp\n         */\n        drawBasePairLabel: function drawBasePairLabel(args) {\n            var name = args.name || 0;\n            var offset = args.offset || 0;\n            var numX = args.x;\n            this.basePairLabels = this.basePairLabels || {};\n\n            if (!this.basePairLabels[name]) {\n                var scaleTrackPos = dojo.position(args.scaleDiv || this.scaleTrackDiv);\n                this.basePairLabels[name] = dojo.create('div', {\n                    className: 'basePairLabel' + (args.className ? ' ' + args.className : ''),\n                    style: { top: scaleTrackPos.y + scaleTrackPos.h - 3 + 'px' }\n                }, this.browser.container);\n            }\n\n            var label = this.basePairLabels[name];\n\n            if ((typeof numX === 'undefined' ? 'undefined' : _typeof(numX)) == 'object') {\n                numX = numX.clientX;\n            }\n\n            label.style.display = 'block'; //make label visible\n            var absfunc = args.xToBp || dojo.hitch(this, 'absXtoBp');\n            //set text to BP location (adding 1 to convert from interbase)\n            label.innerHTML = Util.addCommas(Math.floor(absfunc(numX)) + 1);\n\n            //label.style.top = args.top + 'px';\n\n            // 15 pixels on either side of the label\n            if (window.innerWidth - numX > 8 + label.offsetWidth) {\n                label.style.left = numX + offset + 'px'; //set location on screen to the right\n            } else {\n                label.style.left = numX + 1 - offset - label.offsetWidth + 'px'; //set location on screen to the left\n            }\n        },\n\n        /**\n         * Turn off the basepair-position line if it is being displayed.\n         */\n        clearVerticalPositionLine: function clearVerticalPositionLine() {\n            if (this.verticalPositionLine) this.verticalPositionLine.style.display = 'none';\n        },\n\n        /**\n         * Delete any base pair labels that are being displayed.\n         */\n        clearBasePairLabels: function clearBasePairLabels() {\n            for (var name in this.basePairLabels) {\n                var label = this.basePairLabels[name];\n                if (label.parentNode) label.parentNode.removeChild(label);\n            }\n            this.basePairLabels = {};\n        },\n\n        /**\n         * Convert absolute X pixel position to base pair position on the\n         * <b>overview</b> track.  This needs refactoring; a scale bar should\n         * itself know how to convert an absolute X position to base pairs.\n         * @param {Number} x absolute pixel X position (for example, from a click event's clientX property)\n         */\n        overview_absXtoBp: function overview_absXtoBp(x) {\n            var overviewBox = dojo.position(this.overview);\n            return (x - overviewBox.x) / overviewBox.w * (this.ref.end - this.ref.start) + this.ref.start;\n        },\n\n        /**\n         * Event handler fired when the track scale bar is single-clicked.\n         */\n        scaleClicked: function scaleClicked(evt) {\n            var bp = this.absXtoBp(evt.clientX);\n\n            this.scaleClickedTimeout = window.setTimeout(dojo.hitch(this, function () {\n                this.centerAtBase(bp);\n            }, 100));\n        },\n\n        /**\n         * Event handler fired when the region thumbnail in the overview bar\n         * is dragged.\n         */\n        thumbMoved: function thumbMoved(mover) {\n            var pxLeft = parseInt(this.locationThumb.style.left);\n            var pxWidth = parseInt(this.locationThumb.style.width);\n            var pxCenter = pxLeft + pxWidth / 2;\n            this.centerAtBase(pxCenter / this.overviewBox.w * (this.ref.end - this.ref.start) + this.ref.start);\n        },\n\n        /**\n         * Updates the position of the red box in the overview that indicates\n         * the region being shown by the detail pane.\n         */\n        updateLocationThumb: function updateLocationThumb() {\n            var startbp = this.minVisible();\n            var endbp = this.maxVisible();\n\n            var length = this.ref.end - this.ref.start;\n            var trapLeft = Math.round((startbp - this.ref.start) / length * this.overviewBox.w + this.overviewBox.l);\n            var trapRight = Math.round((endbp - this.ref.start) / length * this.overviewBox.w + this.overviewBox.l);\n\n            this.locationThumb.style.cssText = \"height: \" + (this.overviewBox.h - 4) + \"px; \" + \"left: \" + trapLeft + \"px; \" + \"width: \" + (trapRight - trapLeft) + \"px;\" + \"z-index: 20\";\n        },\n\n        checkY: function checkY(y) {\n            return Math.min(y < 0 ? 0 : y, this.containerHeight - this.getHeight());\n        },\n\n        /**\n         * Given a new X and Y pixels position for the main track container,\n         * reposition static elements that \"float\" over it, like track labels,\n         * Y axis labels, the main track ruler, and so on.\n         *\n         * @param [args.x] the new X coordinate.  if not provided,\n         *   elements that only need updates on the X position are not\n         *   updated.\n         * @param [args.y] the new Y coordinate.  if not provided,\n         *   elements that only need updates on the Y position are not\n         *   updated.\n         * @param [args.width] the new width of the view.  if not provided,\n         *   elements that only need updates on the width are not\n         *   updated.\n         * @param [args.height] the new height of the view. if not provided,\n         *   elements that only need updates on the height are not\n         *   updated.\n         */\n        updateStaticElements: function updateStaticElements(args) {\n            this.trackIterate(function (t) {\n                t.updateStaticElements(args);\n            }, this);\n\n            this._updateVerticalScrollBar(args);\n        },\n\n        showWait: function showWait() {\n            var oldCursors = [];\n            for (var i = 0; i < this.waitElems.length; i++) {\n                oldCursors[i] = this.waitElems[i].style.cursor;\n                this.waitElems[i].style.cursor = \"wait\";\n            }\n            this.prevCursors.push(oldCursors);\n        },\n\n        showDone: function showDone() {\n            var oldCursors = this.prevCursors.pop();\n            for (var i = 0; i < this.waitElems.length; i++) {\n                this.waitElems[i].style.cursor = oldCursors[i];\n            }\n        },\n\n        pxToBp: function pxToBp(pixels) {\n            return pixels / this.pxPerBp;\n        },\n\n        /**\n         * Convert absolute pixels X position to base pair position on the\n         * current reference sequence.\n         * @returns {Number}\n         */\n        absXtoBp: function absXtoBp( /**Number*/pixels) {\n            return this.pxToBp(this.getPosition().x + this.offset - dojo.position(this.elem, true).x + pixels) - 1;\n        },\n\n        bpToPx: function bpToPx(bp) {\n            return bp * this.pxPerBp;\n        },\n\n        /**\n         * Update the view's state, and that of its tracks, for the current\n         * width and height of its container.\n         * @returns nothing\n         */\n        sizeInit: function sizeInit() {\n            this.overviewBox = dojo.marginBox(this.overview);\n            this.elemBox = { h: this.elem.offsetHeight, w: this.elem.offsetWidth };\n\n            //scale values, in pixels per bp, for all zoom levels\n            var desiredZoomLevels = [1 / 500000, 1 / 200000, 1 / 100000, 1 / 50000, 1 / 20000, 1 / 10000, 1 / 5000, 1 / 2000, 1 / 1000, 1 / 500, 1 / 200, 1 / 100, 1 / 50, 1 / 20, 1 / 10, 1 / 5, 1 / 2, 1, 2, 5, 10, 20];\n\n            this.zoomLevels = [];\n            for (var i = 0; i < desiredZoomLevels.length; i++) {\n                var zlevel = desiredZoomLevels[i];\n                if (zlevel < this.maxPxPerBp) this.zoomLevels.push(zlevel);else break; // once get to zoom level >= maxPxPerBp, quit\n            }\n            this.zoomLevels.push(this.maxPxPerBp);\n\n            //make sure we don't zoom out too far\n            while ((this.ref.end - this.ref.start) * this.zoomLevels[0] < this.getWidth()) {\n                this.zoomLevels.shift();\n            }\n            this.zoomLevels.unshift(this.getWidth() / (this.ref.end - this.ref.start));\n\n            //width, in pixels, of stripes at min zoom (so the view covers\n            //the whole ref seq)\n            this.minZoomStripe = this.regularStripe * (this.zoomLevels[0] / this.zoomLevels[1]);\n\n            this.curZoom = 0;\n            while (this.pxPerBp > this.zoomLevels[this.curZoom]) {\n                this.curZoom++;\n            }this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth();\n\n            delete this.stripePercent;\n            //25, 50, 100 don't work as well due to the way scrollUpdate works\n            var possiblePercents = [20, 10, 5, 4, 2, 1];\n            for (var i = 0; i < possiblePercents.length; i++) {\n                // we'll have (100 / possiblePercents[i]) stripes.\n                // multiplying that number of stripes by the minimum stripe width\n                // gives us the total width of the \"container\" div.\n                // (or what that width would be if we used possiblePercents[i]\n                // as our stripePercent)\n                // That width should be wide enough to make sure that the user can\n                // scroll at least one page-width in either direction without making\n                // the container div bump into the edge of its parent element, taking\n                // into account the fact that the container won't always be perfectly\n                // centered (it may be as much as 1/2 stripe width off center)\n                // So, (this.getWidth() * 3) gives one screen-width on either side,\n                // and we add a regularStripe width to handle the slightly off-center\n                // cases.\n                // The minimum stripe width is going to be halfway between\n                // \"canonical\" zoom levels; the widest distance between those\n                // zoom levels is 2.5-fold, so halfway between them is 0.7 times\n                // the stripe width at the higher zoom level\n                if (100 / possiblePercents[i] * (this.regularStripe * 0.7) > this.getWidth() * 3 + this.regularStripe) {\n                    this.stripePercent = possiblePercents[i];\n                    break;\n                }\n            }\n\n            if (!this.stripePercent) {\n                console.warn(\"stripeWidth too small: \" + this.stripeWidth + \", \" + this.getWidth());\n                this.stripePercent = 1;\n            }\n\n            var oldX;\n            var oldStripeCount = this.stripeCount;\n            if (oldStripeCount) oldX = this.getX();\n            this.stripeCount = Math.round(100 / this.stripePercent);\n\n            this.scrollContainer.style.width = this.stripeCount * this.stripeWidth + \"px\";\n            this.zoomContainer.style.width = this.stripeCount * this.stripeWidth + \"px\";\n\n            var blockDelta;\n            if (oldStripeCount && oldStripeCount != this.stripeCount) {\n                blockDelta = Math.floor((oldStripeCount - this.stripeCount) / 2);\n                var delta = blockDelta * this.stripeWidth;\n                var newX = this.getX() - delta;\n                this.offset += delta;\n                this.updateStaticElements({ x: newX });\n                this.rawSetX(newX);\n            }\n\n            // update the sizes for each of the tracks\n            this.trackIterate(function (track, view) {\n                track.sizeInit(view.stripeCount, view.stripePercent, blockDelta);\n            });\n\n            var newHeight = this.trackHeights && this.trackHeights.length ? Math.max(dojof.reduce(this.trackHeights, '+') + this.config.trackPadding * this.trackHeights.length, this.getHeight()) : this.getHeight();\n            this.scrollContainer.style.height = newHeight + \"px\";\n            this.containerHeight = newHeight;\n\n            var refLength = this.ref.end - this.ref.start;\n            if (refLength < 0) throw new Error(\"reference sequence \" + this.ref.name + \" has an invalid start coordinate, it is greater than its end coordinate.\");\n\n            var posSize = document.createElement(\"div\");\n            posSize.className = \"overview-pos\";\n            posSize.appendChild(document.createTextNode(Util.addCommas(this.ref.end)));\n            posSize.style.visibility = \"hidden\";\n            this.overview.appendChild(posSize);\n            // we want the stripes to be at least as wide as the position labels,\n            // plus an arbitrary 20% padding so it's clear which grid line\n            // a position label corresponds to.\n            var minStripe = posSize.clientWidth * 1.2;\n            this.overviewPosHeight = posSize.clientHeight * 1.2;\n            this.overview.removeChild(posSize);\n            for (var n = 1; n < 30; n++) {\n                //http://research.att.com/~njas/sequences/A051109\n                // JBrowse uses this sequence (1, 2, 5, 10, 20, 50, 100, 200, 500...)\n                // as its set of zoom levels.  That gives nice round numbers for\n                // bases per block, and it gives zoom transitions that feel about the\n                // right size to me. -MS\n                this.overviewStripeBases = (Math.pow(n % 3, 2) + 1) * Math.pow(10, Math.floor(n / 3));\n                this.overviewStripes = Math.ceil(refLength / this.overviewStripeBases);\n                if (this.overviewBox.w / this.overviewStripes > minStripe) break;\n                if (this.overviewStripes < 2) break;\n            }\n\n            // update our overview tracks\n            var overviewStripePct = 100 / (refLength / this.overviewStripeBases);\n            var overviewHeight = 0;\n            this.overviewTrackIterate(function (track, view) {\n                track.clear();\n                track.sizeInit(view.overviewStripes, overviewStripePct);\n                track.showRange(0, view.overviewStripes - 1, view.ref.start - 1, view.overviewStripeBases, view.overviewBox.w / (view.ref.end - view.ref.start));\n            });\n            this.updateOverviewHeight();\n\n            this.updateScroll();\n        },\n\n        /**\n         * @private\n         */\n        updateScroll: function updateScroll() {\n\n            // may need to update our Y position if our height has changed\n            var update = { height: this.getHeight() };\n            if (this.getY() > 0) {\n                if (this.containerHeight - this.getY() < update.height) {\n                    //console.log( this.totalTrackHeight, update.height, this.getY() );\n                    update.y = this.setY(Math.max(0, this.containerHeight - update.height));\n                }\n            }\n\n            // update any static (i.e. fixed-position) elements that need to\n            // float in one position over the scrolling track div (can't use\n            // CSS position:fixed for these)\n            this.updateStaticElements(update);\n        },\n\n        overviewTrackIterate: function overviewTrackIterate(callback) {\n            var overviewTrack = this.overview.firstChild;\n            do {\n                if (overviewTrack && overviewTrack.track) callback.call(this, overviewTrack.track, this);\n            } while (overviewTrack && (overviewTrack = overviewTrack.nextSibling));\n        },\n\n        updateOverviewHeight: function updateOverviewHeight(trackName, height) {\n            var overviewHeight = 0;\n            this.overviewTrackIterate(function (track, view) {\n                overviewHeight += track.height;\n                track.div.style.height = track.height + 'px';\n            });\n            this.overview.style.height = overviewHeight + \"px\";\n            this.overviewBox = dojo.marginBox(this.overview);\n        },\n\n        addOverviewTrack: function addOverviewTrack(track) {\n            var refLength = this.ref.end - this.ref.start;\n\n            var overviewStripePct = 100 / (refLength / this.overviewStripeBases);\n            var trackDiv = document.createElement(\"div\");\n            trackDiv.className = \"track\";\n            trackDiv.style.height = this.overviewBox.h + \"px\";\n            trackDiv.id = \"overviewtrack_\" + track.name;\n            trackDiv.track = track;\n            var view = this;\n            var heightUpdate = function heightUpdate(height) {\n                view.updateOverviewHeight();\n            };\n            track.setViewInfo(this, heightUpdate, this.overviewStripes, trackDiv, overviewStripePct, this.overviewStripeBases, this.pxPerBp, this.config.trackPadding);\n            this.overview.appendChild(trackDiv);\n            this.updateOverviewHeight();\n\n            return trackDiv;\n        },\n\n        trimVertical: function trimVertical(y) {\n            if (y === undefined) y = this.getY();\n            var trackBottom;\n            var trackTop = this.topSpace;\n            var bottom = y + this.getHeight();\n            for (var i = 0; i < this.tracks.length; i++) {\n                if (this.tracks[i].shown) {\n                    trackBottom = trackTop + this.trackHeights[i];\n                    if (!(trackBottom > y && trackTop < bottom)) {\n                        this.tracks[i].hideAll();\n                    }\n                    trackTop = trackBottom + this.config.trackPadding;\n                }\n            }\n        },\n\n        redrawTracks: function redrawTracks() {\n            this.trackIterate(function (t) {\n                t.hideAll();\n            });\n            this.showVisibleBlocks(false);\n        },\n\n        hideRegion: function hideRegion(location) {\n            this.overviewTrackIterate(function (t) {\n                t.hideRegion(location);\n            });\n            this.trackIterate(function (t) {\n                t.hideRegion(location);\n            });\n        },\n\n        redrawRegion: function redrawRegion(location) {\n            this.hideRegion(location);\n            this.showVisibleBlocks(false);\n        },\n\n        zoomIn: function zoomIn(e, zoomLoc, steps) {\n            if (this.animation) return;\n            this._unsetPosBeforeZoom();\n            if (zoomLoc === undefined) zoomLoc = 0.5;\n            if (steps === undefined) steps = 1;\n            steps = Math.min(steps, this.zoomLevels.length - 1 - this.curZoom);\n            if (0 == steps && this.pxPerBp == this.zoomLevels[this.curZoom]) return;\n\n            this.showWait();\n            var pos = this.getPosition();\n            this.trimVertical(pos.y);\n\n            var scale = this.zoomLevels[this.curZoom + steps] / this.pxPerBp;\n            var fixedBp = this.pxToBp(pos.x + this.offset + zoomLoc * this.getWidth());\n            this.curZoom += steps;\n            this.pxPerBp = this.zoomLevels[this.curZoom];\n            this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth();\n\n            for (var track = 0; track < this.tracks.length; track++) {\n                this.tracks[track].startZoom(this.pxPerBp, fixedBp - zoomLoc * this.getWidth() / this.pxPerBp, fixedBp + (1 - zoomLoc) * this.getWidth() / this.pxPerBp);\n            } //YAHOO.log(\"centerBp: \" + centerBp + \"; estimated post-zoom start base: \" + (centerBp - ((zoomLoc * this.getWidth()) / this.pxPerBp)) + \", end base: \" + (centerBp + (((1 - zoomLoc) * this.getWidth()) / this.pxPerBp)));\n\n            // Zooms take an arbitrary 700 milliseconds, which feels about right\n            // to me, although if the zooms were smoother they could probably\n            // get faster without becoming off-putting. -MS\n            new Zoomer(scale, this, function () {\n                this.zoomUpdate(zoomLoc, fixedBp);\n            }, 700, zoomLoc);\n        },\n\n        /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n        zoomToBaseLevel: function zoomToBaseLevel(e, pos) {\n            if (this.animation) return;\n            //   if (this.zoomLevels[this.curZoom] === this.charWidth)  {  console.log(\"already zoomed to base level\"); return; }\n            // if at max zoomLevel then already zoomed to bases, so then no-op\n            var baseZoomIndex = this.zoomLevels.length - 1;\n\n            if (this.curZoom === baseZoomIndex) {\n                console.log(\"already zoomed to base level\");return;\n            }\n            this._setPosBeforeZoom(this.minVisible(), this.maxVisible(), this.curZoom);\n            var zoomLoc = 0.5;\n\n            this.showWait();\n            this.trimVertical();\n\n            var relativeScale = this.zoomLevels[baseZoomIndex] / this.pxPerBp;\n            var fixedBp = pos;\n            this.curZoom = baseZoomIndex;\n            this.pxPerBp = this.zoomLevels[baseZoomIndex];\n\n            this.maxLeft = this.pxPerBp * this.ref.end - this.getWidth();\n\n            for (var track = 0; track < this.tracks.length; track++) {\n                this.tracks[track].startZoom(this.pxPerBp, fixedBp - zoomLoc * this.getWidth() / this.pxPerBp, fixedBp + (1 - zoomLoc) * this.getWidth() / this.pxPerBp);\n            } //YAHOO.log(\"centerBp: \" + centerBp + \"; estimated post-zoom start base: \" + (centerBp - ((zoomLoc * this.getWidth()) / this.pxPerBp)) + \", end base: \" + (centerBp + (((1 - zoomLoc) * this.getWidth()) / this.pxPerBp)));\n            new Zoomer(relativeScale, this, function () {\n                this.zoomUpdate(zoomLoc, fixedBp);\n            }, 700, zoomLoc);\n        },\n\n        zoomOut: function zoomOut(e, zoomLoc, steps) {\n            if (this.animation) return;\n            this._unsetPosBeforeZoom();\n            if (steps === undefined) steps = 1;\n            steps = Math.min(steps, this.curZoom);\n            if (0 == steps) return;\n\n            this.showWait();\n            var pos = this.getPosition();\n            this.trimVertical(pos.y);\n            if (zoomLoc === undefined) zoomLoc = 0.5;\n            var scale = this.zoomLevels[this.curZoom - steps] / this.pxPerBp;\n            var edgeDist = this.bpToPx(this.ref.end) - (this.offset + pos.x + this.getWidth());\n            //zoomLoc is a number on [0,1] that indicates\n            //the fixed point of the zoom\n            zoomLoc = Math.max(zoomLoc, 1 - edgeDist * scale / (1 - scale) / this.getWidth());\n            edgeDist = pos.x + this.offset - this.bpToPx(this.ref.start);\n            zoomLoc = Math.min(zoomLoc, edgeDist * scale / (1 - scale) / this.getWidth());\n            var fixedBp = this.pxToBp(pos.x + this.offset + zoomLoc * this.getWidth());\n            this.curZoom -= steps;\n            this.pxPerBp = this.zoomLevels[this.curZoom];\n\n            for (var track = 0; track < this.tracks.length; track++) {\n                this.tracks[track].startZoom(this.pxPerBp, fixedBp - zoomLoc * this.getWidth() / this.pxPerBp, fixedBp + (1 - zoomLoc) * this.getWidth() / this.pxPerBp);\n            } //YAHOO.log(\"centerBp: \" + centerBp + \"; estimated post-zoom start base: \" + (centerBp - ((zoomLoc * this.getWidth()) / this.pxPerBp)) + \", end base: \" + (centerBp + (((1 - zoomLoc) * this.getWidth()) / this.pxPerBp)));\n            this.minLeft = this.pxPerBp * this.ref.start;\n\n            // Zooms take an arbitrary 700 milliseconds, which feels about right\n            // to me, although if the zooms were smoother they could probably\n            // get faster without becoming off-putting. -MS\n            new Zoomer(scale, this, function () {\n                this.zoomUpdate(zoomLoc, fixedBp);\n            }, 700, zoomLoc);\n        },\n\n        /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n        zoomBackOut: function zoomBackOut(e) {\n            if (this.animation) {\n                return;\n            }\n            if (!this.isZoomedToBase()) {\n                return;\n            }\n\n            var min = this.posBeforeZoom.min;\n            var max = this.posBeforeZoom.max;\n            var zoomIndex = this.posBeforeZoom.zoomIndex;\n            this.posBeforeZoom = undefined;\n\n            var zoomLoc = 0.5;\n            this.showWait();\n\n            var scale = this.zoomLevels[zoomIndex] / this.pxPerBp;\n            var fixedBp = (min + max) / 2;\n            this.curZoom = zoomIndex;\n            this.pxPerBp = this.zoomLevels[zoomIndex];\n\n            for (var track = 0; track < this.tracks.length; track++) {\n                this.tracks[track].startZoom(this.pxPerBp, fixedBp - zoomLoc * this.getWidth() / this.pxPerBp, fixedBp + (1 - zoomLoc) * this.getWidth() / this.pxPerBp);\n            }\n\n            this.minLeft = this.pxPerBp * this.ref.start;\n            var thisObj = this;\n            // Zooms take an arbitrary 700 milliseconds, which feels about right\n            // to me, although if the zooms were smoother they could probably\n            // get faster without becoming off-putting. -MS\n            new Zoomer(scale, this, function () {\n                thisObj.setLocation(thisObj.ref, min, max);thisObj.zoomUpdate(zoomLoc, fixedBp);\n            }, 700, zoomLoc);\n        },\n\n        /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n        isZoomedToBase: function isZoomedToBase() {\n            return this.posBeforeZoom !== undefined;\n        },\n\n        /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n        _setPosBeforeZoom: function _setPosBeforeZoom(min, max, zoomIndex) {\n            this.posBeforeZoom = { \"min\": min, \"max\": max, \"zoomIndex\": zoomIndex };\n        },\n\n        /** WebApollo support for zooming directly to base level, and later restoring previous zoom level before zooming to base */\n        _unsetPosBeforeZoom: function _unsetPosBeforeZoom() {\n            this.posBeforeZoom = undefined;\n        },\n\n        zoomUpdate: function zoomUpdate(zoomLoc, fixedBp) {\n            var eWidth = this.elem.clientWidth;\n            var centerPx = this.bpToPx(fixedBp) - zoomLoc * eWidth + eWidth / 2;\n            // stripeWidth: pixels per block\n            this.stripeWidth = this.stripeWidthForZoom(this.curZoom);\n            this.scrollContainer.style.width = this.stripeCount * this.stripeWidth + \"px\";\n            this.zoomContainer.style.width = this.stripeCount * this.stripeWidth + \"px\";\n            var centerStripe = Math.round(centerPx / this.stripeWidth);\n            var firstStripe = centerStripe - this.stripeCount / 2 | 0;\n            this.offset = firstStripe * this.stripeWidth;\n            this.maxOffset = this.bpToPx(this.ref.end + 1) - this.stripeCount * this.stripeWidth;\n            this.maxLeft = this.bpToPx(this.ref.end + 1) - this.getWidth();\n            this.minLeft = this.bpToPx(this.ref.start);\n            this.zoomContainer.style.left = \"0px\";\n            this.setX(centerPx - this.offset - eWidth / 2);\n\n            dojo.forEach(this.uiTracks, function (track) {\n                track.clear();\n            });\n\n            this.trackIterate(function (track) {\n                track.endZoom(this.pxPerBp, Math.round(this.stripeWidth / this.pxPerBp));\n            });\n\n            this.showVisibleBlocks(true);\n            this.showDone();\n            this.showCoarse();\n        },\n\n        scrollUpdate: function scrollUpdate() {\n            var x = this.getX();\n            var numStripes = this.stripeCount;\n            var cWidth = numStripes * this.stripeWidth;\n            var eWidth = this.getWidth();\n            //dx: horizontal distance between the centers of\n            //this.scrollContainer and this.elem\n            var dx = cWidth / 2 - (eWidth / 2 + x);\n            //If dx is negative, we add stripes on the right, if positive,\n            //add on the left.\n            //We remove stripes from the other side to keep cWidth the same.\n            //The end goal is to minimize dx while making sure the surviving\n            //stripes end up in the same place.\n\n            var dStripes = dx / this.stripeWidth | 0;\n            if (0 == dStripes) return;\n            var changedStripes = Math.abs(dStripes);\n\n            var newOffset = this.offset - dStripes * this.stripeWidth;\n\n            if (this.offset == newOffset) return;\n            this.offset = newOffset;\n\n            this.trackIterate(function (track) {\n                track.moveBlocks(dStripes);\n            });\n\n            var newX = x + dStripes * this.stripeWidth;\n            this.updateStaticElements({ x: newX });\n            this.rawSetX(newX);\n            var firstVisible = newX / this.stripeWidth | 0;\n        },\n\n        trackHeightUpdate: function trackHeightUpdate(trackName, height) {\n            var y = this.getY();\n            if (!(trackName in this.trackIndices)) return;\n            var track = this.trackIndices[trackName];\n            if (Math.abs(height - this.trackHeights[track]) < 1) return;\n\n            //console.log(\"trackHeightUpdate: \" + trackName + \" \" + this.trackHeights[track] + \" -> \" + height);\n            // if the bottom of this track is a above the halfway point,\n            // and we're not all the way at the top,\n            if (this.trackTops[track] + this.trackHeights[track] - y < this.getHeight() / 2 && y > 0) {\n                // scroll so that lower tracks stay in place on screen\n                this.setY(y + (height - this.trackHeights[track]));\n                //console.log(\"track \" + trackName + \": \" + this.trackHeights[track] + \" -> \" + height + \"; y: \" + y + \" -> \" + this.getY());\n            }\n            this.trackHeights[track] = height;\n            this.tracks[track].div.style.height = height + this.config.trackPadding + \"px\";\n\n            this.layoutTracks();\n\n            this.setY(this.getY());\n\n            this.updateStaticElements({ height: this.getHeight() });\n        },\n\n        showVisibleBlocks: function showVisibleBlocks(updateHeight, pos, startX, endX, finishCallback) {\n            var _this = this;\n\n            if (pos === undefined) pos = this.getPosition();\n            if (startX === undefined) startX = pos.x - this.drawMargin * this.getWidth();\n            if (endX === undefined) endX = pos.x + (1 + this.drawMargin) * this.getWidth();\n            var leftVisible = Math.max(0, startX / this.stripeWidth | 0);\n            var rightVisible = Math.min(this.stripeCount - 1, endX / this.stripeWidth | 0);\n\n            var bpPerBlock = Math.round(this.stripeWidth / this.pxPerBp);\n\n            var startBase = Math.round(this.pxToBp(leftVisible * this.stripeWidth + this.offset));\n            startBase -= 1;\n            var containerStart = Math.round(this.pxToBp(this.offset));\n            var containerEnd = Math.round(this.pxToBp(this.offset + this.stripeCount * this.stripeWidth));\n\n            // Track update will be carried after the maxVisible has a value\n            if (!this.maxVisible()) return;\n\n            var showingPromises = [];\n            this.overviewTrackIterate(function (track, view) {\n                showingPromises.push(new Promise(function (resolve, reject) {\n                    track.showRange(0, view.overviewStripes - 1, view.ref.start - 1, view.overviewStripeBases, view.overviewBox.w / (view.ref.end - view.ref.start), undefined, undefined, resolve);\n                }));\n            });\n            this.trackIterate(function (track, view) {\n                showingPromises.push(new Promise(function (resolve, reject) {\n                    track.showRange(leftVisible, rightVisible, startBase, bpPerBlock, view.pxPerBp, containerStart, containerEnd, resolve);\n                }));\n            });\n\n            this.updateStaticElements({\n                height: this.getHeight(),\n                width: this.getWidth(),\n                x: this.getX(),\n                y: this.getY()\n            });\n\n            this.browser.publish('/jbrowse/v1/n/tracks/redraw');\n\n            var after = function after() {\n                if (finishCallback) finishCallback();\n                _this.browser.publish('/jbrowse/v1/n/tracks/redrawFinished');\n            };\n            Promise.all(showingPromises).then(after, after);\n        },\n\n        /**\n         * Add the given track configurations to the genome view.\n         * @param trackConfigs {Array[Object]} array of track configuration\n         * objects to add\n         */\n        showTracks: function showTracks(trackConfigs) {\n            // filter out any track configs that are already displayed\n            var needed = dojo.filter(trackConfigs, function (conf) {\n                return this._getTracks([conf.label]).length == 0 && !this.desiredTracks[conf.label];\n            }, this);\n            if (!needed.length) return;\n            array.forEach(trackConfigs, function (ret) {\n                this.desiredTracks[ret.label] = true;\n            }, this);\n\n            // insert the track configs into the trackDndWidget ( the widget\n            // will call create() on the confs to render them)\n            this.trackDndWidget.insertNodes(false, needed);\n\n            this.updateTrackList();\n\n            // scroll the view to the bottom so we can see the new track\n            var thisB = this;\n            window.setTimeout(function () {\n                thisB.setY(Infinity);\n            }, 300);\n        },\n\n        /**\n         * Replace the track configurations that are currently visible in the genome view.\n         * @param trackConfigs {Array[Object]} array of track configuration\n         * objects to add\n         */\n        replaceTracks: function replaceTracks(trackConfigs) {\n            // for each one\n            array.forEach(trackConfigs, function (conf) {\n                // figure out its position in the genome view and delete it\n                var anchor;\n                var done;\n                var listNode = this.trackDndWidget.parent;\n                array.forEach(listNode.children, function (item) {\n                    if (done) return;\n\n                    var track = item.track;\n                    if (track && track.config.label == conf.label) {\n                        done = 1;\n                        this.trackDndWidget.delItem(item.id);\n                        if (item && item.parentNode) item.parentNode.removeChild(item);\n                    } else {\n                        anchor = item;\n                    }\n                }, this);\n\n                this.updateTrackList();\n\n                // insert the new track config into the trackDndWidget after the 'before'\n                this.trackDndWidget.insertNodes(false, [conf], false, anchor);\n            }, this);\n\n            if (trackConfigs.length) this.updateTrackList();\n        },\n\n        /**\n         * Remove the given track (configs) from the genome view.\n         * @param trackConfigs {Array[Object]} array of track configurations\n         */\n        hideTracks: function hideTracks( /**Array[String]*/trackConfigs) {\n\n            // filter out any track configs that are not displayed\n            var displayed = dojo.filter(trackConfigs, function (conf) {\n                return this._getTracks([conf.label]).length != 0;\n            }, this);\n            if (!displayed.length) return;\n            array.forEach(trackConfigs, function (ret) {\n                delete this.desiredTracks[ret.label];\n            }, this);\n\n            // remove the track configs from the trackDndWidget ( the widget\n            // will call create() on the confs to render them )\n            dojo.forEach(displayed, function (conf) {\n                this.trackDndWidget.forInItems(function (obj, id, map) {\n                    if (conf.label === obj.data.label) {\n                        this.trackDndWidget.delItem(id);\n                        var item = dojo.byId(id);\n                        if (item && item.parentNode) item.parentNode.removeChild(item);\n                    }\n                }, this);\n            }, this);\n\n            this.updateTrackList();\n        },\n\n        /**\n         * Pin the tracks with the given names.  Returns an array with the\n         * names of tracks that were actually pinned.\n         */\n        pinTracks: function pinTracks( /**Array[String]*/trackNames) {\n            var tracks = this._getTracks(trackNames);\n            array.forEach(tracks, function (track) {\n                track.setPinned(true);\n            });\n            this.updateTrackList();\n            return array.map(tracks, function (t) {\n                return t.name;\n            });\n        },\n\n        /**\n         * Unpin the tracks with the given names.  Returns an array with the\n         * names of tracks that were actually unpinned.\n         */\n        unpinTracks: function unpinTracks( /**Array[String]*/trackNames) {\n            var tracks = this._getTracks(trackNames);\n            array.forEach(tracks, function (track) {\n                track.setPinned(false);\n            });\n            this.updateTrackList();\n            return array.map(tracks, function (t) {\n                return t.name;\n            });\n        },\n\n        /**\n         * For an array of track names, get the track object if it exists.\n         * @private\n         * @returns {Array[Track]} the track objects that were found\n         */\n        _getTracks: function _getTracks( /**Array[String]*/trackNames) {\n            var tracks = [],\n                tn = { count: trackNames.length };\n            dojo.forEach(trackNames, function (n) {\n                tn[n] = 1;\n            });\n            dojo.some(this.tracks, function (t) {\n                if (tn[t.name]) {\n                    tracks.push(t);\n                    tn.count--;\n                }\n                return !tn.count;\n            }, this);\n            return tracks;\n        },\n\n        /**\n         * Create the DOM elements that will contain the rendering of the\n         * given track in this genome view.\n         * @private\n         * @returns {HTMLElement} the HTML element that will contain the\n         *                        rendering of this track\n         */\n        renderTrack: function renderTrack( /**Object*/trackConfig) {\n            var thisB = this;\n\n            if (!trackConfig) return null;\n\n            // just return its div if this track is already on\n            var existingTrack;\n            if (dojo.some(this.tracks, function (t) {\n                if (t.name == trackConfig.label) {\n                    existingTrack = t;\n                    return true;\n                }\n                return false;\n            })) {\n                return existingTrack.div;\n            }\n\n            var cssName = function cssName(str) {\n                // replace weird characters and lowercase\n                return str.replace(/[^A-Za-z_0-9]/g, '_').toLowerCase();\n            };\n\n            var trackName = trackConfig.label;\n            var trackDiv = dojo.create('div', {\n                className: ['track', cssName('track_' + trackConfig.type), cssName('track_' + trackName)].join(' '),\n                id: \"track_\" + trackName\n            });\n            trackDiv.trackName = trackName;\n\n            var trackClass, store;\n\n            var makeTrack = dojo.hitch(this, function () {\n\n                // if there is no key for this track in its configuration, attempt to load the key from the track metadata\n                var metadataKey;\n                try {\n                    metadataKey = this.browser.trackMetaDataStore.getItem(trackConfig.label).key;\n                } catch (e) {}\n\n                // create the track\n\n                var track = new trackClass({\n                    key: trackConfig.key || metadataKey,\n                    refSeq: this.ref,\n                    config: trackConfig,\n                    changeCallback: dojo.hitch(this, 'showVisibleBlocks', true),\n                    trackPadding: this.config.trackPadding,\n                    store: store,\n                    browser: this.browser\n                });\n                if (typeof store.setTrack == 'function') store.setTrack(track);\n\n                trackDiv.track = track;\n\n                // track focus handler\n                dojo.connect(trackDiv, \"onclick\", function (evt) {\n                    thisB.setTrackFocus(track, 1);\n                });\n\n                var heightUpdate = dojo.hitch(this, 'trackHeightUpdate', trackName);\n                track.setViewInfo(this, heightUpdate, this.stripeCount, trackDiv, this.stripePercent, this.stripeWidth, this.pxPerBp, this.config.trackPadding);\n\n                track.updateStaticElements({\n                    x: this.getX(),\n                    y: this.getY(),\n                    height: this.getHeight(),\n                    width: this.getWidth()\n                });\n\n                this.updateTrackList();\n            });\n\n            // might need to load both the store and the track class, so do it in\n            // parallel and have whichever one completes last do the actual\n            // track making.\n\n            if (!trackConfig.store) console.warn(\"configuration for track \" + trackConfig.label + \" has no store set\", trackConfig);\n\n            // get the store\n            this.browser.getStore(trackConfig.store, function (s) {\n                store = s;\n                // get the track class\n                var trackType = trackConfig.type || thisB.browser.getTrackTypes().trackTypeDefaults[store.config.type];\n                dojo.global.require([trackType], function (class_) {\n                    if (typeof class_ === \"string\") {\n                        console.error(\"Failed to load module: \" + trackConfig.type);\n                        return;\n                    }\n                    trackClass = class_;\n                    makeTrack();\n                });\n            });\n\n            return trackDiv;\n        },\n        /**\n         *\n         * @param {type} track\n         * @param {type} state\n         * @returns {undefined}\n         */\n        setTrackFocus: function setTrackFocus(track, state) {\n            var thisB = this;\n\n            if (state === 1) {\n                if (this.focusTrack !== null) {\n\n                    // if already in focus, don't do anything\n                    if (this.focusTrack == track) return;\n\n                    thisB.browser.publish('/jbrowse/v1/n/tracks/unfocus', this.focusTrack);\n                    this.focusTrack = null;\n                }\n                thisB.focusTrack = track;\n                thisB.browser.publish('/jbrowse/v1/n/tracks/focus', track);\n            }\n            if (state === 0) {\n                // if already in focus, don't do anything\n                if (this.focusTrack === null) {\n                    console.log(\"no track in focus\");\n                    return;\n                }\n                thisB.browser.publish('/jbrowse/v1/n/tracks/unfocus', this.focusTrack);\n                this.focusTrack = null;\n            }\n        },\n\n        trackIterate: function trackIterate(callback) {\n            var i;\n            for (i = 0; i < this.uiTracks.length; i++) {\n                callback.call(this, this.uiTracks[i], this);\n            }for (i = 0; i < this.tracks.length; i++) {\n                callback.call(this, this.tracks[i], this);\n            }\n        },\n\n        /* this function must be called whenever tracks in the GenomeView\n         * are added, removed, or reordered\n         */\n        updateTrackList: function updateTrackList() {\n            var tracks = [],\n                oldtracks = dojo.toJson(this.trackIndices || {});\n\n            // after a track has been dragged, the DOM is the only place\n            // that knows the new ordering\n            var containerChild = this.trackContainer.firstChild;\n            do {\n                // this test excludes UI tracks, whose divs don't have a track property\n                if (containerChild.track) tracks.push(containerChild.track);\n            } while (containerChild = containerChild.nextSibling);\n\n            // sort so that the pinned tracks come first.  also, sorting is\n            // not stable in all implementations, need to stabilize it\n            // ourselves by doing a schwartzian transform with the indices\n            tracks = array.map(tracks, function (t, i) {\n                return [t, i];\n            });\n            tracks = tracks.sort(function (a, b) {\n                var ap = a[0].isPinned() ? 1 : 0,\n                    bp = b[0].isPinned() ? 1 : 0;\n                return bp - ap || a[1] - b[1];\n            });\n            tracks = array.map(tracks, function (tr) {\n                return tr[0];\n            });\n\n            // create or destroy the pinned-track underlay as needed\n            if (tracks[0] && tracks[0].isPinned()) {\n                if (!this.pinUnderlay) this.pinUnderlay = domConstruct.create('div', {\n                    className: 'pin_underlay',\n                    style: 'top: ' + this.topSpace\n                }, this.trackContainer);\n                if (!this.pinGridlinesTrack) {\n                    var gridTrackDiv = domConstruct.create(\"div\", { className: \"track\",\n                        style: \"top: 0px; height: 100%\"\n                    }, this.pinUnderlay);\n                    this.pinGridlinesTrack = new GridLinesTrack({\n                        browser: this.browser,\n                        refSeq: this.ref\n                    });\n                    this.pinGridlinesTrack.setViewInfo(this, function () {}, this.stripeCount, gridTrackDiv, this.stripePercent, this.stripeWidth, this.pxPerBp, this.config.trackPadding);\n                    this.uiTracks.push(this.pinGridlinesTrack);\n                }\n            } else if (this.pinUnderlay) {\n                domConstruct.destroy(this.pinUnderlay);\n                delete this.pinUnderlay;\n                this.uiTracks = array.filter(this.uiTracks, function (t) {\n                    return t !== this.pinGridlinesTrack;\n                }, this);\n                delete this.pinGridlinesTrack;\n            }\n\n            // set the new tracklist\n            var oldTracks = this.tracks;\n            this.tracks = tracks;\n\n            // recalculate this.trackHeights and this.trackIndices\n            var newIndices = {};\n            var newHeights = new Array(this.tracks.length);\n            var totalHeight = 0;\n            for (var i = 0; i < tracks.length; i++) {\n                newIndices[tracks[i].name] = i;\n                if (tracks[i].name in this.trackIndices) {\n                    newHeights[i] = this.trackHeights[this.trackIndices[tracks[i].name]];\n                } else {\n                    newHeights[i] = 0;\n                }\n                totalHeight += newHeights[i];\n                this.trackIndices[tracks[i].name] = i;\n            }\n            this.trackIndices = newIndices;\n            this.trackHeights = newHeights;\n\n            // call destroy on any tracks that are being thrown out\n            array.forEach(oldTracks || [], function (track) {\n                if (!(track.name in newIndices)) {\n                    Util.removeAttribute(track.div, 'track'); //< because this file put it there\n                    track.destroy();\n                }\n            }, this);\n\n            // lay the tracks out bottom to top\n            this.layoutTracks();\n\n            this.updateScroll();\n\n            // publish a message if the visible tracks or their ordering has changed\n            if (oldtracks != dojo.toJson(this.trackIndices || {})) {\n                this.browser.publish('/jbrowse/v1/n/tracks/visibleChanged', [this.visibleTrackNames()]);\n                this.showVisibleBlocks();\n            }\n        },\n\n        /**\n         * Lay out all shown tracks.\n         */\n        layoutTracks: function layoutTracks() {\n            // lay out the track tops\n            var nextTop = this.topSpace;\n            var lastTop = 0;\n            var pinnedHeight = 0;\n            var lastWasPinned = false;\n            array.forEach(this.tracks, function (track, i) {\n                this.trackTops[i] = nextTop;\n                lastTop = nextTop;\n\n                if (track.isPinned()) {\n                    track.div.style.top = nextTop + \"px\";\n                    lastWasPinned = true;\n                } else {\n                    track.div.style.top = nextTop - this.y + (lastWasPinned ? 15 : 0) + \"px\";\n                    lastWasPinned = false;\n                }\n\n                if (track.shown) {\n                    nextTop += this.trackHeights[i] + this.config.trackPadding;\n                    if (track.isPinned()) pinnedHeight = nextTop;\n                }\n            }, this);\n            if (pinnedHeight && this.pinUnderlay) {\n                this.pinUnderlay.style.height = pinnedHeight + 'px';\n            }\n\n            this.containerHeight = Math.max(nextTop || 0, Math.min(this.getY(), lastTop) + this.getHeight());\n            this.scrollContainer.style.height = this.containerHeight + \"px\";\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n\n//# sourceURL=webpack:///./src/JBrowse/GenomeView.js?");

/***/ }),

/***/ "./src/JBrowse/Model/ArrayRepr.js":
/*!****************************************!*\
  !*** ./src/JBrowse/Model/ArrayRepr.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    /**\n     * @class JBrowse.Model.ArrayRepr\n     * @constructor\n     *\n     * @description\n     *\n     * Class for operating on indexed array representations of objects.\n     *\n     * For example, if we have a lot of objects with similar attrbutes, e.g.:\n     *\n     * <pre class=\"code\">\n     *     [\n     *         {start: 1, end: 2, strand: -1},\n     *         {start: 5, end: 6, strand: 1},\n     *         ...\n     *     ]\n     * </pre>\n     *\n     * @description\n     * we can represent them more compactly (e.g., in JSON) something like this:\n     *\n     * <pre class=\"code\">\n     *     class = [\"start\", \"end\", \"strand\"]\n     *     [\n     *         [1, 2, -1],\n     *         [5, 6, 1],\n     *         ...\n     *     ]\n     * </pre>\n     *\n     * If we want to represent a few different kinds of objects in our big list,\n     * we can have multiple \"class\" arrays, and tag each object to identify\n     * which \"class\" array describes it.\n     *\n     * For example, if we have a lot of instances of a few types of objects,\n     * like this:\n     *\n     * <pre class=\"code\">\n     *     [\n     *         {start: 1, end: 2, strand: 1, id: 1},\n     *         {start: 5, end: 6, strand: 1, id: 2},\n     *         ...\n     *         {start: 10, end: 20, chunk: 1},\n     *         {start: 30, end: 40, chunk: 2},\n     *         ...\n     *     ]\n     * </pre>\n     *\n     * We could use the first array position to indicate the \"class\" for the\n     * object, like this:\n     *\n     * <pre class=\"code\">\n     *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n     *     [\n     *         [0, 1, 2, 1, 1],\n     *         [0, 5, 6, 1, 2],\n     *         ...\n     *         [1, 10, 20, 1],\n     *         [1, 30, 40, 1]\n     *     ]\n     * </pre>\n     *\n     * Also, if we occasionally want to add an ad-hoc attribute, we could just\n     * stick an optional dictionary onto the end:\n     *\n     * <pre class=\"code\">\n     *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n     *     [\n     *         [0, 1, 2, 1, 1],\n     *         [0, 5, 6, 1, 2, {foo: 1}]\n     *     ]\n     * </pre>\n     *\n     * Given that individual objects are being represented by arrays, generic\n     * code needs some way to differentiate arrays that are meant to be objects\n     * from arrays that are actually meant to be arrays.\n     * So for each class, we include a dict with <attribute name>: true mappings\n     * for each attribute that is meant to be an array.\n     *\n     * Also, in cases where some attribute values are the same for all objects\n     * in a particular set, it may be convenient to define a \"prototype\"\n     * with default values for all objects in the set\n     *\n     * In the end, we get something like this:\n     *\n     * <pre class=\"code\">\n     *     classes=[\n     *         {'attributes': ['Start', 'End', 'Subfeatures'],\n     *          'proto': {'Chrom': 'chr1'},\n     *          'isArrayAttr': {Subfeatures: true}}\n     *         ]\n     * </pre>\n     *\n     * That's what this class facilitates.\n     */\n    function ArrayRepr(classes) {\n        this.classes = classes;\n        this.fields = [];\n        for (var cl = 0; cl < classes.length; cl++) {\n            this.fields[cl] = {};\n            for (var f = 0; f < classes[cl].attributes.length; f++) {\n                this.fields[cl][classes[cl].attributes[f]] = f + 1;\n            }\n            if (classes[cl].proto === undefined) classes[cl].proto = {};\n            if (classes[cl].isArrayAttr === undefined) classes[cl].isArrayAttr = {};\n        }\n    }\n\n    /**\n     * @private\n     */\n    ArrayRepr.prototype.attrIndices = function (attr) {\n        return this.classes.map(function (x) {\n            return x.attributes.indexOf(attr) + 1 || x.attributes.indexOf(attr.toLowerCase()) + 1 || undefined;\n        });\n    };\n\n    ArrayRepr.prototype.get = function (obj, attr) {\n        if (attr in this.fields[obj[0]]) {\n            return obj[this.fields[obj[0]][attr]];\n        } else {\n            // try lowercase\n            var lcattr = attr.toLowerCase();\n            if (lcattr in this.fields[obj[0]]) {\n                return obj[this.fields[obj[0]][lcattr]];\n            } else {\n                var adhocIndex = this.classes[obj[0]].attributes.length + 1;\n                if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {\n                    if (attr in this.classes[obj[0]].proto) return this.classes[obj[0]].proto[attr];\n                    return undefined;\n                }\n                return obj[adhocIndex][attr];\n            }\n        }\n    };\n\n    ArrayRepr.prototype.set = function (obj, attr, val) {\n        if (attr in this.fields[obj[0]]) {\n            obj[this.fields[obj[0]][attr]] = val;\n        } else {\n            // try lowercase\n            var lcattr = attr.toLowerCase();\n            if (lcattr in this.fields[obj[0]]) {\n                obj[this.fields[obj[0]][lcattr]] = val;\n            } else {\n                var adhocIndex = this.classes[obj[0]].attributes.length + 1;\n                if (adhocIndex >= obj.length) obj[adhocIndex] = {};\n                obj[adhocIndex][attr] = val;\n            }\n        }\n    };\n\n    ArrayRepr.prototype.makeSetter = function (attr) {\n        var self = this;\n        return function (obj, val) {\n            self.set(obj, attr, val);\n        };\n    };\n\n    ArrayRepr.prototype.makeGetter = function (attr) {\n        var self = this;\n        return function (obj) {\n            return self.get(obj, attr);\n        };\n    };\n\n    ArrayRepr.prototype.makeFastSetter = function (attr) {\n        // can be used only if attr is guaranteed to be in\n        // the \"classes\" array for this object\n        var indices = this.attrIndices(attr);\n        return function (obj, val) {\n            if (indices[obj[0]] !== undefined) obj[indices[obj[0]]] = val;\n        };\n    };\n\n    ArrayRepr.prototype.makeFastGetter = function (attr) {\n        // can be used only if attr is guaranteed to be in\n        // the \"classes\" array for this object\n        var indices = this.attrIndices(attr);\n        return function (obj) {\n            if (indices[obj[0]] !== undefined) return obj[indices[obj[0]]];else return undefined;\n        };\n    };\n\n    ArrayRepr.prototype.construct = function (self, obj, klass) {\n        var result = new Array(self.classes[klass].length);\n        for (var attr in obj) {\n            this.set(result, attr, obj[attr]);\n        }\n        return result;\n    };\n\n    /**\n    \n    Returns fast pre-compiled getter and setter functions for use with\n    Arrays that use this representation.\n    \n    When the returned <code>get</code> and <code>set</code> functions are\n    added as methods to an Array that contains data in this\n    representation, they provide fast access by name to the data.\n    \n    @returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>\n    \n    @example\n    var accessors = attrs.accessors();\n    var feature = get_feature_from_someplace();\n    feature.get = accessors.get;\n    // print out the feature start and end\n    console.log( feature.get('start') + ',' + feature.get('end') );\n    \n    */\n    ArrayRepr.prototype.accessors = function () {\n        return this._accessors = this._accessors || this._makeAccessors();\n    };\n\n    /**\n     * @private\n     */\n    ArrayRepr.prototype._makeAccessors = function () {\n        var that = this,\n            indices = {},\n            _tags,\n            accessors = {\n            get: function get(field) {\n                var f = this.get.field_accessors[field.toLowerCase()];\n                if (f) return f.call(this);else return undefined;\n            },\n            set: function set(field, val) {\n                var f = this.set.field_accessors[field];\n                if (f) return f.call(this, val);else return undefined;\n            },\n            tags: function tags() {\n                return _tags[this[0]] || [];\n            }\n        };\n        accessors.get.field_accessors = {};\n        accessors.set.field_accessors = {};\n\n        // make a data structure as: { attr_name: [offset,offset,offset], }\n        // that will be convenient for finding the location of the attr\n        // for a given class like: indexForAttr{attrname}[classnum]\n        dojo.forEach(this.classes, function (cdef, classnum) {\n            dojo.forEach(cdef.attributes || [], function (attrname, offset) {\n                indices[attrname] = indices[attrname] || [];\n                indices[attrname][classnum] = offset + 1;\n\n                attrname = attrname.toLowerCase();\n\n                indices[attrname] = indices[attrname] || [];\n                indices[attrname][classnum] = offset + 1;\n            });\n        });\n\n        // lowercase all the class attributes\n        _tags = dojo.map(this.classes, function (c) {\n            return c.attributes;\n        });\n\n        // use that to make precalculated get and set accessors for each field\n        for (var attrname in indices) {\n            if (!indices.hasOwnProperty(attrname)) continue;\n\n            // get\n            accessors.get.field_accessors[attrname] = function () {\n                var attr_indices = indices[attrname];\n                return !attr_indices ? function () {\n                    return undefined;\n                } : function () {\n                    return this[attr_indices[this[0]]];\n                };\n            }();\n\n            // set\n            accessors.set.field_accessors[attrname] = function () {\n                var attr_indices = indices[attrname];\n                return !attr_indices ? function () {\n                    return undefined;\n                } : function (v) {\n                    return this[attr_indices[this[0]]] = v;\n                };\n            }();\n        }\n\n        return accessors;\n    };\n\n    return ArrayRepr;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n/*\n\nCopyright (c) 2007-2010 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n\n//# sourceURL=webpack:///./src/JBrowse/Model/ArrayRepr.js?");

/***/ }),

/***/ "./src/JBrowse/Model/BGZip/BGZBlob.js":
/*!********************************************!*\
  !*** ./src/JBrowse/Model/BGZip/BGZBlob.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * File blob in Heng Li's `bgzip` format.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! jszlib/inflate */ \"./node_modules/jszlib/inflate.js\"), __webpack_require__(/*! jszlib/arrayCopy */ \"./node_modules/jszlib/arrayCopy.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, inflate, arrayCopy) {\n\n    var BGZBlob = declare(null, {\n        constructor: function constructor(blob) {\n            this.blob = blob;\n        },\n\n        blockSize: 1 << 16,\n\n        slice: function slice(s, l) {\n            return new BGZBlob(this.blob.slice(s, l));\n        },\n\n        fetch: function fetch(callback, failCallback) {\n            this.blob.fetch(this._wrap(callback), failCallback);\n        },\n\n        read: function read(offset, length, callback, failCallback) {\n            this.blob.read(offset, length + this.blockSize, //< need to over-fetch by a whole block size\n            this._wrap(callback, length), failCallback);\n        },\n\n        _wrap: function _wrap(callback, maxLen) {\n            var thisB = this;\n            return function (bgzData) {\n                callback(thisB.unbgzf(bgzData, maxLen));\n            };\n        },\n\n        readInt: function readInt(ba, offset) {\n            return ba[offset + 3] << 24 | ba[offset + 2] << 16 | ba[offset + 1] << 8 | ba[offset];\n        },\n\n        readShort: function readShort(ba, offset) {\n            return ba[offset + 1] << 8 | ba[offset];\n        },\n\n        readFloat: function readFloat(ba, offset) {\n            var temp = new Uint8Array(4);\n            for (var i = 0; i < 4; i++) {\n                temp[i] = ba[offset + i];\n            }\n            var fa = new Float32Array(temp.buffer);\n            return fa[0];\n        },\n\n        unbgzf: function unbgzf(data, lim) {\n            lim = Math.min(lim || Infinity, data.byteLength - 27);\n            var oBlockList = [];\n            var totalSize = 0;\n\n            for (var ptr = [0]; ptr[0] < lim; ptr[0] += 8) {\n\n                var ba = new Uint8Array(data, ptr[0], 18);\n\n                // check the bgzf block magic\n                if (!(ba[0] == 31 && ba[1] == 139)) {\n                    console.error('invalid BGZF block header, skipping', ba);\n                    break;\n                }\n\n                var xlen = this.readShort(ba, 10);\n                var compressedDataOffset = ptr[0] + 12 + xlen;\n\n                // var inPtr = ptr[0];\n                // var bSize = Utils.readShort( ba, 16 );\n                // var logLength = Math.min(data.byteLength-ptr[0], 40);\n                // console.log( xlen, bSize, bSize - xlen - 19, new Uint8Array( data, ptr[0], logLength ), logLength );\n\n                var unc;\n                try {\n                    unc = inflate(data, compressedDataOffset, data.byteLength - compressedDataOffset, ptr);\n                } catch (inflateError) {\n                    // if we have a buffer error and we have already\n                    // inflated some data, there is probably just an\n                    // incomplete BGZF block at the end of the data, so\n                    // ignore it and stop inflating\n                    if (/^Z_BUF_ERROR/.test(inflateError.statusString) && oBlockList.length) {\n                        break;\n                    }\n                    // otherwise it's some other kind of real error\n                    else {\n                            throw inflateError;\n                        }\n                }\n                if (unc.byteLength) {\n                    totalSize += unc.byteLength;\n                    oBlockList.push(unc);\n                }\n                // else {\n                //     console.error( 'BGZF decompression failed for block ', compressedDataOffset, data.byteLength-compressedDataOffset, [inPtr] );\n                // }\n            }\n\n            if (oBlockList.length == 1) {\n                return oBlockList[0];\n            } else {\n                var out = new Uint8Array(totalSize);\n                var cursor = 0;\n                for (var i = 0; i < oBlockList.length; ++i) {\n                    var b = new Uint8Array(oBlockList[i]);\n                    arrayCopy(b, 0, out, cursor, b.length);\n                    cursor += b.length;\n                }\n                return out.buffer;\n            }\n        }\n\n    });\n\n    return BGZBlob;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/BGZip/BGZBlob.js?");

/***/ }),

/***/ "./src/JBrowse/Model/BGZip/VirtualOffset.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/Model/BGZip/VirtualOffset.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * a virtual offset into a bgzipped file\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Util) {\n\n    var VirtualOffset = Util.fastDeclare({\n        constructor: function constructor(b, o) {\n            if (arguments.length >= 2) {\n                this.block = b;\n                this.offset = o;\n            } else {\n                this._fromBytes(b);\n            }\n        },\n\n        _fromBytes: function _fromBytes(ba, offset) {\n            offset = offset || 0;\n\n            //console.log( 'readVob', offset );\n            var block = ba[offset] * 0x10000000000 + ba[offset + 1] * 0x100000000 + ba[offset + 2] * 0x1000000 + ba[offset + 3] * 0x10000 + ba[offset + 4] * 0x100 + ba[offset + 5];\n            var bint = ba[offset + 6] << 8 | ba[offset + 7];\n            if (block == 0 && bint == 0) {\n                this.block = this.offset = null;\n            } else {\n                this.block = block;\n                this.offset = bint;\n            }\n        },\n        toString: function toString() {\n            return '' + this.block + ':' + this.offset;\n        },\n        compareTo: function compareTo(b) {\n            return this.block - b.block || this.offset - b.offset;\n        },\n        cmp: function cmp(b) {\n            return this.compareTo(b);\n        }\n    });\n\n    return VirtualOffset;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/BGZip/VirtualOffset.js?");

/***/ }),

/***/ "./src/JBrowse/Model/BinaryTreeNode.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/Model/BinaryTreeNode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang) {\n\n    // A class representing a node of a binary tree.\n\n    return declare(null, {\n        // Initialize relevant values\n        constructor: function constructor(args) {\n            this.Value = args.Value;\n            if (args.leftChild) {\n                this.leftChild = args.leftChild;\n            }\n            if (args.rightChild) {\n                this.rightChild = args.rightChild;\n            }\n\n            this.leaf = args.leaf || false;\n        },\n\n        // Attempt to add the given child node to the left of this node.  Return true if success.\n        addLeft: function addLeft(child) {\n            if (!this.leaf && this.leftChild === undefined) {\n                this.leftChild = child;\n                return true;\n            }\n            return false;\n        },\n\n        // Attempt to add the given child node to the right of this node.  Return true if success.\n        addRight: function addRight(child) {\n            if (!this.leaf && this.rightChild === undefined) {\n                this.rightChild = child;\n                return true;\n            }\n            return false;\n        },\n\n        // Try to add the given child node on either the left or the right of this node.  Return true if success.\n        add: function add(child) {\n            var added = this.addLeft(child) || this.addRight(child);\n            return added;\n        },\n\n        // Return true if this node is a leaf (has no children, or is specially designated as a leaf node)\n        isLeaf: function isLeaf() {\n            return this.leaf || this.leftChild === undefined && this.rightChild === undefined;\n        },\n\n        // Get the value of this node.\n        get: function get() {\n            return this.Value;\n        },\n\n        // Set the value of this node.\n        set: function set(value) {\n            this.Value = value;\n        },\n\n        // Get the leftChild of this node\n        left: function left() {\n            return this.leftChild;\n        },\n\n        // Get the rightChild of this node\n        right: function right() {\n            return this.rightChild;\n        },\n\n        // Return whether this node has a left child\n        hasLeft: function hasLeft() {\n            return !(this.leftChild === undefined);\n        },\n\n        // Return whether this node has a right child\n        hasRight: function hasRight() {\n            return !(this.rightChild === undefined);\n        },\n\n        // Remove the left child from this node\n        removeLeft: function removeLeft() {\n            this.leftChild = undefined;\n        },\n\n        // Remove the right child from this node\n        removeRight: function removeRight() {\n            this.rightChild = undefined;\n        },\n\n        // Remove all children from this node\n        removeAll: function removeAll() {\n            this.removeLeft();\n            this.removeRight();\n        },\n\n        // Destroy this node and all its children.\n        destroy: function destroy() {\n            if (this.leftChild) {\n                this.leftChild.destroy();\n                this.removeLeft();\n            }\n            if (this.rightChild) {\n                this.rightChild.destroy();\n                this.removeRight();\n            }\n            this.Value = undefined;\n        },\n\n        // Return an array containing all leaf nodes of this tree.\n        getLeaves: function getLeaves() {\n            if (this.isLeaf()) {\n                var retArray = [];\n                retArray[0] = this.Value;\n                return retArray;\n            } else if (this.leftChild === undefined) {\n                return this.rightChild.getLeaves();\n            } else if (this.rightChild === undefined) {\n                return this.leftChild.getLeaves();\n            }\n\n            return this.leftChild.getLeaves().concat(this.rightChild.getLeaves());\n        },\n\n        recursivelyCall: function recursivelyCall(callback) {\n            if (this.leftChild) {\n                this.leftChild.recursivelyCall(callback);\n            }\n            if (this.rightChild) {\n                this.rightChild.recursivelyCall(callback);\n            }\n            callback(this);\n        },\n\n        clone: function clone() {\n            var newTreeNode = lang.mixin({}, this);\n            if (this.leftChild) {\n                var newLeftChild = this.leftChild.clone();\n                newTreeNode.leftChild = newLeftChild;\n            }\n            if (this.rightChild) {\n                var newRightChild = this.rightChild.clone();\n                newTreeNode.rightChild = newRightChild;\n            }\n\n            return newTreeNode;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/BinaryTreeNode.js?");

/***/ }),

/***/ "./src/JBrowse/Model/BlobFilehandleWrapper.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Model/BlobFilehandleWrapper.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _cjsRequire = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _cjsRequire.Buffer;\n/**\n * Wraps a XHRBlob or FileBlob in a new promise-based API (which is\n * the upcoming node fs.promises API) for use by newer code.\n */\n\n\nvar BlobFilehandleWrapper = function () {\n    function BlobFilehandleWrapper(oldStyleBlob) {\n        _classCallCheck(this, BlobFilehandleWrapper);\n\n        this.blob = oldStyleBlob;\n    }\n\n    _createClass(BlobFilehandleWrapper, [{\n        key: 'read',\n        value: function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(buffer) {\n                var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var length = arguments[2];\n                var position = arguments[3];\n                var data;\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                _context.next = 2;\n                                return this.blob.readBufferPromise(position, length);\n\n                            case 2:\n                                data = _context.sent;\n\n                                data.copy(buffer, offset);\n                                return _context.abrupt('return', { bytesRead: data.length, buffer: buffer });\n\n                            case 5:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, this);\n            }));\n\n            function read(_x) {\n                return _ref.apply(this, arguments);\n            }\n\n            return read;\n        }()\n    }, {\n        key: 'readFile',\n        value: function () {\n            var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                        switch (_context2.prev = _context2.next) {\n                            case 0:\n                                return _context2.abrupt('return', this.blob.fetchBufferPromise());\n\n                            case 1:\n                            case 'end':\n                                return _context2.stop();\n                        }\n                    }\n                }, _callee2, this);\n            }));\n\n            function readFile() {\n                return _ref2.apply(this, arguments);\n            }\n\n            return readFile;\n        }()\n    }, {\n        key: 'stat',\n        value: function stat() {\n            return this.blob.statPromise();\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return (this.blob.url ? this.blob.url : this.blob.blob ? this.blob.blob.name : undefined) || undefined;\n        }\n    }]);\n\n    return BlobFilehandleWrapper;\n}();\n\nmodule.exports = BlobFilehandleWrapper;\n\n//# sourceURL=webpack:///./src/JBrowse/Model/BlobFilehandleWrapper.js?");

/***/ }),

/***/ "./src/JBrowse/Model/CSIIndex.js":
/*!***************************************!*\
  !*** ./src/JBrowse/Model/CSIIndex.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/DataView */ \"./src/JBrowse/Model/DataView.js\"), __webpack_require__(/*! JBrowse/Model/TabixIndex */ \"./src/JBrowse/Model/TabixIndex.js\"), __webpack_require__(/*! JBrowse/Model/BGZip/VirtualOffset */ \"./src/JBrowse/Model/BGZip/VirtualOffset.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, jDataView, TabixIndex, VirtualOffset) {\n\n    function lshift(num, bits) {\n        return num * Math.pow(2, bits);\n    }\n    function rshift(num, bits) {\n        return Math.floor(num / Math.pow(2, bits));\n    }\n    // inner class representing a chunk\n    var Chunk = Util.fastDeclare({\n        constructor: function constructor(minv, maxv, bin) {\n            this.minv = minv;\n            this.maxv = maxv;\n            this.bin = bin;\n        },\n        toUniqueString: function toUniqueString() {\n            return this.minv + '..' + this.maxv + ' (bin ' + this.bin + ')';\n        },\n        toString: function toString() {\n            return this.toUniqueString();\n        },\n        compareTo: function compareTo(b) {\n            return this.minv.compareTo(b.minv) || this.maxv.compareTo(b.maxv) || this.bin - b.bin;\n        },\n        compare: function compare(b) {\n            return this.compareTo(b);\n        },\n        fetchedSize: function fetchedSize() {\n            return this.maxv.block + lshift(1, 16) - this.minv.block + 1;\n        }\n    });\n\n    return declare(TabixIndex, {\n        // fetch and parse the index\n        _parseIndex: function _parseIndex(bytes, deferred) {\n            this._littleEndian = true;\n            var data = new jDataView(bytes, 0, undefined, this._littleEndian);\n\n            // check TBI magic numbers\n            if (data.getInt32() != 21582659 /* \"CSI\\1\" */) {\n                    // try the other endianness if no magic\n                    this._littleEndian = false;\n                    data = new jDataView(bytes, 0, undefined, this._littleEndian);\n                    if (data.getInt32() != 21582659 /* \"CSI\\1\" */) {\n                            console.error('Not a CSI file');\n                            deferred.reject('Not a CSI file');\n                            return;\n                        }\n                }\n\n            // number of reference sequences in the index\n            this.minShift = data.getInt32();\n            this.depth = data.getInt32();\n            var l_aux = data.getInt32();\n            var aux = data.getBytes(l_aux, undefined, false);\n            var refCount = data.getInt32();\n\n            // read sequence dictionary\n            this._refIDToName = new Array(refCount);\n            this._refNameToID = {};\n\n            if (l_aux) {\n                this._parseAux(aux);\n            }\n\n            // read the per-reference-sequence indexes\n            this._indices = new Array(refCount);\n            for (var i = 0; i < refCount; ++i) {\n                // the binning index\n                var binCount = data.getInt32();\n                var idx = this._indices[i] = { binIndex: {} };\n                for (var j = 0; j < binCount; ++j) {\n                    var bin = data.getInt32();\n                    var loffset = new VirtualOffset(data.getBytes(8));\n                    var chunkCount = data.getInt32();\n                    var chunks = new Array(chunkCount);\n                    for (var k = 0; k < chunkCount; ++k) {\n                        var u = new VirtualOffset(data.getBytes(8));\n                        var v = new VirtualOffset(data.getBytes(8));\n                        this._findFirstData(u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    idx.binIndex[bin] = chunks;\n                }\n                // the linear index\n            }\n\n            this.minAlignmentVO = this.firstDataLine;\n            deferred.resolve({ success: true });\n        },\n\n        _parseAux: function _parseAux(aux) {\n            var data = new jDataView(new Uint8Array(aux).buffer, 0, undefined, true);\n            var ret = data.getInt32();\n            this.columnNumbers = {\n                ref: data.getInt32(),\n                start: data.getInt32(),\n                end: data.getInt32()\n            };\n            this.metaValue = data.getInt32();\n            this.metaChar = this.metaValue ? String.fromCharCode(this.metaValue) : null;\n            this.skipLines = data.getInt32();\n            var nameSectionLength = data.getInt32();\n\n            this._parseNameBytes(data.getBytes(nameSectionLength, undefined, false));\n        },\n\n        TAD_LIDX_SHIFT: 14,\n\n        featureCount: function featureCount(refName, refNameIsID) {\n            var tid;\n            if (refNameIsID) tid = refName;else tid = this.getRefId(refName);\n\n            var indexes = this._indices[tid];\n            if (!indexes) return -1;\n            var bl = this._bin_limit(this.minShift, this.depth);\n            var ret = indexes.binIndex[bl + 1];\n            return ret ? ret[ret.length - 1].minv.offset : -1;\n        },\n        blocksForRange: function blocksForRange(refName, beg, end, refNameIsID) {\n            if (beg < 0) beg = 0;\n\n            var tid;\n            if (refNameIsID) tid = refName;else tid = this.getRefId(refName);\n\n            var indexes = this._indices[tid];\n            if (!indexes) return [];\n\n            var linearIndex = indexes.linearIndex,\n                binIndex = indexes.binIndex;\n\n            var bins = this._reg2bins(beg, end, this.minShift, this.depth);\n            // var linearCount = data.getInt32();\n            // var linear = idx.linearIndex = new Array( linearCount );\n            // for (var k = 0; k < linearCount; ++k) {\n            //     linear[k] = new VirtualOffset( data.getBytes(8) );\n            //     this._findFirstData( linear[k] );\n            // }\n            var min_off = new VirtualOffset(0, 0);\n\n            var i,\n                l,\n                n_off = 0;\n            for (i = 0; i < bins.length; ++i) {\n                n_off += (binIndex[bins[i]] || []).length;\n            }\n\n            if (n_off == 0) return [];\n\n            var off = [];\n\n            var chunks;\n            for (i = n_off = 0; i < bins.length; ++i) {\n                if (chunks = binIndex[bins[i]]) for (var j = 0; j < chunks.length; ++j) {\n                    //if( min_off.compareTo( chunks[j].maxv ) < 0 )\n                    off[n_off++] = new Chunk(chunks[j].minv, chunks[j].maxv, chunks[j].bin);\n                }\n            }if (!off.length) return [];\n\n            off = off.sort(function (a, b) {\n                return a.compareTo(b);\n            });\n\n            // resolve completely contained adjacent blocks\n            for (i = 1, l = 0; i < n_off; ++i) {\n                if (off[l].maxv.compareTo(off[i].maxv) < 0) {\n                    ++l;\n                    off[l].minv = off[i].minv;\n                    off[l].maxv = off[i].maxv;\n                }\n            }\n            n_off = l + 1;\n\n            return off.slice(0, n_off);\n        },\n\n        /* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */\n        _reg2bin: function _reg2bin(beg, end, min_shift, depth) {\n            var l = void 0,\n                s = min_shift,\n                t = ((1 << depth * 3) - 1) / 7;\n            for (--end, l = depth; l > 0; --l, s += 3, t -= 1 << l * 3) {\n                if (beg >> s == end >> s) return t + (beg >> s);\n            }\n            return 0;\n        },\n\n        _reg2bins: function _reg2bins(beg, end, min_shift, depth) {\n            var l = void 0,\n                t = void 0,\n                s = min_shift + depth * 3,\n                n = void 0;\n            var bins = [];\n            for (--end, l = n = t = 0; l <= depth; s -= 3, t += lshift(1, l * 3), ++l) {\n                var b = t + rshift(beg, s);\n                var e = t + rshift(end, s);\n                for (var i = b; i <= e; ++i) {\n                    bins[n++] = i;\n                }\n            }\n            return bins;\n        },\n        _bin_limit: function _bin_limit(min_shift) {\n            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n            return ((1 << (depth + 1) * 3) - 1) / 7;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/CSIIndex.js?");

/***/ }),

/***/ "./src/JBrowse/Model/CoverageFeature.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/Model/CoverageFeature.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Very minimal feature class for the features we make for just\n * calculating coverage.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Util) {\n\n    return Util.fastDeclare({\n        get: function get(f) {\n            return this[f];\n        },\n        tags: function tags() {\n            return ['start', 'end', 'score'];\n        },\n        score: 0,\n        constructor: function constructor(args) {\n            this.start = args.start;\n            this.end = args.end;\n            this.score = args.score;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/CoverageFeature.js?");

/***/ }),

/***/ "./src/JBrowse/Model/DataView.js":
/*!***************************************!*\
  !*** ./src/JBrowse/Model/DataView.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var jDataViewOld = __webpack_require__(/*! ../../jdataview-1.1-patch.X */ \"./src/jdataview-1.1-patch.X.js\");\nvar deprecate = __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\");\n\n/**\n * Subclass of jDataView with a getUint64 method.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    var DataView = function DataView() {\n        jDataViewOld.apply(this, arguments);\n    };\n\n    // jDataView, in the version that JBrowse is using it, does not conform to the DataView API as\n    // it was eventually settled. We need to move away from using it.\n    DataView = deprecate(DataView, 'JBrowse/Model/DataView is deprecated, please migrate to something else');\n\n    try {\n        DataView.prototype = new jDataViewOld(new ArrayBuffer([1]), 0, 1);\n    } catch (e) {\n        console.error(e);\n    }\n\n    /**\n     * Get a 53-bit integer from 64 bits and approximate the number if it overflows.\n     */\n    DataView.prototype.getUint64Approx = function (byteOffset, littleEndian) {\n        var b = this._getBytes(8, byteOffset, littleEndian);\n        var result = b[0] * Math.pow(2, 56) + b[1] * Math.pow(2, 48) + b[2] * Math.pow(2, 40) + b[3] * Math.pow(2, 32) + b[4] * Math.pow(2, 24) + (b[5] << 16) + (b[6] << 8) + b[7];\n\n        if (b[0] || b[1] & 224) {\n            result = Number(result);\n            result.overflow = true;\n        }\n\n        return result;\n    };\n\n    /**\n     * Get a 53-bit integer from 64 bits and throw if it overflows.\n     */\n    DataView.prototype.getUint64 = function (byteOffset, littleEndian) {\n        var result = this.getUint64Approx(byteOffset, littleEndian);\n        if (result.overflow) throw new Error('integer overflow');\n        return result;\n    };\n\n    return DataView;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/DataView.js?");

/***/ }),

/***/ "./src/JBrowse/Model/Location.js":
/*!***************************************!*\
  !*** ./src/JBrowse/Model/Location.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (array, Util) {\n\n    return Util.fastDeclare({\n        constructor: function constructor(args) {\n            if (args) {\n\n                if (typeof args == 'string') args = Util.parseLocString(args);\n\n                if (args.location) this._populate(args.location);\n                if (args.feature) {\n                    var f = args.feature;\n                    this._populate({ start: f.get('start'),\n                        end: f.get('end'),\n                        ref: f.get('seq_id') || (args.tracks ? args.tracks[0].browser.refSeq.name : undefined),\n                        strand: f.get('strand'),\n                        objectName: f.get('name') || f.get('id')\n                    });\n                }\n\n                this._populate(args);\n            }\n        },\n        _populate: function _populate(args) {\n            array.forEach('ref,start,end,strand,tracks,objectName'.split(','), function (p) {\n                if (p in args) this[p] = args[p];\n            }, this);\n        },\n\n        toString: function toString() {\n            var locstring = Util.assembleLocString(this);\n            if (this.objectName) return locstring + ' (' + this.objectName + ')';else return locstring;\n        },\n\n        fromString: function fromString(str) {\n            var p = Util.parseLocString(str);\n            p.objectName = p.extra;\n            delete p.extra;\n            this._populate(p);\n        },\n\n        localeCompare: function localeCompare(b) {\n            var as = this.toString();\n            var bs = b.toString();\n            return as.localeCompare(bs);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/Location.js?");

/***/ }),

/***/ "./src/JBrowse/Model/Range.js":
/*!************************************!*\
  !*** ./src/JBrowse/Model/Range.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare) {\n    var Range = declare(null,\n    /**\n     * @lends JBrowse.Model.Range.prototype\n     */\n    {\n\n        /**\n         * Adapted from a combination of Range and _Compound in the\n         * Dalliance Genome Explorer, (c) Thomas Down 2006-2010.\n         */\n        constructor: function constructor() {\n            this._ranges = arguments.length == 2 ? [{ min: arguments[0], max: arguments[1] }] : 0 in arguments[0] ? dojo.clone(arguments[0]) : [arguments[0]];\n        },\n\n        min: function min() {\n            return this._ranges[0].min;\n        },\n\n        max: function max() {\n            return this._ranges[this._ranges.length - 1].max;\n        },\n\n        contains: function contains(pos) {\n            for (var s = 0; s < this._ranges.length; ++s) {\n                var r = this._ranges[s];\n                if (r.min <= pos && r.max >= pos) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        isContiguous: function isContiguous() {\n            return this._ranges.length > 1;\n        },\n\n        ranges: function ranges() {\n            return this._ranges.map(function (r) {\n                return new Range(r.min, r.max);\n            });\n        },\n\n        toString: function toString() {\n            return this._ranges.map(function (r) {\n                return '[' + r.min + '-' + r.max + ']';\n            }).join(',');\n        },\n\n        union: function union(s1) {\n            var s0 = this;\n            var ranges = s0.ranges().concat(s1.ranges()).sort(this.rangeOrder);\n            var oranges = [];\n            var current = ranges[0];\n\n            for (var i = 1; i < ranges.length; ++i) {\n                var nxt = ranges[i];\n                if (nxt.min() > current.max() + 1) {\n                    oranges.push(current);\n                    current = nxt;\n                } else {\n                    if (nxt.max() > current.max()) {\n                        current = new Range(current.min(), nxt.max());\n                    }\n                }\n            }\n            oranges.push(current);\n\n            if (oranges.length == 1) {\n                return oranges[0];\n            } else {\n                return new Range(oranges);\n            }\n        },\n\n        intersection: function intersection(s1) {\n            var s0 = this;\n            var r0 = s0.ranges();\n            var r1 = s1.ranges();\n            var l0 = r0.length,\n                l1 = r1.length;\n            var i0 = 0,\n                i1 = 0;\n            var or = [];\n\n            while (i0 < l0 && i1 < l1) {\n                var s0 = r0[i0],\n                    s1 = r1[i1];\n                var lapMin = Math.max(s0.min(), s1.min());\n                var lapMax = Math.min(s0.max(), s1.max());\n                if (lapMax >= lapMin) {\n                    or.push(new Range(lapMin, lapMax));\n                }\n                if (s0.max() > s1.max()) {\n                    ++i1;\n                } else {\n                    ++i0;\n                }\n            }\n\n            if (or.length == 0) {\n                return null; // FIXME\n            } else if (or.length == 1) {\n                return or[0];\n            } else {\n                return new Range(or);\n            }\n        },\n\n        coverage: function coverage() {\n            var tot = 0;\n            var rl = this.ranges();\n            for (var ri = 0; ri < rl.length; ++ri) {\n                var r = rl[ri];\n                tot += r.max() - r.min() + 1;\n            }\n            return tot;\n        },\n\n        rangeOrder: function rangeOrder(a, b) {\n            if (arguments.length < 2) {\n                b = a;\n                a = this;\n            }\n\n            if (a.min() < b.min()) {\n                return -1;\n            } else if (a.min() > b.min()) {\n                return 1;\n            } else if (a.max() < b.max()) {\n                return -1;\n            } else if (b.max() > a.max()) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    });\n\n    return Range;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/Range.js?");

/***/ }),

/***/ "./src/JBrowse/Model/TabixIndex.js":
/*!*****************************************!*\
  !*** ./src/JBrowse/Model/TabixIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/Deferred */ \"./node_modules/dojo/_base/Deferred.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! JBrowse/Model/DataView */ \"./src/JBrowse/Model/DataView.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/BGZip/VirtualOffset */ \"./src/JBrowse/Model/BGZip/VirtualOffset.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Deferred, has, jDataView, Util, VirtualOffset) {\n\n    // inner class representing a chunk\n    var Chunk = Util.fastDeclare({\n        constructor: function constructor(minv, maxv, bin) {\n            this.minv = minv;\n            this.maxv = maxv;\n            this.bin = bin;\n        },\n        toUniqueString: function toUniqueString() {\n            return this.minv + '..' + this.maxv + ' (bin ' + this.bin + ')';\n        },\n        toString: function toString() {\n            return this.toUniqueString();\n        },\n        compareTo: function compareTo(b) {\n            return this.minv.compareTo(b.minv) || this.maxv.compareTo(b.maxv) || this.bin - b.bin;\n        },\n        compare: function compare(b) {\n            return this.compareTo(b);\n        },\n        fetchedSize: function fetchedSize() {\n            return this.maxv.block + (1 << 16) - this.minv.block + 1;\n        }\n    });\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.blob = args.blob;\n            this.load();\n        },\n\n        load: function load() {\n            var thisB = this;\n            return this._loaded = this._loaded || function () {\n                var d = new Deferred();\n                if (!has('typed-arrays')) d.reject('This web browser lacks support for JavaScript typed arrays.');else this.blob.fetch(function (data) {\n                    thisB._parseIndex(data, d);\n                }, dojo.hitch(d, 'reject'));\n                return d;\n            }.call(this);\n        },\n\n        // fetch and parse the index\n        _parseIndex: function _parseIndex(bytes, deferred) {\n\n            this._littleEndian = true;\n            var data = new jDataView(bytes, 0, undefined, this._littleEndian);\n\n            // check TBI magic numbers\n            if (data.getInt32() != 21578324 /* \"TBI\\1\" */) {\n                    // try the other endianness if no magic\n                    this._littleEndian = false;\n                    data = new jDataView(bytes, 0, undefined, this._littleEndian);\n                    if (data.getInt32() != 21578324 /* \"TBI\\1\" */) {\n                            console.error('Not a TBI file');\n                            deferred.reject('Not a TBI file');\n                            return;\n                        }\n                }\n\n            // number of reference sequences in the index\n            var refCount = data.getInt32();\n            this.presetType = data.getInt32();\n            this.columnNumbers = {\n                ref: data.getInt32(),\n                start: data.getInt32(),\n                end: data.getInt32()\n            };\n            this.metaValue = data.getInt32();\n            this.metaChar = this.metaValue ? String.fromCharCode(this.metaValue) : null;\n            this.skipLines = data.getInt32();\n\n            // read sequence dictionary\n            this._refIDToName = new Array(refCount);\n            this._refNameToID = {};\n            var nameSectionLength = data.getInt32();\n            this._parseNameBytes(data.getBytes(nameSectionLength, undefined, false));\n\n            // read the per-reference-sequence indexes\n            this._indices = new Array(refCount);\n            for (var i = 0; i < refCount; ++i) {\n                // the binning index\n                var binCount = data.getInt32();\n                var idx = this._indices[i] = { binIndex: {} };\n                for (var j = 0; j < binCount; ++j) {\n                    var bin = data.getInt32();\n                    var chunkCount = data.getInt32();\n                    var chunks = new Array(chunkCount);\n                    for (var k = 0; k < chunkCount; ++k) {\n                        var u = new VirtualOffset(data.getBytes(8));\n                        var v = new VirtualOffset(data.getBytes(8));\n                        this._findFirstData(u);\n                        chunks[k] = new Chunk(u, v, bin);\n                    }\n                    idx.binIndex[bin] = chunks;\n                }\n                // the linear index\n                var linearCount = data.getInt32();\n                var linear = idx.linearIndex = new Array(linearCount);\n                for (var k = 0; k < linearCount; ++k) {\n                    linear[k] = new VirtualOffset(data.getBytes(8));\n                    this._findFirstData(linear[k]);\n                }\n            }\n            deferred.resolve({ success: true });\n        },\n\n        _findFirstData: function _findFirstData(virtualOffset) {\n            var fdl = this.firstDataLine;\n            this.firstDataLine = fdl ? fdl.compareTo(virtualOffset) > 0 ? virtualOffset : fdl : virtualOffset;\n        },\n\n        _parseNameBytes: function _parseNameBytes(namesBytes) {\n            var offset = 0;\n\n            function getChar() {\n                var b = namesBytes[offset++];\n                return b ? String.fromCharCode(b) : null;\n            }\n\n            function getString() {\n                var c,\n                    s = '';\n                while (c = getChar()) {\n                    s += c;\n                }return s.length ? s : null;\n            }\n\n            var refName,\n                refID = 0;\n            for (; refName = getString(); refID++) {\n                this._refIDToName[refID] = refName;\n                this._refNameToID[this.browser.regularizeReferenceName(refName)] = refID;\n            }\n        },\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            var thisB = this;\n            seqName = thisB.browser.regularizeReferenceName(seqName);\n            thisB.load().then(function () {\n                if (seqName in thisB._refNameToID) {\n                    callback(true);\n                    return;\n                }\n                callback(false);\n            });\n        },\n\n        getRefId: function getRefId(refName) {\n            refName = this.browser.regularizeReferenceName(refName);\n            return this._refNameToID[refName];\n        },\n\n        TAD_LIDX_SHIFT: 14,\n\n        featureCount: function featureCount(refName) {\n            var tid = this.getRefId(refName);\n            var indexes = this._indices[tid];\n            if (!indexes) return -1;\n            var ret = indexes.binIndex[this._bin_limit() + 1];\n            return ret ? ret[ret.length - 1].minv.offset : -1;\n        },\n\n        blocksForRange: function blocksForRange(refName, beg, end) {\n            if (beg < 0) beg = 0;\n\n            var tid = this.getRefId(refName);\n            var indexes = this._indices[tid];\n            if (!indexes) return [];\n\n            var linearIndex = indexes.linearIndex,\n                binIndex = indexes.binIndex;\n\n            var bins = this._reg2bins(beg, end);\n\n            var min_off = linearIndex.length ? linearIndex[beg >> this.TAD_LIDX_SHIFT >= linearIndex.length ? linearIndex.length - 1 : beg >> this.TAD_LIDX_SHIFT] : new VirtualOffset(0, 0);\n\n            var i,\n                l,\n                n_off = 0;\n            for (i = 0; i < bins.length; ++i) {\n                n_off += (binIndex[bins[i]] || []).length;\n            }\n\n            if (n_off == 0) return [];\n\n            var off = [];\n\n            var chunks;\n            for (i = n_off = 0; i < bins.length; ++i) {\n                if (chunks = binIndex[bins[i]]) for (var j = 0; j < chunks.length; ++j) {\n                    if (min_off.compareTo(chunks[j].maxv) < 0) off[n_off++] = new Chunk(chunks[j].minv, chunks[j].maxv, chunks[j].bin);\n                }\n            }if (!off.length) return [];\n\n            off = off.sort(function (a, b) {\n                return a.compareTo(b);\n            });\n\n            // resolve completely contained adjacent blocks\n            for (i = 1, l = 0; i < n_off; ++i) {\n                if (off[l].maxv.compareTo(off[i].maxv) < 0) {\n                    ++l;\n                    off[l].minv = off[i].minv;\n                    off[l].maxv = off[i].maxv;\n                }\n            }\n            n_off = l + 1;\n\n            // resolve overlaps between adjacent blocks; this may happen due to the merge in indexing\n            for (i = 1; i < n_off; ++i) {\n                if (off[i - 1].maxv.compareTo(off[i].minv) >= 0) off[i - 1].maxv = off[i].minv;\n            } // merge adjacent blocks\n            for (i = 1, l = 0; i < n_off; ++i) {\n                if (off[l].maxv.block == off[i].minv.block) off[l].maxv = off[i].maxv;else {\n                    ++l;\n                    off[l].minv = off[i].minv;\n                    off[l].maxv = off[i].maxv;\n                }\n            }\n            n_off = l + 1;\n\n            return off.slice(0, n_off);\n        },\n\n        /* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */\n        _reg2bin: function _reg2bin(beg, end) {\n            --end;\n            if (beg >> 14 == end >> 14) return ((1 << 15) - 1) / 7 + (beg >> 14);\n            if (beg >> 17 == end >> 17) return ((1 << 12) - 1) / 7 + (beg >> 17);\n            if (beg >> 20 == end >> 20) return ((1 << 9) - 1) / 7 + (beg >> 20);\n            if (beg >> 23 == end >> 23) return ((1 << 6) - 1) / 7 + (beg >> 23);\n            if (beg >> 26 == end >> 26) return ((1 << 3) - 1) / 7 + (beg >> 26);\n            return 0;\n        },\n\n        /* calculate the list of bins that may overlap with region [beg,end) (zero-based) */\n        _reg2bins: function _reg2bins(beg, end) {\n            var k,\n                list = [];\n            --end;\n            list.push(0);\n            for (k = 1 + (beg >> 26); k <= 1 + (end >> 26); ++k) {\n                list.push(k);\n            }for (k = 9 + (beg >> 23); k <= 9 + (end >> 23); ++k) {\n                list.push(k);\n            }for (k = 73 + (beg >> 20); k <= 73 + (end >> 20); ++k) {\n                list.push(k);\n            }for (k = 585 + (beg >> 17); k <= 585 + (end >> 17); ++k) {\n                list.push(k);\n            }for (k = 4681 + (beg >> 14); k <= 4681 + (end >> 14); ++k) {\n                list.push(k);\n            }return list;\n        },\n        _bin_limit: function _bin_limit(min_shift) {\n            var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n            return ((1 << (depth + 1) * 3) - 1) / 7;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/TabixIndex.js?");

/***/ }),

/***/ "./src/JBrowse/Model/VCFFeature.js":
/*!*****************************************!*\
  !*** ./src/JBrowse/Model/VCFFeature.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * VCF Feature creation with lazy genotpye evaluation.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Util) {\n    var Feature = Util.fastDeclare({\n        constructor: function constructor(args) {\n            this.variant = args.variant;\n            this.parser = args.parser;\n            this._id = args.id;\n            this.data = this.dataFromVariant(this.variant);\n        },\n\n        get: function get(field) {\n            return this._get(field) || this._get(field.toLowerCase());\n        },\n\n\n        // same as get(), except requires lower-case arguments.    used\n        // internally to save lots of calls to field.toLowerCase()\n        _get: function _get(field) {\n            return field in this.data ? this.data[field] : // have we already parsed it out?\n            function (field) {\n                var v = this.data[field] = this['_parse_' + field] ? this['_parse_' + field]() : // maybe we have a special parser for it\n                undefined;\n                return v;\n            }.call(this, field);\n        },\n        parent: function parent() {\n            return null;\n        },\n        children: function children() {\n            return null;\n        },\n        tags: function tags() {\n            var t = [];\n            var d = this.data;\n            for (var k in d) {\n                if (d.hasOwnProperty(k)) t.push(k);\n            }\n            if (!d.genotypes) t.push('genotypes');\n            return t;\n        },\n        id: function id() {\n            return this._id;\n        },\n        _parse_genotypes: function _parse_genotypes() {\n            var _this = this;\n\n            var variant = this.variant;\n            delete this.variant; // TODO: remove this delete if we add other laziness\n\n            if (Object.keys(variant.SAMPLES).length) {\n                this.data.genotypes = {};\n                Object.keys(variant.SAMPLES).forEach(function (sample) {\n                    _this.data.genotypes[sample] = {};\n                    Object.keys(variant.SAMPLES[sample]).forEach(function (field) {\n                        _this.data.genotypes[sample][field] = {\n                            values: variant.SAMPLES[sample][field]\n                        };\n                    });\n                });\n                return this.data.genotypes;\n            } else {\n                this.data.genotypes = null;\n                return null;\n            }\n        },\n\n\n        dataFromVariant: function dataFromVariant(variant) {\n            var ref = variant.REF;\n            var alt = variant.ALT;\n            var start = variant.POS - 1;\n            var end = variant.INFO['END'] ? Number(variant.INFO['END'][0]) : start + ref.length;\n\n            var _getSOTermAndDescript = this._getSOTermAndDescription(ref, alt),\n                _getSOTermAndDescript2 = _slicedToArray(_getSOTermAndDescript, 2),\n                SO_term = _getSOTermAndDescript2[0],\n                description = _getSOTermAndDescript2[1];\n\n            var featureData = {\n                start: start,\n                end: end,\n                seq_id: variant.CHROM,\n                description: description,\n                type: SO_term,\n                reference_allele: ref\n            };\n\n            if (variant.ID) {\n                featureData.name = variant.ID[0];\n                if (variant.ID > 1) {\n                    featureData.aliases = variant.ID.slice(1).join(',');\n                }\n            }\n\n            if (variant.QUAL) {\n                featureData.score = variant.QUAL;\n            };\n\n            if (variant.FILTER) {\n                featureData.filter = {\n                    meta: {\n                        description: 'List of filters that this site has not passed, or PASS if it has passed all filters',\n                        filters: this.parser.getMetadata('FILTER')\n                    },\n                    values: variant.FILTER === 'PASS' ? ['PASS'] : variant.FILTER\n                };\n            }\n\n            if (alt) {\n                featureData.alternative_alleles = {\n                    meta: {\n                        description: 'VCF ALT field, list of alternate non-reference alleles called on at least one of the samples'\n                    },\n                    values: alt\n                };\n            }\n\n            // parse the info field and store its contents as attributes in featureData\n            if (variant.INFO) {\n                this._parseInfoField(featureData, variant.INFO);\n            }\n\n            return featureData;\n        },\n\n        /**\n        * parse a VCF line's INFO field, storing the contents as\n        * attributes in featureData\n        */\n        _parseInfoField: function _parseInfoField(featureData, info) {\n\n            // decorate the info records with references to their descriptions\n            for (var field in info) {\n                if (info.hasOwnProperty(field)) {\n                    var i = info[field] = {\n                        values: info[field]\n                    };\n                    var meta = this.parser.getMetadata('INFO', field);\n                    if (meta) i.meta = meta;\n                    featureData[field] = i;\n                }\n            }\n        },\n\n        /**\n         * Get a sequence ontology (SO) term that describes the variant type\n         */\n        _getSOTermAndDescription: function _getSOTermAndDescription(ref, alt) {\n            var _this2 = this;\n\n            // it's just a remark if there are no alternate alleles\n            if (!alt || alt === []) {\n                return ['remark', 'no alternative alleles'];\n            };\n\n            var soTerms = new Set();\n            var descriptions = new Set();\n            alt.forEach(function (a) {\n                var _getSOAndDescFromAltD = _this2._getSOAndDescFromAltDefs(ref, a),\n                    _getSOAndDescFromAltD2 = _slicedToArray(_getSOAndDescFromAltD, 2),\n                    soTerm = _getSOAndDescFromAltD2[0],\n                    description = _getSOAndDescFromAltD2[1];\n\n                if (!soTerm) {\n                    var _getSOAndDescByExamin = _this2._getSOAndDescByExamination(ref, a);\n\n                    var _getSOAndDescByExamin2 = _slicedToArray(_getSOAndDescByExamin, 2);\n\n                    soTerm = _getSOAndDescByExamin2[0];\n                    description = _getSOAndDescByExamin2[1];\n                }\n                if (soTerm) {\n                    soTerms.add(soTerm);\n                    descriptions.add(description);\n                }\n            });\n            // Combine descriptions like [\"SNV G -> A\", \"SNV G -> T\"] to [\"SNV G -> A,T\"]\n            if (descriptions.size > 1) {\n                var prefixes = new Set();\n                [].concat(_toConsumableArray(descriptions)).forEach(function (desc) {\n                    var prefix = desc.match(/(\\w+? \\w+? -> )(?:<)\\w+(?:>)/);\n                    if (prefix && prefix[1]) prefixes.add(prefix[1]);else prefixes.add(desc);\n                });\n                var new_descs = [];\n                [].concat(_toConsumableArray(prefixes)).forEach(function (prefix) {\n                    var suffixes = [];\n                    [].concat(_toConsumableArray(descriptions)).forEach(function (desc) {\n                        if (desc.startsWith(prefix)) {\n                            suffixes.push(desc.slice(prefix.length));\n                        }\n                    });\n                    new_descs.push(prefix + suffixes.join(','));\n                });\n                descriptions = new_descs;\n            }\n            if (soTerms.size) {\n                return [[].concat(_toConsumableArray(soTerms)).join(','), [].concat(_toConsumableArray(descriptions)).join(',')];\n            } else return [null, null];\n        },\n\n        _altTypeToSO: {\n            DEL: 'deletion',\n            INS: 'insertion',\n            DUP: 'copy_number_gain',\n            INV: 'inversion',\n            CNV: 'copy_number_variation',\n            'DUP:TANDEM': 'copy_number_gain',\n            NON_REF: 'sequence_variant',\n            '*': 'sequence_variant'\n        },\n\n        _getSOAndDescFromAltDefs: function _getSOAndDescFromAltDefs(ref, alt) {\n            // not a symbolic ALT if doesn't begin with '<', so we'll have no definition\n            if (alt[0] != '<') {\n                return [null, null];\n            }\n\n            alt = alt.replace(/^<|>$/g, ''); // trim off < and >\n\n            // look for a definition with an SO type for this\n            var soTerm = this._altTypeToSO[alt];\n            // if no SO term but ALT is in metadata, assume sequence_variant\n            if (!soTerm && this.parser.getMetadata('ALT', alt)) soTerm = 'sequence_variant';\n            if (soTerm) {\n                var description = this.parser.getMetadata('ALT', alt, 'Description') ? alt + ' - ' + this.parser.getMetadata('ALT', alt, 'Description') : this._makeDescriptionString(soTerm, ref, alt);\n                return [soTerm, description];\n            }\n\n            // try to look for a definition for a parent term if we can\n            alt = alt.split(':');\n            if (alt.length > 1) {\n                return this._getSOAndDescFromAltDefs(ref, '<' + alt.slice(0, alt.length - 1).join(':') + '>');\n            } else {\n                // no parent\n                return [null, null];\n            }\n        },\n\n        _getSOAndDescByExamination: function _getSOAndDescByExamination(ref, alt) {\n            if (ref.length == 1 && alt.length == 1) {\n                // use SNV because SO definition of SNP says abundance must be at\n                // least 1% in population, and can't be sure we meet that\n                return ['SNV', this._makeDescriptionString('SNV', ref, alt)];\n            }\n\n            if (ref.length == alt.length) if (ref.split('').reverse().join('') == alt) return ['inversion', this._makeDescriptionString('inversion', ref, alt)];else return ['substitution', this._makeDescriptionString('substitution', ref, alt)];\n\n            if (ref.length <= alt.length) return ['insertion', this._makeDescriptionString('insertion', ref, alt)];\n\n            if (ref.length > alt.length) return ['deletion', this._makeDescriptionString('deletion', ref, alt)];\n\n            return ['indel', this._makeDescriptionString('indel', ref, alt)];\n        },\n\n        _makeDescriptionString: function _makeDescriptionString(soTerm, ref, alt) {\n            return soTerm + \" \" + ref + \" -> \" + alt;\n        }\n\n    });\n\n    return Feature;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/VCFFeature.js?");

/***/ }),

/***/ "./src/JBrowse/Model/modEncodeTrackMetadata.js":
/*!*****************************************************!*\
  !*** ./src/JBrowse/Model/modEncodeTrackMetadata.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/data/util/simpleFetch */ \"./node_modules/dojo/data/util/simpleFetch.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, simpleFetch, Util) {\n\n    var dojof = Util.dojof;\n\n    var M = declare(null,\n\n    /**\n     * @lends JBrowse.Model.modEncodeTrackMetadata.prototype\n     */\n    {\n        /**\n         * Track metadata datasource that understands the format of the\n         * modencode.js track metadata JSON currently (May 2012) used at\n         * data.modencode.org.\n         * @constructor\n         * @param args.url {String} URL to fetch the metadata JSON from\n         */\n        constructor: function constructor(args) {\n            this.url = args.url;\n        },\n\n        // dojo.data.api.Read support\n        getValue: function getValue(i, attr, defaultValue) {\n            var v = i[attr];\n            return typeof v == 'undefined' ? defaultValue : v;\n        },\n        getValues: function getValues(i, attr) {\n            var a = [i[attr]];\n            return typeof a[0] == 'undefined' ? [] : a;\n        },\n\n        getAttributes: function getAttributes(item) {\n            return dojof.keys(item);\n        },\n\n        hasAttribute: function hasAttribute(item, attr) {\n            return item.hasOwnProperty(attr);\n        },\n\n        containsValue: function containsValue(item, attribute, value) {\n            return item[attribute] == value;\n        },\n\n        isItem: function isItem(item) {\n            return (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object' && typeof item.label == 'string';\n        },\n\n        isItemLoaded: function isItemLoaded() {\n            return true;\n        },\n\n        loadItem: function loadItem(args) {},\n\n        // used by the dojo.data.util.simpleFetch mixin to implement fetch()\n        _fetchItems: function _fetchItems(keywordArgs, findCallback, errorCallback) {\n            dojo.xhrGet({\n                url: this.url,\n                handleAs: 'json',\n                load: dojo.hitch(this, function (data) {\n                    var items = [];\n                    dojo.forEach(data.items || [], function (i) {\n                        if (dojo.isArray(i.Tracks)) dojo.forEach(i.Tracks, function (trackName) {\n                            var item = dojo.clone(i);\n                            item.key = item.label;\n                            item.label = trackName;\n                            delete item.Tracks;\n                            items.push(item);\n                        }, this);\n                    }, this);\n                    findCallback(items, keywordArgs);\n                }),\n                error: function error(e) {\n                    errorCallback(e, keywordArgs);\n                }\n            });\n        },\n\n        getFeatures: function getFeatures() {\n            return {\n                'dojo.data.api.Read': true,\n                'dojo.data.api.Identity': true\n            };\n        },\n        close: function close() {},\n\n        getLabel: function getLabel(i) {\n            return this.getValue(i, 'key', undefined);\n        },\n        getLabelAttributes: function getLabelAttributes(i) {\n            return ['key'];\n        },\n\n        // dojo.data.api.Identity support\n        getIdentityAttributes: function getIdentityAttributes() {\n            return ['label'];\n        },\n        getIdentity: function getIdentity(i) {\n            return this.getValue(i, 'label', undefined);\n        },\n        fetchItemByIdentity: function fetchItemByIdentity(id) {\n            return this.identIndex[id];\n        }\n    });\n\n    dojo.extend(M, simpleFetch);\n\n    return M;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Model/modEncodeTrackMetadata.js?");

/***/ }),

/***/ "./src/JBrowse/Plugin.js":
/*!*******************************!*\
  !*** ./src/JBrowse/Plugin.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Component */ \"./src/JBrowse/Component.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Component) {\n    return declare(Component, {\n        constructor: function constructor(args) {\n            this.name = args.name;\n            this.cssLoaded = args.cssLoaded;\n            this._finalizeConfig(args.config);\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return {\n                baseUrl: '/plugins/' + this.name\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Plugin.js?");

/***/ }),

/***/ "./src/JBrowse/Store/BigWig.js":
/*!*************************************!*\
  !*** ./src/JBrowse/Store/BigWig.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Store/SeqFeature/BigWig */ \"./src/JBrowse/Store/SeqFeature/BigWig.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (bw) {\n  return bw;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/BigWig.js?");

/***/ }),

/***/ "./src/JBrowse/Store/LazyTrie.js":
/*!***************************************!*\
  !*** ./src/JBrowse/Store/LazyTrie.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/request */ \"./node_modules/dojo/request.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, request, Util) {\n    return declare('JBrowse.Store.LazyTrie', null,\n    /**\n     * @lends JBrowse.Store.LazyTrie.prototype\n     */\n    {\n\n        /**\n         * <pre>\n         * Implements a lazy PATRICIA tree.\n         *  This structure is a map where the keys are strings.  The map supports fast\n         * queries by key string prefix (\"show me all the values for keys that\n         * start with \"abc\").  It also supports lazily loading subtrees.\n         *\n         * Each edge is labeled with a substring of a key string.\n         * Each node in the tree has one or more children, each of which represents\n         *   a potential completion of the string formed by concatenating all of the\n         *   edge strings from that node up to the root.\n         *   Nodes also have zero or one data items.\n         * Leaves have zero or one data items.\n         *\n         * Each loaded node is an array.\n         *    element 0 is the edge string;\n         *    element 1 is the data item, or null if there is none;\n         *    any further elements are the child nodes, sorted lexicographically\n         *      by their edge string\n         *\n         *  Each lazy node is an array where the first element is the number of\n         *  data items in the subtree rooted at that node, and the second element\n         *  is the edge string for that node.\n         *    when the lazy node is loaded, the lazy array gets replaced with\n         *    a loaded node array; lazy nodes and loaded nodes can be distinguished by:\n         *    \"string\" == typeof loaded_node[0]\n         *    \"number\" == typeof lazy_node[0]\n         *\n         *  e.g., for the mappings:\n         *    abc   => 0\n         *    abcd  => 1\n         *    abce  => \"baz\"\n         *    abfoo => [3, 4]\n         *    abbar (subtree to be loaded lazily)\n         *\n         *  the structure is:\n         *\n         *  [, , [\"ab\", ,\n         *        [3, \"bar\"],\n         *        [\"c\", 0, [\"d\", 1],\n         *         [\"e\", \"baz\"]],\n         *        [\"foo\", [3, 4]]\n         *        ]\n         *   ]\n         *\n         *  The main goals for this structure were to minimize the JSON size on\n         *  the wire (so, no type tags in the JSON to distinguish loaded nodes,\n         *  lazy nodes, and leaves) while supporting lazy loading and reasonably\n         *  fast lookups.\n         * </pre>\n         *\n         * @constructs\n         */\n        constructor: function constructor(rootURL, chunkTempl) {\n            var _this = this;\n\n            this.rootURL = rootURL;\n            this.chunkTempl = chunkTempl;\n            var trie = this;\n\n            request(rootURL, { handleAs: \"json\" }).then(function (o) {\n                if (!o) {\n                    console.log(\"failed to load trie\");\n                    return;\n                }\n                trie.root = o;\n                trie.extra = o[0];\n                if (trie.deferred) {\n                    trie.deferred.callee.apply(trie, trie.deferred);\n                    delete trie.deferred;\n                }\n            }, function (error) {\n                console.log('No name store configuration found and requesting the default root.json not found. Likely you have not run generate-names.pl yet. This is not essential for running JBrowse but will remove this message if it is run');\n                _this.error = error;\n            });\n        },\n\n        chunkUrl: function chunkUrl(prefix) {\n            var chunkUrl = this.chunkTempl.replace(\"\\{Chunk\\}\", prefix);\n            return Util.resolveUrl(this.rootURL, chunkUrl);\n        },\n\n        pathToPrefix: function pathToPrefix(path) {\n            var node = this.root;\n            var result = \"\";\n            loop: for (var i = 0; i < path.length; i++) {\n                switch (_typeof(node[path[i]][0])) {\n                    case 'string':\n                        // regular node\n                        result += node[path[i]][0];\n                        break;\n                    case 'number':\n                        // lazy node\n                        result += node[path[i]][1];\n                        break loop;\n                }\n                node = node[path[i]];\n            }\n            return result;\n        },\n\n        valuesFromPrefix: function valuesFromPrefix(query, callback) {\n            var trie = this;\n            this.findNode(query, function (prefix, node) {\n                callback(trie.valuesFromNode(node));\n            }, function () {\n                callback([]);\n            });\n        },\n\n        mappingsFromPrefix: function mappingsFromPrefix(query, callback) {\n            var trie = this;\n            this.findNode(query, function (prefix, node) {\n                callback(trie.mappingsFromNode(prefix, node));\n            }, function () {\n                callback([]);\n            });\n        },\n\n        mappingsFromNode: function mappingsFromNode(prefix, node) {\n            var results = [];\n            if (node[1] !== null) results.push([prefix, node[1]]);\n            for (var i = 2; i < node.length; i++) {\n                if (\"string\" == typeof node[i][0]) {\n                    results = results.concat(this.mappingsFromNode(prefix + node[i][0], node[i]));\n                }\n            }\n            return results;\n        },\n\n        valuesFromNode: function valuesFromNode(node) {\n            var results = [];\n            if (node[1] !== null) results.push(node[1]);\n            for (var i = 2; i < node.length; i++) {\n                results = results.concat(this.valuesFromNode(node[i]));\n            }return results;\n        },\n\n        exactMatch: function exactMatch(key, callback, notfoundCallback) {\n            notfoundCallback = notfoundCallback || function () {};\n            if (this.error) {\n                notfoundCallback();\n                return;\n            }\n\n            var trie = this;\n            this.findNode(key, function (prefix, node) {\n                if (prefix.toLowerCase() == key.toLowerCase() && node[1]) callback(node[1]);\n            }, notfoundCallback);\n        },\n\n        findNode: function findNode(query, foundCallback, notfoundCallback) {\n            notfoundCallback = notfoundCallback || function () {};\n\n            if (this.error) {\n                notfoundCallback();\n                return;\n            }\n\n            var trie = this;\n            this.findPath(query, function (path) {\n                var node = trie.root;\n                for (var i = 0; i < path.length; i++) {\n                    node = node[path[i]];\n                }var foundPrefix = trie.pathToPrefix(path);\n                foundCallback(foundPrefix, node);\n            }, notfoundCallback);\n        },\n\n        findPath: function findPath(query, foundCallback, notfoundCallback) {\n            var _this2 = this;\n\n            if (this.error) {\n                notfoundCallback();\n                return;\n            }\n\n            notfoundCallback = notfoundCallback || function () {};\n\n            if (!this.root) {\n                notfoundCallback();\n                return;\n            }\n            query = query.toLowerCase();\n            var node = this.root;\n            var qStart = 0;\n            var childIndex;\n\n            var path = [];\n\n            while (true) {\n                childIndex = this.binarySearch(node, query.charAt(qStart));\n                if (childIndex < 0) {\n                    notfoundCallback();\n                    return;\n                }\n                path.push(childIndex);\n\n                if (\"number\" == typeof node[childIndex][0]) {\n                    // lazy node\n                    var trie = this;\n                    dojo.xhrGet({ url: this.chunkUrl(this.pathToPrefix(path)),\n                        handleAs: \"json\",\n                        load: function load(o) {\n                            node[childIndex] = o;\n                            trie.findPath(query, foundCallback);\n                        },\n                        error: function error(err) {\n                            _this2.error = err;\n                        }\n                    });\n                    return;\n                }\n\n                node = node[childIndex];\n\n                // if the current edge string doesn't match the\n                // relevant part of the query string, then there's no\n                // match\n                if (query.substr(qStart, node[0].length) != node[0].substr(0, Math.min(node[0].length, query.length - qStart))) {\n                    notfoundCallback();\n                    return;\n                }\n\n                qStart += node[0].length;\n                if (qStart >= query.length) {\n                    // we've reached the end of the query string, and we\n                    // have some matches\n                    foundCallback(path);\n                    return;\n                }\n            }\n        },\n\n        binarySearch: function binarySearch(a, firstChar) {\n            var low = 2; // skip edge string (in 0) and data item (in 1)\n            var high = a.length - 1;\n            var mid, midVal;\n            while (low <= high) {\n                mid = low + high >>> 1;\n                switch (_typeof(a[mid][0])) {\n                    case 'string':\n                        // regular node\n                        midVal = a[mid][0].charAt(0);\n                        break;\n                    case 'number':\n                        // lazy node\n                        midVal = a[mid][1].charAt(0);\n                        break;\n                }\n\n                if (midVal < firstChar) {\n                    low = mid + 1;\n                } else if (midVal > firstChar) {\n                    high = mid - 1;\n                } else {\n                    return mid; // key found\n                }\n            }\n\n            return -(low + 1); // key not found.\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n\n//# sourceURL=webpack:///./src/JBrowse/Store/LazyTrie.js?");

/***/ }),

/***/ "./src/JBrowse/Store/NCList.js":
/*!*************************************!*\
  !*** ./src/JBrowse/Store/NCList.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/request */ \"./node_modules/dojo/request.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store/LRUCache */ \"./src/JBrowse/Store/LRUCache.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (request, all, Deferred, Util, LRUCache) {\n\n    /**\n    \n    Nested containment list.\n    \n    @class\n    \n    After\n    <pre>\n      Alekseyenko, A., and Lee, C. (2007).\n      Nested Containment List (NCList): A new algorithm for accelerating\n         interval query of genome alignment and interval databases.\n      Bioinformatics, doi:10.1093/bioinformatics/btl647\n    </pre>\n    \n    <a href=\"http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btl647v1\">http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btl647v1</a>\n    \n     */\n\n    function NCList() {\n        this.topList = [];\n    }\n\n    NCList.prototype.importExisting = function (nclist, attrs, baseURL, lazyUrlTemplate, lazyClass) {\n        this.topList = nclist;\n        this.attrs = attrs;\n        this.start = attrs.makeFastGetter(\"Start\");\n        this.end = attrs.makeFastGetter(\"End\");\n        this.lazyClass = lazyClass;\n        this.baseURL = baseURL;\n        this.lazyUrlTemplate = lazyUrlTemplate;\n        this.lazyChunks = {};\n    };\n\n    /**\n     *\n     *  Given an array of features, creates the nested containment list data structure\n     *  WARNING: DO NOT USE directly for adding additional intervals!\n     *  completely replaces existing nested containment structure\n     *  (erases current topList and subarrays, repopulates from intervals)\n     *  currently assumes each feature is array as described above\n     */\n    NCList.prototype.fill = function (intervals, attrs) {\n        //intervals: array of arrays of [start, end, ...]\n        //attrs: an ArrayRepr object\n        //half-open?\n        if (intervals.length == 0) {\n            this.topList = [];\n            return;\n        }\n\n        this.attrs = attrs;\n        this.start = attrs.makeFastGetter(\"Start\");\n        this.end = attrs.makeFastGetter(\"End\");\n        var sublist = attrs.makeSetter(\"Sublist\");\n        var start = this.start;\n        var end = this.end;\n        var myIntervals = intervals;\n        //sort by OL\n        myIntervals.sort(function (a, b) {\n            if (start(a) != start(b)) return start(a) - start(b);else return end(b) - end(a);\n        });\n        var sublistStack = [];\n        var curList = [];\n        this.topList = curList;\n        curList.push(myIntervals[0]);\n        if (myIntervals.length == 1) return;\n        var curInterval, topSublist;\n        for (var i = 1, len = myIntervals.length; i < len; i++) {\n            curInterval = myIntervals[i];\n            //if this interval is contained in the previous interval,\n            if (end(curInterval) < end(myIntervals[i - 1])) {\n                //create a new sublist starting with this interval\n                sublistStack.push(curList);\n                curList = new Array(curInterval);\n                sublist(myIntervals[i - 1], curList);\n            } else {\n                //find the right sublist for this interval\n                while (true) {\n                    if (0 == sublistStack.length) {\n                        curList.push(curInterval);\n                        break;\n                    } else {\n                        topSublist = sublistStack[sublistStack.length - 1];\n                        if (end(topSublist[topSublist.length - 1]) > end(curInterval)) {\n                            //curList is the first (deepest) sublist that\n                            //curInterval fits into\n                            curList.push(curInterval);\n                            break;\n                        } else {\n                            curList = sublistStack.pop();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    NCList.prototype.binarySearch = function (arr, item, getter) {\n        var low = -1;\n        var high = arr.length;\n        var mid;\n\n        while (high - low > 1) {\n            mid = low + high >>> 1;\n            if (getter(arr[mid]) >= item) high = mid;else low = mid;\n        }\n\n        //if we're iterating rightward, return the high index;\n        //if leftward, the low index\n        if (getter === this.end) return high;else return low;\n    };\n    NCList.prototype._readChunkItems = function (chunk, callback) {\n        request.get(Util.resolveUrl(this.baseURL, this.lazyUrlTemplate.replace(/\\{Chunk\\}/ig, chunk.chunkNum)), {\n            handleAs: 'json',\n            headers: {\n                'X-Requested-With': null\n            }\n        }).then(function (sublist) {\n            callback(sublist);\n        }, function (error) {\n            if (error.response.status != 404) callback(null, error);else callback();\n        });\n    };\n    NCList.prototype.iterHelper = function (arr, from, to, fun, inc, searchGet, testGet, path) {\n        var len = arr.length;\n        var i = this.binarySearch(arr, from, searchGet);\n        var getChunk = this.attrs.makeGetter(\"Chunk\");\n        var getSublist = this.attrs.makeGetter(\"Sublist\");\n\n        var promises = [];\n\n        var cache = this.chunkCache = this.chunkCache || new LRUCache({\n            name: 'NCListCache',\n            fillCallback: dojo.hitch(this, '_readChunkItems'),\n            sizeFunction: function sizeFunction(chunkItems) {\n                return chunkItems.length;\n            },\n            maxSize: 5000 // cache up to 100 seqchunks\n        });\n        while (i < len && i >= 0 && inc * testGet(arr[i]) < inc * to) {\n\n            if (arr[i][0] == this.lazyClass) {\n                // this is a lazily-loaded chunk of the nclist\n                (function () {\n                    var thisB = this;\n                    var chunkNum = getChunk(arr[i]);\n                    if (!(chunkNum in this.lazyChunks)) {\n                        this.lazyChunks[chunkNum] = {};\n                    }\n\n                    var getDone = new Deferred();\n                    promises.push(getDone.promise);\n\n                    cache.get({ chunkNum: chunkNum }, function (item, e) {\n                        if (e) {\n                            getDone.reject(e);\n                            return;\n                        }\n                        if (!item) {\n                            getDone.resolve();\n                            return;\n                        }\n                        return thisB.iterHelper(item, from, to, fun, inc, searchGet, testGet, [chunkNum]).then(function () {\n                            getDone.resolve();\n                        });\n                    });\n                }).call(this);\n            } else {\n                // this is just a regular feature\n\n                fun(arr[i], path.concat(i));\n            }\n\n            // if this node has a contained sublist, process that too\n            var sublist = getSublist(arr[i]);\n            if (sublist) promises.push(this.iterHelper(sublist, from, to, fun, inc, searchGet, testGet, path.concat(i)));\n            i += inc;\n        }\n\n        return all(promises);\n    };\n\n    NCList.prototype.iterate = function (from, to, fun, postFun) {\n        // calls the given function once for each of the\n        // intervals that overlap the given interval\n        //if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n        //inc: iterate leftward or rightward\n        var inc = from > to ? -1 : 1;\n        //searchGet: search on start or end\n        var searchGet = from > to ? this.start : this.end;\n        //testGet: test on start or end\n        var testGet = from > to ? this.end : this.start;\n\n        if (this.topList.length > 0) {\n            this.iterHelper(this.topList, from, to, fun, inc, searchGet, testGet, [0]).then(postFun);\n        }\n    };\n\n    NCList.prototype.histogram = function (from, to, numBins, callback) {\n        //calls callback with a histogram of the feature density\n        //in the given interval\n\n        var result = new Array(numBins);\n        var binWidth = (to - from) / numBins;\n        var start = this.start;\n        var end = this.end;\n        for (var i = 0; i < numBins; i++) {\n            result[i] = 0;\n        }this.iterate(from, to, function (feat) {\n            var firstBin = Math.max(0, (start(feat) - from) / binWidth | 0);\n            var lastBin = Math.min(numBins, (end(feat) - from) / binWidth | 0);\n            for (var bin = firstBin; bin <= lastBin; bin++) {\n                result[bin]++;\n            }\n        }, function () {\n            callback(result);\n        });\n    };\n\n    /*\n    \n    Copyright (c) 2007-2009 The Evolutionary Software Foundation\n    \n    Created by Mitchell Skinner <mitch_skinner@berkeley.edu>\n    \n    This package and its accompanying libraries are free software; you can\n    redistribute it and/or modify it under the terms of the LGPL (either\n    version 2.1, or at your option, any later version) or the Artistic\n    License 2.0.  Refer to LICENSE for the full license text.\n    \n    */\n    return NCList;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/NCList.js?");

/***/ }),

/***/ "./src/JBrowse/Store/NCList_v0.js":
/*!****************************************!*\
  !*** ./src/JBrowse/Store/NCList_v0.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Finisher */ \"./src/JBrowse/Finisher.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Finisher, Util) {\n\n    /**\n     * Legacy-compatible NCList for 1.2.1 backward compatibility.\n     * @lends JBrowse.Store.NCList_v0\n     * @constructs\n     */\n    function NCList_v0() {}\n\n    NCList_v0.prototype.importExisting = function (nclist, sublistIndex, lazyIndex, baseURL, lazyUrlTemplate) {\n        this.topList = nclist;\n        this.sublistIndex = sublistIndex;\n        this.lazyIndex = lazyIndex;\n        this.baseURL = baseURL;\n        this.lazyUrlTemplate = lazyUrlTemplate;\n    };\n\n    NCList_v0.prototype.fill = function (intervals, sublistIndex) {\n        //intervals: array of arrays of [start, end, ...]\n        //sublistIndex: index into a [start, end] array for storing a sublist\n        //              array. this is so you can use those arrays for something\n        //              else, and keep the NCList_v0 bookkeeping from interfering.\n        //              That's hacky, but keeping a separate copy of the intervals\n        //              in the NCList_v0 seems like a waste (TODO: measure that waste).\n        //half-open?\n        this.sublistIndex = sublistIndex;\n        var myIntervals = intervals; //.concat();\n        //sort by OL\n        myIntervals.sort(function (a, b) {\n            if (a[0] != b[0]) return a[0] - b[0];else return b[1] - a[1];\n        });\n        var sublistStack = [];\n        var curList = [];\n        this.topList = curList;\n        curList.push(myIntervals[0]);\n        var curInterval, topSublist;\n        for (var i = 1, len = myIntervals.length; i < len; i++) {\n            curInterval = myIntervals[i];\n            //if this interval is contained in the previous interval,\n            if (curInterval[1] < myIntervals[i - 1][1]) {\n                //create a new sublist starting with this interval\n                sublistStack.push(curList);\n                curList = new Array(curInterval);\n                myIntervals[i - 1][sublistIndex] = curList;\n            } else {\n                //find the right sublist for this interval\n                while (true) {\n                    if (0 == sublistStack.length) {\n                        curList.push(curInterval);\n                        break;\n                    } else {\n                        topSublist = sublistStack[sublistStack.length - 1];\n                        if (topSublist[topSublist.length - 1][1] > curInterval[1]) {\n                            //curList is the first (deepest) sublist that\n                            //curInterval fits into\n                            curList.push(curInterval);\n                            break;\n                        } else {\n                            curList = sublistStack.pop();\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    NCList_v0.prototype.binarySearch = function (arr, item, itemIndex) {\n        var low = -1;\n        var high = arr.length;\n        var mid;\n\n        while (high - low > 1) {\n            mid = low + high >>> 1;\n            if (arr[mid][itemIndex] > item) high = mid;else low = mid;\n        }\n\n        //if we're iterating rightward, return the high index;\n        //if leftward, the low index\n        if (1 == itemIndex) return high;else return low;\n    };\n\n    NCList_v0.prototype.iterHelper = function (arr, from, to, fun, finish, inc, searchIndex, testIndex, path) {\n        var len = arr.length;\n        var i = this.binarySearch(arr, from, searchIndex);\n        while (i < len && i >= 0 && inc * arr[i][testIndex] < inc * to) {\n\n            if (\"object\" == _typeof(arr[i][this.lazyIndex])) {\n                var ncl = this;\n                // lazy node\n                if (arr[i][this.lazyIndex].state) {\n                    if (\"loading\" == arr[i][this.lazyIndex].state) {\n                        // node is currenly loading; finish this query once it\n                        // has been loaded\n                        finish.inc();\n                        arr[i][this.lazyIndex].callbacks.push(function (parentIndex) {\n                            return function (o) {\n                                ncl.iterHelper(o, from, to, fun, finish, inc, searchIndex, testIndex, path.concat(parentIndex));\n                                finish.dec();\n                            };\n                        }(i));\n                    } else if (\"loaded\" == arr[i][this.lazyIndex].state) {\n                        // just continue below\n                    } else {\n                        console.log(\"unknown lazy type: \" + arr[i]);\n                    }\n                } else {\n                    // no \"state\" property means this node hasn't been loaded,\n                    // start loading\n                    arr[i][this.lazyIndex].state = \"loading\";\n                    arr[i][this.lazyIndex].callbacks = [];\n                    finish.inc();\n                    dojo.xhrGet({\n                        url: Util.resolveUrl(this.baseURL, this.lazyUrlTemplate.replace(/\\{chunk\\}/g, arr[i][this.lazyIndex].chunk)),\n                        headers: {\n                            'X-Requested-With': null\n                        },\n                        handleAs: \"json\",\n                        load: function (lazyFeat, lazyObj, sublistIndex, parentIndex) {\n                            return function (o) {\n                                lazyObj.state = \"loaded\";\n                                lazyFeat[sublistIndex] = o;\n                                ncl.iterHelper(o, from, to, fun, finish, inc, searchIndex, testIndex, path.concat(parentIndex));\n                                for (var c = 0; c < lazyObj.callbacks.length; c++) {\n                                    lazyObj.callbacks[c](o);\n                                }finish.dec();\n                            };\n                        }(arr[i], arr[i][this.lazyIndex], this.sublistIndex, i),\n                        error: function error() {\n                            finish.dec();\n                        }\n                    });\n                }\n            } else {\n                fun(arr[i], path.concat(i));\n            }\n\n            if (arr[i][this.sublistIndex]) this.iterHelper(arr[i][this.sublistIndex], from, to, fun, finish, inc, searchIndex, testIndex, path.concat(i));\n            i += inc;\n        }\n    };\n\n    NCList_v0.prototype.iterate = function (from, to, fun, postFun) {\n        // calls the given function once for each of the\n        // intervals that overlap the given interval\n        //if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n        //inc: iterate leftward or rightward\n        var inc = from > to ? -1 : 1;\n        //searchIndex: search on start or end\n        var searchIndex = from > to ? 0 : 1;\n        //testIndex: test on start or end\n        var testIndex = from > to ? 1 : 0;\n        var finish = new Finisher(postFun);\n        this.iterHelper(this.topList, from, to, fun, finish, inc, searchIndex, testIndex, []);\n        finish.finish();\n    };\n\n    NCList_v0.prototype.histogram = function (from, to, numBins, callback) {\n        //calls callback with a histogram of the feature density\n        //in the given interval\n\n        var result = new Array(numBins);\n        var binWidth = (to - from) / numBins;\n        for (var i = 0; i < numBins; i++) {\n            result[i] = 0;\n        } //this.histHelper(this.topList, from, to, result, numBins, (to - from) / numBins);\n        this.iterate(from, to, function (feat) {\n            var firstBin = Math.max(0, (feat[0] - from) / binWidth | 0);\n            var lastBin = Math.min(numBins, (feat[1] - from) / binWidth | 0);\n            for (var bin = firstBin; bin <= lastBin; bin++) {\n                result[bin]++;\n            }\n        }, function () {\n            callback(result);\n        });\n    };\n\n    /*\n    \n    Copyright (c) 2007-2009 The Evolutionary Software Foundation\n    \n    Created by Mitchell Skinner <mitch_skinner@berkeley.edu>\n    \n    This package and its accompanying libraries are free software; you can\n    redistribute it and/or modify it under the terms of the LGPL (either\n    version 2.1, or at your option, any later version) or the Artistic\n    License 2.0.  Refer to LICENSE for the full license text.\n    \n    */\n\n    return NCList_v0;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/NCList_v0.js?");

/***/ }),

/***/ "./src/JBrowse/Store/Names/Hash.js":
/*!*****************************************!*\
  !*** ./src/JBrowse/Store/Names/Hash.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/store/util/QueryResults */ \"./node_modules/dojo/store/util/QueryResults.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store/Hash */ \"./src/JBrowse/Store/Hash.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, QueryResults, Util, HashStore, Location) {\n\n    return declare(HashStore, {\n\n        constructor: function constructor(args) {\n\n            this.tooManyMatchesMessage = args.tooManyMatchesMessage || '(too many matches to display)';\n\n            // generate stopPrefixes\n            var stopPrefixes = this.stopPrefixes = {};\n            // make our stopPrefixes an object as { prefix: true, ... }\n            // with all possible prefixes of our stop prefixes\n            if (args.stopPrefixes) {\n                var prefixesInput = typeof args.stopPrefixes == 'string' ? [args.stopPrefixes] : args.stopPrefixes;\n\n                dojo.forEach(prefixesInput, function (prefix) {\n                    while (prefix.length) {\n                        stopPrefixes[prefix] = true;\n                        prefix = prefix.substr(0, prefix.length - 1);\n                    }\n                });\n            }\n        },\n\n        _nameRecordToItem: function _nameRecordToItem(nameRecord) {\n            if (nameRecord.hitLimit) {\n                // it's a too-many-matches marker\n                return { name: this.tooManyMatchesMessage, hitLimit: true };\n            } else {\n                // it's an actual name record\n                var item = {};\n                if ((typeof nameRecord === 'undefined' ? 'undefined' : _typeof(nameRecord)) == 'object') {\n                    item.name = nameRecord[0];\n                    var trackConfig = this._findTrackConfig(((this.meta || {}).track_names || {})[nameRecord[1]]);\n                    item.location = new Location({\n                        ref: nameRecord[3],\n                        start: parseInt(nameRecord[4]),\n                        end: parseInt(nameRecord[5]),\n                        tracks: trackConfig ? [trackConfig] : null,\n                        objectName: nameRecord[0]\n                    });\n                } else {\n                    item.name = nameRecord;\n                }\n                return item;\n            }\n        },\n\n        // look in the browser's track configuration for the track with the given label\n        _findTrackConfig: function _findTrackConfig(trackLabel) {\n            if (!trackLabel) return null;\n\n            var track = null;\n            var i = array.some(this.browser.config.tracks, function (t) {\n                if (t.label == trackLabel) {\n                    track = t;\n                    return true;\n                }\n                return false;\n            });\n\n            return track;\n        },\n\n        _makeResults: function _makeResults(nameRecords) {\n            // convert the name records into dojo.store-compliant data\n            // items, sort them by name and location\n            var results = array.map(nameRecords, dojo.hitch(this, '_nameRecordToItem')).sort(function (a, b) {\n                return a.name.localeCompare(b.name) || a.location.localeCompare(b.location);\n            });\n\n            var last;\n            var hitLimit;\n\n            // aggregate them and make labels for them.  for names with\n            // multiple locations, make a multipleLocations member.\n            results = array.filter(results, function (i) {\n                if (i.hitLimit) {\n                    hitLimit = i;\n                    if (!hitLimit.label) hitLimit.label = hitLimit.name || 'too many matches';\n                    return false;\n                } else if (last && last.name == i.name) {\n                    last.label = last.name + ' <span class=\"multipleLocations\">multiple locations</span>';\n                    if (last.multipleLocations) {\n                        last.multipleLocations.push(i.location);\n                    } else {\n                        last.multipleLocations = [last.location, i.location];\n                        delete last.location;\n                    }\n                    return false;\n                }\n                last = i;\n                last.label = last.name + (last.location ? ' <span class=\"locString\">' + last.location + '</span>' : '');\n                return true;\n            });\n\n            if (hitLimit) results.push(hitLimit);\n\n            return QueryResults(results);\n        },\n\n        // case-insensitive, and supports prefix queries like 'foo*'\n        query: function query(_query, options) {\n            var _this = this;\n\n            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                var thisB, name, trailingStar;\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                // remove trailing asterisks from query.name\n                                thisB = _this;\n                                name = (_query.name || '').toString();\n\n                                // lowercase the name if the store is all-lowercase\n                                // wait for the ready signal to test for lower case keys\n\n                                _context.next = 4;\n                                return _this.ready;\n\n                            case 4:\n                                if (_this.meta.lowercase_keys) name = name.toLowerCase();\n\n                                trailingStar = /\\*$/;\n\n                                if (!trailingStar.test(name)) {\n                                    _context.next = 11;\n                                    break;\n                                }\n\n                                name = name.replace(trailingStar, '');\n                                return _context.abrupt('return', _this._getEntry(name).then(function (value) {\n                                    value = value || {};\n                                    return thisB._makeResults((value.exact || []).concat(value.prefix || []));\n                                }));\n\n                            case 11:\n                                return _context.abrupt('return', _this._getEntry(name).then(function (value) {\n                                    return thisB._makeResults((value || {}).exact || []);\n                                }));\n\n                            case 12:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, _this);\n            }))();\n        },\n\n\n        get: function get(id) {\n            // lowercase the id if the store is all-lowercase\n            if (this.meta.lowercase_keys) id = id.toLowerCase();\n\n            return this._getEntry(id).then(function (bucket) {\n                var nameRec = (bucket.exact || [])[0];\n                return nameRec ? this._nameRecordToItem(nameRec) : null;\n            });\n        },\n\n        _getEntry: function _getEntry(key) {\n            return this._getBucket(key).then(function (bucket) {\n                return bucket[key];\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/Names/Hash.js?");

/***/ }),

/***/ "./src/JBrowse/Store/Names/LazyTrieDojoData.js":
/*!*****************************************************!*\
  !*** ./src/JBrowse/Store/Names/LazyTrieDojoData.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * dojo.data.api.Read-compatible store object that reads data from an\n * encapsulated JBrowse/Store/LazyTrie.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Util, Location) {\n    return declare(null,\n    /**\n     * @lends JBrowse.Store.Autocomplete.prototype\n     */\n    {\n        /**\n         * @constructs\n         * @param args.namesTrie\n         * @param args.stopPrefixes\n         * @param args.resultLimit\n         * @param args.tooManyMatchesMessage\n         */\n        constructor: function constructor( /**Object*/args) {\n            if (!args.namesTrie) throw \"must provide a namesTrie argument\";\n\n            this.namesTrie = args.namesTrie;\n\n            this.resultLimit = args.resultLimit || 15;\n            this.tooManyMatchesMessage = args.tooManyMatchesMessage || '(too many matches to display)';\n\n            // generate stopPrefixes\n            var stopPrefixes = this.stopPrefixes = {};\n            // make our stopPrefixes an object as { prefix: true, ... }\n            // with all possible prefixes of our stop prefixes\n            if (args.stopPrefixes) {\n                var prefixesInput = typeof args.stopPrefixes == 'string' ? [args.stopPrefixes] : args.stopPrefixes;\n\n                dojo.forEach(prefixesInput, function (prefix) {\n                    while (prefix.length) {\n                        stopPrefixes[prefix] = true;\n                        prefix = prefix.substr(0, prefix.length - 1);\n                    }\n                });\n            }\n\n            // make a self-modifying method for extracting the that\n            // detects whether the name store is formatted with tools\n            // pre-1.4 or post-1.4.  for pre-1.4 formats, will just\n            // complete with the lower-case version of the name.  for\n            // post-1.4, use the original-case version that's stored in\n            // the name record.\n            this.nodeText = function (node) {\n                if (typeof node[1][0][0] == 'number') {\n                    // pre-1.4, for backcompat\n                    this.nodeText = function (node) {\n                        return node[0];\n                    };\n                } else {\n                    // post-1.4\n                    this.nodeText = function (node) {\n                        return node[1][0][0];\n                    };\n                }\n                return this.nodeText(node);\n            };\n        },\n\n        getFeatures: function getFeatures() {\n            return {\n                'dojo.data.api.Read': true,\n                'dojo.data.api.Identity': true\n            };\n        },\n\n        // dojo.data.api.Read support\n\n        fetch: function fetch( /**Object*/request) {\n            var start = request.start || 0;\n            var matchLimit = Math.min(this.resultLimit, Math.max(0, request.count || Infinity));\n            var matchesRemaining = matchLimit;\n            var scope = request.scope || dojo.global;\n            var aborted = false;\n\n            // wrap our abort function to set a flag\n            request.abort = function () {\n                var oldabort = request.abort || function () {};\n                return function () {\n                    aborted = true;\n                    oldabort.call(scope, request);\n                };\n            }.call(this);\n\n            if (!request.store) request.store = this;\n\n            if (request.onBegin) request.onBegin.call(scope, 0, request);\n\n            var prefix = (request.query.name || '').toString().replace(/\\*$/, '');\n\n            if (!this.stopPrefixes[prefix]) {\n                this.namesTrie.mappingsFromPrefix(prefix, dojo.hitch(this, function (tree) {\n                    var matches = [];\n\n                    if (aborted) return;\n\n                    // are we working with a post-JBrowse 1.4 data structure?\n                    var post1_4 = tree[0] && tree[0][1] && tree[0][1][0] && typeof tree[0][1][0][0] == 'string';\n\n                    // use dojo.some so that we can break out of the loop when we hit the limit\n                    dojo.some(tree, function (node) {\n                        if (matchesRemaining--) {\n                            var name = this.nodeText(node);\n                            array.forEach(node[1], function (n) {\n                                var location = new Location({\n                                    ref: n[post1_4 ? 3 : 2],\n                                    start: parseInt(n[post1_4 ? 4 : 3]),\n                                    end: parseInt(n[post1_4 ? 5 : 4]),\n                                    tracks: [this.namesTrie.extra[n[post1_4 ? 1 : 0]]],\n                                    objectName: name\n                                });\n\n                                matches.push({\n                                    name: name,\n                                    location: location\n                                });\n                            }, this);\n                        }\n                        return matchesRemaining < 0;\n                    }, this);\n\n                    // if we found more than the match limit\n                    if (matchesRemaining < 0) matches.push({ name: this.tooManyMatchesMessage, hitLimit: true });\n\n                    if (request.sort) matches.sort(dojo.data.util.sorter.createSortFunction(request.sort, this));\n                    if (!aborted && request.onItem) dojo.forEach(matches, function (item) {\n                        if (!aborted) request.onItem.call(scope, item, request);\n                    });\n                    if (!aborted && request.onComplete) request.onComplete.call(scope, matches, request);\n                }));\n            } else if (request.onComplete) {\n                request.onComplete.call(scope, [], request);\n            }\n\n            return request;\n        },\n\n        getValue: function getValue(i, attr, defaultValue) {\n            var v = i[attr];\n            return typeof v == 'undefined' ? defaultValue : v;\n        },\n        getValues: function getValues(i, attr) {\n            var a = [i[attr]];\n            return typeof a[0] == 'undefined' ? [] : a;\n        },\n\n        getAttributes: function getAttributes(item) {\n            return Util.dojof.keys(item);\n        },\n\n        hasAttribute: function hasAttribute(item, attr) {\n            return item.hasOwnProperty(attr);\n        },\n\n        containsValue: function containsValue(item, attribute, value) {\n            return item[attribute] == value;\n        },\n\n        isItem: function isItem(item) {\n            return (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object' && typeof item.label == 'string';\n        },\n\n        isItemLoaded: function isItemLoaded() {\n            return true;\n        },\n\n        loadItem: function loadItem(args) {},\n\n        close: function close() {},\n\n        getLabel: function getLabel(i) {\n            return this.getValue(i, 'name', undefined);\n        },\n        getLabelAttributes: function getLabelAttributes(i) {\n            return ['name'];\n        },\n\n        getIdentity: function getIdentity(i) {\n            return this.getLabel(i);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/Names/LazyTrieDojoData.js?");

/***/ }),

/***/ "./src/JBrowse/Store/Names/REST.js":
/*!*****************************************!*\
  !*** ./src/JBrowse/Store/Names/REST.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/store/util/QueryResults */ \"./node_modules/dojo/store/util/QueryResults.js\"), __webpack_require__(/*! dojo/request/xhr */ \"./node_modules/dojo/request/xhr.js\"), __webpack_require__(/*! dojo/io-query */ \"./node_modules/dojo/io-query.js\"), __webpack_require__(/*! JBrowse/Store/Hash */ \"./src/JBrowse/Store/Hash.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, QueryResults, xhr, ioQuery, HashStore) {\n\n    return declare(null, {\n        constructor: function constructor(args) {\n            this.url = args.url;\n        },\n\n        query: function query(_query, options) {\n            var thisB = this;\n\n            var op = 'equals';\n            var name = '' + _query.name;\n            if (/\\*$/.test(name)) {\n                name = name.replace(/\\*$/, '');\n                op = 'startswith';\n            }\n            var myquery = {};\n            myquery[op] = name;\n\n            return xhr(thisB.url + \"?\" + ioQuery.objectToQuery(myquery), { handleAs: \"json\" }).then(function (data) {\n                for (var i = 0; i < data.length; i++) {\n                    var dat = data[i];\n                    dat.label = dat.name + (dat.location ? '<span class=\"locString\">' + dat.location.ref + \":\" + dat.location.start + \"..\" + dat.location.end + \" (\" + dat.name + \")\" + \"</span>\" : \"\");\n                }\n                return QueryResults(data);\n            }, function (err) {\n                // Handle the error condition\n                return QueryResults([]);\n            });\n        },\n\n        get: function get(id) {\n            return this.query(id, undefined);\n        },\n\n        getIdentity: function getIdentity(object) {\n            return object.id;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/Names/REST.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BAM.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BAM.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LRU = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n\nvar _cjsRequire = __webpack_require__(/*! @gmod/bam */ \"./node_modules/@gmod/bam/dist/index.js\"),\n    BamFile = _cjsRequire.BamFile;\n\nvar bamIndexedFilesCache = new LRU({ maxSize: 5 });\n\nvar BlobFilehandleWrapper = __webpack_require__(/*! ../../Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\");\n\nvar BamSlightlyLazyFeature = function () {\n    _createClass(BamSlightlyLazyFeature, [{\n        key: '_get_id',\n        value: function _get_id() {\n            this.record.id();\n        }\n    }, {\n        key: '_get_type',\n        value: function _get_type() {\n            return 'match';\n        }\n    }, {\n        key: '_get_score',\n        value: function _get_score() {\n            return this.record.get('mq');\n        }\n    }, {\n        key: '_get_mapping_quality',\n        value: function _get_mapping_quality() {\n            return this.record.mappingQuality;\n        }\n    }, {\n        key: '_get_flags',\n        value: function _get_flags() {\n            return '0x' + this.record.flags.toString(16);\n        }\n    }, {\n        key: '_get_strand',\n        value: function _get_strand() {\n            return this.record.isReverseComplemented() ? -1 : 1;\n        }\n    }, {\n        key: '_get_read_group_id',\n        value: function _get_read_group_id() {\n            return this.record.readGroupId;\n        }\n    }, {\n        key: '_get_seq_id',\n        value: function _get_seq_id() {\n            return this._store._refIdToName(this.record._refID);\n        }\n    }, {\n        key: '_get_qc_failed',\n        value: function _get_qc_failed() {\n            return this.record.isFailedQc();\n        }\n    }, {\n        key: '_get_duplicate',\n        value: function _get_duplicate() {\n            return this.record.isDuplicate();\n        }\n    }, {\n        key: '_get_secondary_alignment',\n        value: function _get_secondary_alignment() {\n            return this.record.isSecondary();\n        }\n    }, {\n        key: '_get_supplementary_alignment',\n        value: function _get_supplementary_alignment() {\n            return this.record.isSupplementary();\n        }\n    }, {\n        key: '_get_multi_segment_template',\n        value: function _get_multi_segment_template() {\n            return this.record.isPaired();\n        }\n    }, {\n        key: '_get_multi_segment_all_correctly_aligned',\n        value: function _get_multi_segment_all_correctly_aligned() {\n            return this.record.isProperlyPaired();\n        }\n    }, {\n        key: '_get_multi_segment_all_aligned',\n        value: function _get_multi_segment_all_aligned() {\n            return this.record.isProperlyPaired();\n        }\n    }, {\n        key: '_get_multi_segment_next_segment_unmapped',\n        value: function _get_multi_segment_next_segment_unmapped() {\n            return this.record.isMateUnmapped();\n        }\n    }, {\n        key: '_get_multi_segment_first',\n        value: function _get_multi_segment_first() {\n            return this.record.isRead1();\n        }\n    }, {\n        key: '_get_multi_segment_last',\n        value: function _get_multi_segment_last() {\n            return this.record.isRead2();\n        }\n    }, {\n        key: '_get_multi_segment_next_segment_reversed',\n        value: function _get_multi_segment_next_segment_reversed() {\n            return this.record.isMateReverseComplemented();\n        }\n    }, {\n        key: '_get_pair_orientation',\n        value: function _get_pair_orientation() {\n            return this.record.getPairOrientation();\n        }\n    }, {\n        key: '_get_unmapped',\n        value: function _get_unmapped() {\n            return this.record.isSegmentUnmapped();\n        }\n    }, {\n        key: '_get_next_seq_id',\n        value: function _get_next_seq_id() {\n            return this.record.isPaired() ? this._store._refIdToName(this.record._next_refid()) : undefined;\n        }\n    }, {\n        key: '_get_is_paired',\n        value: function _get_is_paired() {\n            return this.record.isPaired();\n        }\n    }, {\n        key: '_get_next_pos',\n        value: function _get_next_pos() {\n            return this.record.isPaired() ? this.record._next_pos() : undefined;\n        }\n    }, {\n        key: '_get_next_segment_position',\n        value: function _get_next_segment_position() {\n            return this.record.isPaired() ? this._store._refIdToName(this.record._next_refid()) + ':' + (this.record._next_pos() + 1) : undefined;\n        }\n    }, {\n        key: '_get_tags',\n        value: function _get_tags() {\n            return this.record._tags();\n        }\n    }, {\n        key: '_get_seq',\n        value: function _get_seq() {\n            return this.record.getReadBases();\n        }\n    }]);\n\n    function BamSlightlyLazyFeature(record, store) {\n        _classCallCheck(this, BamSlightlyLazyFeature);\n\n        this.record = record;\n        this._store = store;\n    }\n\n    _createClass(BamSlightlyLazyFeature, [{\n        key: 'tags',\n        value: function tags() {\n            return this._get_tags();\n        }\n    }, {\n        key: 'id',\n        value: function id() {\n            return this.record.id();\n        }\n    }, {\n        key: '_get',\n        value: function _get(field) {\n            var methodName = '_get_' + field;\n            if (this[methodName]) return this[methodName]();else return this.record.get(field);\n        }\n    }, {\n        key: 'get',\n        value: function get(field) {\n            var methodName = '_get_' + field.toLowerCase();\n            if (this[methodName]) return this[methodName]();else return this.record.get(field);\n        }\n    }, {\n        key: 'parent',\n        value: function parent() {}\n    }, {\n        key: 'children',\n        value: function children() {}\n    }, {\n        key: 'pairedFeature',\n        value: function pairedFeature() {\n            return false;\n        }\n    }]);\n\n    return BamSlightlyLazyFeature;\n}();\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_PairCache */ \"./src/JBrowse/Store/SeqFeature/_PairCache.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_SpanCache */ \"./src/JBrowse/Store/SeqFeature/_SpanCache.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_InsertSizeCache */ \"./src/JBrowse/Store/SeqFeature/_InsertSizeCache.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, Errors, SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin, PairCache, SpanCache, InsertSizeCache, XHRBlob, SimpleFeature) {\n\n    return declare([SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin], {\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var dataBlob = void 0;\n            if (args.bam) dataBlob = new BlobFilehandleWrapper(args.bam);else if (args.urlTemplate) dataBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.bam'), { expectRanges: true }));else throw new Error('must provide either `bam` or `urlTemplate`');\n\n            var baiBlob = void 0,\n                csiBlob = void 0;\n            if (args.bai) baiBlob = new BlobFilehandleWrapper(args.bai);else if (args.csi) csiBlob = new BlobFilehandleWrapper(args.csi);else if (args.baiUrlTemplate) baiBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.baiUrlTemplate)));else if (args.csiUrlTemplate) csiBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.csiUrlTemplate)));else if (args.urlTemplate) baiBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate + '.bai')));else throw new Error('no index provided, must provide a BAI or CSI index');\n\n            this.source = dataBlob.toString();\n\n            // LRU-cache the BAM object so we don't have to re-download the\n            // index when we switch chromosomes\n            var cacheKey = 'data: ' + dataBlob + ', index: ' + (csiBlob || baiBlob);\n            this.bam = bamIndexedFilesCache.get(cacheKey);\n            if (!this.bam) {\n                this.bam = new BamFile({\n                    bamFilehandle: dataBlob,\n                    baiFilehandle: baiBlob,\n                    csiFilehandle: csiBlob,\n                    renameRefSeqs: function renameRefSeqs(n) {\n                        return _this.browser.regularizeReferenceName(n);\n                    },\n                    fetchSizeLimit: args.fetchSizeLimit || 100000000,\n                    chunkSizeLimit: args.chunkSizeLimit || 20000000\n                });\n\n                bamIndexedFilesCache.set(cacheKey, this.bam);\n            }\n\n            // pre-download the index before running the statistics estimation so that the stats\n            // estimation doesn't time out\n            this.bam.hasRefSeq(0).then(function () {\n                return _this.bam.getHeader();\n            }).then(function (header) {\n                return _this._setSamHeader(header);\n            }).then(function (res) {\n                _this._deferred.features.resolve({ success: true });\n            }).then(function () {\n                return _this._estimateGlobalStats();\n            }).then(function (stats) {\n                _this.globalStats = stats;\n                _this._deferred.stats.resolve({ success: true });\n            }).catch(function (err) {\n                _this._deferred.features.reject(err);\n                _this._deferred.stats.reject(err);\n            });\n\n            this.insertSizeCache = new InsertSizeCache(args);\n            this.pairCache = new PairCache(args);\n            this.spanCache = new SpanCache(args);\n        },\n\n\n        // process the parsed SAM header from the bam file\n        _setSamHeader: function _setSamHeader(samHeader) {\n            this._samHeader = {};\n\n            // use the @SQ lines in the header to figure out the\n            // mapping between ref seq ID numbers and names\n            var refSeqIdToName = [];\n            var refSeqNameToId = {};\n            var sqLines = samHeader.filter(function (l) {\n                return l.tag === 'SQ';\n            });\n            sqLines.forEach(function (sqLine, seqId) {\n                sqLine.data.forEach(function (item) {\n                    if (item.tag === 'SN') {\n                        // this is the seq name\n                        var seqName = item.value;\n                        refSeqNameToId[seqName] = seqId;\n                        refSeqIdToName[seqId] = seqName;\n                    }\n                });\n            });\n            if (refSeqIdToName.length) {\n                this._samHeader.refSeqIdToName = refSeqIdToName;\n                this._samHeader.refSeqNameToId = refSeqNameToId;\n            }\n        },\n        _refNameToId: function _refNameToId(refName) {\n            // use info from the SAM header if possible, but fall back to using\n            // the ref seq order from when the browser's refseqs were loaded\n            if (this._samHeader.refSeqNameToId) return this._samHeader.refSeqNameToId[refName];else return this.browser.getRefSeqNumber(refName);\n        },\n        _refIdToName: function _refIdToName(refId) {\n            // use info from the SAM header if possible, but fall back to using\n            // the ref seq order from when the browser's refseqs were loaded\n            if (this._samHeader.refSeqIdToName) {\n                return this._samHeader.refSeqIdToName[refId];\n            } else {\n                var ref = this.browser.getRefSeqById(refId);\n                return ref ? ref.name : undefined;\n            }\n        },\n\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            var _this2 = this;\n\n            seqName = this.browser.regularizeReferenceName(seqName);\n\n            this._deferred.stats.then(function () {\n                return _this2.bam.hasRefSeq(_this2._refNameToId(seqName));\n            }).then(callback, errorCallback);\n        },\n\n\n        // called by getFeatures from the DeferredFeaturesMixin\n        _getFeatures: function _getFeatures(query, featCallback, endCallback, errorCallback) {\n            var _this3 = this;\n\n            var seqName = query.ref || this.refSeq.name;\n            seqName = this.browser.regularizeReferenceName(seqName);\n            var pairCache = {};\n            query.maxInsertSize = query.maxInsertSize || 50000;\n\n            this.bam.getRecordsForRange(seqName, query.start, query.end, { viewAsPairs: query.viewAsPairs, viewAsSpans: query.viewAsSpans, maxInsertSize: query.maxInsertSize }).then(function (records) {\n                if (query.viewAsPairs) {\n                    var recs = records.map(function (f) {\n                        return _this3._bamRecordToFeature(f);\n                    });\n                    recs.forEach(function (r) {\n                        return _this3.insertSizeCache.insertFeat(r);\n                    });\n                    _this3.pairCache.pairFeatures(query, recs, featCallback, endCallback, errorCallback);\n                } else if (query.viewAsSpans) {\n                    var _recs = records.map(function (f) {\n                        return _this3._bamRecordToFeature(f);\n                    });\n                    _recs.forEach(function (r) {\n                        return _this3.insertSizeCache.insertFeat(r);\n                    });\n                    _this3.spanCache.pairFeatures(query, _recs, featCallback, endCallback, errorCallback);\n                } else {\n                    for (var i = 0; i < records.length; i++) {\n                        _this3.insertSizeCache.insertFeat(records[i]);\n                        featCallback(_this3._bamRecordToFeature(records[i]));\n                    }\n                }\n                endCallback();\n            }).catch(errorCallback);\n        },\n        getInsertSizeStats: function getInsertSizeStats() {\n            return this.insertSizeCache.getInsertSizeStats();\n        },\n        cleanFeatureCache: function cleanFeatureCache(query) {\n            this.pairCache.cleanFeatureCache(query);\n            this.spanCache.cleanFeatureCache(query);\n        },\n        cleanStatsCache: function cleanStatsCache() {\n            this.insertSizeCache.cleanStatsCache();\n        },\n        _bamRecordToFeature: function _bamRecordToFeature(record) {\n            return new BamSlightlyLazyFeature(record, this);\n        },\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.bam.url,\n                baiUrlTemplate: (this.config.bai || {}).url,\n                csiUrlTemplate: (this.config.csi || {}).url\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BAM.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BAMCombination.js":
/*!********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BAMCombination.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/CombinationBase */ \"./src/JBrowse/Store/SeqFeature/CombinationBase.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, CombinationBaseStore) {\n\n    return declare([CombinationBaseStore], {\n\n        // An implementation of the CombinationBaseStore which works with BAM features.  Currently, the only supported option is\n        // a straight concatenation of the features of two stores.\n\n        // This combination store doesn't need to convert between spans and features, so these two functions are essentially irrelevant.\n        createFeatures: function createFeatures(spans) {\n            return spans;\n        },\n\n        toSpan: function toSpan(features, query) {\n            return features.map(function (feat) {\n                return Object.assign(Object.create(feat), feat);\n            });\n        },\n\n        // Only one supported operation - array concatenation\n        opSpan: function opSpan(op, span1, span2, query) {\n\n            if (op == \"U\") {\n                this._appendStringToID(span1, \"L\");\n                this._appendStringToID(span2, \"R\");\n                return span1.concat(span2);\n            }\n            console.error(\"invalid operation\");\n            return undefined;\n        },\n\n        _appendStringToID: function _appendStringToID(objArray, string) {\n            array.forEach(objArray, function (object) {\n                var oldID = object.id;\n                if (typeof oldID == 'function') {\n                    object.id = function () {\n                        return oldID.call(object) + string;\n                    };\n                } else {\n                    object.id = oldID + string;\n                }\n            });\n            return objArray;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BAMCombination.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BED.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BED.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/RegionStatsMixin */ \"./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! ./BED/Parser */ \"./src/JBrowse/Store/SeqFeature/BED/Parser.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, Deferred, SimpleFeature, SeqFeatureStore, DeferredFeatures, DeferredStats, GlobalStatsEstimationMixin, RegionStatsMixin, XHRBlob, Parser) {\n\n    return declare([SeqFeatureStore, DeferredFeatures, DeferredStats, GlobalStatsEstimationMixin, RegionStatsMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.BED\n     */\n    {\n        constructor: function constructor(args) {\n            this.data = args.blob || new XHRBlob(this.resolveUrl(this._evalConf(args.urlTemplate)));\n            this.features = [];\n            this._loadFeatures();\n        },\n\n        _loadFeatures: function _loadFeatures() {\n            var thisB = this;\n            var features = this.bareFeatures = [];\n\n            var featuresSorted = true;\n            var seenRefs = this.refSeqs = {};\n            var parser = new Parser({\n                featureCallback: function featureCallback(fs) {\n                    array.forEach(fs, function (feature) {\n                        var prevFeature = features[features.length - 1];\n                        var regRefName = thisB.browser.regularizeReferenceName(feature.seq_id);\n                        if (regRefName in seenRefs && prevFeature && prevFeature.seq_id != feature.seq_id) featuresSorted = false;\n                        if (prevFeature && prevFeature.seq_id == feature.seq_id && feature.start < prevFeature.start) featuresSorted = false;\n\n                        if (!(regRefName in seenRefs)) seenRefs[regRefName] = features.length;\n\n                        if (thisB.config.featureCallback) {\n                            features.push(thisB.config.featureCallback(feature, thisB));\n                        } else {\n                            features.push(feature);\n                        }\n                    });\n                },\n                endCallback: function endCallback() {\n                    if (!featuresSorted) {\n                        features.sort(thisB._compareFeatureData);\n                        // need to rebuild the refseq index if changing the sort order\n                        thisB._rebuildRefSeqs(features);\n                    }\n\n                    thisB._estimateGlobalStats().then(function (stats) {\n                        thisB.globalStats = stats;\n                        thisB._deferred.stats.resolve();\n                    });\n\n                    thisB._deferred.features.resolve(features);\n                },\n                commentCallback: this.config.commentCallback || function (i) {},\n                store: this\n            });\n\n            var fail = lang.hitch(this, '_failAllDeferred');\n            // parse the whole file and store it\n            this.data.fetchLines(function (line) {\n                try {\n                    parser.addLine(line);\n                } catch (e) {\n                    fail('Error parsing BED.');\n                    throw e;\n                }\n            }, lang.hitch(parser, 'finish'), fail);\n        },\n\n        _rebuildRefSeqs: function _rebuildRefSeqs(features) {\n            var refs = {};\n            for (var i = 0; i < features.length; i++) {\n                var regRefName = this.browser.regularizeReferenceName(features[i].seq_id);\n\n                if (!(regRefName in refs)) refs[regRefName] = i;\n            }\n            this.refSeqs = refs;\n        },\n\n        _compareFeatureData: function _compareFeatureData(a, b) {\n            if (a.seq_id < b.seq_id) return -1;else if (a.seq_id > b.seq_id) return 1;\n\n            return a.start - b.start;\n        },\n\n        _getFeatures: function _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n            var thisB = this;\n            thisB._deferred.features.then(function () {\n                thisB._search(query, featureCallback, finishedCallback, errorCallback);\n            });\n        },\n\n        _search: function _search(query, featureCallback, finishCallback, errorCallback) {\n            // search in this.features, which are sorted\n            // by ref and start coordinate, to find the beginning of the\n            // relevant range\n            var bare = this.bareFeatures;\n            var converted = this.features;\n\n            var refName = this.browser.regularizeReferenceName(query.ref);\n\n            var i = this.refSeqs[refName];\n            if (!(i >= 0)) {\n                finishCallback();\n                return;\n            }\n\n            var checkEnd = 'start' in query ? function (f) {\n                return f.get('end') >= query.start;\n            } : function () {\n                return true;\n            };\n\n            for (; i < bare.length; i++) {\n                // lazily convert the bare feature data to JBrowse features\n                var f = converted[i] || (converted[i] = function (b, i) {\n                    bare[i] = false;\n                    return this._formatFeature(b, i);\n                }.call(this, bare[i], i));\n                // features are sorted by ref seq and start coord, so we\n                // can stop if we are past the ref seq or the end of the\n                // query region\n                if (f._reg_seq_id != refName || f.get('start') > query.end) break;\n\n                if (checkEnd(f)) {\n                    this.applyFeatureTransforms([f]).forEach(featureCallback);\n                }\n            }\n\n            finishCallback();\n        },\n\n        supportsFeatureTransforms: true,\n\n        _formatFeature: function _formatFeature(data, i) {\n            var f = new SimpleFeature({\n                data: data,\n                id: data.seq_id + \"_\" + data.start + \"_\" + data.end + \"_\" + data.name + \"_\" + i\n            });\n            f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id);\n            return f;\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.blob.url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BED.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BED/Parser.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BED/Parser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* The function to parse the bed files. The standard BED file format (BED-6) is \"chr\\tstart(0based)\\tEnd(1based)\\tname\\tscore\\tstrand\n\nBED-3 is the minimal parsed line by this parser (i.e. includes only first three fields)\nOptional header lines start with '#'\n*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Util/TextIterator */ \"./src/JBrowse/Util/TextIterator.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, TextIterator) {\n\n    var bed_feature_names = 'seq_id start end name score strand'.split(\" \");\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            lang.mixin(this, {\n                featureCallback: args.featureCallback || function () {},\n                endCallback: args.endCallback || function () {},\n                commentCallback: args.commentCallback || function () {},\n                errorCallback: args.errorCallback || function (e) {\n                    console.error(e);\n                },\n                store: args.store,\n                // if this is true, the parser ignores the\n                // rest of the lines in the file.  currently\n                // set when the file switches over to FASTA\n                eof: false\n            });\n        },\n\n        /**\n         * Parse the bytes that contain the BED header, storing the parsed\n         * data in this.header.\n         */\n        parseHeader: function parseHeader(headerBytes) {\n\n            // parse the header lines\n            var headData = {};\n            var lineIterator = new TextIterator.FromBytes({ bytes: headerBytes });\n            var line;\n            while (line = lineIterator.getline()) {\n\n                // only interested in meta and header lines\n                if (line[0] != '#') continue;\n\n                // parse meta line using the parseHeader configuration callback function\n                var metaData = (this.config.parseHeader || function () {})(line);\n                var key = metaData.key;\n                headData[key] = metaData.value;\n            }\n\n            this.header = headData;\n            return headData;\n        },\n        finish: function finish() {\n            this.endCallback();\n        },\n        addLine: function addLine(line) {\n            var match;\n            if (this.eof) {\n                // do nothing\n            } else if (/^\\s*[^#\\s>]/.test(line)) {\n                //< feature line, most common case\n                line = line.replace(/\\r?\\n?$/g, '');\n                var f = this.parse_feature(line);\n                this.featureCallback(this._return_item([f]));\n            }\n            // directive or comment\n            else if (match = /^\\s*(\\#+)(.*)/.exec(line)) {\n                    var hashsigns = match[1],\n                        contents = match[2];\n                    contents = contents.replace(/\\s*/, '');\n                    this._return_item({ comment: contents });\n                } else if (/^\\s*$/.test(line)) {\n                    // blank line, do nothing\n                } else if (/^\\s*>/.test(line)) {\n                    // implicit beginning of a FASTA section.  just stop\n                    // parsing, since we don't currently handle sequences\n                    this._return_all_under_construction_features();\n                    this.eof = true;\n                } else {\n                    // it's a parse error\n                    line = line.replace(/\\r?\\n?$/g, '');\n                    throw \"GFF3 parse error.  Cannot parse '\" + line + \"'.\";\n                }\n        },\n\n        unescape: function unescape(s) {\n            if (s === null) return null;\n\n            return s.replace(/%([0-9A-Fa-f]{2})/g, function (match, seq) {\n                return String.fromCharCode(parseInt(seq, 16));\n            });\n        },\n\n\n        parse_feature: function parse_feature(line) {\n            var f = array.map(line.split(\"\\t\"), function (a) {\n                if (a == '.') {\n                    return null;\n                }\n                return a;\n            });\n\n            // unescape only the ref and source columns\n            f[0] = this.unescape(f[0]);\n\n            var parsed = {};\n            for (var i = 0; i < bed_feature_names.length; i++) {\n                if (f[i]) {\n                    parsed[bed_feature_names[i]] = f[i] == '.' ? null : f[i];\n                }\n            }\n            if (parsed.start !== null) parsed.start = parseInt(parsed.start, 10);\n            if (parsed.end !== null) parsed.end = parseInt(parsed.end, 10);\n            if (parsed.score != null) parsed.score = parseFloat(parsed.score, 10);\n\n            parsed.strand = { '+': 1, '-': -1 }[parsed.strand] || 0;\n\n            return parsed;\n        },\n\n        _return_item: function _return_item(i) {\n            if (i[0]) this.featureCallback(i);else if (i.comment) this.commentCallback(i, this.store);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BED/Parser.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BEDTabix.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BEDTabix.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _cjsRequire = __webpack_require__(/*! @gmod/tabix */ \"./node_modules/@gmod/tabix/dist/index.js\"),\n    TabixIndexedFile = _cjsRequire.TabixIndexedFile;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/RegionStatsMixin */ \"./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js\"), __webpack_require__(/*! JBrowse/Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! ./BED/Parser */ \"./src/JBrowse/Store/SeqFeature/BED/Parser.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Errors, SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin, RegionStatsMixin, BlobFilehandleWrapper, XHRBlob, SimpleFeature, Parser) {\n\n    return declare([SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin, RegionStatsMixin], {\n\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var thisB = this;\n            var csiBlob, tbiBlob;\n\n            if (args.csi || this.config.csiUrlTemplate) {\n                csiBlob = args.csi || new XHRBlob(this.resolveUrl(this.getConf('csiUrlTemplate', [])));\n            } else {\n                tbiBlob = args.tbi || new XHRBlob(this.resolveUrl(this.getConf('tbiUrlTemplate', []) || this.getConf('urlTemplate', []) + '.tbi'));\n            }\n\n            var fileBlob = args.file || new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), { expectRanges: true });\n\n            this.indexedData = new TabixIndexedFile({\n                filehandle: new BlobFilehandleWrapper(fileBlob),\n                tbiFilehandle: tbiBlob && new BlobFilehandleWrapper(tbiBlob),\n                csiFilehandle: csiBlob && new BlobFilehandleWrapper(csiBlob),\n                chunkSizeLimit: args.chunkSizeLimit || 1000000,\n                renameRefSeqs: function renameRefSeqs(n) {\n                    return _this.browser.regularizeReferenceName(n);\n                }\n            });\n\n            this.parser = new Parser({\n                commentCallback: this.config.commentCallback || function (i) {},\n                store: this\n            });\n\n            this.getHeader().then(function (header) {\n                thisB._deferred.features.resolve({ success: true });\n                thisB._estimateGlobalStats().then(function (stats) {\n                    thisB.globalStats = stats;\n                    thisB._deferred.stats.resolve(stats);\n                }, lang.hitch(thisB, '_failAllDeferred'));\n            }, lang.hitch(thisB, '_failAllDeferred'));\n        },\n\n        /**fetch and parse the Header line */\n        getHeader: function getHeader() {\n            var _this2 = this;\n\n            if (!this._parsedHeader) {\n                this._parsedHeader = this.indexedData.lineCount('nonexistent').then(function () {\n                    return _this2.indexedData.getHeader();\n                }).then(function (bytes) {\n                    return _this2.parser.parseHeader(bytes);\n                });\n            }\n            return this._parsedHeader;\n        },\n\n        _getFeatures: function _getFeatures(query, featureCallback, finishCallback, errorCallback) {\n            var _this3 = this;\n\n            this.getHeader().then(function () {\n                _this3.indexedData.getMetadata().then(function (metadata) {\n                    var regularizedReferenceName = _this3.browser.regularizeReferenceName(query.ref);\n                    return _this3.indexedData.getLines(regularizedReferenceName || _this3.refSeq.name, query.start, query.end, function (line) {\n                        _this3.applyFeatureTransforms([_this3.lineToFeature(metadata.columnNumbers, line)]).forEach(function (f) {\n                            if (_this3.config.featureCallback) f = _this3.config.featureCallback(f);\n                            featureCallback(f);\n                        });\n                    });\n                }).then(finishCallback, function (error) {\n                    if (errorCallback) {\n                        if (error.message && error.message.indexOf('Too much data') >= 0) {\n                            error = new Errors.DataOverflow(error.message);\n                        }\n                        errorCallback(error);\n                    } else console.error(error);\n                });\n            }, errorCallback);\n        },\n\n        supportsFeatureTransforms: true,\n\n        _featureData: function _featureData(data) {\n            var f = lang.mixin({}, data);\n            for (var a in data.matrix) {\n                f[a.toLowerCase()] = data.attributes[a].join(',');\n            }\n\n            return f;\n        },\n        _formatFeature: function _formatFeature(data) {\n            var f = new SimpleFeature({\n                data: this._featureData(data),\n                id: data.seq_id + \"_\" + data.start + \"_\" + data.end + \"_\" + data.name\n            });\n            f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id);\n            return f;\n        },\n        //read the line\n        lineToFeature: function lineToFeature(columnNumbers, line) {\n            var fields = line.split(\"\\t\");\n\n            for (var i = 0; i < fields.length; i++) {\n                if (fields[i] == '.') {\n                    fields[i] = null;\n                }\n            }\n\n            var featureData = {\n                start: parseInt(fields[columnNumbers.start - 1]),\n                end: parseInt(fields[columnNumbers.end - 1]),\n                seq_id: fields[columnNumbers.ref - 1],\n                name: fields[3],\n                score: fields[4] || null,\n                strand: { '+': 1, '-': -1 }[fields[5]] || 0,\n                thick_start: fields[6],\n                thick_end: fields[7],\n                itemrgb: fields[8],\n                block_count: fields[9],\n                block_sizes: fields[10],\n                chrom_starts: fields[11]\n            };\n\n            var f = new SimpleFeature({\n                id: fields.slice(0, 5).join('/'),\n                data: featureData,\n                fields: fields\n            });\n\n            return f;\n        },\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            return this.indexedData.index.hasRefSeq(seqName, callback, errorCallback);\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.file.url,\n                tbiUrlTemplate: (this.config.tbi || {}).url,\n                csiUrlTemplate: (this.config.csi || {}).url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BEDTabix.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BgzipIndexedFasta.js":
/*!***********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BgzipIndexedFasta.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var LRU = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n\nvar _cjsRequire = __webpack_require__(/*! @gmod/indexedfasta */ \"./node_modules/@gmod/indexedfasta/dist/index.js\"),\n    BgzipIndexedFasta = _cjsRequire.BgzipIndexedFasta;\n\nvar _cjsRequire2 = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _cjsRequire2.Buffer;\n\nvar fastaIndexedFilesCache = new LRU({ maxSize: 5 });\n\nvar BlobFilehandleWrapper = __webpack_require__(/*! ../../Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/IndexedFasta */ \"./src/JBrowse/Store/SeqFeature/IndexedFasta.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, XHRBlob, IndexedFasta) {\n\n    return declare(IndexedFasta, {\n\n        /**\n         * Storage backend for sequences in indexed fasta files\n         * served as static text files.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var dataBlob = void 0;\n            if (args.bgzfa) dataBlob = new BlobFilehandleWrapper(args.bgzfa);else if (args.urlTemplate) dataBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate), { expectRanges: true }));else dataBlob = new BlobFilehandleWrapper(new XHRBlob('data.fa', { expectRanges: true }));\n\n            var indexBlob = void 0;\n            if (args.fai) indexBlob = new BlobFilehandleWrapper(args.fai);else if (args.faiUrlTemplate) indexBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.faiUrlTemplate)));else if (args.urlTemplate) indexBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate + '.fai')));else throw new Error('no index provided, must provide a FASTA index');\n\n            var gziBlob = void 0;\n            if (args.gzi) gziBlob = new BlobFilehandleWrapper(args.gzi);else if (args.gziUrlTemplate) gziBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.gziUrlTemplate)));else if (args.urlTemplate) gziBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate + '.gzi')));else throw new Error('no gzi index provided, must provide a GZI index');\n\n            this.source = dataBlob.toString();\n\n            // LRU-cache the CRAM object so we don't have to re-download the\n            // index when we switch chromosomes\n            var cacheKey = 'data: ' + dataBlob + ', index: ' + indexBlob + ', gzi: ' + gziBlob;\n            this.fasta = fastaIndexedFilesCache.get(cacheKey);\n            if (!this.fasta) {\n                this.fasta = new BgzipIndexedFasta({\n                    fasta: dataBlob,\n                    fai: indexBlob,\n                    gzi: gziBlob,\n                    chunkSizeLimit: args.chunkSizeLimit || 1000000\n                });\n\n                fastaIndexedFilesCache.set(cacheKey, this.fasta);\n            }\n            this.fasta.getSequenceList().then(function () {\n                return _this._deferred.features.resolve({ success: true });\n            }, function () {\n                return _this._failAllDeferred();\n            });\n        },\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: (this.config.file || this.config.blob).url,\n                faiUrlTemplate: this.config.fai.url,\n                gziUrlTemplate: this.config.gzi.url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BgzipIndexedFasta.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BigBed.js":
/*!************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BigBed.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! ./BigWig */ \"./src/JBrowse/Store/SeqFeature/BigWig.js\"), __webpack_require__(/*! ./BigWig/Window */ \"./src/JBrowse/Store/SeqFeature/BigWig/Window.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, BigWig, Window, SimpleFeature) {\n\n    var predefinedFeatureTransforms = {};\n\n    return declare(BigWig,\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.BigBed\n     */\n    {\n        constructor: function constructor(args) {},\n        _getFeatures: function _getFeatures(query, featureCallback, endCallback, errorCallback) {\n            var _this = this;\n\n            var chrName = this.browser.regularizeReferenceName(query.ref);\n            var view = this.getUnzoomedView();\n\n            if (!view) {\n                endCallback();\n                return;\n            }\n\n            view.readWigData(chrName, query.start, query.end, function (features) {\n                _this.applyFeatureTransforms(features || []).forEach(featureCallback);\n                endCallback();\n            }, errorCallback);\n        },\n\n\n        supportsFeatureTransforms: true,\n\n        getView: function getView() {\n            return this.getUnzoomedView();\n        },\n\n\n        getPredefinedFeatureTransform: function getPredefinedFeatureTransform(name) {\n            return predefinedFeatureTransforms[name] || this.inherited(getPredefinedFeatureTransform, arguments);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BigBed.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BigWig.js":
/*!************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BigWig.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/url */ \"./node_modules/dojo/_base/url.js\"), __webpack_require__(/*! JBrowse/Model/DataView */ \"./src/JBrowse/Model/DataView.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! ./BigWig/Window */ \"./src/JBrowse/Store/SeqFeature/BigWig/Window.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, urlObj, jDataView, has, JBrowseErrors, SeqFeatureStore, DeferredFeaturesMixin, DeferredStatsMixin, Window, Util, XHRBlob) {\n    return declare([SeqFeatureStore, DeferredFeaturesMixin, DeferredStatsMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.BigWig\n     */\n    {\n\n        BIG_WIG_MAGIC: -2003829722,\n        BIG_BED_MAGIC: -2021002517,\n\n        BIG_WIG_TYPE_GRAPH: 1,\n        BIG_WIG_TYPE_VSTEP: 2,\n        BIG_WIG_TYPE_FSTEP: 3,\n\n        _littleEndian: true,\n\n        /**\n         * Data backend for reading wiggle data from BigWig or BigBed files.\n         *\n         * Adapted by Robert Buels from bigwig.js in the Dalliance Genome\n         * Explorer which is copyright Thomas Down 2006-2010\n         * @constructs\n         */\n        constructor: function constructor(args) {\n\n            this.data = args.blob || new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.bigwig'), { expectRanges: true });\n\n            this.name = args.name || this.data.url && new urlObj(this.data.url).path.replace(/^.+\\//, '') || 'anonymous';\n\n            this._load();\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                chunkSizeLimit: 30000000 // 30mb\n            });\n        },\n\n        _getGlobalStats: function _getGlobalStats(successCallback, errorCallback) {\n            var s = this._globalStats || {};\n\n            // calc mean and standard deviation if necessary\n            if (!('scoreMean' in s)) s.scoreMean = s.basesCovered ? s.scoreSum / s.basesCovered : 0;\n            if (!('scoreStdDev' in s)) s.scoreStdDev = this._calcStdFromSums(s.scoreSum, s.scoreSumSquares, s.basesCovered);\n\n            successCallback(s);\n        },\n\n        /**\n         * Read from the bbi file, respecting the configured chunkSizeLimit.\n         */\n        _read: function _read(start, size, callback, errorcallback) {\n            if (size > this.config.chunkSizeLimit) errorcallback(new JBrowseErrors.DataOverflow('Too much data. Chunk size ' + Util.commifyNumber(size) + ' bytes exceeds chunkSizeLimit of ' + Util.commifyNumber(this.config.chunkSizeLimit) + '.'));else this.data.read.apply(this.data, arguments);\n        },\n\n        _load: function _load() {\n            var _this = this;\n\n            var headerLen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;\n\n            this._read(0, headerLen, function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(bytes) {\n                    var res, data, magic, zl, zlReduction, zlData, zlIndex;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                            switch (_context.prev = _context.next) {\n                                case 0:\n                                    _context.prev = 0;\n                                    _context.next = 3;\n                                    return _this.data.statPromise();\n\n                                case 3:\n                                    res = _context.sent;\n\n                                    if (bytes) {\n                                        _context.next = 7;\n                                        break;\n                                    }\n\n                                    _this._failAllDeferred('BBI header not readable');\n                                    return _context.abrupt('return');\n\n                                case 7:\n                                    data = _this.newDataView(bytes);\n\n                                    // check magic numbers\n\n                                    magic = data.getInt32();\n\n                                    if (!(magic != _this.BIG_WIG_MAGIC && magic != _this.BIG_BED_MAGIC)) {\n                                        _context.next = 16;\n                                        break;\n                                    }\n\n                                    // try the other endianness if no magic\n                                    _this._littleEndian = false;\n                                    data = _this.newDataView(bytes);\n\n                                    if (!(data.getInt32() != _this.BIG_WIG_MAGIC && magic != _this.BIG_BED_MAGIC)) {\n                                        _context.next = 16;\n                                        break;\n                                    }\n\n                                    console.error('Not a BigWig or BigBed file');\n                                    _this._failAllDeferred('Not a BigWig or BigBed file');\n                                    return _context.abrupt('return');\n\n                                case 16:\n                                    _this.type = magic == _this.BIG_BED_MAGIC ? 'bigbed' : 'bigwig';\n\n                                    _this.fileSize = (res || {}).size;\n                                    if (!_this.fileSize) console.warn(\"cannot get size of BigWig/BigBed file, widest zoom level not available\");\n\n                                    _this.version = data.getUint16();\n                                    _this.numZoomLevels = data.getUint16();\n                                    _this.chromTreeOffset = data.getUint64();\n                                    _this.unzoomedDataOffset = data.getUint64();\n                                    _this.unzoomedIndexOffset = data.getUint64();\n                                    _this.fieldCount = data.getUint16();\n                                    _this.definedFieldCount = data.getUint16();\n                                    _this.asOffset = data.getUint64();\n                                    _this.totalSummaryOffset = data.getUint64();\n                                    _this.uncompressBufSize = data.getUint32();\n\n                                    if (!(_this.asOffset > headerLen || _this.totalSummaryOffset > headerLen)) {\n                                        _context.next = 31;\n                                        break;\n                                    }\n\n                                    return _context.abrupt('return', _this._load(headerLen * 2));\n\n                                case 31:\n\n                                    // dlog('bigType: ' + this.type);\n                                    // dlog('chromTree at: ' + this.chromTreeOffset);\n                                    // dlog('uncompress: ' + this.uncompressBufSize);\n                                    // dlog('data at: ' + this.unzoomedDataOffset);\n                                    // dlog('index at: ' + this.unzoomedIndexOffset);\n                                    // dlog('field count: ' + this.fieldCount);\n                                    // dlog('defined count: ' + this.definedFieldCount);\n\n                                    _this.zoomLevels = [];\n                                    for (zl = 0; zl < _this.numZoomLevels; ++zl) {\n                                        zlReduction = data.getUint32(4 * (zl * 6 + 16));\n                                        zlData = data.getUint64(4 * (zl * 6 + 18));\n                                        zlIndex = data.getUint64(4 * (zl * 6 + 20));\n\n                                        //          dlog('zoom(' + zl + '): reduction=' + zlReduction + '; data=' + zlData + '; index=' + zlIndex);\n\n                                        _this.zoomLevels.push({ reductionLevel: zlReduction, dataOffset: zlData, indexOffset: zlIndex });\n                                    }\n\n                                    // parse the autoSql if present (bigbed)\n                                    if (_this.asOffset) {\n                                        (function () {\n                                            var d = this.newDataView(bytes, this.asOffset);\n                                            var string = \"\";\n                                            var c;\n                                            while ((c = d.getChar()) && c.charCodeAt() != 0) {\n                                                string += c;\n                                            }\n                                            this.parseAutoSql(string);\n                                        }).call(_this);\n                                    }\n\n                                    // parse the totalSummary if present (summary of all data in the file)\n                                    if (_this.totalSummaryOffset) {\n                                        (function () {\n                                            var d = this.newDataView(bytes, this.totalSummaryOffset);\n                                            var s = {\n                                                basesCovered: d.getUint64(),\n                                                scoreMin: d.getFloat64(),\n                                                scoreMax: d.getFloat64(),\n                                                scoreSum: d.getFloat64(),\n                                                scoreSumSquares: d.getFloat64()\n                                            };\n                                            this._globalStats = s;\n                                            // rest of stats will be calculated on demand in getGlobalStats\n                                        }).call(_this);\n                                    } else {\n                                        console.warn(\"BigWig \" + _this.data.url + \" has no total summary data.\");\n                                    }\n\n                                    _this._readChromTree(function () {\n                                        this._deferred.features.resolve({ success: true });\n                                        this._deferred.stats.resolve({ success: true });\n                                    }, lang.hitch(_this, '_failAllDeferred'));\n                                    _context.next = 41;\n                                    break;\n\n                                case 38:\n                                    _context.prev = 38;\n                                    _context.t0 = _context['catch'](0);\n\n                                    _this._failAllDeferred(_context.t0);\n\n                                case 41:\n                                case 'end':\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, _this, [[0, 38]]);\n                }));\n\n                return function (_x2) {\n                    return _ref.apply(this, arguments);\n                };\n            }(), lang.hitch(this, '_failAllDeferred'));\n        },\n\n        newDataView: function newDataView(bytes, offset, length) {\n            return new jDataView(bytes, offset, length, this._littleEndian);\n        },\n\n        /**\n         * @private\n         */\n        _readChromTree: function _readChromTree(callback, errorCallback) {\n            var thisB = this;\n            this.refsByNumber = {};\n            this.refsByName = {};\n\n            var udo = this.unzoomedDataOffset;\n            while (udo % 4 != 0) {\n                ++udo;\n            }\n\n            this._read(this.chromTreeOffset, udo - this.chromTreeOffset, function (bpt) {\n                if (!has('typed-arrays')) {\n                    thisB._failAllDeferred('Web browser does not support typed arrays');\n                    return;\n                }\n                var data = thisB.newDataView(bpt);\n\n                if (data.getUint32() !== 2026540177) throw \"parse error: not a Kent bPlusTree\";\n                var blockSize = data.getUint32();\n                var keySize = data.getUint32();\n                var valSize = data.getUint32();\n                var itemCount = data.getUint64();\n                var rootNodeOffset = 32;\n\n                //dlog('blockSize=' + blockSize + '    keySize=' + keySize + '   valSize=' + valSize + '    itemCount=' + itemCount);\n\n                var bptReadNode = function bptReadNode(offset) {\n                    if (offset >= bpt.length) throw \"reading beyond end of buffer\";\n                    var isLeafNode = data.getUint8(offset);\n                    var cnt = data.getUint16(offset + 2);\n                    //dlog('ReadNode: ' + offset + '     type=' + isLeafNode + '   count=' + cnt);\n                    offset += 4;\n                    for (var n = 0; n < cnt; ++n) {\n                        if (isLeafNode) {\n                            // parse leaf node\n                            var key = '';\n                            for (var ki = 0; ki < keySize; ++ki) {\n                                var charCode = data.getUint8(offset++);\n                                if (charCode != 0) {\n                                    key += String.fromCharCode(charCode);\n                                }\n                            }\n                            var refId = data.getUint32(offset);\n                            var refSize = data.getUint32(offset + 4);\n                            offset += 8;\n\n                            var refRec = { name: key, id: refId, length: refSize };\n\n                            //dlog(key + ':' + refId + ',' + refSize);\n                            thisB.refsByName[thisB.browser.regularizeReferenceName(key)] = refRec;\n                            thisB.refsByNumber[refId] = refRec;\n                        } else {\n                            // parse index node\n                            offset += keySize;\n                            var childOffset = data.getUint64(offset);\n                            offset += 8;\n                            childOffset -= thisB.chromTreeOffset;\n                            bptReadNode(childOffset);\n                        }\n                    }\n                };\n                bptReadNode(rootNodeOffset);\n\n                callback.call(thisB, thisB);\n            }, errorCallback);\n        },\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            var thisB = this;\n            seqName = thisB.browser.regularizeReferenceName(seqName);\n            this._deferred.features.then(function () {\n                callback(seqName in thisB.refsByName);\n            }, errorCallback);\n        },\n\n        _getFeatures: function _getFeatures(query, featureCallback, endCallback, errorCallback) {\n\n            var chrName = this.browser.regularizeReferenceName(query.ref);\n            var min = query.start;\n            var max = query.end;\n\n            var v = query.basesPerSpan ? this.getView(1 / query.basesPerSpan) : query.scale ? this.getView(query.scale) : this.getView(1);\n\n            if (!v) {\n                endCallback();\n                return;\n            }\n\n            v.readWigData(chrName, min, max, dojo.hitch(this, function (features) {\n                array.forEach(features || [], featureCallback);\n                endCallback();\n            }), errorCallback);\n        },\n\n        getUnzoomedView: function getUnzoomedView() {\n            if (!this.unzoomedView) {\n                var cirLen = 4000;\n                var nzl = this.zoomLevels[0];\n                if (nzl) {\n                    cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;\n                }\n                this.unzoomedView = new Window(this, this.unzoomedIndexOffset, cirLen, false, this.autoSql);\n            }\n            return this.unzoomedView;\n        },\n\n        getView: function getView(scale) {\n            if (!this.zoomLevels || !this.zoomLevels.length) return null;\n\n            if (!this._viewCache || this._viewCache.scale != scale) {\n                this._viewCache = {\n                    scale: scale,\n                    view: this._getView(scale)\n                };\n            }\n            return this._viewCache.view;\n        },\n\n        _getView: function _getView(scale) {\n            var basesPerPx = 1 / scale;\n            //console.log('getting view for '+basesPerSpan+' bases per span');\n            var maxLevel = this.zoomLevels.length;\n            if (!this.fileSize) // if we don't know the file size, we can't fetch the highest zoom level :-(\n                maxLevel--;\n            for (var i = maxLevel; i >= 0; i--) {\n                var zh = this.zoomLevels[i];\n                if (zh && zh.reductionLevel <= 2 * basesPerPx) {\n                    var indexLength = i < this.zoomLevels.length - 1 ? this.zoomLevels[i + 1].dataOffset - zh.indexOffset : this.fileSize - 4 - zh.indexOffset;\n                    //console.log( 'using zoom level '+i);\n                    return new Window(this, zh.indexOffset, indexLength, true);\n                }\n            }\n            //console.log( 'using unzoomed level');\n            return this.getUnzoomedView();\n        },\n\n        getTagMetadata: function getTagMetadata(tagName) {\n            if (this.autoSql) {\n                var lcTagName = tagName.replace(/_/g, '').toLowerCase();\n                var fieldDefinition = this.autoSql.fields.find(function (field) {\n                    return field.name.toLowerCase() === lcTagName;\n                });\n                if (fieldDefinition) return fieldDefinition;\n            }\n        },\n\n\n        parseAutoSql: function parseAutoSql(string) {\n            string = string.trim();\n            var res = string.split('\\n');\n            this.autoSql = {\n                name: /table\\s+(\\w+)/.exec(res[0])[1],\n                description: /\"(.*)\"/.exec(res[1])[1],\n                fields: []\n            };\n            var i = 3;\n            var field;\n            while (res[i].trim() != ')') {\n                if (field = /([\\w\\[\\]0-9]+)\\s*(\\w+)\\s*;\\s*\"(.*)\"/.exec(res[i].trim())) {\n                    this.autoSql.fields.push({\n                        type: field[1],\n                        name: field[2],\n                        description: field[3]\n                    });\n                } else {\n                    console.warn('autosql line not parsed', res[i]);\n                }\n                i++;\n            }\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.blob.url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BigWig.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BigWig/RequestWorker.js":
/*!**************************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BigWig/RequestWorker.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var snakeCase = __webpack_require__(/*! snake-case */ \"./node_modules/snake-case/snake-case.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Util/RejectableFastPromise */ \"./src/JBrowse/Util/RejectableFastPromise.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Model/Range */ \"./src/JBrowse/Model/Range.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! jszlib/inflate */ \"./node_modules/jszlib/inflate.js\"), __webpack_require__(/*! jszlib/arrayCopy */ \"./node_modules/jszlib/arrayCopy.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dlang, array, Util, RejectableFastPromise, all, Range, SimpleFeature, inflate, arrayCopy) {\n\n    var dlog = function dlog() {\n        console.log.apply(console, arguments);\n    };\n\n    var defaultAutoSql = {\n        name: 'BigBED file',\n        description: 'this file has no associated autoSQL',\n        fields: [{\n            type: 'string',\n            name: 'chrom',\n            description: 'Name of chromosome '\n        }, {\n            type: 'uint',\n            name: 'chromStart',\n            description: 'Start position (first base is 0).'\n        }, {\n            type: 'uint',\n            name: 'chromEnd',\n            description: 'End position plus one (chromEnd – chromStart = size).'\n        }, {\n            type: 'string',\n            name: 'name',\n            description: 'Name of feature.'\n        }, {\n            type: 'float',\n            name: 'score',\n            description: 'A number between 0 and 1000 that controls shading of item (0 if unused).'\n        }, {\n            type: 'string',\n            name: 'strand',\n            description: '+ or – (or . for unknown).'\n        }, {\n            type: 'uint',\n            name: 'thickStart',\n            description: 'Start position where feature is drawn as thicker line; used for CDS start for genes.'\n        }, {\n            type: 'uint',\n            name: 'thickEnd',\n            description: 'Position where thicker part of feature ends.'\n        }, {\n            type: 'string',\n            name: 'itemRgb',\n            description: 'Comma-separated list of red, green, blue values from 0-255 (0 if unused).'\n        }, {\n            type: 'uint',\n            name: 'blockCount',\n            description: 'For multipart items, the number of blocks; corresponds to exons for genes.'\n        }, {\n            type: 'string',\n            name: 'blockSizes',\n            description: 'Comma-separated list of block sizes.'\n        }, {\n            type: 'string',\n            name: 'chromStarts',\n            description: 'Comma-separated list of block starts relative to chromStart.'\n        }]\n    };\n\n    var RequestWorker = declare(null,\n    /**\n     * @lends JBrowse.Store.BigWig.Window.RequestWorker.prototype\n     */\n    {\n\n        BIG_WIG_TYPE_GRAPH: 1,\n        BIG_WIG_TYPE_VSTEP: 2,\n        BIG_WIG_TYPE_FSTEP: 3,\n\n        /**\n         * Worker object for reading data from a bigwig or bigbed file.\n         * Manages the state necessary for traversing the index trees and\n         * so forth.\n         *\n         * Adapted by Robert Buels from bigwig.js in the Dalliance Genome\n         * Explorer by Thomas Down.\n         * @constructs\n         */\n        constructor: function constructor(window, chr, min, max, callback, errorCallback) {\n            this.window = window;\n            this.source = window.bwg.name || undefined;\n\n            this.blocksToFetch = [];\n            this.outstanding = 0;\n\n            this.chr = chr;\n            this.min = min;\n            this.max = max;\n            this.callback = callback;\n            this.errorCallback = errorCallback || function (e) {\n                console.error(e, e.stack, arguments.caller);\n            };\n        },\n\n        cirFobRecur: function cirFobRecur(offset, level) {\n            this.outstanding += offset.length;\n\n            var maxCirBlockSpan = 4 + this.window.cirBlockSize * 32; // Upper bound on size, based on a completely full leaf node.\n            var spans;\n            for (var i = 0; i < offset.length; ++i) {\n                var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n                spans = spans ? spans.union(blockSpan) : blockSpan;\n            }\n\n            var fetchRanges = spans.ranges();\n            //dlog('fetchRanges: ' + fetchRanges);\n            for (var r = 0; r < fetchRanges.length; ++r) {\n                var fr = fetchRanges[r];\n                this.cirFobStartFetch(offset, fr, level);\n            }\n        },\n\n        cirFobStartFetch: function cirFobStartFetch(offset, fr, level, attempts) {\n            var length = fr.max() - fr.min();\n            // dlog('fetching ' + fr.min() + '-' + fr.max() + ' (' + Util.humanReadableNumber(length) + ')');\n            //console.log('cirfobstartfetch');\n            this.window.bwg._read(fr.min(), length, dlang.hitch(this, function (resultBuffer) {\n                for (var i = 0; i < offset.length; ++i) {\n                    if (fr.contains(offset[i])) {\n                        this.cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n                        --this.outstanding;\n                        if (this.outstanding == 0) {\n                            this.cirCompleted();\n                        }\n                    }\n                }\n            }), this.errorCallback);\n        },\n\n        cirFobRecur2: function cirFobRecur2(cirBlockData, offset, level) {\n            var data = this.window.bwg.newDataView(cirBlockData, offset);\n\n            var isLeaf = data.getUint8();\n            var cnt = data.getUint16(2);\n            //dlog('cir level=' + level + '; cnt=' + cnt);\n\n            if (isLeaf != 0) {\n                for (var i = 0; i < cnt; ++i) {\n                    var startChrom = data.getUint32();\n                    var startBase = data.getUint32();\n                    var endChrom = data.getUint32();\n                    var endBase = data.getUint32();\n                    var blockOffset = data.getUint64();\n                    var blockSize = data.getUint64();\n                    if ((startChrom < this.chr || startChrom == this.chr && startBase <= this.max) && (endChrom > this.chr || endChrom == this.chr && endBase >= this.min)) {\n                        // dlog('Got an interesting block: startBase=' + startBase + '; endBase=' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                        this.blocksToFetch.push({ offset: blockOffset, size: blockSize });\n                    }\n                }\n            } else {\n                var recurOffsets = [];\n                for (var i = 0; i < cnt; ++i) {\n                    var startChrom = data.getUint32();\n                    var startBase = data.getUint32();\n                    var endChrom = data.getUint32();\n                    var endBase = data.getUint32();\n                    var blockOffset = data.getUint64();\n                    if ((startChrom < this.chr || startChrom == this.chr && startBase <= this.max) && (endChrom > this.chr || endChrom == this.chr && endBase >= this.min)) {\n                        recurOffsets.push(blockOffset);\n                    }\n                }\n                if (recurOffsets.length > 0) {\n                    this.cirFobRecur(recurOffsets, level + 1);\n                }\n            }\n        },\n\n        cirCompleted: function cirCompleted() {\n            // merge contiguous blocks\n            this.blockGroupsToFetch = this.groupBlocks(this.blocksToFetch);\n\n            if (this.blockGroupsToFetch.length == 0) {\n                this.callback([]);\n            } else {\n                this.features = [];\n                this.readFeatures();\n            }\n        },\n\n        groupBlocks: function groupBlocks(blocks) {\n\n            // sort the blocks by file offset\n            blocks.sort(function (b0, b1) {\n                return (b0.offset | 0) - (b1.offset | 0);\n            });\n\n            // group blocks that are within 2KB of eachother\n            var blockGroups = [];\n            var lastBlock;\n            var lastBlockEnd;\n            for (var i = 0; i < blocks.length; i++) {\n                if (lastBlock && blocks[i].offset - lastBlockEnd <= 2000) {\n                    lastBlock.size += blocks[i].size - lastBlockEnd + blocks[i].offset;\n                    lastBlock.blocks.push(blocks[i]);\n                } else {\n                    blockGroups.push(lastBlock = { blocks: [blocks[i]], size: blocks[i].size, offset: blocks[i].offset });\n                }\n                lastBlockEnd = lastBlock.offset + lastBlock.size;\n            }\n\n            return blockGroups;\n        },\n\n        createFeature: function createFeature(fmin, fmax, opts) {\n            // dlog('createFeature(' + fmin +', ' + fmax + ', '+opts.score+')');\n\n            var data = {\n                start: fmin,\n                end: fmax\n            };\n\n            for (var k in opts) {\n                data[k] = opts[k];\n            }var id = data.id;\n            delete data.id;\n\n            var f = new SimpleFeature({\n                data: data,\n                id: id ? id : data.start + '_' + data.end + '_' + data.score\n            });\n\n            this.features.push(f);\n        },\n\n        maybeCreateFeature: function maybeCreateFeature(fmin, fmax, opts) {\n            if (fmin <= this.max && fmax >= this.min) {\n                this.createFeature(fmin, fmax, opts);\n            }\n        },\n\n        parseSummaryBlock: function parseSummaryBlock(bytes, startOffset) {\n            var data = this.window.bwg.newDataView(bytes, startOffset);\n\n            var itemCount = bytes.byteLength / 32;\n            for (var i = 0; i < itemCount; ++i) {\n                var chromId = data.getInt32();\n                var start = data.getInt32();\n                var end = data.getInt32();\n                var validCnt = data.getInt32() || 1;\n                var minVal = data.getFloat32();\n                var maxVal = data.getFloat32();\n                var sumData = data.getFloat32();\n                var sumSqData = data.getFloat32();\n\n                if (chromId == this.chr) {\n                    var summaryOpts = { score: sumData / validCnt, maxScore: maxVal, minScore: minVal };\n                    if (this.window.bwg.type == 'bigbed') {\n                        summaryOpts.type = 'density';\n                    }\n                    this.maybeCreateFeature(start, end, summaryOpts);\n                }\n            }\n        },\n\n        parseBigWigBlock: function parseBigWigBlock(bytes, startOffset) {\n            var data = this.window.bwg.newDataView(bytes, startOffset);\n\n            var itemSpan = data.getUint32(16);\n            var blockType = data.getUint8(20);\n            var itemCount = data.getUint16(22);\n\n            // dlog('processing bigwig block, type=' + blockType + '; count=' + itemCount);\n\n            if (blockType == this.BIG_WIG_TYPE_FSTEP) {\n                var blockStart = data.getInt32(4);\n                var itemStep = data.getUint32(12);\n                for (var i = 0; i < itemCount; ++i) {\n                    var score = data.getFloat32(4 * i + 24);\n                    this.maybeCreateFeature(blockStart + i * itemStep, blockStart + i * itemStep + itemSpan, { score: score });\n                }\n            } else if (blockType == this.BIG_WIG_TYPE_VSTEP) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var start = data.getInt32(8 * i + 24);\n                    var score = data.getFloat32();\n                    this.maybeCreateFeature(start, start + itemSpan, { score: score });\n                }\n            } else if (blockType == this.BIG_WIG_TYPE_GRAPH) {\n                for (var i = 0; i < itemCount; ++i) {\n                    var start = data.getInt32(12 * i + 24);\n                    var end = data.getInt32();\n                    var score = data.getFloat32();\n                    if (start > end) {\n                        start = end;\n                    }\n                    this.maybeCreateFeature(start, end, { score: score });\n                }\n            } else {\n                dlog('Currently not handling bwgType=' + blockType);\n            }\n        },\n\n        parseBigBedBlock: function parseBigBedBlock(bytes, startOffset) {\n            var data = this.window.bwg.newDataView(bytes, startOffset);\n\n            var offset = 0;\n            while (offset < bytes.byteLength) {\n                var chromId = data.getUint32(offset);\n                var start = data.getInt32(offset + 4);\n                var end = data.getInt32(offset + 8);\n                offset += 12;\n                if (chromId !== this.chr) {\n                    console.warn('BigBed block is out of current range');\n                    return;\n                }\n\n                var rest = '';\n                while (offset < bytes.byteLength) {\n                    var ch = data.getUint8(offset++);\n                    if (ch !== 0) {\n                        rest += String.fromCharCode(ch);\n                    } else {\n                        break;\n                    }\n                }\n\n                var featureData = this.parseBedText(start, end, rest);\n                featureData.id = 'bb-' + (startOffset + offset);\n                this.maybeCreateFeature(start, end, featureData);\n            }\n        },\n\n        /**\n         * parse the `rest` field of a binary bed data section, using\n         * the autosql schema defined for this file\n         *\n         * @returns {Object} feature data with native BED field names\n         */\n        parseBedText: function parseBedText(start, end, rest) {\n            // include ucsc-style names as well as jbrowse-style names\n            var featureData = {\n                start: start,\n                end: end\n            };\n\n            var bedColumns = rest.split('\\t');\n            var asql = this.window.autoSql || defaultAutoSql;\n            var numericTypes = ['uint', 'int', 'float', 'long'];\n            // first three columns (chrom,start,end) are not included in bigBed\n            for (var i = 3; i < asql.fields.length; i++) {\n                if (bedColumns[i - 3] !== '.' && bedColumns[i - 3] !== '') {\n                    var autoField = asql.fields[i];\n                    var columnVal = bedColumns[i - 3];\n\n                    // for speed, cache some of the tests we need inside the autofield definition\n                    if (!autoField._requestWorkerCache) {\n                        var match = /^(\\w+)\\[/.exec(autoField.type);\n                        autoField._requestWorkerCache = {\n                            isNumeric: numericTypes.includes(autoField.type),\n                            isArray: !!match,\n                            arrayIsNumeric: match && numericTypes.includes(match[1])\n                        };\n                    }\n\n                    if (autoField._requestWorkerCache.isNumeric) {\n                        var num = Number(columnVal);\n                        // if the number parse results in NaN, somebody probably\n                        // listed the type erroneously as numeric, so don't use\n                        // the parsed number\n                        columnVal = isNaN(num) ? columnVal : num;\n                    } else if (autoField._requestWorkerCache.isArray) {\n                        // parse array values\n                        columnVal = columnVal.split(',');\n                        if (columnVal[columnVal.length - 1] === '') columnVal.pop();\n                        if (autoField._requestWorkerCache.arrayIsNumeric) columnVal = columnVal.map(function (str) {\n                            return Number(str);\n                        });\n                    }\n\n                    featureData[snakeCase(autoField.name)] = columnVal;\n                }\n            }\n\n            if (featureData.strand) {\n                featureData.strand = { '-': -1, '+': 1 }[featureData.strand];\n            }\n\n            return featureData;\n        },\n\n        readFeatures: function readFeatures() {\n            var thisB = this;\n            var blockFetches = array.map(thisB.blockGroupsToFetch, function (blockGroup) {\n                //console.log( 'fetching blockgroup with '+blockGroup.blocks.length+' blocks: '+blockGroup );\n                var d = new RejectableFastPromise();\n                thisB.window.bwg._read(blockGroup.offset, blockGroup.size, function (data) {\n                    blockGroup.data = data;\n                    d.resolve(blockGroup);\n                }, dlang.hitch(d, 'reject'));\n                return d;\n            }, thisB);\n\n            all(blockFetches).then(function (blockGroups) {\n                array.forEach(blockGroups, function (blockGroup) {\n                    array.forEach(blockGroup.blocks, function (block) {\n                        var data;\n                        var offset = block.offset - blockGroup.offset;\n                        if (thisB.window.bwg.uncompressBufSize > 0) {\n                            // var beforeInf = new Date();\n                            data = inflate(blockGroup.data, offset + 2, block.size - 2);\n                            offset = 0;\n                            //console.log( 'inflate', 2, block.size - 2);\n                            // var afterInf = new Date();\n                            // dlog('inflate: ' + (afterInf - beforeInf) + 'ms');\n                        } else {\n                            data = blockGroup.data;\n                        }\n\n                        if (thisB.window.isSummary) {\n                            thisB.parseSummaryBlock(data, offset);\n                        } else if (thisB.window.bwg.type == 'bigwig') {\n                            thisB.parseBigWigBlock(data, offset);\n                        } else if (thisB.window.bwg.type == 'bigbed') {\n                            thisB.parseBigBedBlock(data, offset);\n                        } else {\n                            dlog(\"Don't know what to do with \" + thisB.window.bwg.type);\n                        }\n                    });\n                });\n\n                thisB.callback(thisB.features);\n            }, thisB.errorCallback);\n        }\n    });\n\n    return RequestWorker;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BigWig/RequestWorker.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/BigWig/Window.js":
/*!*******************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/BigWig/Window.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Store/LRUCache */ \"./src/JBrowse/Store/LRUCache.js\"), __webpack_require__(/*! ./RequestWorker */ \"./src/JBrowse/Store/SeqFeature/BigWig/RequestWorker.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, LRUCache, RequestWorker) {\n\n    var dlog = function dlog() {\n        console.log.apply(console, arguments);\n    };\n\n    return declare(null,\n    /**\n     * @lends JBrowse.Store.BigWig.Window.prototype\n     */\n    {\n\n        /**\n         * View into a subset of the data in a BigWig file.\n         *\n         * Adapted by Robert Buels from bigwig.js in the Dalliance Genome\n         * Explorer by Thomas Down.\n         * @constructs\n         */\n        constructor: function constructor(bwg, cirTreeOffset, cirTreeLength, isSummary, autoSql) {\n            var _this = this;\n\n            this.bwg = bwg;\n            this.autoSql = autoSql;\n            if (!(cirTreeOffset >= 0)) throw \"invalid cirTreeOffset!\";\n            if (!(cirTreeLength > 0)) throw \"invalid cirTreeLength!\";\n\n            this.cirTreeOffset = cirTreeOffset;\n            this.cirTreeLength = cirTreeLength;\n            this.isSummary = isSummary;\n\n            function countFeatures(features) {\n                if (!features) return 0;\n                var total = features.length;\n                features.forEach(function (feature) {\n                    total += countFeatures(feature.children());\n                });\n                return total;\n            }\n            this.featureCache = new LRUCache({\n                name: 'feature cache',\n                fillCallback: function fillCallback(query, callback) {\n                    _this.readWigDataById.apply(_this, _toConsumableArray(query).concat([callback, function (err) {\n                        console.error(err);\n                    }]));\n                },\n                sizeFunction: countFeatures,\n                maxSize: 500000 // cache up to 50000 features and subfeatures\n            });\n        },\n\n        BED_COLOR_REGEXP: /^[0-9]+,[0-9]+,[0-9]+/,\n\n        readWigData: function readWigData(chrName, min, max, callback, errorCallback) {\n            // console.log( 'reading wig data from '+chrName+':'+min+'..'+max);\n            var chr = this.bwg.refsByName[chrName];\n            if (!chr) {\n                // Not an error because some .bwgs won't have data for all chromosomes.\n\n                // dlog(\"Couldn't find chr \" + chrName);\n                // dlog('Chroms=' + miniJSONify(this.bwg.refsByName));\n                callback([]);\n            } else {\n                this.readWigDataByIdWithCache(chr.id, min, max, callback, errorCallback);\n            }\n        },\n\n        readWigDataByIdWithCache: function readWigDataByIdWithCache(chr, min, max, callback, errorCallback) {\n            this.featureCache.get([chr, min, max], function (result, error) {\n                if (error) errorCallback(error);else callback(result);\n            });\n        },\n\n\n        readWigDataById: function readWigDataById(chr, min, max, callback, errorCallback) {\n            if (!this.cirHeader) {\n                var readCallback = lang.hitch(this, 'readWigDataById', chr, min, max, callback, errorCallback);\n                if (this.cirHeaderLoading) {\n                    this.cirHeaderLoading.push(readCallback);\n                } else {\n                    this.cirHeaderLoading = [readCallback];\n                    // dlog('No CIR yet, fetching');\n                    this.bwg.data.read(this.cirTreeOffset, 48, lang.hitch(this, function (result) {\n                        this.cirHeader = result;\n                        this.cirBlockSize = this.bwg.newDataView(result, 4, 4).getUint32();\n                        array.forEach(this.cirHeaderLoading, function (c) {\n                            c();\n                        });\n                        delete this.cirHeaderLoading;\n                    }), errorCallback);\n                }\n                return;\n            }\n\n            //dlog('_readWigDataById', chr, min, max, callback);\n\n            var worker = new RequestWorker(this, chr, min, max, callback, errorCallback);\n            worker.cirFobRecur([this.cirTreeOffset + 48], 1);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/BigWig/Window.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/CRAM.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/CRAM.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LRU = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n\nvar _cjsRequire = __webpack_require__(/*! @gmod/cram */ \"./node_modules/@gmod/cram/dist/index.js\"),\n    IndexedCramFile = _cjsRequire.IndexedCramFile,\n    CraiIndex = _cjsRequire.CraiIndex;\n\nvar _cjsRequire2 = __webpack_require__(/*! @gmod/cram/errors */ \"./node_modules/@gmod/cram/errors.js\"),\n    CramSizeLimitError = _cjsRequire2.CramSizeLimitError;\n\nvar cramIndexedFilesCache = new LRU({ maxSize: 5 });\n\nvar BlobFilehandleWrapper = __webpack_require__(/*! ../../Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\");\n\nvar CramSlightlyLazyFeature = function () {\n    _createClass(CramSlightlyLazyFeature, [{\n        key: '_get_id',\n        value: function _get_id() {\n            return this.id();\n        }\n    }, {\n        key: '_get_name',\n        value: function _get_name() {\n            return this.record.readName;\n        }\n    }, {\n        key: '_get_start',\n        value: function _get_start() {\n            return this.record.alignmentStart - 1;\n        }\n    }, {\n        key: '_get_end',\n        value: function _get_end() {\n            return this.record.alignmentStart + this.record.lengthOnRef - 1;\n        }\n    }, {\n        key: '_get_cram_read_features',\n        value: function _get_cram_read_features() {\n            return this.record.readFeatures;\n        }\n    }, {\n        key: '_get_type',\n        value: function _get_type() {\n            return 'match';\n        }\n    }, {\n        key: '_get_score',\n        value: function _get_score() {\n            return this.record.mappingQuality;\n        }\n    }, {\n        key: '_get_mapping_quality',\n        value: function _get_mapping_quality() {\n            return this.record.mappingQuality;\n        }\n    }, {\n        key: '_get_flags',\n        value: function _get_flags() {\n            return '0x' + this.record.flags.toString(16);\n        }\n    }, {\n        key: '_get_cramFlags',\n        value: function _get_cramFlags() {\n            return '0x' + this.record.cramFlags.toString(16);\n        }\n    }, {\n        key: '_get_strand',\n        value: function _get_strand() {\n            return this.record.isReverseComplemented() ? -1 : 1;\n        }\n    }, {\n        key: '_get_read_group_id',\n        value: function _get_read_group_id() {\n            return this.record.readGroupId;\n        }\n    }, {\n        key: '_get_qual',\n        value: function _get_qual() {\n            return (this.record.qualityScores || []).map(function (q) {\n                return q + 33;\n            }).join(' ');\n        }\n    }, {\n        key: '_get_seq_id',\n        value: function _get_seq_id() {\n            return this._store._refIdToName(this.record.sequenceId);\n        }\n    }, {\n        key: '_get_qc_failed',\n        value: function _get_qc_failed() {\n            return this.record.isFailedQc();\n        }\n    }, {\n        key: '_get_secondary_alignment',\n        value: function _get_secondary_alignment() {\n            return this.record.isSecondary();\n        }\n    }, {\n        key: '_get_duplicate',\n        value: function _get_duplicate() {\n            return this.record.isDuplicate();\n        }\n    }, {\n        key: '_get_supplementary_alignment',\n        value: function _get_supplementary_alignment() {\n            return this.record.isSupplementary();\n        }\n    }, {\n        key: '_get_pair_orientation',\n        value: function _get_pair_orientation() {\n            return this.record.getPairOrientation();\n        }\n    }, {\n        key: '_get_multi_segment_template',\n        value: function _get_multi_segment_template() {\n            return this.record.isPaired();\n        }\n    }, {\n        key: '_get_multi_segment_all_correctly_aligned',\n        value: function _get_multi_segment_all_correctly_aligned() {\n            return this.record.isProperlyPaired();\n        }\n    }, {\n        key: '_get_multi_segment_all_aligned',\n        value: function _get_multi_segment_all_aligned() {\n            return this.record.isProperlyPaired();\n        }\n    }, {\n        key: '_get_multi_segment_next_segment_unmapped',\n        value: function _get_multi_segment_next_segment_unmapped() {\n            return this.record.isMateUnmapped();\n        }\n    }, {\n        key: '_get_multi_segment_first',\n        value: function _get_multi_segment_first() {\n            return this.record.isRead1();\n        }\n    }, {\n        key: '_get_multi_segment_last',\n        value: function _get_multi_segment_last() {\n            return this.record.isRead2();\n        }\n    }, {\n        key: '_get_multi_segment_next_segment_reversed',\n        value: function _get_multi_segment_next_segment_reversed() {\n            return this.record.isMateReverseComplemented();\n        }\n    }, {\n        key: '_get_is_paired',\n        value: function _get_is_paired() {\n            return !!this.record.mate;\n        }\n    }, {\n        key: '_get_unmapped',\n        value: function _get_unmapped() {\n            return this.record.isSegmentUnmapped();\n        }\n    }, {\n        key: '_get_template_length',\n        value: function _get_template_length() {\n            return this.record.templateLength || this.record.templateSize;\n        }\n    }, {\n        key: '_get_next_seq_id',\n        value: function _get_next_seq_id() {\n            return this.record.mate ? this._store._refIdToName(this.record.mate.sequenceId) : undefined;\n        }\n    }, {\n        key: '_get_next_pos',\n        value: function _get_next_pos() {\n            return this.record.mate ? this.record.mate.alignmentStart : undefined;\n        }\n    }, {\n        key: '_get_next_segment_position',\n        value: function _get_next_segment_position() {\n            return this.record.mate ? this._store._refIdToName(this.record.mate.sequenceId) + ':' + this.record.mate.alignmentStart : undefined;\n        }\n    }, {\n        key: '_get_tags',\n        value: function _get_tags() {\n            return this.record.tags;\n        }\n    }, {\n        key: '_get_seq',\n        value: function _get_seq() {\n            return this.record.getReadBases();\n        }\n    }]);\n\n    function CramSlightlyLazyFeature(record, store) {\n        _classCallCheck(this, CramSlightlyLazyFeature);\n\n        this.record = record;\n        this._store = store;\n    }\n\n    _createClass(CramSlightlyLazyFeature, [{\n        key: 'tags',\n        value: function tags() {\n            var properties = Object.getOwnPropertyNames(CramSlightlyLazyFeature.prototype);\n            return properties.filter(function (prop) {\n                return (/^_get_/.test(prop)\n                );\n            }).map(function (methodName) {\n                return methodName.replace('_get_', '');\n            });\n        }\n    }, {\n        key: 'id',\n        value: function id() {\n            return this.record.uniqueId + 1;\n        }\n    }, {\n        key: '_get',\n        value: function _get(field) {\n            var methodName = '_get_' + field;\n            if (this[methodName]) return this[methodName]();\n            return undefined;\n        }\n    }, {\n        key: 'get',\n        value: function get(field) {\n            var methodName = '_get_' + field.toLowerCase();\n            if (this[methodName]) return this[methodName]();\n            return undefined;\n        }\n    }, {\n        key: 'parent',\n        value: function parent() {}\n    }, {\n        key: 'children',\n        value: function children() {}\n    }, {\n        key: 'pairedFeature',\n        value: function pairedFeature() {\n            return false;\n        }\n    }]);\n\n    return CramSlightlyLazyFeature;\n}();\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_PairCache */ \"./src/JBrowse/Store/SeqFeature/_PairCache.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_SpanCache */ \"./src/JBrowse/Store/SeqFeature/_SpanCache.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_InsertSizeCache */ \"./src/JBrowse/Store/SeqFeature/_InsertSizeCache.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, Errors, SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, GlobalStatsEstimationMixin, PairCache, SpanCache, InsertSizeCache, XHRBlob, SimpleFeature) {\n\n    return declare([SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, GlobalStatsEstimationMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.CRAM\n     */\n    {\n        /**\n         * Data backend for reading feature data directly from a\n         * web-accessible CRAM file.\n         *\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var dataBlob = void 0;\n            if (args.cram) dataBlob = new BlobFilehandleWrapper(args.cram);else if (args.urlTemplate) dataBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.cram'), { expectRanges: true }));else throw new Error('must provide either `cram` or `urlTemplate`');\n\n            var indexBlob = void 0;\n            if (args.crai) indexBlob = new BlobFilehandleWrapper(args.crai);else if (args.craiUrlTemplate) indexBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.craiUrlTemplate)));else if (args.urlTemplate) indexBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate + '.crai')));else throw new Error('no index provided, must provide a CRAM index');\n\n            this.source = dataBlob.toString();\n\n            // LRU-cache the CRAM object so we don't have to re-download the\n            // index when we switch chromosomes\n            var cacheKey = 'data: ' + dataBlob + ', index: ' + indexBlob;\n            this.cram = cramIndexedFilesCache.get(cacheKey);\n            if (!this.cram) {\n                this.cram = new IndexedCramFile({\n                    cramFilehandle: dataBlob,\n                    index: new CraiIndex({ filehandle: indexBlob }),\n                    seqFetch: this._seqFetch.bind(this),\n                    checkSequenceMD5: false,\n                    fetchSizeLimit: args.fetchSizeLimit || 60000000\n                });\n\n                cramIndexedFilesCache.set(cacheKey, this.cram);\n            }\n\n            // pre-download the index before running the statistics estimation so that the stats\n            // estimation doesn't time out\n            this.cram.hasDataForReferenceSequence(0).then(function () {\n                return _this.cram.cram.getSamHeader();\n            }).then(function (samHeader) {\n                _this._setSamHeader(samHeader);\n            }).then(function () {\n                _this._deferred.features.resolve({ success: true });\n            }).then(function () {\n                return _this._estimateGlobalStats();\n            }).then(function (stats) {\n                _this.globalStats = stats;\n                _this._deferred.stats.resolve({ success: true });\n            }).catch(function (err) {\n                _this._deferred.features.reject(err);\n                _this._deferred.stats.reject(err);\n            });\n\n            this.insertSizeCache = new InsertSizeCache(args);\n            this.pairCache = new PairCache(args);\n            this.spanCache = new SpanCache(args);\n        },\n\n        // process the parsed SAM header from the cram file\n        _setSamHeader: function _setSamHeader(samHeader) {\n            var _this2 = this;\n\n            this._samHeader = {};\n\n            // use the @SQ lines in the header to figure out the\n            // mapping between ref seq ID numbers and names\n            var refSeqIdToName = [];\n            var refSeqNameToId = {};\n            var sqLines = samHeader.filter(function (l) {\n                return l.tag === 'SQ';\n            });\n            sqLines.forEach(function (sqLine, seqId) {\n                sqLine.data.forEach(function (item) {\n                    if (item.tag === 'SN') {\n                        // this is the seq name\n                        var seqName = _this2.browser.regularizeReferenceName(item.value);\n                        refSeqNameToId[seqName] = seqId;\n                        refSeqIdToName[seqId] = seqName;\n                    }\n                });\n            });\n            if (refSeqIdToName.length) {\n                this._samHeader.refSeqIdToName = refSeqIdToName;\n                this._samHeader.refSeqNameToId = refSeqNameToId;\n            }\n        },\n        _refNameToId: function _refNameToId(refName) {\n            // use info from the SAM header if possible, but fall back to using\n            // the ref seq order from when the browser's refseqs were loaded\n            if (this._samHeader.refSeqNameToId) return this._samHeader.refSeqNameToId[refName];else return this.browser.getRefSeqNumber(refName);\n        },\n        _refIdToName: function _refIdToName(refId) {\n            // use info from the SAM header if possible, but fall back to using\n            // the ref seq order from when the browser's refseqs were loaded\n            if (this._samHeader.refSeqIdToName) {\n                return this._samHeader.refSeqIdToName[refId];\n            } else {\n                var ref = this.browser.getRefSeqById(refId);\n                return ref ? ref.name : undefined;\n            }\n        },\n        _getRefSeqStore: function _getRefSeqStore() {\n            var _this3 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this3.browser.getStore('refseqs', resolve, reject);\n            });\n        },\n\n\n        // used by the CRAM backend to fetch a region of the underlying reference\n        // sequence.  needed for some of its calculations\n        _seqFetch: function _seqFetch(seqId, start, end) {\n            var _this4 = this;\n\n            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                var refSeqStore, refName, seqChunks, trimmed, sequence;\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                start -= 1; // convert from 1-based closed to interbase\n\n                                _context.next = 3;\n                                return _this4._getRefSeqStore();\n\n                            case 3:\n                                refSeqStore = _context.sent;\n\n                                if (refSeqStore) {\n                                    _context.next = 6;\n                                    break;\n                                }\n\n                                return _context.abrupt('return', undefined);\n\n                            case 6:\n                                refName = _this4._refIdToName(seqId);\n\n                                if (refName) {\n                                    _context.next = 9;\n                                    break;\n                                }\n\n                                return _context.abrupt('return', undefined);\n\n                            case 9:\n                                _context.next = 11;\n                                return new Promise(function (resolve, reject) {\n                                    var features = [];\n                                    refSeqStore.getFeatures({ ref: refName, start: start - 1, end: end }, function (f) {\n                                        return features.push(f);\n                                    }, function () {\n                                        return resolve(features);\n                                    }, reject);\n                                });\n\n                            case 11:\n                                seqChunks = _context.sent;\n                                trimmed = [];\n\n                                seqChunks.sort(function (a, b) {\n                                    return a.get('start') - b.get('start');\n                                }).forEach(function (chunk, i) {\n                                    var chunkStart = chunk.get('start');\n                                    var chunkEnd = chunk.get('end');\n                                    var trimStart = Math.max(start - chunkStart, 0);\n                                    var trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);\n                                    var trimLength = trimEnd - trimStart;\n                                    var chunkSeq = chunk.get('seq') || chunk.get('residues');\n                                    trimmed.push(chunkSeq.substr(trimStart, trimLength));\n                                });\n\n                                sequence = trimmed.join('');\n\n                                if (!(sequence.length !== end - start)) {\n                                    _context.next = 17;\n                                    break;\n                                }\n\n                                throw new Error('sequence fetch failed: fetching ' + (start - 1).toLocaleString() + '-' + end.toLocaleString() + ' only returned ' + sequence.length.toLocaleString() + ' bases, but should have returned ' + (end - start).toLocaleString());\n\n                            case 17:\n                                return _context.abrupt('return', sequence);\n\n                            case 18:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, _this4);\n            }))();\n        },\n\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            var _this5 = this;\n\n            seqName = this.browser.regularizeReferenceName(seqName);\n            var refSeqNumber = this._refNameToId(seqName);\n            if (refSeqNumber === undefined) callback(false);\n\n            this._deferred.stats.then(function () {\n                return _this5.cram.hasDataForReferenceSequence(refSeqNumber);\n            }).then(callback, errorCallback);\n        },\n\n        // called by getFeatures from the DeferredFeaturesMixin\n        _getFeatures: function _getFeatures(query, featCallback, endCallback, errorCallback) {\n            var _this6 = this;\n\n            var pairCache = {};\n            var seqName = query.ref || this.refSeq.name;\n            var refSeqNumber = this._refNameToId(this.browser.regularizeReferenceName(seqName));\n            query.maxInsertSize = query.maxInsertSize || 50000;\n            if (refSeqNumber === undefined) {\n                endCallback();\n                return;\n            }\n            this.cram.getRecordsForRange(refSeqNumber, query.start + 1, query.end, { viewAsPairs: query.viewAsPairs, viewAsSpans: query.viewAsSpans, maxInsertSize: query.maxInsertSize }).then(function (records) {\n                if (query.viewAsPairs) {\n                    var recs = records.map(function (f) {\n                        return _this6._cramRecordToFeature(f);\n                    });\n                    recs.forEach(function (r) {\n                        return _this6.insertSizeCache.insertFeat(r);\n                    });\n                    _this6.pairCache.pairFeatures(query, recs, featCallback, endCallback, errorCallback);\n                } else if (query.viewAsSpans) {\n                    var _recs = records.map(function (f) {\n                        return _this6._cramRecordToFeature(f);\n                    });\n                    _recs.forEach(function (r) {\n                        return _this6.insertSizeCache.insertFeat(r);\n                    });\n                    _this6.spanCache.pairFeatures(query, _recs, featCallback, endCallback, errorCallback);\n                } else {\n                    for (var i = 0; i < records.length; i++) {\n                        var feat = _this6._cramRecordToFeature(records[i]);\n                        _this6.insertSizeCache.insertFeat(feat);\n                        featCallback(feat);\n                    }\n                }\n                endCallback();\n            }).catch(function (err) {\n                // map the CramSizeLimitError to JBrowse Errors.DataOverflow\n                if (err instanceof CramSizeLimitError) {\n                    err = new Errors.DataOverflow(err);\n                }\n\n                errorCallback(err);\n            });\n        },\n\n        getInsertSizeStats: function getInsertSizeStats() {\n            return this.insertSizeCache.getInsertSizeStats();\n        },\n        cleanFeatureCache: function cleanFeatureCache(query) {\n            this.pairCache.cleanFeatureCache(query);\n            this.spanCache.cleanFeatureCache(query);\n        },\n        cleanStatsCache: function cleanStatsCache() {\n            this.insertSizeCache.cleanStatsCache();\n        },\n        _cramRecordToFeature: function _cramRecordToFeature(record) {\n            return new CramSlightlyLazyFeature(record, this);\n        },\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.cram.url,\n                craiUrlTemplate: this.config.crai.url\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/CRAM.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/ChromSizes.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/ChromSizes.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar BlobFilehandleWrapper = __webpack_require__(/*! ../../Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, SeqFeatureStore, XHRBlob, DeferredFeaturesMixin) {\n\n    return declare([SeqFeatureStore, DeferredFeaturesMixin], {\n\n        /**\n         * Storage backend for sequences in chrom.sizes files\n         * served as static text files.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var dataBlob = void 0;\n            if (args.blob) dataBlob = new BlobFilehandleWrapper(args.blob);else if (args.urlTemplate) dataBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate)));\n\n            this.source = dataBlob.toString();\n            this.data = dataBlob;\n            this.refSeqs = {};\n\n            this.init({\n                success: function success() {\n                    return _this._deferred.features.resolve({ success: true });\n                },\n                failure: this._failAllDeferred.bind(this)\n            });\n        },\n\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            this.getSequenceSize(seqName).then(function (size) {\n                callback(size !== undefined);\n            }, errorCallback);\n        },\n        getRefSeqs: function getRefSeqs(callback, errorCallback) {\n            var _this2 = this;\n\n            this.getSequenceSizes().then(function (sizes) {\n                return Object.entries(_this2.refSeqs).map(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                        name = _ref2[0],\n                        length = _ref2[1];\n\n                    return {\n                        name: name,\n                        length: length,\n                        end: length,\n                        start: 0\n                    };\n                });\n            }).then(callback, errorCallback);\n        },\n        getSequenceSize: function getSequenceSize(refSeq) {\n            var _this3 = this;\n\n            return this._deferred.features.then(function () {\n                return _this3.refSeqs[refSeq];\n            });\n        },\n        getSequenceSizes: function getSequenceSizes() {\n            var _this4 = this;\n\n            return this._deferred.features.then(function () {\n                return _this4.refSeqs;\n            });\n        },\n        init: function init(args) {\n            var _this5 = this;\n\n            var fasta = this.data;\n            var successCallback = args.success || function () {};\n            var failCallback = args.failure || function (e) {\n                console.error(e, e.stack);\n            };\n            this.data.readFile().then(function (data) {\n                if (!data.length) {\n                    failCallback('Could not read file ' + _this5.source);\n                }\n                var chroms = data.toString('utf8');\n                chroms.split('\\n').forEach(function (line) {\n                    if (line.length) {\n                        var _line$split = line.split('\\t'),\n                            _line$split2 = _slicedToArray(_line$split, 2),\n                            name = _line$split2[0],\n                            length = _line$split2[1];\n\n                        _this5.refSeqs[name] = length;\n                    }\n                });\n                successCallback();\n            }, failCallback);\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: (this.config.file || this.config.blob).url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/ChromSizes.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/Combination.js":
/*!*****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/Combination.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/CombinationBase */ \"./src/JBrowse/Store/SeqFeature/CombinationBase.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Deferred, SimpleFeature, CombinationBaseStore) {\n\n    return declare([CombinationBaseStore], {\n\n        // An implementation of CombinationBase that deals with set-type features (without score, as in HTMLFeatures tracks).\n        // Usual operations are things like intersection, union, set subtraction and XOR.\n\n        // Creates features from spans.  Essentially copies the basic span information and adds a feature id.\n        createFeatures: function createFeatures(spans) {\n            var features = [];\n            //Validate this next time...\n            for (var span in spans) {\n                var id = \"comfeat_\" + spans[span].start + \".\" + spans[span].end + \".\" + spans[span].strand;\n                features.push(new SimpleFeature({ data: { start: spans[span].start, end: spans[span].end, strand: spans[span].strand }, id: id }));\n            }\n            return features;\n        },\n\n        // Defines the various set-theoretic operations that may occur and assigns each to a span-making function.\n        // Passes the two sets of spans to the appropriate operator function.\n        opSpan: function opSpan(op, span1, span2, query) {\n            switch (op) {\n                case \"&\":\n                    return this.andSpan(span1, span2);\n                case \"U\":\n                    return this.orSpan(span1, span2);\n                case \"X\":\n                    return this.andSpan(this.orSpan(span1, span2), this.notSpan(this.andSpan(span1, span2), query));\n                case \"S\":\n                    return this.andSpan(span1, this.notSpan(span2, query));\n                default:\n                    console.error(\"Invalid boolean operation: \" + op);\n            }\n            return undefined;\n        },\n\n        // given a set of features, takes the \"union\" of them and outputs a single set of nonoverlapping spans\n        toSpan: function toSpan(features, query) {\n            // strip away extra stuff and keep only the relevant feature data\n            var rawSpans = this._rawToSpan(features, query);\n\n            // Splits the spans based on which strand they're on, and remove overlap from each strand's spans, recombining at the end.\n            return this._removeOverlap(this._strandFilter(rawSpans, +1)).concat(this._removeOverlap(this._strandFilter(rawSpans, -1)));\n        },\n\n        _rawToSpan: function _rawToSpan(features, query) {\n            // given a set of features, makes a set of spans with the\n            // same start and end points (a.k.a. pseudo-features)\n            var spans = [];\n            for (var feature in features) {\n                if (features.hasOwnProperty(feature)) {\n                    spans.push({ start: features[feature].get('start'), //Math.max( features[feature].get('start'), query.start ),\n                        end: features[feature].get('end'), //Math.min( features[feature].get('end'),   query.end   ),\n                        strand: features[feature].get('strand') });\n                }\n            }\n            return spans;\n        },\n\n        // Filters an array of spans based on which strand of the reference sequence they are attached to\n        _strandFilter: function _strandFilter(spans, strand) {\n            return array.filter(spans, function (item) {\n                return item.strand == strand || !item.strand;\n            }).map(function (item) {\n                if (!item.strand) return { start: item.start, end: item.end, strand: strand // Adds strand to strandless spans\n                };else return item;\n            });\n        },\n\n        // converts overlapping spans into their union.  Assumes the spans are all on the same strand.\n        _removeOverlap: function _removeOverlap(spans) {\n            if (!spans.length) {\n                return [];\n            }\n            spans.sort(function (a, b) {\n                return a.start - b.start;\n            });\n            return this._removeOverlapSorted(spans);\n        },\n\n        // Given an array of spans sorted by their start bp, converts them into a single non-overlapping set (ie takes their union).\n        _removeOverlapSorted: function _removeOverlapSorted(spans) {\n            var retSpans = [];\n            var i = 0;\n            var strand = spans[0].strand;\n            while (i < spans.length) {\n                var start = spans[i].start;\n                var end = spans[i].end;\n                while (i < spans.length && spans[i].start <= end) {\n                    end = Math.max(end, spans[i].end);\n                    i++;\n                }\n                retSpans.push({ start: start, end: end, strand: strand });\n            }\n            return retSpans;\n        },\n\n        // given two sets of spans without internal overlap, outputs a set corresponding to their union.\n        orSpan: function orSpan(span1, span2) {\n            return this._computeUnion(this._strandFilter(span1, 1), this._strandFilter(span2, 1)).concat(this._computeUnion(this._strandFilter(span1, -1), this._strandFilter(span2, -1)));\n        },\n\n        // given two sets of spans without internal overlap, outputs a set corresponding to their intersection\n        andSpan: function andSpan(span1, span2) {\n\n            return this._computeIntersection(this._strandFilter(span1, 1), this._strandFilter(span2, 1)).concat(this._computeIntersection(this._strandFilter(span1, -1), this._strandFilter(span2, -1)));\n        },\n\n        // This method should merge two sorted span arrays in O(n) time, which is better\n        // then using span1.concat(span2) and then array.sort(), which takes O(n*log(n)) time.\n        _sortedArrayMerge: function _sortedArrayMerge(span1, span2) {\n            var newArray = [];\n            var i = 0;\n            var j = 0;\n            while (i < span1.length && j < span2.length) {\n                if (span1[i].start <= span2[j].start) {\n                    newArray.push(span1[i]);\n                    i++;\n                } else {\n                    newArray.push(span2[j]);\n                    j++;\n                }\n            }\n            if (i < span1.length) {\n                newArray = newArray.concat(span1.slice(i, span1.length));\n            } else if (j < span2.length) {\n                newArray = newArray.concat(span2.slice(j, span2.length));\n            }\n            return newArray;\n        },\n\n        // A helper method for computing the union of two arrays of spans.\n        _computeUnion: function _computeUnion(span1, span2) {\n            if (!span1.length && !span2.length) {\n                return [];\n            }\n            return this._removeOverlapSorted(this._sortedArrayMerge(span1, span2));\n        },\n\n        // A helper method for computing the intersection of two arrays of spans.\n        _computeIntersection: function _computeIntersection(span1, span2) {\n            if (!span1.length || !span2.length) {\n                return [];\n            }\n\n            var allSpans = this._sortedArrayMerge(span1, span2);\n            var retSpans = [];\n\n            var maxEnd = allSpans[0].end;\n            var strand = span1[0].strand; // Assumes both span sets contain only features for one specific strand\n            var i = 1;\n            while (i < allSpans.length) {\n                var start = allSpans[i].start;\n                var end = Math.min(allSpans[i].end, maxEnd);\n                if (start < end) {\n                    retSpans.push({ start: start, end: end, strand: strand });\n                }\n                maxEnd = Math.max(allSpans[i].end, maxEnd);\n                i++;\n            }\n\n            return retSpans;\n        },\n\n        // Filters span set by strand, inverts the sets represented on each strand, and recombines.\n        notSpan: function notSpan(spans, query) {\n            return this._rawNotSpan(this._strandFilter(spans, +1), query, +1).concat(this._rawNotSpan(this._strandFilter(spans, -1), query, -1));\n        },\n\n        // Converts a set of spans into its complement in the reference sequence.\n        _rawNotSpan: function _rawNotSpan(spans, query, strand) {\n            var invSpan = [];\n            invSpan[0] = { start: query.start };\n            var i = 0;\n            for (var span in spans) {\n                if (spans.hasOwnProperty(span)) {\n                    span = spans[span];\n                    invSpan[i].strand = strand;\n                    invSpan[i].end = span.start;\n                    i++;\n                    invSpan[i] = { start: span.end };\n                }\n            }\n            invSpan[i].strand = strand;\n            invSpan[i].end = query.end;\n            if (invSpan[i].end <= invSpan[i].start) {\n                invSpan.splice(i, 1);\n            }\n            if (invSpan[0].end <= invSpan[0].start) {\n                invSpan.splice(0, 1);\n            }\n            return invSpan;\n        },\n\n        loadRegion: function loadRegion(region) {\n            var d = new Deferred();\n\n            if (this.stores.length == 1) {\n                d.resolve(this, true);\n                return d.promise;\n            }\n            var thisB = this;\n            var regionLoaded = region;\n            regionLoaded.spans = [];\n\n            delete this.regionLoaded;\n\n            this._getFeatures(region, function () {}, function (results) {\n                if (results && results.spans) {\n                    regionLoaded.spans = results.spans;\n                    thisB.regionLoaded = regionLoaded;\n                }\n                d.resolve(thisB, true);\n            }, function () {\n                d.reject(\"cannot load region\");\n            });\n            return d.promise;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/Combination.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/CombinationBase.js":
/*!*********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/CombinationBase.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/when */ \"./node_modules/dojo/when.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/BinaryTreeNode */ \"./src/JBrowse/Model/BinaryTreeNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Deferred, when, all, SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, GlobalStatsEstimationMixin, Util, TreeNode) {\n    // Helper object that wraps a feature and which store it comes from\n    var featureWrapper = Util.fastDeclare({\n        get: function get(arg) {\n            return this.feature.get(arg);\n        },\n\n        id: function id() {\n            return this.feature.id() + this.storeName;\n        },\n\n        parent: function parent() {\n            return this.feature.parent();\n        },\n\n        children: function children() {\n            return this.feature.children();\n        },\n\n        tags: function tags() {\n            return this.feature.tags();\n        },\n\n        constructor: function constructor(feat, storeName) {\n            this.feature = feat;\n            this.storeName = storeName;\n            this.source = feat ? feat.source : undefined;\n        }\n    });\n\n    return declare([SeqFeatureStore, DeferredFeaturesMixin, DeferredStatsMixin, GlobalStatsEstimationMixin], {\n\n        // The base class for combination stores.  A combination store is one that pulls feature data from other stores\n        // and combines it according to a binary tree of operations in order to produce new features.\n\n        constructor: function constructor(args) {\n\n            // Objects can access this to know if a given store is a combination store of some kind\n            this.isCombinationStore = true;\n\n            this.defaultOp = args.op;\n\n            // If constructed with an opTree already included, might as well try to get all the store info from that opTree.\n            if (args.opTree) {\n                this.reload(args.opTree);\n            }\n        },\n\n        // Loads an operation tree (opTree).\n\n        reload: function reload(optree) {\n            this._deferred.features = new Deferred();\n            this._deferred.stats = new Deferred();\n            var refSeq;\n\n            // Load in opTree\n            if (!optree) {\n                optree = new TreeNode({ Value: this.defaultOp });\n            }\n            this.opTree = optree;\n            this.stores = optree.getLeaves() || [];\n\n            // If any of the stores doesn't have a name, then something weird is happening...\n            for (var store in this.stores) {\n                if (!this.stores[store].name) {\n                    this.stores = [];\n                }\n            }\n            var thisB = this;\n\n            this._deferred.features.resolve(true);\n            delete this._regionStatsCache;\n            this._estimateGlobalStats().then(dojo.hitch(this, function (stats) {\n                this.globalStats = stats;\n                this._deferred.stats.resolve({ success: true });\n            }), dojo.hitch(this, '_failAllDeferred'));\n        },\n\n        // Filters the featureArrays to return the list of features for the query, and then calls finish() to pass to the callback\n        _getFeatures: function _getFeatures(query, featCallback, doneCallback, errorCallback) {\n            var thisB = this;\n            if (this.stores.length == 1) {\n                this.stores[0].getFeatures(query, featCallback, doneCallback, errorCallback);\n                return;\n            }\n\n            if (this.regionLoaded) {\n                var spans = array.filter(this.regionLoaded.spans, function (span) {\n                    return span.start <= query.end && span.end >= query.start;\n                });\n                var features = this.createFeatures(spans);\n                this.finish(features, spans, featCallback, doneCallback);\n                return;\n            }\n\n            // featureArrays will be a map from the names of the stores to an array of each store's features\n            var featureArrays = {};\n\n            // Generate map\n            var fetchAllFeatures = thisB.stores.map(function (store) {\n                var d = new Deferred();\n                if (!featureArrays[store.name]) {\n                    featureArrays[store.name] = [];\n                    store.getFeatures(query, dojo.hitch(this, function (feature) {\n                        var feat = new featureWrapper(feature, store.name);\n                        featureArrays[store.name].push(feat);\n                    }), function () {\n                        d.resolve(featureArrays[store.name]);\n                    }, function () {\n                        d.reject(\"Error fetching features for store \" + store.name);\n                    });\n                } else {\n                    d.resolve(featureArrays[store.name], true);\n                }\n                d.then(function () {}, errorCallback); // Makes sure that none of the rejected deferred promises keep propagating\n                return d.promise;\n            });\n\n            // Once we have all features, combine them according to the operation tree and create new features based on them.\n            when(all(fetchAllFeatures), function () {\n                // Create a set of spans based on the evaluation of the operation tree\n                var spans = thisB.evalTree(featureArrays, thisB.opTree, query);\n                var features = thisB.createFeatures(spans);\n                thisB.finish(features, spans, featCallback, doneCallback);\n            }, errorCallback);\n        },\n\n        // Evaluate (recursively) an operation tree to create a list of spans (essentially pseudo-features)\n        evalTree: function evalTree(featureArrays, tree, query) {\n            if (!tree) {\n                return false;\n            } else if (tree.isLeaf()) {\n                return this.toSpan(featureArrays[tree.get().name], query);\n            } else if (!tree.hasLeft()) {\n                return this.toSpan(featureArrays[tree.right().get().name], query);\n            } else if (!tree.hasRight()) {\n                return this.toSpan(featureArrays[tree.left().get().name], query);\n            }\n            return this.opSpan(tree.get(), this.evalTree(featureArrays, tree.left(), query), this.evalTree(featureArrays, tree.right(), query), query);\n        },\n\n        // Passes the list of combined features to the getFeatures() callbacks\n        finish: function finish(features, spans, featCallback, doneCallback) {\n            /* Pass features to the track's original featCallback, and pass spans to the doneCallback.\n             */\n            for (var key in features) {\n                if (features.hasOwnProperty(key)) {\n                    featCallback(features[key]);\n                }\n            }\n            doneCallback({ spans: spans });\n        },\n\n        // These last four functions are stubbed out because each derived class should have its own implementation of them.\n\n        // Converts a list of spans into a list of features.\n        createFeatures: function createFeatures(spans) {},\n\n        // Transforms a set of features into a set of spans\n        toSpan: function toSpan(features, query) {},\n\n        // Defines the various operations that may occur and assigns each to a span-making function.\n        opSpan: function opSpan(op, span1, span2, query) {}\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/CombinationBase.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/Coverage.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/Coverage.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Store class that encapsulates another store, and synthesizes\n * quantitative features that give the depth of coverage for the\n * features in it.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/CoverageFeature */ \"./src/JBrowse/Model/CoverageFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, SeqFeatureStore, Util, CoverageFeature) {\n\n    return declare(SeqFeatureStore, {\n\n        constructor: function constructor(args) {\n            this.store = args.store;\n        },\n\n        getGlobalStats: function getGlobalStats(callback, errorCallback) {\n            callback({});\n        },\n\n        getFeatures: function getFeatures(query, featureCallback, finishCallback, errorCallback) {\n            var leftBase = query.start;\n            var rightBase = query.end;\n            var scale = query.scale || ('basesPerSpan' in query ? 1 / query.basesPerSpan : 10); // px/bp\n            var widthBp = rightBase - leftBase;\n            var widthPx = widthBp * scale;\n\n            var binWidth = Math.ceil(1 / scale); // in bp\n\n            var coverageBins = new Array(Math.ceil(widthBp / binWidth));\n            var binOverlap = function binOverlap(bp, isRightEnd) {\n                var binCoord = (bp - leftBase - 1) / binWidth;\n                var binNumber = Math.floor(binCoord);\n                var overlap = isRightEnd ? 1 - (binCoord - binNumber) : binCoord - binNumber;\n                return {\n                    bin: binNumber,\n                    overlap: overlap // between 0 and 1: proportion of this bin that the feature overlaps\n                };\n            };\n\n            this.store.getFeatures(query, function (feature) {\n                var startBO = binOverlap(feature.get('start'), false);\n                var endBO = binOverlap(feature.get('end'), true);\n\n                // increment start and end partial-overlap bins by proportion of overlap\n                if (startBO.bin == endBO.bin) {\n                    coverageBins[startBO.bin] = (coverageBins[startBO.bin] || 0) + endBO.overlap + startBO.overlap - 1;\n                } else {\n                    coverageBins[startBO.bin] = (coverageBins[startBO.bin] || 0) + startBO.overlap;\n                    coverageBins[endBO.bin] = (coverageBins[endBO.bin] || 0) + endBO.overlap;\n                }\n\n                // increment completely overlapped interior bins by 1\n                for (var i = startBO.bin + 1; i <= endBO.bin - 1; i++) {\n                    coverageBins[i] = (coverageBins[i] || 0) + 1;\n                }\n            }, function () {\n                // make fake features from the coverage\n                for (var i = 0; i < coverageBins.length; i++) {\n                    var score = coverageBins[i] || 0;\n                    var bpOffset = leftBase + binWidth * i;\n                    featureCallback(new CoverageFeature({\n                        start: bpOffset,\n                        end: bpOffset + binWidth,\n                        score: score\n                    }));\n                }\n                finishCallback();\n            }, errorCallback);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/Coverage.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/FromConfig.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/FromConfig.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Store that shows features defined in its `features` configuration\n * key, like:\n *   \"features\": [ { \"seq_id\": \"ctgA\", \"start\":1, \"end\":20 },\n *                 ...\n *               ]\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, SeqFeatureStore, SimpleFeature) {\n\n    return declare(SeqFeatureStore, {\n        constructor: function constructor(args) {\n            this.features = this._makeFeatures(this.config.features || []);\n        },\n\n        _makeFeatures: function _makeFeatures(fdata) {\n            var features = {};\n            for (var i = 0; i < fdata.length; i++) {\n                if (fdata[i]) {\n                    var f = this._makeFeature(fdata[i]);\n                    var refName = this.browser.regularizeReferenceName(f.get('seq_id'));\n                    var refFeatures = features[refName] || function () {\n                        return features[refName] = [];\n                    }.call();\n                    refFeatures.push(f);\n                }\n            }\n            return features;\n        },\n\n        _parseInt: function _parseInt(data) {\n            array.forEach(['start', 'end', 'strand'], function (field) {\n                if (field in data) data[field] = parseInt(data[field]);\n            });\n            if ('score' in data) data.score = parseFloat(data.score);\n            if ('subfeatures' in data) for (var i = 0; i < data.subfeatures.length; i++) {\n                this._parseInt(data.subfeatures[i]);\n            }\n        },\n\n        _makeFeature: function _makeFeature(data, parent) {\n            this._parseInt(data);\n            return new SimpleFeature({ data: data, parent: parent });\n        },\n\n        getGlobalStats: function getGlobalStats(cb, errorCb) {\n            this.getRegionStats({ ref: this.refSeq.name, start: this.refSeq.start, end: this.refSeq.end }, cb, errorCb);\n        },\n\n        getFeatures: function getFeatures(query, featCallback, endCallback, errorCallback) {\n            var start = query.start;\n            var end = query.end;\n            var features = this.features[this.browser.regularizeReferenceName(query.ref)] || {};\n            for (var id in features) {\n                var f = features[id];\n                if (!(f.get('end') < start || f.get('start') > end)) {\n                    featCallback(f);\n                }\n            }\n            endCallback();\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/FromConfig.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/GFF3.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/GFF3.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _gff = __webpack_require__(/*! @gmod/gff */ \"./node_modules/@gmod/gff/dist/index.js\");\n\nvar _gff2 = _interopRequireDefault(_gff);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/RegionStatsMixin */ \"./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, Deferred, Util, SimpleFeature, SeqFeatureStore, DeferredFeatures, DeferredStats, GlobalStatsEstimationMixin, RegionStatsMixin, XHRBlob) {\n\n    return declare([SeqFeatureStore, DeferredFeatures, DeferredStats, GlobalStatsEstimationMixin, RegionStatsMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.GFF3\n     */\n    {\n        constructor: function constructor(args) {\n            this.data = args.blob || new XHRBlob(this.resolveUrl(this._evalConf(args.urlTemplate)));\n            this.features = [];\n            this._loadFeatures();\n        },\n\n        _loadFeatures: function _loadFeatures() {\n            var _this = this;\n\n            var features = this.bareFeatures = [];\n\n            var featuresSorted = true;\n            var seenRefs = this.refSeqs = {};\n\n            var addFeature = function addFeature(fs) {\n                fs.forEach(function (feature) {\n                    var prevFeature = features[features.length - 1];\n                    var regRefName = _this.browser.regularizeReferenceName(feature.seq_id);\n                    if (regRefName in seenRefs && prevFeature && prevFeature.seq_id != feature.seq_id) featuresSorted = false;\n                    if (prevFeature && prevFeature.seq_id == feature.seq_id && feature.start < prevFeature.start) featuresSorted = false;\n\n                    if (!(regRefName in seenRefs)) seenRefs[regRefName] = features.length;\n\n                    features.push(feature);\n                });\n            };\n\n            var endFeatures = function endFeatures() {\n                if (!featuresSorted) {\n                    features.sort(_this._compareFeatureData);\n                    // need to rebuild the refseq index if changing the sort order\n                    _this._rebuildRefSeqs(features);\n                }\n\n                _this._estimateGlobalStats().then(function (stats) {\n                    _this.globalStats = stats;\n                    _this._deferred.stats.resolve();\n                });\n\n                _this._deferred.features.resolve(features);\n            };\n\n            var fail = this._failAllDeferred.bind(this);\n\n            var parseStream = _gff2.default.parseStream({\n                parseFeatures: true,\n                parseSequences: false\n            }).on('data', addFeature).on('end', endFeatures).on('error', fail);\n\n            // parse the whole file and store it\n            this.data.fetchLines(function (line) {\n                return parseStream.write(line);\n            }, function () {\n                return parseStream.end();\n            }, fail);\n        },\n\n\n        _rebuildRefSeqs: function _rebuildRefSeqs(features) {\n            var refs = {};\n            for (var i = 0; i < features.length; i++) {\n                var regRefName = this.browser.regularizeReferenceName(features[i].seq_id);\n\n                if (!(regRefName in refs)) refs[regRefName] = i;\n            }\n            this.refSeqs = refs;\n        },\n\n        _compareFeatureData: function _compareFeatureData(a, b) {\n            if (a.seq_id < b.seq_id) return -1;else if (a.seq_id > b.seq_id) return 1;\n\n            return a.start - b.start;\n        },\n\n        _getFeatures: function _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n            var thisB = this;\n            thisB._deferred.features.then(function () {\n                thisB._search(query, featureCallback, finishedCallback, errorCallback);\n            });\n        },\n\n        _search: function _search(query, featureCallback, finishCallback, errorCallback) {\n            // search in this.features, which are sorted\n            // by ref and start coordinate, to find the beginning of the\n            // relevant range\n            var bare = this.bareFeatures;\n            var converted = this.features;\n\n            var refName = this.browser.regularizeReferenceName(query.ref);\n\n            var i = this.refSeqs[refName];\n            if (!(i >= 0)) {\n                finishCallback();\n                return;\n            }\n\n            var checkEnd = 'start' in query ? function (f) {\n                return f.get('end') >= query.start;\n            } : function () {\n                return true;\n            };\n\n            for (; i < bare.length; i++) {\n                // lazily convert the bare feature data to JBrowse features\n                var f = converted[i] || (converted[i] = function (b, i) {\n                    bare[i] = false;\n                    return this._formatFeature(b);\n                }.call(this, bare[i], i));\n                // features are sorted by ref seq and start coord, so we\n                // can stop if we are past the ref seq or the end of the\n                // query region\n                if (f._reg_seq_id != refName || f.get('start') > query.end) break;\n\n                if (checkEnd(f)) {\n                    this.applyFeatureTransforms([f]).forEach(featureCallback);\n                }\n            }\n\n            finishCallback();\n        },\n\n        supportsFeatureTransforms: true,\n\n        _formatFeature: function _formatFeature(data) {\n            var f = new SimpleFeature({\n                data: this._featureData(data),\n                id: (data.attributes.ID || [])[0]\n            });\n            f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id);\n            return f;\n        },\n\n        _featureData: function _featureData(data) {\n            var f = lang.mixin({}, data);\n            delete f.child_features;\n            delete f.derived_features;\n            delete f.attributes;\n            f.start -= 1; // convert to interbase\n            f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[data.strand];\n            var defaultFields = ['start', 'end', 'seq_id', 'score', 'type', 'source', 'phase', 'strand'];\n            for (var a in data.attributes) {\n                var b = a.toLowerCase();\n                if (defaultFields.includes(b)) b += '2'; //reproduce behavior of NCList\n                f[b] = data.attributes[a];\n                if (f[b].length == 1) f[b] = f[b][0];\n            }\n            var sub = array.map(Util.flattenOneLevel(data.child_features), this._featureData, this);\n            if (sub.length) f.subfeatures = sub;\n\n            return f;\n        },\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            var thisB = this;\n            this._deferred.features.then(function () {\n                callback(thisB.browser.regularizeReferenceName(seqName) in thisB.refSeqs);\n            });\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.blob.url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/GFF3.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/GFF3Tabix.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/GFF3Tabix.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var gff = __webpack_require__(/*! @gmod/gff */ \"./node_modules/@gmod/gff/dist/index.js\").default;\n\nvar _cjsRequire = __webpack_require__(/*! @gmod/tabix */ \"./node_modules/@gmod/tabix/dist/index.js\"),\n    TabixIndexedFile = _cjsRequire.TabixIndexedFile;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/RegionStatsMixin */ \"./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js\"), __webpack_require__(/*! JBrowse/Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, Errors, SimpleFeature, SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin, RegionStatsMixin, BlobFilehandleWrapper, XHRBlob) {\n\n    return declare([SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin, RegionStatsMixin], {\n        supportsFeatureTransforms: true,\n\n        constructor: function constructor(args) {\n            var _this = this;\n\n            this.dontRedispatch = (args.dontRedispatch || 'chromosome,region').split(/\\s*,\\s*/);\n            var csiBlob, tbiBlob;\n\n            if (args.csi || this.config.csiUrlTemplate) {\n                csiBlob = args.csi || new XHRBlob(this.resolveUrl(this.getConf('csiUrlTemplate', [])));\n            } else {\n                tbiBlob = args.tbi || new XHRBlob(this.resolveUrl(this.getConf('tbiUrlTemplate', []) || this.getConf('urlTemplate', []) + '.tbi'));\n            }\n\n            var fileBlob = args.file || new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), { expectRanges: true });\n\n            this.indexedData = new TabixIndexedFile({\n                filehandle: new BlobFilehandleWrapper(fileBlob),\n                tbiFilehandle: tbiBlob && new BlobFilehandleWrapper(tbiBlob),\n                csiFilehandle: csiBlob && new BlobFilehandleWrapper(csiBlob),\n                chunkSizeLimit: args.chunkSizeLimit || 1000000,\n                renameRefSeqs: function renameRefSeqs(n) {\n                    return _this.browser.regularizeReferenceName(n);\n                }\n            });\n\n            // start our global stats estimation\n            this.indexedData.lineCount('nonexistent').then(function () {\n                _this._deferred.features.resolve({ success: true });\n                _this._estimateGlobalStats().then(function (stats) {\n                    _this.globalStats = stats;\n                    _this._deferred.stats.resolve(stats);\n                }, function (err) {\n                    return _this._failAllDeferred(err);\n                });\n            }, function (err) {\n                return _this._failAllDeferred(err);\n            });\n        },\n        _parseLine: function _parseLine(columnNumbers, line, fileOffset) {\n            var fields = line.split(\"\\t\");\n\n            return { // note: index column numbers are 1-based\n                start: parseInt(fields[columnNumbers.start - 1]),\n                end: parseInt(fields[columnNumbers.end - 1]),\n                lineHash: fileOffset,\n                fields: fields\n            };\n        },\n        _getFeatures: function _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n            var _this2 = this;\n\n            var allowRedispatch = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n            this.indexedData.getMetadata().then(function (metadata) {\n                var regularizedReferenceName = _this2.browser.regularizeReferenceName(query.ref);\n                var lines = [];\n                _this2.indexedData.getLines(regularizedReferenceName || _this2.refSeq.name, query.start, query.end, function (line, fileOffset) {\n                    lines.push(_this2._parseLine(metadata.columnNumbers, line, fileOffset));\n                }).then(function () {\n                    // If this is the first fetch (allowRedispatch is true), check whether\n                    // any of the features protrude out of the queried range.\n                    // If it is, redo the fetch to fetch the max span of the features, so\n                    // that we will get all of the child features of the top-level features.\n                    // This assumes that child features will always fall within the span\n                    // of the parent feature, which isn't true in the general case, but\n                    // this should work for most use cases\n                    if (allowRedispatch && lines.length) {\n                        var minStart = Infinity;\n                        var maxEnd = -Infinity;\n                        lines.forEach(function (line) {\n                            var featureType = line.fields[2];\n                            // only expand redispatch range if the feature is not in dontRedispatch,\n                            // and is a top-level feature\n                            if (!_this2.dontRedispatch.includes(featureType) && _this2._isTopLevelFeatureType(featureType)) {\n                                var start = line.start - 1; // gff is 1-based\n                                if (start < minStart) minStart = start;\n                                if (line.end > maxEnd) maxEnd = line.end;\n                            }\n                        });\n                        if (maxEnd > query.end || minStart < query.start) {\n                            // console.log(`redispatching ${query.start}-${query.end} => ${minStart}-${maxEnd}`)\n                            var newQuery = Object.assign({}, query, {\n                                start: minStart,\n                                end: maxEnd\n                            });\n                            // make a new feature callback to only return top-level features\n                            // in the original query range\n                            var newFeatureCallback = function newFeatureCallback(feature) {\n                                if (feature.get('start') < query.end && feature.get('end') > query.start) {\n                                    featureCallback(feature);\n                                }\n                            };\n                            _this2._getFeatures(newQuery, newFeatureCallback, finishedCallback, errorCallback, false);\n                            return;\n                        }\n                    }\n\n                    // decorate each of the lines with a _lineHash attribute\n                    var gff3 = lines.map(function (lineRecord) {\n                        // add a lineHash attr to each gff3 line sayings its offset in\n                        // the file, we can use this later to synthesize a unique ID for\n                        // features that don't have one\n                        if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n                            if (!lineRecord.fields[8].includes('_lineHash')) lineRecord.fields[8] += ';_lineHash=' + lineRecord.lineHash;\n                        } else {\n                            lineRecord.fields[8] = '_lineHash=' + lineRecord.lineHash;\n                        }\n                        return lineRecord.fields.join('\\t');\n                    }).join('\\n');\n                    var features = gff.parseStringSync(gff3, {\n                        parseFeatures: true,\n                        parseComments: false,\n                        parseDirectives: false,\n                        parseSequences: false\n                    });\n\n                    features.forEach(function (feature) {\n                        return _this2.applyFeatureTransforms(_this2._formatFeatures(feature)).forEach(featureCallback);\n                    });\n                    finishedCallback();\n                }, function (error) {\n                    if (errorCallback) {\n                        if (error.message && error.message.indexOf('Too much data') >= 0) {\n                            error = new Errors.DataOverflow(error.message);\n                        }\n                        errorCallback(error);\n                    } else console.error(error);\n                }).catch(errorCallback);\n            }, errorCallback);\n        },\n        _featureData: function _featureData(data) {\n            var _this3 = this;\n\n            var f = Object.assign({}, data);\n            delete f.child_features;\n            delete f.data;\n            delete f.derived_features;\n            f.start -= 1; // convert to interbase\n            f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[f.strand]; // convert strand\n            var defaultFields = ['start', 'end', 'seq_id', 'score', 'type', 'source', 'phase', 'strand'];\n            for (var a in data.attributes) {\n                var b = a.toLowerCase();\n                if (defaultFields.includes(b)) b += '2'; //reproduce behavior of NCList\n                f[b] = data.attributes[a];\n                if (f[b].length == 1) f[b] = f[b][0];\n            }\n            f.uniqueID = 'offset-' + f._linehash;\n\n            delete f._linehash;\n            delete f.attributes;\n            // the SimpleFeature constructor takes care of recursively inflating subfeatures\n            if (data.child_features && data.child_features.length) {\n                f.subfeatures = Util.flattenOneLevel(data.child_features.map(function (childLocs) {\n                    return childLocs.map(function (childLoc) {\n                        return _this3._featureData(childLoc);\n                    });\n                }));\n            }\n\n            return f;\n        },\n\n\n        /**\n         * A GFF3 feature is an arrayref of that feature's locations. Because a single feature could be\n         * in multiple locations. To match that with the JBrowse feature model, we treat each of those\n         * locations as a separate feature, and disambiguate them by appending an index to their ID\n         */\n        _formatFeatures: function _formatFeatures(featureLocs) {\n            var _this4 = this;\n\n            var features = [];\n            featureLocs.forEach(function (featureLoc, locIndex) {\n                var ids = featureLoc.attributes.ID || ['offset-' + featureLoc.attributes._lineHash[0]];\n                ids.forEach(function (id, idIndex) {\n                    var f = new SimpleFeature({\n                        data: _this4._featureData(featureLoc),\n                        id: idIndex === 0 ? id : id + '-' + (idIndex + 1)\n                    });\n                    f._reg_seq_id = _this4.browser.regularizeReferenceName(featureLoc.seq_id);\n                    features.push(f);\n                });\n            });\n            return features;\n        },\n\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            return this.indexedData.hasRefSeq(seqName, callback, errorCallback);\n        },\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.file.url,\n                tbiUrlTemplate: (this.config.tbi || {}).url,\n                csiUrlTemplate: (this.config.csi || {}).url\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/GFF3Tabix.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/GTF.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/GTF.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! ./GTF/Parser */ \"./src/JBrowse/Store/SeqFeature/GTF/Parser.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, Deferred, Util, SimpleFeature, SeqFeatureStore, DeferredFeatures, DeferredStats, GlobalStatsEstimationMixin, XHRBlob, Parser) {\n\n    return declare([SeqFeatureStore, DeferredFeatures, DeferredStats, GlobalStatsEstimationMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.GTF\n     */\n    {\n        constructor: function constructor(args) {\n            this.data = args.blob || new XHRBlob(this.resolveUrl(args.urlTemplate));\n            this.features = [];\n            this._loadFeatures();\n        },\n\n        _loadFeatures: function _loadFeatures() {\n            var thisB = this;\n            var features = this.bareFeatures = [];\n\n            var featuresSorted = true;\n            var seenRefs = this.refSeqs = {};\n            var parser = new Parser({\n                featureCallback: function featureCallback(fs) {\n                    array.forEach(fs, function (feature) {\n                        var prevFeature = features[features.length - 1];\n                        var regRefName = thisB.browser.regularizeReferenceName(feature.seq_id);\n                        if (regRefName in seenRefs && prevFeature && prevFeature.seq_id != feature.seq_id) featuresSorted = false;\n                        if (prevFeature && prevFeature.seq_id == feature.seq_id && feature.start < prevFeature.start) featuresSorted = false;\n\n                        if (!(regRefName in seenRefs)) seenRefs[regRefName] = features.length;\n\n                        features.push(feature);\n                    });\n                },\n                endCallback: function endCallback() {\n                    if (!featuresSorted) {\n                        features.sort(thisB._compareFeatureData);\n                        // need to rebuild the refseq index if changing the sort order\n                        thisB._rebuildRefSeqs(features);\n                    }\n\n                    thisB._estimateGlobalStats().then(function (stats) {\n                        thisB.globalStats = stats;\n                        thisB._deferred.stats.resolve();\n                    });\n\n                    thisB._deferred.features.resolve(features);\n                }\n            });\n            var fail = lang.hitch(this, '_failAllDeferred');\n            // parse the whole file and store it\n            this.data.fetchLines(function (line) {\n                try {\n                    parser.addLine(line);\n                } catch (e) {\n                    fail('Error parsing GTF.');\n                    throw e;\n                }\n            }, lang.hitch(parser, 'finish'), fail);\n        },\n\n        _rebuildRefSeqs: function _rebuildRefSeqs(features) {\n            var refs = {};\n            for (var i = 0; i < features.length; i++) {\n                var regRefName = this.browser.regularizeReferenceName(features[i].seq_id);\n\n                if (!(regRefName in refs)) refs[regRefName] = i;\n            }\n            this.refSeqs = refs;\n        },\n\n        _compareFeatureData: function _compareFeatureData(a, b) {\n            if (a.seq_id < b.seq_id) return -1;else if (a.seq_id > b.seq_id) return 1;\n\n            return a.start - b.start;\n        },\n\n        _getFeatures: function _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n            var thisB = this;\n            thisB._deferred.features.then(function () {\n                thisB._search(query, featureCallback, finishedCallback, errorCallback);\n            });\n        },\n\n        _search: function _search(query, featureCallback, finishCallback, errorCallback) {\n            // search in this.features, which are sorted\n            // by ref and start coordinate, to find the beginning of the\n            // relevant range\n            var bare = this.bareFeatures;\n            var converted = this.features;\n\n            var refName = this.browser.regularizeReferenceName(query.ref);\n\n            var i = this.refSeqs[refName];\n            if (!(i >= 0)) {\n                finishCallback();\n                return;\n            }\n\n            var checkEnd = 'start' in query ? function (f) {\n                return f.get('end') >= query.start;\n            } : function () {\n                return true;\n            };\n\n            for (; i < bare.length; i++) {\n                // lazily convert the bare feature data to JBrowse features\n                var f = converted[i] || (converted[i] = function (b, i) {\n                    bare[i] = false;\n                    return this._formatFeature(b);\n                }.call(this, bare[i], i));\n                // features are sorted by ref seq and start coord, so we\n                // can stop if we are past the ref seq or the end of the\n                // query region\n                if (f._reg_seq_id != refName || f.get('start') > query.end) break;\n\n                if (checkEnd(f)) {\n                    this.applyFeatureTransforms([f]).forEach(featureCallback);\n                }\n            }\n\n            finishCallback();\n        },\n\n        supportsFeatureTransforms: true,\n\n        _formatFeature: function _formatFeature(data) {\n            var f = new SimpleFeature({\n                data: this._featureData(data),\n                id: (data.attributes.ID || [])[0]\n            });\n            f._reg_seq_id = this.browser.regularizeReferenceName(data.seq_id);\n            return f;\n        },\n\n        _featureData: function _featureData(data) {\n            var f = lang.mixin({}, data);\n            delete f.child_features;\n            delete f.derived_features;\n            delete f.attributes;\n            f.start -= 1; // convert to interbase\n            for (var a in data.attributes) {\n                f[a.toLowerCase()] = data.attributes[a].join(',');\n            }\n            var sub = array.map(Util.flattenOneLevel(data.child_features), this._featureData, this);\n            if (sub.length) f.subfeatures = sub;\n\n            return f;\n        },\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            var thisB = this;\n            this._deferred.features.then(function () {\n                callback(thisB.browser.regularizeReferenceName(seqName) in thisB.refSeqs);\n            });\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.blob.url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/GTF.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/GTF/Parser.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/GTF/Parser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// the challenge with GTF is that there is no parent relationship\n// every feature line has a gene_id and a transcript_id but there are no ids that uniquely id each feature\n// in eukaryotes a gene can have multiple transcripts\n// in prokaryotes a transcript can have multiple genes\n// here we just create transcript features with children features and let 'gene_ids' simply be attributes not a feature in themselves\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\"), __webpack_require__(/*! JBrowse/Util/GTF */ \"./src/JBrowse/Util/GTF.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, JSON, GTF) {\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            lang.mixin(this, {\n                featureCallback: args.featureCallback || function () {},\n                endCallback: args.endCallback || function () {},\n                commentCallback: args.commentCallback || function () {},\n                errorCallback: args.errorCallback || function (e) {\n                    console.error(e);\n                },\n                directiveCallback: args.directiveCallback || function () {},\n\n                // features that we have to keep on hand for now because they\n                // might be referenced by something else\n                under_construction_top_level: [],\n                // index of the above by ID\n                under_construction_by_id: {},\n\n                completed_references: {},\n\n                // features that reference something we have not seen yet\n                // structured as:\n                // {  'some_id' : {\n                //     'Parent' : [ orphans that have a Parent attr referencing it ],\n                //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n                // }\n                under_construction_orphans: {},\n\n                // if this is true, the parser ignores the\n                // rest of the lines in the file.  currently\n                // set when the file switches over to FASTA\n                eof: false\n            });\n        },\n\n        addLine: function addLine(line) {\n            var match;\n            if (this.eof) {\n                // do nothing\n            } else if (/^\\s*[^#\\s>]/.test(line)) {\n                //< feature line, most common case\n                var f = GTF.parse_feature(line);\n                this._buffer_feature(f);\n            }\n            // directive or comment\n            else if (match = /^\\s*(\\#+)(.*)/.exec(line)) {\n                    var hashsigns = match[1],\n                        contents = match[2];\n                    if (hashsigns.length == 3) {\n                        //< sync directive, all forward-references are resolved.\n                        this._return_all_under_construction_features();\n                    } else if (hashsigns.length == 2) {\n                        var directive = GTF.parse_directive(line);\n                        if (directive.directive == 'FASTA') {\n                            this._return_all_under_construction_features();\n                            this.eof = true;\n                        } else {\n                            this._return_item(directive);\n                        }\n                    } else {\n                        contents = contents.replace(/\\s*/, '');\n                        this._return_item({ comment: contents });\n                    }\n                } else if (/^\\s*$/.test(line)) {\n                    // blank line, do nothing\n                } else if (/^\\s*>/.test(line)) {\n                    // implicit beginning of a FASTA section.  just stop\n                    // parsing, since we don't currently handle sequences\n                    this._return_all_under_construction_features();\n                    this.eof = true;\n                } else {\n                    // it's a parse error\n                    line = line.replace(/\\r?\\n?$/g, '');\n                    throw \"GTF parse error.  Cannot parse '\" + line + \"'.\";\n                }\n        },\n\n        _return_item: function _return_item(i) {\n            if (i[0]) this.featureCallback(i);else if (i.directive) this.directiveCallback(i);else if (i.comment) this.commentCallback(i);\n        },\n\n        finish: function finish() {\n            this._return_all_under_construction_features();\n            this.endCallback();\n        },\n\n        /**\n         * return all under-construction features, called when we know\n         * there will be no additional data to attach to them\n         */\n        _return_all_under_construction_features: function _return_all_under_construction_features() {\n            // since the under_construction_top_level buffer is likely to be\n            // much larger than the item_buffer, we swap them and unshift the\n            // existing buffer onto it to avoid a big copy.\n            array.forEach(this.under_construction_top_level, this._return_item, this);\n\n            this.under_construction_top_level = [];\n            this.under_construction_by_id = {};\n            this.completed_references = {};\n\n            // if we have any orphans hanging around still, this is a\n            // problem. die with a parse error\n            for (var o in this.under_construction_orphans) {\n                for (var orphan in o) {\n                    throw \"parse error: orphans \" + JSON.stringify(this.under_construction_orphans);\n                }\n            }\n        },\n\n        container_attributes: { Parent: 'child_features', Derives_from: 'derived_features' },\n        line_number: 0,\n\n        // do the right thing with a newly-parsed feature line\n        _buffer_feature: function _buffer_feature(feature_line) {\n            feature_line.child_features = [];\n            feature_line.derived_features = [];\n\n            // NOTE: a feature is an arrayref of one or more feature lines.\n            this.line_number = this.line_number + 1;\n            var feature_number = this.line_number; // no such thing as unique ID in GTF. make one up.\n            var is_transcript = feature_line.type == 'transcript'; //trying to support the Cufflinks convention of adding a transcript line\n            var ids = is_transcript ? feature_line.attributes.transcript_id || [] : [feature_number];\n            var parents = is_transcript ? [] : feature_line.attributes.transcript_id || [];\n            var derives = feature_line.attributes.Derives_from || [];\n\n            if (!ids.length && !parents.length && !derives.length) {\n                // if it has no IDs and does not refer to anything, we can just\n                // output it\n                this._return_item([feature_line]);\n                return;\n            }\n            array.forEach(parents, function (id) {\n                if (!this.under_construction_by_id[id]) {\n                    this._buffer_feature(this._create_transcript(feature_line));\n                }\n            }, this);\n\n            var feature;\n            array.forEach(ids, function (id) {\n                var existing;\n                if (existing = this.under_construction_by_id[id]) {\n                    // another location of the same feature\n                    existing.push(feature_line);\n                    feature = existing;\n                } else {\n                    // haven't seen it yet\n                    feature = [feature_line];\n                    if (!parents.length && !derives.length) {\n                        this.under_construction_top_level.push(feature);\n                    }\n                    this.under_construction_by_id[id] = feature;\n\n                    // see if we have anything buffered that refers to it\n                    this._resolve_references_to(feature, id);\n                }\n            }, this);\n\n            // try to resolve all its references\n            this._resolve_references_from(feature || [feature_line], { Parent: parents, Derives_from: derives }, ids);\n        },\n\n        _create_transcript: function _create_transcript(feature) {\n            var result = JSON.parse(JSON.stringify(feature));\n            result.type = 'transcript';\n            //result.attributes={'transcript_id':result.attributes.transcript_id, 'gene_id':result.attributes.gene_id};\n            return result;\n        },\n\n        //there are no unique ids so no chance for collision just use first elements\n        _expand_feature: function _expand_feature(parent_feature, child_feature) {\n            parent_feature[0].start = Math.min(parent_feature[0].start, child_feature[0].start);\n            parent_feature[0].end = Math.max(parent_feature[0].end, child_feature[0].end);\n        },\n\n        _resolve_references_to: function _resolve_references_to(feature, id) {\n            var references = this.under_construction_orphans[id];\n            if (!references) return;\n\n            for (var attrname in references) {\n                var pname = this.container_attributes[attrname] || attrname.toLowerCase();\n                array.forEach(feature, function (loc) {\n                    loc[pname].push(references[attrname]);\n                    delete references[attrname];\n                });\n            }\n        },\n        _resolve_references_from: function _resolve_references_from(feature, references, ids) {\n            // go through our references\n            //  if we have the feature under construction, put this feature in the right place\n            //  otherwise, put this feature in the right slot in the orphans\n\n            var pname;\n            for (var attrname in references) {\n                array.forEach(references[attrname], function (to_id) {\n                    var other_feature;\n                    if (other_feature = this.under_construction_by_id[to_id]) {\n                        this._expand_feature(other_feature, feature);\n                        if (!pname) pname = this.container_attributes[attrname] || attrname.toLowerCase();\n                        if (!array.some(ids, function (i) {\n                            return this.completed_references[i + ',' + attrname + ',' + to_id]++;\n                        }, this)) {\n                            array.forEach(other_feature, function (loc) {\n                                loc[pname].push(feature);\n                            });\n                        }\n                    } else {\n                        (this.under_construction_orphans[to_id][attrname] = this.under_construction_orphans[to_id][attrname] || []).push(feature);\n                    }\n                }, this);\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/GTF/Parser.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js":
/*!********************************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Mixin that adds _estimateGlobalStats method to a store, which\n * samples a section of the features in the store and uses those to\n * esimate the statistics of the whole data set.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Deferred, Errors) {\n\n    return declare(null, {\n\n        /**\n         * Fetch a region of the current reference sequence and use it to\n         * estimate the feature density of the store.\n         * @private\n         */\n        _estimateGlobalStats: function _estimateGlobalStats(refseq) {\n            var deferred = new Deferred();\n\n            refseq = refseq || this.refSeq;\n            var timeout = this.storeTimeout || 3000;\n            if (this.storeTimeout == 0) {\n                deferred.resolve({ featureDensity: 0, error: 'global stats estimation timed out' });\n                return;\n            }\n\n            var startTime = new Date();\n\n            var statsFromInterval = function statsFromInterval(length, callback) {\n                var thisB = this;\n                var sampleCenter = refseq.start * 0.75 + refseq.end * 0.25;\n                var start = Math.max(0, Math.round(sampleCenter - length / 2));\n                var end = Math.min(Math.round(sampleCenter + length / 2), refseq.end);\n                var features = [];\n                //console.log(`${this.source} stats fetching ${refseq.name}:${start}..${end}`)\n                this._getFeatures({ ref: refseq.name, start: start, end: end }, function (f) {\n                    features.push(f);\n                }, function (error) {\n                    features = array.filter(features, function (f) {\n                        return f.get('start') >= start && f.get('end') <= end;\n                    });\n                    var correctionFactor = (thisB.getConf('topLevelFeaturesPercent') || 100) / 100;\n                    callback.call(thisB, length, {\n                        featureDensity: features.length / length * correctionFactor,\n                        _correctionFactor: correctionFactor,\n                        _statsSampleFeatures: features.length,\n                        _statsSampleInterval: { ref: refseq.name, start: start, end: end, length: length }\n                    });\n                }, function (error) {\n                    callback.call(thisB, length, null, error);\n                });\n            };\n\n            var maybeRecordStats = function maybeRecordStats(interval, stats, error) {\n                if (error) {\n                    if (error.isInstanceOf && error.isInstanceOf(Errors.DataOverflow)) {\n                        console.log('Store statistics found chunkSizeLimit error, using empty: ' + (this.source || this.name));\n                        deferred.resolve({ featureDensity: 0, error: 'global stats estimation found chunkSizeError' });\n                    } else {\n                        deferred.reject(error);\n                    }\n                } else {\n                    var refLen = refseq.end - refseq.start;\n                    if (stats._statsSampleFeatures >= 300 || interval * 2 > refLen || error) {\n                        console.log('Store statistics: ' + (this.source || this.name), stats);\n                        deferred.resolve(stats);\n                    } else if (new Date() - startTime < timeout) {\n                        statsFromInterval.call(this, interval * 2, maybeRecordStats);\n                    } else {\n                        console.log('Store statistics timed out: ' + (this.source || this.name));\n                        deferred.resolve({ featureDensity: 0, error: 'global stats estimation timed out' });\n                    }\n                }\n            };\n\n            statsFromInterval.call(this, 100, maybeRecordStats);\n            return deferred;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/IndexedFasta.js":
/*!******************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/IndexedFasta.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar LRU = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n\nvar _cjsRequire = __webpack_require__(/*! @gmod/indexedfasta */ \"./node_modules/@gmod/indexedfasta/dist/index.js\"),\n    IndexedFasta = _cjsRequire.IndexedFasta;\n\nvar _cjsRequire2 = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _cjsRequire2.Buffer;\n\nvar fastaIndexedFilesCache = new LRU({ maxSize: 5 });\n\nvar BlobFilehandleWrapper = __webpack_require__(/*! ../../Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, SeqFeatureStore, XHRBlob, SimpleFeature, DeferredFeaturesMixin) {\n\n    return declare([SeqFeatureStore, DeferredFeaturesMixin], {\n\n        /**\n         * Storage backend for sequences in indexed fasta files\n         * served as static text files.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var dataBlob = void 0;\n            if (args.fasta) dataBlob = new BlobFilehandleWrapper(args.fasta);else if (args.urlTemplate) dataBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate), { expectRanges: true }));else dataBlob = new BlobFilehandleWrapper(new XHRBlob('data.fa', { expectRanges: true }));\n\n            var indexBlob = void 0;\n            if (args.fai) indexBlob = new BlobFilehandleWrapper(args.fai);else if (args.faiUrlTemplate) indexBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.faiUrlTemplate)));else if (args.urlTemplate) indexBlob = new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(args.urlTemplate + '.fai')));else throw new Error('no index provided, must provide a FASTA index');\n\n            this.source = dataBlob.toString();\n\n            // LRU-cache the FASTA object so we don't have to re-download the\n            // index when we switch chromosomes\n            var cacheKey = 'data: ' + dataBlob + ', index: ' + indexBlob;\n            this.fasta = fastaIndexedFilesCache.get(cacheKey);\n            if (!this.fasta) {\n                this.fasta = new IndexedFasta({\n                    fasta: dataBlob,\n                    fai: indexBlob,\n                    chunkSizeLimit: args.chunkSizeLimit || 1000000\n                });\n\n                fastaIndexedFilesCache.set(cacheKey, this.fasta);\n            }\n            this.fasta.getSequenceList().then(function () {\n                _this._deferred.features.resolve({ success: true });\n            }, this._failAllDeferred.bind(this));\n        },\n\n        _getFeatures: function _getFeatures(query, featCallback, endCallback, errorCallback) {\n            if (query.start < 0) {\n                query.start = 0;\n            }\n            var refname = query.ref;\n            // if they both regularize to the same thing, use this.refSeq.name since that is guaranteed to be from refseq store\n            if (!this.browser.compareReferenceNames(this.refSeq.name, refname)) refname = this.refSeq.name;\n\n            this.fasta.getResiduesByName(refname, query.start, query.end).then(function (seq) {\n                featCallback(new SimpleFeature({ data: { seq: seq, start: query.start, end: query.end } }));\n                endCallback();\n            }, errorCallback);\n        },\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            this.fasta.getSequenceSize(seqName).then(function (size) {\n                callback(size !== undefined);\n            }, errorCallback);\n        },\n        getRefSeqs: function getRefSeqs(callback, errorCallback) {\n            this.fasta.getSequenceSizes().then(function (sizes) {\n                return Object.entries(sizes).map(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                        name = _ref2[0],\n                        length = _ref2[1];\n\n                    return {\n                        name: name,\n                        length: length,\n                        end: length,\n                        start: 0\n                    };\n                });\n            }).then(callback, errorCallback);\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: (this.config.file || this.config.blob).url,\n                faiUrlTemplate: this.config.fai.url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/IndexedFasta.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js":
/*!*********************************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Deferred, Errors, GlobalStats) {\n\n    return declare(GlobalStats, {\n\n        /**\n         * Fetch a region of the current reference sequence and use it to\n         * estimate the feature density of the store.\n         * @private\n         */\n        _estimateGlobalStats: function _estimateGlobalStats(refseq) {\n            var _this = this,\n                _arguments = arguments;\n\n            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n                var featCount, chr, chrId, correctionFactor, featureDensity;\n                return regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                refseq = refseq || _this.refSeq;\n                                featCount = void 0;\n\n                                if (!_this.indexedData) {\n                                    _context.next = 8;\n                                    break;\n                                }\n\n                                _context.next = 5;\n                                return _this.indexedData.lineCount(_this.browser.regularizeReferenceName(refseq.name));\n\n                            case 5:\n                                featCount = _context.sent;\n                                _context.next = 14;\n                                break;\n\n                            case 8:\n                                if (!_this.bam) {\n                                    _context.next = 14;\n                                    break;\n                                }\n\n                                chr = _this.browser.regularizeReferenceName(refseq.name);\n                                chrId = _this.bam.chrToIndex && _this.bam.chrToIndex[chr];\n                                _context.next = 13;\n                                return _this.bam.index.lineCount(chrId, true);\n\n                            case 13:\n                                featCount = _context.sent;\n\n                            case 14:\n                                if (!(featCount == -1)) {\n                                    _context.next = 16;\n                                    break;\n                                }\n\n                                return _context.abrupt('return', _this.inherited('_estimateGlobalStats', _arguments));\n\n                            case 16:\n                                correctionFactor = (_this.getConf('topLevelFeaturesPercent') || 100) / 100;\n                                featureDensity = featCount / (refseq.end - refseq.start) * correctionFactor;\n                                return _context.abrupt('return', { featureDensity: featureDensity });\n\n                            case 19:\n                            case 'end':\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, _this);\n            }))();\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/Mask.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/Mask.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/when */ \"./node_modules/dojo/when.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Model/BinaryTreeNode */ \"./src/JBrowse/Model/BinaryTreeNode.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Deferred, when, all, SeqFeatureStore, SimpleFeature, TreeNode, Util) {\n\n    return declare([SeqFeatureStore], {\n\n        // A store that takes in two feature stores (one of them set-based e.g. NCList) and uses the data from one store as a mask\n        // for the other.  Although the design resembles those of combinationStores, differences are substantial enough that\n        // this class does not derive from CombinationBase.\n\n        constructor: function constructor(args) {\n            this.isCombinationStore = true;\n            this.inverse = args.inverse || false;\n            this.stores = {};\n\n            if (args.mask && args.display) {\n                this.reload(args.mask, args.display);\n            }\n        },\n\n        // Loads an opTree (optionally), and a mask and display store.  Ensure all stores exist,\n        // and build an operation tree for the benefit of combination tracks.\n        reload: function reload(opTree, mask, display) {\n            var inverse;\n\n            this.gotAllStores = new Deferred();\n            if (opTree) {\n                this.opTree = opTree;\n                this.inverse = inverse === undefined ? opTree.get() == \"N\" : inverse;\n                this.stores.mask = opTree.leftChild && !mask ? opTree.leftChild.get() : mask;\n                this.stores.display = opTree.rightChild && !display ? opTree.rightChild.get() : display;\n                this.gotAllStores.resolve(true);\n            } else {\n                if (inverse !== undefined) {\n                    this.inverse = inverse;\n                }\n                this.opTree = new TreeNode({ Value: this.inverse ? \"N\" : \"M\" });\n                this.stores.mask = mask;\n                this.stores.display = display;\n                var thisB = this;\n\n                var grabStore = function grabStore(store) {\n                    var haveStore = new Deferred();\n                    if (typeof store == \"string\") {\n                        thisB.browser.getStore(store, function (result) {\n                            if (result) {\n                                haveStore.resolve(result, true);\n                            } else {\n                                haveStore.reject(\"store \" + store + \" not found\");\n                            }\n                        });\n                    } else {\n                        haveStore.resolve(store, true);\n                    }\n                    return haveStore.promise;\n                };\n\n                var haveMaskStore = grabStore(this.stores.mask).then(function (store) {\n                    thisB.stores.mask = store;\n                });\n                var haveDisplayStore = grabStore(this.stores.display).then(function (store) {\n                    thisB.stores.display = store;\n                });\n                this.gotAllStores = all([haveMaskStore, haveDisplayStore]);\n                this.gotAllStores.then(function () {\n                    thisB.opTree.leftChild = thisB.stores.mask.isCombinationStore ? thisB.stores.mask.opTree : new TreeNode({ Value: thisB.stores.mask });\n                    thisB.opTree.rightChild = thisB.stores.display.isCombinationStore ? thisB.stores.display.opTree : new TreeNode({ Value: thisB.stores.display });\n                });\n            }\n        },\n\n        // The global stats of this store should be the same as those for the display data.\n        getGlobalStats: function getGlobalStats(callback, errorCallback) {\n            this.stores.display.getGlobalStats(callback, errorCallback);\n        },\n\n        // The regional stats of this store should be the same as those for the display data.\n        getRegionStats: function getRegionStats(query, callback, errorCallback) {\n            this.stores.display.getRegionStats(query, callback, errorCallback);\n        },\n\n        // Gets the features from the mask and display stores, and then returns the display store features with the mask store features\n        // added as masks\n        getFeatures: function getFeatures(query, featCallback, doneCallback, errorCallback) {\n            var thisB = this;\n\n            this.gotAllStores.then(function () {\n                var featureArray = {};\n\n                // Get features from one particular store\n                var grabFeats = function grabFeats(key) {\n                    var d = new Deferred();\n                    featureArray[key] = [];\n\n                    thisB.stores[key].getFeatures(query, function (feature) {\n                        featureArray[key].push(feature);\n                    }, function () {\n                        d.resolve(true);\n                    }, function () {\n                        d.reject(\"failed to load features for \" + key + \" store\");\n                    });\n                    return d.promise;\n                };\n\n                when(all([grabFeats(\"mask\"), grabFeats(\"display\")]), function () {\n                    // Convert mask features into simplified spans\n                    var spans = thisB.toSpans(featureArray.mask, query);\n                    // invert masking spans if necessary\n                    spans = thisB.inverse ? thisB.notSpan(spans, query) : spans;\n                    var features = featureArray.display;\n\n                    thisB.maskFeatures(features, spans, featCallback, doneCallback);\n                }, errorCallback);\n            }, errorCallback);\n        },\n\n        // given a feature or pseudo-feature, returns true if the feature\n        // overlaps the span. False otherwise.\n        inSpan: function inSpan(feature, span) {\n            if (!feature || !span) {\n                console.error(\"invalid arguments to inSpan function\");\n            }\n            return feature.get ? !(feature.get('start') >= span.end || feature.get('end') <= span.start) : !(feature.start >= span.end || feature.end <= span.start);\n        },\n\n        maskFeatures: function maskFeatures(features, spans, featCallback, doneCallback) {\n            /* Pass features to the track's original featCallback, and pass spans to the doneCallback.\n             * If the track has boolean support, the DoneCallback will use the spans to mask the features.\n             * For glyph based tracks, the masks passed to each feature will be used to do masking.\n             */\n            for (var key in features) {\n                if (features.hasOwnProperty(key)) {\n                    var feat = features[key];\n                    delete feat.masks;\n                    for (var span in spans) {\n                        if (spans.hasOwnProperty(span) && this.inSpan(feat, spans[span])) {\n                            // add masks to the feature. Used by Glyphs to do masking.\n                            feat.masks = feat.masks ? feat.masks.concat([spans[span]]) : [spans[span]];\n                        }\n                    }\n                    featCallback(features[key]);\n                }\n            }\n            doneCallback({ maskingSpans: spans });\n        },\n\n        notSpan: function notSpan(spans, query) {\n            // creates the complement spans of the input spans\n            var invSpan = [];\n            invSpan[0] = { start: query.start };\n            var i = 0;\n            for (var span in spans) {\n                if (spans.hasOwnProperty(span)) {\n                    span = spans[span];\n                    invSpan[i].end = span.start;\n                    i++;\n                    invSpan[i] = { start: span.end };\n                }\n            }\n            invSpan[i].end = query.end;\n            if (invSpan[i].end <= invSpan[i].start) {\n                invSpan.splice(i, 1);\n            }\n            if (invSpan[0].end <= invSpan[0].start) {\n                invSpan.splice(0, 1);\n            }\n            return invSpan;\n        },\n\n        toSpans: function toSpans(features, query) {\n            // given a set of features, takes the \"union\" of them and outputs a single set of nonoverlapping spans\n            var spans = [];\n            for (var feature in features) {\n                if (features.hasOwnProperty(feature)) {\n                    spans.push({ start: features[feature].get('start'), //Math.max( features[feature].get('start'), query.start ),\n                        end: features[feature].get('end') //Math.min( features[feature].get('end'),   query.end   )\n                    });\n                }\n            }\n\n            if (!spans.length) return [];\n            spans.sort(function (a, b) {\n                return a.start - b.start;\n            });\n\n            var retSpans = [];\n            var i = 0;\n            while (i < spans.length) {\n                var start = spans[i].start;\n                var end = spans[i].end;\n                while (i < spans.length && spans[i].start <= end) {\n                    end = Math.max(end, spans[i].end);\n                    i++;\n                }\n                retSpans.push({ start: start, end: end });\n            }\n            return retSpans;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/Mask.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/NCList.js":
/*!************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/NCList.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/request/xhr */ \"./node_modules/dojo/request/xhr.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/ArrayRepr */ \"./src/JBrowse/Model/ArrayRepr.js\"), __webpack_require__(/*! JBrowse/Store/NCList */ \"./src/JBrowse/Store/NCList.js\"), __webpack_require__(/*! JBrowse/Store/LazyArray */ \"./src/JBrowse/Store/LazyArray.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred, xhr, SeqFeatureStore, DeferredFeaturesMixin, DeferredStatsMixin, Util, ArrayRepr, GenericNCList, LazyArray) {\n\n    /**\n     * Implementation of SeqFeatureStore using nested containment\n     * lists held in static files that are lazily fetched from the web\n     * server.\n     *\n     * @class JBrowse.Store.SeqFeature.NCList\n     * @extends SeqFeatureStore\n     */\n\n    var idfunc = function idfunc() {\n        return this._uniqueID;\n    };\n    var parentfunc = function parentfunc() {\n        return this._parent;\n    };\n    var childrenfunc = function childrenfunc() {\n        return this.get('subfeatures');\n    };\n\n    return declare(SeqFeatureStore, {\n        constructor: function constructor(args) {\n            this.args = args;\n\n            this.baseUrl = args.baseUrl;\n            this.urlTemplates = { root: args.urlTemplate };\n\n            this._deferred = {};\n        },\n\n        makeNCList: function makeNCList() {\n            return new GenericNCList();\n        },\n\n        loadNCList: function loadNCList(refData, trackInfo, url) {\n            refData.nclist.importExisting(trackInfo.intervals.nclist, refData.attrs, url, trackInfo.intervals.urlTemplate, trackInfo.intervals.lazyClass);\n        },\n\n        getDataRoot: function getDataRoot(refName) {\n            if (!this._deferred.root || this.curRefName != refName) {\n                var d = this._deferred.root = new Deferred();\n                this.curRefName = refName;\n\n                var refData = {\n                    nclist: this.makeNCList()\n                };\n\n                var url = this.resolveUrl(this._evalConf(this.urlTemplates.root), { refseq: refName });\n\n                // fetch the trackdata\n                var thisB = this;\n                xhr.get(url, {\n                    handleAs: 'json',\n                    failOk: true,\n                    headers: {\n                        'X-Requested-With': null\n                    }\n                }).then(function (trackInfo, request) {\n                    //trackInfo = JSON.parse( trackInfo );\n                    thisB._handleTrackInfo(refData, trackInfo, url);\n                }, function (error) {\n                    if (Util.isElectron() || error.response.status == 404) {\n                        thisB._handleTrackInfo(refData, {}, url);\n                    } else if (error.response.status != 200) {\n                        thisB._failAllDeferred(\"Server returned an HTTP \" + error.response.status + \" error\");\n                    } else thisB._failAllDeferred(error);\n                });\n            }\n            return this._deferred.root;\n        },\n\n        _handleTrackInfo: function _handleTrackInfo(refData, trackInfo, url) {\n            refData.stats = {\n                featureCount: trackInfo.featureCount || 0,\n                featureDensity: (trackInfo.featureCount || 0) / this.refSeq.length\n            };\n\n            this.empty = !trackInfo.featureCount;\n\n            if (trackInfo.intervals) {\n                refData.attrs = new ArrayRepr(trackInfo.intervals.classes);\n                this.loadNCList(refData, trackInfo, url);\n            }\n\n            var histograms = trackInfo.histograms;\n            if (histograms && histograms.meta) {\n                for (var i = 0; i < histograms.meta.length; i++) {\n                    histograms.meta[i].lazyArray = new LazyArray(histograms.meta[i].arrayParams, url);\n                }\n                refData._histograms = histograms;\n            }\n\n            this._deferred.root.resolve(refData);\n        },\n\n        getGlobalStats: function getGlobalStats(successCallback, errorCallback) {\n            return (this._deferred.root || this.getDataRoot(this.browser.refSeq.name)).then(function (data) {\n                successCallback(data.stats);\n            }, errorCallback);\n        },\n\n        getRegionStats: function getRegionStats(query, successCallback, errorCallback) {\n            this.getDataRoot(query.ref).then(function (data) {\n                successCallback(data.stats);\n            }, errorCallback);\n        },\n\n        getRegionFeatureDensities: function getRegionFeatureDensities(query, successCallback, errorCallback) {\n            this.getDataRoot(query.ref).then(function (data) {\n\n                var numBins, basesPerBin;\n                if (query.numBins) {\n                    numBins = query.numBins;\n                    basesPerBin = (query.end - query.start) / numBins;\n                } else if (query.basesPerBin) {\n                    basesPerBin = query.basesPerBin;\n                    numBins = Math.ceil((query.end - query.start) / basesPerBin);\n                } else {\n                    throw new Error('numBins or basesPerBin arg required for getRegionFeatureDensities');\n                }\n\n                // pick the relevant entry in our pre-calculated stats\n                var statEntry = function (basesPerBin, stats) {\n                    for (var i = 0; i < stats.length; i++) {\n                        if (stats[i].basesPerBin >= basesPerBin) {\n                            return stats[i];\n                        }\n                    }\n                    return undefined;\n                }(basesPerBin, data._histograms.stats || []);\n\n                // The histogramMeta array describes multiple levels of histogram detail,\n                // going from the finest (smallest number of bases per bin) to the\n                // coarsest (largest number of bases per bin).\n                // We want to use coarsest histogramMeta that's at least as fine as the\n                // one we're currently rendering.\n                // TODO: take into account that the histogramMeta chosen here might not\n                // fit neatly into the current histogram (e.g., if the current histogram\n                // is at 50,000 bases/bin, and we have server histograms at 20,000\n                // and 2,000 bases/bin, then we should choose the 2,000 histogramMeta\n                // rather than the 20,000)\n                var histogramMeta = data._histograms.meta[0];\n                for (var i = 0; i < data._histograms.meta.length; i++) {\n                    if (basesPerBin >= data._histograms.meta[i].basesPerBin) histogramMeta = data._histograms.meta[i];\n                }\n\n                // number of bins in the server-supplied histogram for each current bin\n                var binRatio = basesPerBin / histogramMeta.basesPerBin;\n\n                // if the server-supplied histogram fits neatly into our requested\n                if (binRatio > 0.9 && Math.abs(binRatio - Math.round(binRatio)) < 0.0001) {\n                    //console.log('server-supplied',query);\n                    // we can use the server-supplied counts\n                    var firstServerBin = Math.floor(query.start / histogramMeta.basesPerBin);\n                    binRatio = Math.round(binRatio);\n                    var histogram = [];\n                    for (var bin = 0; bin < numBins; bin++) {\n                        histogram[bin] = 0;\n                    }histogramMeta.lazyArray.range(firstServerBin, firstServerBin + binRatio * numBins, function (i, val) {\n                        // this will count features that span the boundaries of\n                        // the original histogram multiple times, so it's not\n                        // perfectly quantitative.  Hopefully it's still useful, though.\n                        histogram[Math.floor((i - firstServerBin) / binRatio)] += val;\n                    }, function () {\n                        successCallback({ bins: histogram, stats: statEntry });\n                    });\n                } else {\n                    //console.log('make own',query);\n                    // make our own counts\n                    data.nclist.histogram.call(data.nclist, query.start, query.end, numBins, function (hist) {\n                        successCallback({ bins: hist, stats: statEntry });\n                    });\n                }\n            }).catch(errorCallback);\n        },\n\n        getFeatures: function getFeatures(query, origFeatCallback, finishCallback, errorCallback) {\n            if (this.empty) {\n                finishCallback();\n                return;\n            }\n\n            var thisB = this;\n            this.getDataRoot(query.ref).then(function (data) {\n                thisB._getFeatures(data, query, origFeatCallback, finishCallback, errorCallback);\n            }, errorCallback);\n        },\n\n        _getFeatures: function _getFeatures(data, query, origFeatCallback, finishCallback, errorCallback) {\n            var thisB = this;\n            var startBase = query.start;\n            var endBase = query.end;\n            var accessors = data.attrs.accessors(),\n\n            /** @inner */\n            featCallBack = function featCallBack(feature, path) {\n                // the unique ID is a stringification of the path in the\n                // NCList where the feature lives; it's unique across the\n                // top-level NCList (the top-level NCList covers a\n                // track/chromosome combination)\n\n                // only need to decorate a feature once\n                if (!feature.decorated) {\n                    var uniqueID = path.join(\",\");\n                    thisB._decorate_feature(accessors, feature, uniqueID);\n                }\n                return origFeatCallback(feature);\n            };\n\n            data.nclist.iterate.call(data.nclist, startBase, endBase, featCallBack, finishCallback, errorCallback);\n        },\n\n        // helper method to recursively add .get and .tags methods to a feature and its\n        // subfeatures\n        _decorate_feature: function _decorate_feature(accessors, feature, id, parent) {\n            feature.get = accessors.get;\n            // possibly include set method in decorations? not currently\n            //    feature.set = accessors.set;\n            feature.tags = accessors.tags;\n            feature._uniqueID = id;\n            feature.id = idfunc;\n            feature._parent = parent;\n            feature.parent = parentfunc;\n            feature.children = childrenfunc;\n            dojo.forEach(feature.get('subfeatures'), function (f, i) {\n                this._decorate_feature(accessors, f, id + '-' + i, feature);\n            }, this);\n            feature.decorated = true;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/NCList.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/NCList_v0.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/NCList_v0.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/NCList */ \"./src/JBrowse/Store/SeqFeature/NCList.js\"), __webpack_require__(/*! JBrowse/Store/NCList_v0 */ \"./src/JBrowse/Store/NCList_v0.js\"), __webpack_require__(/*! JBrowse/Store/LazyArray */ \"./src/JBrowse/Store/LazyArray.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Deferred, SFNCList, GenericNCList, LazyArray) {\n    return declare(SFNCList,\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.NCList_v0\n     */\n    {\n\n        /**\n         * Feature storage backend for backward-compatibility with JBrowse 1.2.1 stores.\n         * @extends SeqFeatureStore.NCList\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this.fields = {};\n            this.track = new Deferred();\n            if (args.track) this.track.resolve(args.track);\n        },\n\n        setTrack: function setTrack(t) {\n            if (!this.track.isFulfilled()) this.track.resolve(t);\n        },\n\n        /**\n         * Delete an object member and return the deleted value.\n         * @private\n         */\n        _del: function _del(obj, old) {\n            var x = obj[old];\n            delete obj[old];\n            return x;\n        },\n\n        _handleTrackInfo: function _handleTrackInfo(refData, trackInfo, url) {\n\n            if (trackInfo) {\n\n                // munge the trackInfo to make the histogram stuff work with v1 code\n                dojo.forEach(trackInfo.histogramMeta, function (m) {\n                    m.arrayParams.urlTemplate = m.arrayParams.urlTemplate.replace(/\\{chunk\\}/, '{Chunk}');\n                });\n                trackInfo.histograms = {\n                    meta: this._del(trackInfo, 'histogramMeta'),\n                    stats: this._del(trackInfo, 'histStats')\n                };\n                // rename stats.bases to stats.basesPerBin\n                dojo.forEach(trackInfo.histograms.stats, function (s) {\n                    s.basesPerBin = this._del(s, 'bases');\n                }, this);\n\n                // since the old format had style information inside the\n                // trackdata file, yuckily push it up to the track's config.style\n                var renameVar = {\n                    urlTemplate: \"linkTemplate\"\n                };\n\n                this.track.then(function (track) {\n                    dojo.forEach(['className', 'arrowheadClass', 'subfeatureClasses', 'urlTemplate', 'clientConfig'], function (varname) {\n                        if (!track.config.style) track.config.style = {};\n                        var dest_varname = renameVar[varname] || varname;\n                        if (varname in trackInfo) track.config.style[dest_varname] = trackInfo[varname];\n                    }, this);\n\n                    // also need to merge Ye Olde clientConfig values into the style object\n                    if (track.config.style.clientConfig) {\n                        track.config.style = dojo.mixin(track.config.style, track.config.style.clientConfig);\n                        delete track.config.style.clientConfig;\n                    }\n                });\n\n                // remember the field offsets from the old-style trackinfo headers\n                refData.fields = {};\n                refData.fieldOrder = [];\n                var i;\n                for (i = 0; i < trackInfo.headers.length; i++) {\n                    refData.fieldOrder.push(trackInfo.headers[i]);\n                    refData.fields[trackInfo.headers[i]] = i;\n                }\n                refData.subFields = {};\n                refData.subFieldOrder = [];\n                if (trackInfo.subfeatureHeaders) {\n                    for (i = 0; i < trackInfo.subfeatureHeaders.length; i++) {\n                        refData.subFieldOrder.push(trackInfo.subfeatureHeaders[i]);\n                        refData.subFields[trackInfo.subfeatureHeaders[i]] = i;\n                    }\n                }\n\n                refData.stats = {\n                    featureCount: trackInfo.featureCount,\n                    featureDensity: trackInfo.featureCount / this.refSeq.length\n                };\n\n                this.loadNCList(refData, trackInfo, url);\n\n                var histograms = trackInfo.histograms;\n                if (histograms && histograms.meta) {\n                    for (var i = 0; i < histograms.meta.length; i++) {\n                        histograms.meta[i].lazyArray = new LazyArray(histograms.meta[i].arrayParams, url);\n                    }\n                    refData._histograms = histograms;\n                }\n\n                this._deferred.root.resolve(refData);\n            }\n        },\n\n        makeNCList: function makeNCList() {\n            return new GenericNCList();\n        },\n\n        loadNCList: function loadNCList(refData, trackInfo, url) {\n            refData.nclist.importExisting(trackInfo.featureNCList, trackInfo.sublistIndex, trackInfo.lazyIndex, url, trackInfo.lazyfeatureUrlTemplate);\n        },\n\n        _getFeatures: function _getFeatures(data, query, origFeatCallback, finishCallback, errorCallback) {\n            var that = this,\n                startBase = query.start,\n                endBase = query.end,\n                fields = data.fields,\n                fieldOrder = data.fieldOrder,\n                subFields = data.subFields,\n                subfieldOrder = data.subfieldOrder,\n                get = function get(fieldname) {\n                var f = fields[fieldname];\n                if (f >= 0) return this[f];else return undefined;\n            },\n                subget = function subget(fieldname) {\n                var f = subFields[fieldname];\n                if (f >= 0) return this[f];else return undefined;\n            },\n                tags = function tags() {\n                return fieldOrder;\n            },\n                subTags = function subTags() {\n                return subfieldOrder;\n            },\n                featCallBack = function featCallBack(feature, path) {\n                that._decorate_feature({ get: get, tags: tags }, feature, path.join(','));\n                return origFeatCallback(feature, path);\n            };\n\n            return data.nclist.iterate.call(data.nclist, startBase, endBase, featCallBack, finishCallback);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/NCList_v0.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/QuantitativeCombination.js":
/*!*****************************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/QuantitativeCombination.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/CombinationBase */ \"./src/JBrowse/Store/SeqFeature/CombinationBase.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, CombinationBaseStore) {\n\n    // Plagiarized from Store/SeqFeature/Bigwig/RequestWorker to create BigWig features\n    var gettable = declare(null, {\n        get: function get(name) {\n            return this[{ start: 'start', end: 'end', seq_id: 'segment' }[name] || name];\n        },\n        tags: function tags() {\n            return ['start', 'end', 'seq_id', 'score', 'type', 'source'];\n        }\n    });\n    var Feature = declare(gettable, {});\n\n    return declare([CombinationBaseStore], {\n\n        // An implementation of CombinationBase that deals with quantitative features (with score, as with BigWig features).\n        // Usual operations are things like addition, subtraction, multiplication, and division.\n\n        // Applies a given operation on two scores.\n        applyOp: function applyOp(scoreA, scoreB, op) {\n            var retValue;\n            switch (op) {\n                case \"+\":\n                    retValue = scoreA + scoreB;\n                    break;\n                case \"-\":\n                    retValue = scoreA - scoreB;\n                    break;\n                case \"*\":\n                    retValue = scoreA * scoreB;\n                    break;\n                case \"/\":\n                    retValue = scoreB == 0 ? undefined : scoreA / scoreB;\n                    break;\n                default:\n                    console.error(\"invalid operation \" + op);\n                    return undefined;\n            }\n            return retValue;\n        },\n\n        // Converts a list of spans to a list of features.\n        createFeatures: function createFeatures(spans) {\n            var features = [];\n            for (var span in spans) {\n                var f = new Feature();\n                f.start = spans[span].start;\n                f.end = spans[span].end;\n                f.score = spans[span].score;\n                if (spans[span].segment) f.segment = spans[span].segment;\n                if (spans[span].type) f.type = spans[span].type;\n                f.source = this.name;\n\n                features.push(f);\n            }\n            return features;\n        },\n\n        // Loops through two sets of pseudo-features (spans).  At any region for which both sets have features defined,\n        // applies the given operation on those features.  Otherwise, uses whichever one is defined.\n        opSpan: function opSpan(op, pseudosA, pseudosB, query) {\n            var retPseudos = [];\n            var i = 0;\n            var j = 0;\n\n            if (!pseudosA.length && !pseudosB.length) return retPseudos;\n\n            // Critical values are the starts and ends of features for either set of spans.\n            // nextCritical will iterate through all critical values.\n            var nextCritical = pseudosA[i] ? pseudosB[j] ? Math.min(pseudosA[i].start, pseudosB[j].start) : pseudosA[i].start : pseudosB[j].start;\n\n            var inA;\n            var inB;\n\n            while (i < pseudosA.length && j < pseudosB.length) {\n                // Decide whether to add a span to the list at all - we don't add spans if the gap from this critical point to the\n                // next critical point is not inside any feature.\n                if (nextCritical == pseudosA[i].start) inA = true;\n                if (nextCritical == pseudosB[j].start) inB = true;\n                var addPseudo = inA || inB;\n                var newPseudo;\n                // If we're inside at least one pseudo-feature, adds data for the current feature.\n                if (addPseudo) {\n                    newPseudo = {\n                        start: nextCritical,\n                        score: this.applyOp(inA ? pseudosA[i].score : 0, inB ? pseudosB[j].score : 0, op)\n                    };\n                    if (inA != inB || pseudosA[i].segment == pseudosB[j].segment) {\n                        newPseudo.segment = inA ? pseudosA[i].segment : pseudosB[j].segment;\n                    }\n                    if (inA != inB || pseudosA[i].type == pseudosB[j].type) {\n                        newPseudo.type = inA ? pseudosA[i].type : pseudosB[j].type;\n                    }\n                }\n                // Dividing by zero or other invalid operation being performed, don't add the feature\n                if (newPseudo.score === undefined) addPseudo = false;\n\n                // Fetches the next critical point (the next base pair greater than the current nextCritical value\n                //    that is either the beginning or the end of a pseudo)\n                var _possibleCriticals = [pseudosA[i].start, pseudosA[i].end, pseudosB[j].start, pseudosB[j].end];\n\n                _possibleCriticals = array.filter(_possibleCriticals, function (item) {\n                    return item > nextCritical;\n                }).sort(function (a, b) {\n                    return a - b;\n                });\n\n                nextCritical = _possibleCriticals[0];\n                if (!nextCritical) break;\n\n                // Determines whether the next pseudo to be created will use data from pseudosA or pseudosB or both\n                if (nextCritical == pseudosA[i].end) {\n                    inA = false;\n                    i++;\n                }\n                if (nextCritical == pseudosB[j].end) {\n                    inB = false;\n                    j++;\n                }\n\n                // If there is currently a pseudo-feature being built, adds it\n                if (addPseudo) {\n                    newPseudo.end = nextCritical;\n\n                    retPseudos.push(newPseudo);\n                }\n            }\n\n            // If some pseudofeatures remain in either pseudo set, they are pushed as is into the return pseudo set.\n            for (; i < pseudosA.length; i++) {\n                retPseudos.push({\n                    start: Math.max(nextCritical, pseudosA[i].start),\n                    end: pseudosA[i].end,\n                    score: this.applyOp(pseudosA[i].score, 0, op),\n                    segment: pseudosA[i].segment,\n                    type: pseudosA[i].type\n                });\n            }\n            for (; j < pseudosB.length; j++) {\n                retPseudos.push({\n                    start: Math.max(nextCritical, pseudosB[j].start),\n                    end: pseudosB[j].end,\n                    score: this.applyOp(0, pseudosB[j].score, op),\n                    segment: pseudosB[j].segment,\n                    type: pseudosB[j].type\n                });\n            }\n            return retPseudos;\n        },\n\n        toSpan: function toSpan(features, query) {\n            // given a set of features, creates a set of pseudo-features with similar properties.\n            var pseudos = [];\n            for (var feature in features) {\n                var pseudo = {\n                    start: features[feature].get('start'),\n                    end: features[feature].get('end'),\n                    score: features[feature].get('score'),\n                    segment: features[feature].get('segment'),\n                    type: features[feature].get('type')\n                };\n                pseudos.push(pseudo);\n            }\n            return pseudos;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/QuantitativeCombination.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js":
/*!**********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Mixin that adds getRegionFeatureDensities method to a store\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare) {\n\n    return declare(null, {\n        getRegionFeatureDensities: function getRegionFeatureDensities(query, successCallback, errorCallback) {\n            var _this = this;\n\n            var numBins = void 0;\n            var basesPerBin = void 0;\n\n            this.scoreMax = this.scoreMax || 0;\n\n            if (query.numBins) {\n                numBins = query.numBins;\n                basesPerBin = (query.end - query.start) / numBins;\n            } else if (query.basesPerBin) {\n                basesPerBin = query.basesPerBin || query.ref.basesPerBin;\n                numBins = Math.ceil((query.end - query.start) / basesPerBin);\n            } else {\n                throw new Error('numBins or basesPerBin arg required for getRegionFeatureDensities');\n            }\n\n            var statEntry = function (basesPerBin, stats) {\n                for (var i = 0; i < stats.length; i++) {\n                    if (stats[i].basesPerBin >= basesPerBin) {\n                        return stats[i];\n                    }\n                }\n                return undefined;\n            }(basesPerBin, []);\n\n            var stats = {};\n            stats.basesPerBin = basesPerBin;\n\n            stats.max = 0;\n            var firstServerBin = Math.floor(query.start / basesPerBin);\n            var histogram = [];\n            var binRatio = 1 / basesPerBin;\n\n            var binStart = void 0;\n            var binEnd = void 0;\n\n            for (var bin = 0; bin < numBins; bin++) {\n                histogram[bin] = 0;\n            }\n            this._getFeatures(query, function (feature) {\n                var binValue = Math.round((feature.get('start') - query.start) * binRatio);\n                var binValueEnd = Math.round((feature.get('end') - query.start) * binRatio);\n                for (var _bin = binValue; _bin <= binValueEnd; _bin++) {\n                    if (_bin >= 0 && _bin < numBins) {\n                        histogram[_bin] = (histogram[_bin] || 0) + 1;\n                        if (histogram[_bin] > stats.max) {\n                            stats.max = histogram[_bin];\n                            if (stats.max > _this.scoreMax) {\n                                _this.scoreMax = stats.max;\n                            }\n                        }\n                    }\n                }\n            }, function () {\n                stats.max = _this.scoreMax;\n                successCallback({ bins: histogram, stats: stats });\n            }, errorCallback);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/RegionStatsMixin.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/SNPCoverage.js":
/*!*****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/SNPCoverage.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Store that encapsulates another store, which is expected to have\n * features in it that have CIGAR and MD attributes.  Produces\n * features that include SNP allele frequencies.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/NestedFrequencyTable */ \"./src/JBrowse/Model/NestedFrequencyTable.js\"), __webpack_require__(/*! JBrowse/Model/CoverageFeature */ \"./src/JBrowse/Model/CoverageFeature.js\"), __webpack_require__(/*! ./_MismatchesMixin */ \"./src/JBrowse/Store/SeqFeature/_MismatchesMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Util, SeqFeatureStore, NestedFrequencyTable, CoverageFeature, MismatchesMixin) {\n\n    return declare([SeqFeatureStore, MismatchesMixin], {\n\n        constructor: function constructor(args) {\n            this.store = args.store;\n            this.filter = args.filter || function () {\n                return true;\n            };\n        },\n\n        getGlobalStats: function getGlobalStats(callback, errorCallback) {\n            callback({});\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                mismatchScale: 1 / 10\n            });\n        },\n\n        getFeatures: function getFeatures(query, featureCallback, finishCallback, errorCallback) {\n            var thisB = this;\n            var leftBase = query.start;\n            var rightBase = query.end;\n            var scale = query.scale || query.basesPerSpan && 1 / query.basesPerSpan || 10; // px/bp\n            var widthBp = rightBase - leftBase;\n            var widthPx = widthBp * scale;\n\n            var binWidth = function () {\n                var bpPerPixel = 1 / scale;\n                if (bpPerPixel <= 1 / thisB.config.mismatchScale) {\n                    return 1;\n                } else {\n                    return Math.ceil(bpPerPixel);\n                }\n            }();\n\n            function binNumber(bp) {\n                return Math.floor((bp - leftBase) / binWidth);\n            };\n\n            // init coverage bins\n            var binMax = Math.ceil((rightBase - leftBase) / binWidth);\n            var coverageBins = new Array(binMax);\n            for (var i = 0; i < binMax; i++) {\n                coverageBins[i] = new NestedFrequencyTable();\n                if (binWidth == 1) coverageBins[i].snpsCounted = true;\n            }\n\n            function forEachBin(start, end, callback) {\n                var s = (start - leftBase) / binWidth;\n                var e = (end - 1 - leftBase) / binWidth;\n                var sb = Math.floor(s),\n                    eb = Math.floor(e);\n\n                if (sb >= binMax || eb < 0) return; // does not overlap this block\n\n                // enforce 0 <= bin < binMax\n                if (sb < 0) s = sb = 0;\n                if (eb >= binMax) {\n                    eb = binMax - 1;\n                    e = binMax;\n                }\n\n                // now iterate\n                if (sb == eb) // if in the same bin, just one call\n                    callback(sb, e - s);else {\n                    // if in different bins, two or more calls\n                    callback(sb, sb + 1 - s);\n                    for (var i = sb + 1; i < eb; i++) {\n                        callback(i, 1);\n                    }callback(eb, e - eb);\n                }\n            };\n\n            thisB.store.getFeatures(query, function (feature) {\n                if (!thisB.filter(feature)) return;\n\n                var strand = { '-1': '-', '1': '+' }['' + feature.get('strand')] || 'unstranded';\n\n                // increment start and end partial-overlap bins by proportion of overlap\n                forEachBin(feature.get('start'), feature.get('end'), function (bin, overlap) {\n                    coverageBins[bin].getNested('reference').increment(strand, overlap);\n                });\n\n                // Calculate SNP coverage\n                if (binWidth == 1) {\n                    var mismatches = thisB._getMismatches(feature);\n                    // loops through mismatches and updates coverage variables accordingly.\n                    for (var i = 0; i < mismatches.length; i++) {\n                        var mismatch = mismatches[i];\n                        forEachBin(feature.get('start') + mismatch.start, feature.get('start') + mismatch.start + mismatch.length, function (binNumber, overlap) {\n                            // Note: we decrement 'reference' so that total of the score is the total coverage\n                            var bin = coverageBins[binNumber];\n                            bin.getNested('reference').decrement(strand, overlap);\n                            var base = mismatch.base;\n                            if (mismatch.type == 'insertion') base = 'ins ' + base;else if (mismatch.type == 'skip') base = 'skip';\n                            bin.getNested(base).increment(strand, overlap);\n                        });\n                    }\n                }\n            }, function (args) {\n                var makeFeatures = function makeFeatures() {\n                    // make fake features from the coverage\n                    for (var i = 0; i < coverageBins.length; i++) {\n                        var bpOffset = leftBase + binWidth * i;\n                        featureCallback(new CoverageFeature({\n                            start: bpOffset,\n                            end: bpOffset + binWidth,\n                            score: coverageBins[i]\n                        }));\n                    }\n                    finishCallback(args); // optional arguments may change callback behaviour (e.g. add masking)\n                };\n\n                // if we are zoomed to base level, try to fetch the\n                // reference sequence for this region and record each\n                // of the bases in the coverage bins\n                if (binWidth == 1) {\n                    var sequence;\n                    thisB.browser.getStore('refseqs', function (refSeqStore) {\n                        if (refSeqStore) {\n                            refSeqStore.getFeatures(query, function (f) {\n                                sequence = f.get('seq');\n                            }, function () {\n                                if (sequence) {\n                                    for (var base = leftBase; base <= rightBase; base++) {\n                                        var bin = binNumber(base);\n                                        if (coverageBins[bin]) coverageBins[bin].refBase = sequence[bin];\n                                    }\n                                }\n                                makeFeatures();\n                            }, makeFeatures);\n                        } else {\n                            makeFeatures();\n                        }\n                    });\n                } else {\n                    makeFeatures();\n                }\n            }, errorCallback);\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.bam.url,\n                baiUrlTemplate: this.config.bai.url\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/SNPCoverage.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/SPARQL.js":
/*!************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/SPARQL.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/request/xhr */ \"./node_modules/dojo/request/xhr.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! dojo/io-query */ \"./node_modules/dojo/io-query.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, xhr, SeqFeatureStore, DeferredStatsMixin, GlobalStatsEstimationMixin, Util, SimpleFeature, ioQuery) {\n\n    return declare([SeqFeatureStore, DeferredStatsMixin, GlobalStatsEstimationMixin],\n\n    /**\n     * @lends JBrowse.Store.SeqFeature.SPARQL\n     */\n    {\n\n        /**\n         * JBrowse feature backend to retrieve features from a SPARQL endpoint.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this.url = this.urlTemplate;\n            this.refSeq = args.refSeq;\n            this.baseUrl = args.baseUrl;\n            this.density = 0;\n            this.url = Util.resolveUrl(this.baseUrl, Util.fillTemplate(args.urlTemplate, { 'refseq': this.refSeq.name }));\n            this.queryTemplate = args.queryTemplate;\n            if (!this.queryTemplate) {\n                console.error(\"No queryTemplate set for SPARQL backend, no data will be displayed\");\n            }\n\n            var thisB = this;\n            this._estimateGlobalStats().then(function (stats) {\n                thisB.globalStats = stats;\n                thisB._deferred.stats.resolve(stats);\n            }, lang.hitch(this, '_failAllDeferred'));\n        },\n\n        // load: function() {\n        //     // ping the endpoint to see if it's there\n        //     dojo.xhrGet({ url: this.url+'?'+ioQuery.objectToQuery({ query: 'SELECT ?s WHERE { ?s ?p ?o } LIMIT 1' }),\n        //                   handleAs: \"text\",\n        //                   failOk: false,\n        //                   load:  Util.debugHandler( this, function(o) { this.loadSuccess(o); }),\n        //                   error: dojo.hitch( this, function(error) { this.loadFail(error, this.url); } )\n        //     });\n        // },\n\n        _makeQuery: function _makeQuery(query) {\n            if (this.config.variables) query = dojo.mixin(dojo.mixin({}, this.config.variables), query);\n\n            return Util.fillTemplate(this.queryTemplate, query);\n        },\n\n        _getFeatures: function _getFeatures() {\n            this.getFeatures.apply(this, arguments);\n        },\n\n        getFeatures: function getFeatures(query, featCallback, finishCallback, errorCallback) {\n            if (this.queryTemplate) {\n                var thisB = this;\n                var headers = { \"Accept\": \"application/json\" };\n                if (this.config.disablePreflight) {\n                    // https://www.sitepen.com/blog/2014/01/15/faq-cors-with-dojo/\n                    headers[\"X-Requested-With\"] = null;\n                }\n\n                xhr.get(this.url + '?' + ioQuery.objectToQuery({\n                    query: this._makeQuery(query)\n                }), {\n                    headers: headers,\n                    handleAs: \"json\",\n                    failOk: true\n                }).then(function (o) {\n                    thisB._resultsToFeatures(o, featCallback);\n                    finishCallback();\n                }, lang.hitch(this, '_failAllDeferred'));\n            } else {\n                finishCallback();\n            }\n        },\n\n        _resultsToFeatures: function _resultsToFeatures(results, featCallback) {\n            var rows = ((results || {}).results || {}).bindings || [];\n            if (!rows.length) return;\n            var fields = results.head.vars;\n            var requiredFields = ['start', 'end', 'strand', 'uniqueID'];\n            for (var i = 0; i < requiredFields.length; i++) {\n                if (fields.indexOf(requiredFields[i]) == -1) {\n                    console.error(\"Required field \" + requiredFields[i] + \" missing from feature data\");\n                    return;\n                }\n            };\n            var seenFeatures = {};\n            array.forEach(rows, function (row) {\n\n                var f = { data: { subfeatures: [] } };\n\n                var data = f.data;\n                array.forEach(fields, function (field) {\n                    if (field in row) data[field] = row[field].value;\n                });\n                data.start = parseInt(data.start);\n                data.end = parseInt(data.end);\n                data.strand = parseInt(data.strand);\n\n                var id = data.uniqueID;\n                delete data.uniqueID;\n                f.id = id;\n                seenFeatures[id] = f;\n            }, this);\n\n            // resolve subfeatures, keeping only top-level features in seenFeatures\n            for (var id in seenFeatures) {\n                var f = seenFeatures[id];\n                var pid = f.data.parentUniqueID;\n                delete f.data.parentUniqueID;\n                if (pid) {\n                    var p = seenFeatures[pid];\n                    if (p) {\n                        p.data.subfeatures.push(f.data);\n                        delete seenFeatures[id];\n                    }\n                }\n            }\n\n            for (var id in seenFeatures) {\n                featCallback(new SimpleFeature(seenFeatures[id]));\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/SPARQL.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/SequenceChunks.js":
/*!********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/SequenceChunks.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/request */ \"./node_modules/dojo/request.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/LRUCache */ \"./src/JBrowse/Store/LRUCache.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/Digest/Crc32 */ \"./src/JBrowse/Digest/Crc32.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, request, all, Deferred, SeqFeatureStore, LRUCache, Util, SimpleFeature, Crc32) {\n\n    return declare(SeqFeatureStore, {\n\n        /**\n         * Storage backend for sequences broken up into chunks, stored and\n         * served as static text files.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this.compress = args.compress;\n            this.urlTemplate = this.getConf('urlTemplate', []);\n            if (!this.urlTemplate) {\n                throw \"no urlTemplate provided, cannot open sequence store\";\n            }\n\n            this.baseUrl = args.baseUrl;\n            this.seqChunkSize = args.seqChunkSize;\n        },\n\n        getFeatures: function getFeatures(query, featureCallback, endCallback, errorCallback) {\n\n            errorCallback = errorCallback || function (e) {\n                console.error(e);\n            };\n\n            var refname = query.ref;\n            // if they both regularize to the same thing, use this.refSeq.name since that is guaranteed to be from refseq store\n            if (!this.browser.compareReferenceNames(this.refSeq.name, refname)) refname = this.refSeq.name;\n\n            var chunkSize = refname == this.refSeq.name && this.refSeq.seqChunkSize || this.seqChunkSize || (this.compress ? 80000 : 20000);\n\n            var chunksProcessed = 0;\n\n            var cache = this.chunkCache = this.chunkCache || new LRUCache({\n                name: 'SequenceCache',\n                fillCallback: dojo.hitch(this, '_readChunkItems'),\n                sizeFunction: function sizeFunction(chunkItems) {\n                    return chunkItems.length;\n                },\n                maxSize: 100 // cache up to 100 seqchunks\n            });\n            var firstChunk = Math.floor(Math.max(0, query.start) / chunkSize);\n            var lastChunk = Math.floor((query.end - 1) / chunkSize);\n\n            var chunks = [];\n            for (var i = firstChunk; i <= lastChunk; i++) {\n                chunks.push({ refname: refname, chunkNum: i, chunkSize: chunkSize });\n            }\n\n            var haveError;\n            array.forEach(chunks, function (c) {\n                cache.get(c, function (item, e) {\n                    if (e && !haveError) errorCallback(e);\n                    if (haveError = haveError || e) {\n                        return;\n                    }\n\n                    featureCallback(item);\n                    if (++chunksProcessed == chunks.length) {\n                        endCallback();\n                    }\n                });\n            });\n        },\n        _readChunkItems: function _readChunkItems(chunk, callback) {\n            var thisB = this;\n            var d = new Deferred(); // need to have our own deferred that is resolved to '' on 404\n\n            var sequrl = this.resolveUrl(this.urlTemplate, {\n                'refseq': chunk.refname,\n                'refseq_dirpath': function refseq_dirpath() {\n                    var hex = Crc32.crc32(chunk.refname).toString(16).toLowerCase().replace('-', 'n');\n                    // zero-pad the hex string to be 8 chars if necessary\n                    while (hex.length < 8) {\n                        hex = '0' + hex;\n                    }var dirpath = [];\n                    for (var i = 0; i < hex.length; i += 3) {\n                        dirpath.push(hex.substring(i, i + 3));\n                    }\n                    return dirpath.join('/');\n                }\n            });\n            this._fetchChunk(sequrl, chunk.chunkNum).then(lang.hitch(d, 'resolve'), function (e) {\n                if (e.response.status == 404) d.resolve('');else d.reject(e);\n            });\n            d.then(function (sequenceString) {\n                callback(thisB._makeFeature(chunk.refname, chunk.chunkNum, chunk.chunkSize, sequenceString));\n            }, function (e) {\n                callback(null, e);\n            });\n        },\n\n        _fetchChunk: function _fetchChunk(sequrl, chunkNum) {\n            return request.get(sequrl + chunkNum + \".txt\" + (this.compress ? 'z' : ''), { handleAs: 'text', headers: { 'X-Requested-With': null } });\n        },\n\n        _makeFeature: function _makeFeature(refname, chunkNum, chunkSize, sequenceString) {\n            return new SimpleFeature({\n                data: {\n                    start: chunkNum * chunkSize,\n                    end: chunkNum * chunkSize + sequenceString.length,\n                    residues: sequenceString,\n                    seq_id: refname,\n                    name: refname\n                }\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/SequenceChunks.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/TwoBit.js":
/*!************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/TwoBit.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _cjsRequire = __webpack_require__(/*! @gmod/twobit */ \"./node_modules/@gmod/twobit/dist/index.js\"),\n    TwoBitFile = _cjsRequire.TwoBitFile;\n\nvar BlobFilehandleWrapper = __webpack_require__(/*! ../../Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, XHRBlob, SeqFeatureStore, DeferredFeaturesMixin, SimpleFeature) {\n\n    return declare([SeqFeatureStore, DeferredFeaturesMixin], {\n\n        /**\n         * Data backend for reading feature data directly from a\n         * web-accessible .2bit file.\n         *\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var blob = args.blob || new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.2bit'), { expectRanges: true });\n\n            this.twoBit = new TwoBitFile({\n                filehandle: new BlobFilehandleWrapper(blob)\n            });\n\n            this.twoBit.getIndex().then(function () {\n                _this._deferred.features.resolve({ success: true });\n            }, this._failAllDeferred.bind(this));\n        },\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            this.twoBit.getSequenceSize(seqName).then(function (size) {\n                callback(size !== undefined);\n            }, errorCallback);\n        },\n        getRefSeqs: function getRefSeqs(callback, errorCallback) {\n            this.twoBit.getSequenceSizes().then(function (sizes) {\n                return Object.entries(sizes).map(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                        name = _ref2[0],\n                        length = _ref2[1];\n\n                    return {\n                        name: name,\n                        length: length,\n                        end: length,\n                        start: 0\n                    };\n                });\n            }).then(callback, errorCallback);\n        },\n\n        // called by getFeatures from the DeferredFeaturesMixin\n        _getFeatures: function _getFeatures(query, featCallback, endCallback, errorCallback) {\n            var start = query.start;\n            if (start < 0) {\n                start = 0;\n            }\n            var refname = query.ref;\n            // if they both regularize to the same thing, use this.refSeq.name since that is guaranteed to be from refseq store\n            if (!this.browser.compareReferenceNames(this.refSeq.name, refname)) refname = this.refSeq.name;\n\n            this.twoBit.getSequence(refname, start, query.end).then(function (seq) {\n                if (seq !== undefined) {\n                    featCallback(new SimpleFeature({\n                        data: { seq_id: query.ref, start: start, end: query.end, seq: seq }\n                    }));\n                }\n                endCallback();\n            }, errorCallback);\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: (this.config.file || this.config.blob).url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/TwoBit.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/UnindexedFasta.js":
/*!********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/UnindexedFasta.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! ./UnindexedFasta/File */ \"./src/JBrowse/Store/SeqFeature/UnindexedFasta/File.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, SeqFeatureStore, XHRBlob, DeferredFeaturesMixin, FASTAFile) {\n\n    return declare([SeqFeatureStore, DeferredFeaturesMixin], {\n\n        /**\n         * Storage backend for sequences in UNINDEXED fasta files\n         * served as static text files.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            var fastaBlob = args.fasta || args.blob || new XHRBlob(this.resolveUrl(args.urlTemplate || 'data.fasta'));\n\n            this.index = {};\n\n            this.fasta = new FASTAFile({\n                store: this,\n                data: fastaBlob\n            });\n\n            this.fasta.init({\n                success: lang.hitch(this, function () {\n                    this._deferred.features.resolve({ success: true });\n                }),\n                failure: lang.hitch(this, '_failAllDeferred')\n            });\n        },\n\n        _getFeatures: function _getFeatures(query, featCallback, endCallback, errorCallback) {\n            this.fasta.fetch(this.refSeq.name, query.start, query.end, featCallback, endCallback, errorCallback);\n        },\n\n        getRefSeqs: function getRefSeqs(featCallback, errorCallback) {\n            var thisB = this;\n            this._deferred.features.then(function () {\n                featCallback(thisB.fasta.refseqs);\n            }, errorCallback);\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: (this.config.file || this.config.blob).url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/UnindexedFasta.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/UnindexedFasta/File.js":
/*!*************************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/UnindexedFasta/File.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Deferred, has, Util, Errors, SimpleFeature) {\n\n    return declare(null, {\n        constructor: function constructor(args) {\n            this.store = args.store;\n            this.data = args.data;\n            this.features = {};\n            this.refseqs = [];\n        },\n\n        init: function init(args) {\n            var fasta = this.data;\n            var thisB = this;\n            var successCallback = args.success || function () {};\n            var failCallback = args.failure || function (e) {\n                console.error(e, e.stack);\n            };\n            this.parseFile(fasta, function (data) {\n\n                array.forEach(data, function (rs) {\n                    thisB.features[rs.name] = {\n                        seq_id: rs.name,\n                        name: rs.name,\n                        start: 0,\n                        end: rs.seq.length,\n                        seq: rs.seq\n                    };\n                    thisB.refseqs.push({\n                        name: rs.name,\n                        start: 0,\n                        end: rs.seq.length,\n                        length: rs.seq.length\n                    });\n                });\n\n                successCallback();\n            }, failCallback);\n        },\n\n        fetch: function fetch(chr, min, max, featCallback, endCallback, errorCallback) {\n            errorCallback = errorCallback || function (e) {\n                console.error(e);\n            };\n            var refname = chr;\n            if (!this.store.browser.compareReferenceNames(chr, refname)) {\n                refname = chr;\n            }\n            featCallback(new SimpleFeature({\n                data: {\n                    start: this.features[refname].start,\n                    end: this.features[refname].end,\n                    residues: this.features[refname].seq,\n                    seq_id: refname,\n                    name: refname\n                }\n            }));\n\n            endCallback();\n        },\n\n        parseFile: function parseFile(fastaFile, successCallback, failCallback) {\n            this.data.fetch(dojo.hitch(this, function (text) {\n                var fastaString = \"\";\n                var bytes = new Uint8Array(text);\n                var length = bytes.length;\n                for (var i = 0; i < length; i++) {\n                    fastaString += String.fromCharCode(bytes[i]);\n                }\n\n                if (!(fastaString && fastaString.length)) failCallback(\"Could not read file: \" + fastaFile.name);else {\n                    var data = this.parseString(fastaString);\n                    if (!data.length) failCallback(\"File contained no (FASTA) sequences\");else successCallback(data);\n                }\n            }), failCallback);\n        },\n\n        parseString: function parseString(fastaString) {\n            var data = [];\n            var addSeq = function addSeq(s) {\n                if (\"name\" in s && s.seq.length) // ignore empty sequences\n                    data.push(s);\n            };\n            var current = { seq: \"\" };\n            var lines = fastaString.match(/^.*((\\r\\n|\\n|\\r)|$)/gm); // this is wasteful, maybe try to avoid storing split lines separately later\n\n            for (var i = 0; i < lines.length; i++) {\n                var m;\n                if (m = /^>(\\S*)/.exec(lines[i])) {\n                    addSeq(current);\n                    current = { seq: \"\" };\n                    if (m[1].length) current.name = m[1];\n                } else if (m = /^\\s*(\\S+)\\s*$/.exec(lines[i])) {\n                    current.seq += m[1];\n                }\n            }\n            addSeq(current);\n\n            return data;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/UnindexedFasta/File.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/VCFTabix.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/VCFTabix.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _cjsRequire = __webpack_require__(/*! @gmod/tabix */ \"./node_modules/@gmod/tabix/dist/index.js\"),\n    TabixIndexedFile = _cjsRequire.TabixIndexedFile;\n\nvar VCF = __webpack_require__(/*! @gmod/vcf */ \"./node_modules/@gmod/vcf/dist/index.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/IndexedStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\"), __webpack_require__(/*! JBrowse/Model/VCFFeature */ \"./src/JBrowse/Model/VCFFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Errors, lang, SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin, XHRBlob, BlobFilehandleWrapper, VCFFeature) {\n\n    return declare([SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, IndexedStatsEstimationMixin], {\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var thisB = this;\n            var csiBlob, tbiBlob;\n\n            if (args.csi || this.config.csiUrlTemplate) {\n                csiBlob = new BlobFilehandleWrapper(args.csi || new XHRBlob(this.resolveUrl(this.getConf('csiUrlTemplate', []))));\n            } else {\n                tbiBlob = new BlobFilehandleWrapper(args.tbi || new XHRBlob(this.resolveUrl(this.getConf('tbiUrlTemplate', []) || this.getConf('urlTemplate', []) + '.tbi')));\n            }\n\n            var fileBlob = new BlobFilehandleWrapper(args.file || new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), { expectRanges: true }));\n\n            this.fileBlob = fileBlob;\n\n            this.indexedData = new TabixIndexedFile({\n                tbiFilehandle: tbiBlob,\n                csiFilehandle: csiBlob,\n                filehandle: fileBlob,\n                chunkSizeLimit: args.chunkSizeLimit || 1000000,\n                renameRefSeqs: function renameRefSeqs(n) {\n                    return _this.browser.regularizeReferenceName(n);\n                }\n            });\n\n            this.getParser().then(function (parser) {\n                thisB._deferred.features.resolve({ success: true });\n                thisB._estimateGlobalStats().then(function (stats) {\n                    thisB.globalStats = stats;\n                    thisB._deferred.stats.resolve(stats);\n                }, lang.hitch(thisB, '_failAllDeferred'));\n            }, lang.hitch(thisB, '_failAllDeferred'));\n        },\n        getParser: function getParser() {\n            if (!this._parser) {\n                this._parser = this.indexedData.getHeader().then(function (header) {\n                    return new VCF({ header: header });\n                });\n            }\n            return this._parser;\n        },\n        _getFeatures: function _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n            var _this2 = this;\n\n            var thisB = this;\n            thisB.getParser().then(function (parser) {\n                var regularizedReferenceName = _this2.browser.regularizeReferenceName(query.ref);\n                thisB.indexedData.getLines(regularizedReferenceName, query.start, query.end, function (line, fileOffset) {\n                    var variant = parser.parseLine(line);\n                    var feature = new VCFFeature({\n                        variant: variant,\n                        parser: parser,\n                        id: 'vcf-' + fileOffset\n                    });\n                    featureCallback(feature);\n                }).then(finishedCallback, function (error) {\n                    if (errorCallback) {\n                        if (error.message && error.message.indexOf('Too much data') >= 0) {\n                            error = new Errors.DataOverflow(error.message);\n                        }\n                        errorCallback(error);\n                    } else console.error(error);\n                });\n            }).catch(errorCallback);\n        },\n\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            return this.indexedData.index.hasRefSeq(seqName, callback, errorCallback);\n        },\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.file.url,\n                tbiUrlTemplate: (this.config.tbi || {}).url,\n                csiUrlTemplate: (this.config.csi || {}).url\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/VCFTabix.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/VCFTribble.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/VCFTribble.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _cjsRequire = __webpack_require__(/*! @gmod/tribble-index */ \"./node_modules/@gmod/tribble-index/dist/index.js\"),\n    TribbleIndexedFile = _cjsRequire.TribbleIndexedFile;\n\nvar VCF = __webpack_require__(/*! @gmod/vcf */ \"./node_modules/@gmod/vcf/dist/index.js\");\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature */ \"./src/JBrowse/Store/SeqFeature.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Store/DeferredFeaturesMixin */ \"./src/JBrowse/Store/DeferredFeaturesMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin */ \"./src/JBrowse/Store/SeqFeature/GlobalStatsEstimationMixin.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\"), __webpack_require__(/*! JBrowse/Model/BlobFilehandleWrapper */ \"./src/JBrowse/Model/BlobFilehandleWrapper.js\"), __webpack_require__(/*! JBrowse/Model/VCFFeature */ \"./src/JBrowse/Model/VCFFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Errors, lang, SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, GlobalStatsEstimationMixin, XHRBlob, BlobFilehandleWrapper, VCFFeature) {\n\n    return declare([SeqFeatureStore, DeferredStatsMixin, DeferredFeaturesMixin, GlobalStatsEstimationMixin], {\n        constructor: function constructor(args) {\n            var _this = this;\n\n            var thisB = this;\n\n            var idxBlob = args.idx || new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(this.getConf('idxUrlTemplate', []) || this.getConf('urlTemplate', []) + '.idx')));\n\n            var fileBlob = args.file || new BlobFilehandleWrapper(new XHRBlob(this.resolveUrl(this.getConf('urlTemplate', [])), { expectRanges: true }));\n\n            this.indexedData = new TribbleIndexedFile({\n                filehandle: fileBlob,\n                tribbleFilehandle: idxBlob,\n                oneBasedClosed: true,\n                chunkSizeLimit: args.chunkSizeLimit || 2000000,\n                renameRefSeqs: function renameRefSeqs(n) {\n                    return _this.browser.regularizeReferenceName(n);\n                }\n            });\n\n            this.getParser().then(function (parser) {\n                thisB._deferred.features.resolve({ success: true });\n                thisB._estimateGlobalStats().then(function (stats) {\n                    thisB.globalStats = stats;\n                    thisB._deferred.stats.resolve(stats);\n                }, lang.hitch(thisB, '_failAllDeferred'));\n            }, lang.hitch(thisB, '_failAllDeferred'));\n        },\n        getParser: function getParser() {\n            if (!this._parser) {\n                this._parser = this.indexedData.getHeader().then(function (header) {\n                    return new VCF({ header: header });\n                });\n            }\n            return this._parser;\n        },\n        _getFeatures: function _getFeatures(query, featureCallback, finishedCallback, errorCallback) {\n            var _this2 = this;\n\n            var thisB = this;\n            thisB.getParser().then(function (parser) {\n                var regularizedReferenceName = _this2.browser.regularizeReferenceName(query.ref);\n                thisB.indexedData.getLines(regularizedReferenceName, query.start, query.end, function (line) {\n                    var variant = parser.parseLine(line);\n                    var feature = new VCFFeature({\n                        variant: variant,\n                        parser: parser,\n                        id: variant.ID.length ? variant.ID[0] : 'chr' + variant.CHROM + '_pos' + variant.POS + '_ref' + variant.REF + '_alt' + variant.ALT\n                    });\n                    featureCallback(feature);\n                }).then(finishedCallback, function (error) {\n                    if (errorCallback) {\n                        if (error.message && error.message.indexOf('Too much data') >= 0) {\n                            error = new Errors.DataOverflow(error.message);\n                        }\n                        errorCallback(error);\n                    } else console.error(error);\n                });\n            }).catch(errorCallback);\n        },\n\n\n        /**\n         * Interrogate whether a store has data for a given reference\n         * sequence.  Calls the given callback with either true or false.\n         *\n         * Implemented as a binary interrogation because some stores are\n         * smart enough to regularize reference sequence names, while\n         * others are not.\n         */\n        hasRefSeq: function hasRefSeq(seqName, callback, errorCallback) {\n            return this.indexedData.index.hasRefSeq(seqName, callback, errorCallback);\n        },\n\n        saveStore: function saveStore() {\n            return {\n                urlTemplate: this.config.file.url,\n                idxUrlTemplate: this.config.idx.url\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/VCFTribble.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/_InsertSizeCache.js":
/*!**********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/_InsertSizeCache.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util) {\n\n    return declare(null, {\n        constructor: function constructor(args) {\n            this.featureCache = {};\n            this.insertStatsCacheMin = args.insertStatsCacheMin || 400;\n            this.insertStatsMaxSize = args.insertStatsMaxSize || 50000;\n            this.insertStatsMinSize = args.insertStatsMinSize || 100;\n        },\n        cleanStatsCache: function cleanStatsCache() {\n            this.featureCache = {};\n        },\n        insertFeat: function insertFeat(feat) {\n            this.featureCache[feat.id()] = Math.abs(feat.get('template_length'));\n        },\n        getInsertSizeStats: function getInsertSizeStats() {\n            var _this = this;\n\n            var len = Object.keys(this.featureCache).length;\n            if (len > this.insertStatsCacheMin) {\n                var insertSizes = Object.values(this.featureCache).map(function (v) {\n                    return Math.abs(v);\n                });\n                var max = insertSizes.reduce(function (max, n) {\n                    return n > max ? n : max;\n                });\n                var min = insertSizes.reduce(function (min, n) {\n                    return n < min ? n : min;\n                });\n                var filteredInsertSizes = insertSizes.filter(function (tlen) {\n                    return tlen < _this.insertStatsMaxSize && tlen > _this.insertStatsMinSize;\n                });\n                var sum = filteredInsertSizes.reduce(function (a, b) {\n                    return a + b;\n                }, 0);\n                var sum2 = filteredInsertSizes.map(function (a) {\n                    return a * a;\n                }).reduce(function (a, b) {\n                    return a + b;\n                }, 0);\n                var total = filteredInsertSizes.length;\n                var avg = sum / total;\n                var sd = Math.sqrt((total * sum2 - sum * sum) / (total * total));\n                var upper = avg + 3 * sd;\n                var lower = avg - 3 * sd;\n                return { min: min, max: max, upper: upper, lower: lower };\n            }\n            return { upper: Infinity, lower: 0, min: 0, max: Infinity };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/_InsertSizeCache.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/_MismatchesMixin.js":
/*!**********************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/_MismatchesMixin.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Functions for parsing MD and CIGAR strings.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array) {\n\n    return declare(null, {\n\n        constructor: function constructor() {\n            this.cigarAttributeName = (this.config.cigarAttribute || 'cigar').toLowerCase();\n            this.mdAttributeName = (this.config.mdAttribute || 'md').toLowerCase();\n        },\n\n        _getSkipsAndDeletions: function _getSkipsAndDeletions(feature) {\n            var mismatches = [];\n            // parse the CIGAR tag if it has one\n            var cigarString = feature.get(this.cigarAttributeName);\n            if (cigarString) {\n                mismatches = this._cigarToSkipsAndDeletions(feature, this._parseCigar(cigarString));\n            } else {\n                var cramReadFeatures = feature.get('cram_read_features');\n                if (this.config.renderAlignment && cramReadFeatures && cramReadFeatures.length) {\n                    mismatches = mismatches.filter(function (m) {\n                        return !(m.type == \"deletion\" || m.type == \"mismatch\");\n                    });\n                }\n\n                // parse the CRAM read features if it has them\n                if (cramReadFeatures) {\n                    var _mismatches;\n\n                    (_mismatches = mismatches).push.apply(_mismatches, _toConsumableArray(this._cramReadFeaturesToMismatches(feature, cramReadFeatures).filter(function (m) {\n                        return m.type === 'skip' || m.type === 'deletion';\n                    })));\n                }\n            }\n\n            return mismatches;\n        },\n\n        _getMismatches: function _getMismatches(feature) {\n            var mismatches = [];\n            if (this.config.cacheMismatches && feature.record.mismatches) {\n                return feature.record.mismatches;\n            }\n\n            // parse the CIGAR tag if it has one\n            var cigarString = feature.get(this.cigarAttributeName),\n                cigarOps;\n            if (cigarString) {\n                cigarOps = this._parseCigar(cigarString);\n                mismatches.push.apply(mismatches, this._cigarToMismatches(feature, cigarOps));\n            }\n\n            // now let's look for CRAM or MD mismatches\n            var cramReadFeatures = feature.get('cram_read_features');\n            var mdString = feature.get(this.mdAttributeName);\n\n            // if there is an MD tag or CRAM mismatches, mismatches and deletions from the\n            // CIGAR string are replaced by those from MD\n            if (this.config.renderAlignment && (cramReadFeatures && cramReadFeatures.length || mdString)) {\n                mismatches = mismatches.filter(function (m) {\n                    return !(m.type == \"deletion\" || m.type == \"mismatch\");\n                });\n            }\n\n            // parse the CRAM read features if it has them\n            if (cramReadFeatures) {\n                var _mismatches2;\n\n                (_mismatches2 = mismatches).push.apply(_mismatches2, _toConsumableArray(this._cramReadFeaturesToMismatches(feature, cramReadFeatures)));\n            }\n\n            // parse the MD tag if it has one\n            if (mdString) {\n                var _mismatches3;\n\n                (_mismatches3 = mismatches).push.apply(_mismatches3, _toConsumableArray(this._mdToMismatches(feature, mdString, cigarOps, mismatches)));\n            }\n\n            // uniqify the mismatches\n            var seen = {};\n            mismatches = array.filter(mismatches, function (m) {\n                var key = m.type + ',' + m.start + ',' + m.length;\n                var s = seen[key];\n                seen[key] = true;\n                return !s;\n            });\n            if (this.config.cacheMismatches) {\n                feature.record.mismatches = mismatches;\n            }\n\n            return mismatches;\n        },\n\n        _parseCigar: function _parseCigar(cigar) {\n            return array.map(cigar.toUpperCase().match(/\\d+\\D/g), function (op) {\n                return [op.match(/\\D/)[0], parseInt(op)];\n            });\n        },\n\n        _cramReadFeaturesToMismatches: function _cramReadFeaturesToMismatches(feature, readFeatures) {\n            var start = feature.get('start');\n            var mismatches = [];\n            readFeatures.forEach(function (_ref) {\n                var code = _ref.code,\n                    refPos = _ref.refPos,\n                    data = _ref.data,\n                    sub = _ref.sub,\n                    ref = _ref.ref;\n\n                refPos = refPos - 1 - start;\n                if (code === 'X') {\n                    // substitution\n                    mismatches.push({\n                        start: refPos,\n                        length: 1,\n                        base: sub,\n                        altbase: ref,\n                        type: 'mismatch'\n                    });\n                } else if (code === 'I') {\n                    // insertion\n                    mismatches.push({\n                        start: refPos,\n                        type: 'insertion',\n                        base: '' + data.length,\n                        length: data.length\n                    });\n                } else if (code === 'N') {\n                    // reference skip\n                    mismatches.push({\n                        type: 'skip',\n                        length: data,\n                        start: refPos,\n                        base: 'N'\n                    });\n                } else if (code === 'S') {\n                    // soft clip\n                    var len = data.length;\n                    mismatches.push({\n                        start: refPos,\n                        type: 'softclip',\n                        base: 'S' + len,\n                        cliplen: len,\n                        length: 1\n                    });\n                } else if (code === 'P') {\n                    // padding\n                } else if (code === 'H') {\n                    // hard clip\n                    var _len = data;\n                    mismatches.push({\n                        start: refPos,\n                        type: 'hardclip',\n                        base: 'H' + _len,\n                        cliplen: _len,\n                        length: 1\n                    });\n                } else if (code === 'D') {\n                    // deletion\n                    mismatches.push({\n                        type: 'deletion',\n                        length: data,\n                        start: refPos,\n                        base: '*'\n                    });\n                } else if (code === 'b') {\n                    // stretch of bases\n                } else if (code === 'q') {\n                    // stretch of qual scores\n                } else if (code === 'B') {\n                    // a pair of [base, qual]\n                } else if (code === 'i') {\n                    // single-base insertion\n                    // insertion\n                    mismatches.push({\n                        start: refPos,\n                        type: 'insertion',\n                        base: data,\n                        length: 1\n                    });\n                } else if (code === 'Q') {\n                    // single quality value\n                }\n            });\n            return mismatches;\n        },\n\n\n        _cigarToMismatches: function _cigarToMismatches(feature, ops) {\n            var currOffset = 0;\n            var mismatches = [];\n            array.forEach(ops, function (oprec) {\n                var op = oprec[0];\n                var len = oprec[1];\n                // if( op == 'M' || op == '=' || op == 'E' ) {\n                //     // nothing\n                // }\n                if (op == 'I')\n                    // GAH: shouldn't length of insertion really by 0, since JBrowse internally uses zero-interbase coordinates?\n                    mismatches.push({ start: currOffset, type: 'insertion', base: '' + len, length: 1 });else if (op == 'D') mismatches.push({ start: currOffset, type: 'deletion', base: '*', length: len });else if (op == 'N') mismatches.push({ start: currOffset, type: 'skip', base: 'N', length: len });else if (op == 'X') mismatches.push({ start: currOffset, type: 'mismatch', base: 'X', length: len });else if (op == 'H') mismatches.push({ start: currOffset, type: 'hardclip', base: 'H' + len, length: 1 });else if (op == 'S') mismatches.push({ start: currOffset, type: 'softclip', base: 'S' + len, cliplen: len, length: 1 });\n\n                if (op != 'I' && op != 'S' && op != 'H') currOffset += len;\n            });\n            return mismatches;\n        },\n\n        // parse just the skips and deletions out of a CIGAR string\n        _cigarToSkipsAndDeletions: function _cigarToSkipsAndDeletions(feature, ops) {\n            var currOffset = 0;\n            var mismatches = [];\n            array.forEach(ops, function (oprec) {\n                var op = oprec[0];\n                var len = oprec[1];\n                if (op == 'D') mismatches.push({ start: currOffset, type: 'deletion', base: '*', length: len });else if (op == 'N') mismatches.push({ start: currOffset, type: 'skip', base: 'N', length: len });\n\n                if (op != 'I' && op != 'S' && op != 'H') currOffset += len;\n            });\n            return mismatches;\n        },\n\n        /**\n         * parse a SAM MD tag to find mismatching bases of the template versus the reference\n         * @returns {Array[Object]} array of mismatches and their positions\n         * @private\n         */\n        _mdToMismatches: function _mdToMismatches(feature, mdstring, cigarOps, cigarMismatches) {\n            var mismatchRecords = [];\n            var curr = { start: 0, base: '', length: 0, type: 'mismatch' };\n\n            // convert a position on the reference sequence to a position\n            // on the template sequence, taking into account hard and soft\n            // clipping of reads\n            function getTemplateCoord(refCoord, cigarOps) {\n                var templateOffset = 0;\n                var refOffset = 0;\n                for (var i = 0; i < cigarOps.length && refOffset <= refCoord; i++) {\n                    var op = cigarOps[i][0];\n                    var len = cigarOps[i][1];\n                    if (op == 'S' || op == 'I') {\n                        templateOffset += len;\n                    } else if (op == 'D' || op == 'P') {\n                        refOffset += len;\n                    } else {\n                        templateOffset += len;\n                        refOffset += len;\n                    }\n                }\n                return templateOffset - (refOffset - refCoord);\n            }\n\n            function nextRecord() {\n                // correct the start of the current mismatch if it comes after a cigar skip\n                var skipOffset = 0;\n                array.forEach(cigarMismatches || [], function (mismatch) {\n                    if (mismatch.type == 'skip' && curr.start >= mismatch.start) {\n                        curr.start += mismatch.length;\n                    }\n                });\n\n                // record it\n                mismatchRecords.push(curr);\n\n                // get a new mismatch record ready\n                curr = { start: curr.start + curr.length, length: 0, base: '', type: 'mismatch' };\n            };\n\n            var seq = feature.get('seq');\n\n            // now actually parse the MD string\n            array.forEach(mdstring.match(/(\\d+|\\^[a-z]+|[a-z])/ig), function (token) {\n                if (token.match(/^\\d/)) {\n                    // matching bases\n                    curr.start += parseInt(token);\n                } else if (token.match(/^\\^/)) {\n                    // insertion in the template\n                    curr.length = token.length - 1;\n                    curr.base = '*';\n                    curr.type = 'deletion';\n                    curr.seq = token.substring(1);\n                    nextRecord();\n                } else if (token.match(/^[a-z]/i)) {\n                    // mismatch\n                    for (var i = 0; i < token.length; i++) {\n                        curr.length = 1;\n                        curr.base = seq ? seq.substr(cigarOps ? getTemplateCoord(curr.start, cigarOps) : curr.start, 1) : 'X';\n                        curr.altbase = token;\n                        nextRecord();\n                    }\n                }\n            });\n            return mismatchRecords;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/_MismatchesMixin.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/_PairCache.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/_PairCache.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PairedRead = function () {\n    function PairedRead() {\n        _classCallCheck(this, PairedRead);\n    }\n\n    _createClass(PairedRead, [{\n        key: 'id',\n        value: function id() {\n            return Math.min(this.read1.id(), this.read2.id());\n        }\n    }, {\n        key: 'get',\n        value: function get(field) {\n            return this._get(field.toLowerCase());\n        }\n    }, {\n        key: '_get',\n        value: function _get(field) {\n            if (field === 'start') {\n                return Math.min(this.read1._get('start'), this.read2._get('start'));\n            } else if (field === 'end') {\n                return Math.max(this.read1._get('end'), this.read2._get('end'));\n            } else if (field === 'name') {\n                return this.read1._get('name');\n            } else if (field === 'pair_orientation') {\n                return this.read1._get('pair_orientation');\n            } else if (field === 'template_length') {\n                return this.read1._get('template_length');\n            } else if (field === 'is_paired') {\n                return true; // simply comes from paired end reads\n            } else if (field === 'paired_feature') {\n                return true; // it is a combination of two reads\n            }\n        }\n    }, {\n        key: 'pairedFeature',\n        value: function pairedFeature() {\n            return true;\n        }\n    }, {\n        key: 'children',\n        value: function children() {}\n    }]);\n\n    return PairedRead;\n}();\n\nfunction canBePaired(alignment) {\n    return alignment._get('multi_segment_template') && !alignment._get('multi_segment_next_segment_unmapped') && alignment._get('seq_id') === alignment._get('next_seq_id') && (alignment._get('multi_segment_first') || alignment._get('multi_segment_last')) && !(alignment._get('secondary_alignment') || alignment._get('supplementary_alignment'));\n}\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util) {\n\n    return declare(null, {\n        constructor: function constructor(args) {\n            this.featureCache = {};\n        },\n        pairFeatures: function pairFeatures(query, records, featCallback, errorCallback) {\n            var pairCache = {};\n            for (var i = 0; i < records.length; i++) {\n                var feat = void 0;\n                if (canBePaired(records[i]) && Math.abs(records[i]._get('template_length')) < query.maxInsertSize) {\n                    var name = records[i]._get('name');\n                    feat = pairCache[name];\n                    if (feat) {\n                        if (records[i]._get('multi_segment_first')) {\n                            feat.read1 = records[i];\n                        } else if (records[i]._get('multi_segment_last')) {\n                            feat.read2 = records[i];\n                        } else {\n                            console.log('unable to pair read', records[i]);\n                        }\n                        if (feat.read1 && feat.read2) {\n                            delete pairCache[name];\n                            this.featureCache[name] = feat;\n                        }\n                    } else {\n                        feat = new PairedRead();\n                        if (records[i]._get('multi_segment_first')) {\n                            feat.read1 = records[i];\n                        } else if (records[i]._get('multi_segment_last')) {\n                            feat.read2 = records[i];\n                        } else {\n                            console.log('unable to pair read', records[i]);\n                        }\n                        pairCache[name] = feat;\n                    }\n                } else if (Util.intersect(records[i]._get('start'), records[i]._get('end'), query.start, query.end)) {\n                    var _feat = records[i];\n                    featCallback(_feat);\n                }\n            }\n            // dump paired features\n            Object.entries(this.featureCache).forEach(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    k = _ref2[0],\n                    v = _ref2[1];\n\n                if (Util.intersect(v._get('start'), v._get('end'), query.start, query.end)) {\n                    featCallback(v);\n                }\n            });\n            // dump unpaired features from the paircache\n            Object.entries(pairCache).forEach(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    k = _ref4[0],\n                    v = _ref4[1];\n\n                if (v.read1) {\n                    if (Util.intersect(v.read1._get('start'), v.read1._get('end'), query.start, query.end)) {\n                        featCallback(v.read1);\n                    }\n                } else if (v.read2) {\n                    if (Util.intersect(v.read2._get('start'), v.read2._get('end'), query.start, query.end)) {\n                        featCallback(v.read2);\n                    }\n                }\n            });\n        },\n        cleanFeatureCache: function cleanFeatureCache(query) {\n            var _this = this;\n\n            Object.entries(this.featureCache).forEach(function (_ref5) {\n                var _ref6 = _slicedToArray(_ref5, 2),\n                    k = _ref6[0],\n                    v = _ref6[1];\n\n                if (!Util.intersect(v._get('start'), v._get('end'), query.start, query.end)) {\n                    delete _this.featureCache[k];\n                }\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/_PairCache.js?");

/***/ }),

/***/ "./src/JBrowse/Store/SeqFeature/_SpanCache.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/SeqFeature/_SpanCache.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SpanFeature = function () {\n    function SpanFeature(feat) {\n        _classCallCheck(this, SpanFeature);\n\n        this.start = Math.min(feat._get('start'), feat._get('next_pos'));\n        this.end = Math.max(feat._get('end'), feat._get('next_pos'));\n        this.feat = feat;\n    }\n\n    _createClass(SpanFeature, [{\n        key: 'id',\n        value: function id() {\n            return this.feat.id();\n        }\n    }, {\n        key: 'get',\n        value: function get(field) {\n            return this._get(field.toLowerCase());\n        }\n    }, {\n        key: '_get',\n        value: function _get(field) {\n            if (field === 'start') {\n                return this.start;\n            } else if (field === 'end') {\n                return this.end;\n            }\n\n            return this.feat.get(field);\n        }\n    }, {\n        key: 'pairedFeature',\n        value: function pairedFeature() {\n            return true;\n        }\n    }, {\n        key: 'children',\n        value: function children() {}\n    }]);\n\n    return SpanFeature;\n}();\n\nfunction canBePaired(alignment) {\n    return alignment._get('multi_segment_template') && !alignment._get('multi_segment_next_segment_unmapped') && (alignment._get('multi_segment_first') || alignment._get('multi_segment_last')) && !(alignment._get('secondary_alignment') || alignment._get('supplementary_alignment'));\n}\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util) {\n\n    return declare(null, {\n        constructor: function constructor(args) {\n            this.featureCache = {};\n        },\n        pairFeatures: function pairFeatures(query, records, featCallback, errorCallback) {\n            for (var i = 0; i < records.length; i++) {\n                var feat = void 0;\n                if (canBePaired(records[i])) {\n                    var name = records[i]._get('name');\n                    if (!this.featureCache[name]) {\n                        this.featureCache[name] = new SpanFeature(records[i]);\n                    }\n                } else if (Util.intersect(records[i]._get('start'), records[i]._get('end'), query.start, query.end)) {\n                    var _feat = records[i];\n                    featCallback(_feat);\n                }\n            }\n            Object.entries(this.featureCache).forEach(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    k = _ref2[0],\n                    v = _ref2[1];\n\n                if (Util.intersect(v._get('start'), v._get('end'), query.start, query.end)) {\n                    featCallback(v);\n                }\n            });\n        },\n        cleanFeatureCache: function cleanFeatureCache(query) {\n            var _this = this;\n\n            Object.entries(this.featureCache).forEach(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 2),\n                    k = _ref4[0],\n                    v = _ref4[1];\n\n                if (!Util.intersect(v._get('start'), v._get('end'), query.start, query.end)) {\n                    delete _this.featureCache[k];\n                }\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/SeqFeature/_SpanCache.js?");

/***/ }),

/***/ "./src/JBrowse/Store/Sequence/IndexedFasta.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/Store/Sequence/IndexedFasta.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// renamed\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Store/SeqFeature/IndexedFasta */ \"./src/JBrowse/Store/SeqFeature/IndexedFasta.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (s) {\n  return s;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/Sequence/IndexedFasta.js?");

/***/ }),

/***/ "./src/JBrowse/Store/Sequence/StaticChunked.js":
/*!*****************************************************!*\
  !*** ./src/JBrowse/Store/Sequence/StaticChunked.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// renamed\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Store/SeqFeature/SequenceChunks */ \"./src/JBrowse/Store/SeqFeature/SequenceChunks.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (s) {\n  return s;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/Sequence/StaticChunked.js?");

/***/ }),

/***/ "./src/JBrowse/Store/Sequence/TwoBit.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/Store/Sequence/TwoBit.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// renamed\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Store/SeqFeature/TwoBit */ \"./src/JBrowse/Store/SeqFeature/TwoBit.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (s) {\n  return s;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/Sequence/TwoBit.js?");

/***/ }),

/***/ "./src/JBrowse/Store/TiledImage/Fixed.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/Store/TiledImage/Fixed.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/Deferred */ \"./node_modules/dojo/_base/Deferred.js\"), __webpack_require__(/*! JBrowse/Store */ \"./src/JBrowse/Store.js\"), __webpack_require__(/*! JBrowse/Store/DeferredStatsMixin */ \"./src/JBrowse/Store/DeferredStatsMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Deferred, Store, DeferredStatsMixin, Util) {\n\n    return declare([Store, DeferredStatsMixin],\n\n    /**\n     * Implements a store for image tiles that are only available at a\n     * fixed set of sizes and zoom levels.  Most often used with\n     * pre-generated image tiles served statically.\n     * @lends JBrowse.Store.TiledImage.Fixed\n     * @class\n     * @extends Store\n     */\n    {\n        constructor: function constructor(args) {\n            this.tileToImage = {};\n            this.zoomCache = {};\n\n            this.baseUrl = args.baseUrl;\n\n            this.url = this.resolveUrl(args.urlTemplate);\n\n            this._deferred.images = new Deferred();\n\n            dojo.xhrGet({ url: this.url,\n                handleAs: \"json\",\n                failOk: true,\n                load: dojo.hitch(this, function (o) {\n                    this.loadSuccess(o);\n                }),\n                error: dojo.hitch(this, '_failAllDeferred')\n            });\n        },\n\n        loadSuccess: function loadSuccess(o) {\n            this.globalStats = o.stats || {};\n            //backcompat\n            if (!('scoreMin' in this.globalStats)) this.globalStats.scoreMin = this.globalStats.global_min;\n            if (!('scoreMax' in this.globalStats)) this.globalStats.scoreMax = this.globalStats.global_max;\n\n            //tileWidth: width, in pixels, of the tiles\n            this.tileWidth = o.tileWidth;\n            this.align = o.align;\n            //zoomLevels: array of {basesPerTile, urlPrefix} hashes\n            this.zoomLevels = o.zoomLevels;\n\n            this._deferred.stats.resolve({ success: true });\n            this._deferred.images.resolve({ success: true });\n        },\n\n        /**\n         * @private\n         */\n        _getZoom: function _getZoom(scale) {\n            var result = this.zoomCache[scale];\n            if (result) return result;\n\n            result = this.zoomLevels[0];\n            var desiredBases = this.tileWidth / scale;\n            for (var i = 1; i < this.zoomLevels.length; i++) {\n                if (Math.abs(this.zoomLevels[i].basesPerTile - desiredBases) < Math.abs(result.basesPerTile - desiredBases)) result = this.zoomLevels[i];\n            }\n\n            this.zoomCache[scale] = result;\n            return result;\n        },\n\n        getImages: function getImages(query, callback, errorCallback) {\n            var thisB = this;\n            this._deferred.images.then(function (result) {\n                if (result.success) thisB._getImages(query, callback, errorCallback);else {\n                    thisB.error = result.error;\n                    errorCallback(result.error || result);\n                }\n            }, errorCallback);\n        },\n\n        /**\n         * Fetch an array of <code>&lt;img&gt;</code> elements for the image\n         * tiles that should be displayed for a certain magnification scale\n         * and section of the reference.\n         */\n        _getImages: function _getImages(query, callback, errorCallback) {\n            var scale = query.scale || 1;\n            var startBase = query.start;\n            var endBase = query.end;\n\n            var zoom = this._getZoom(scale);\n\n            var startTile = Math.max(startBase / zoom.basesPerTile, 0) | 0;\n            var endTile = endBase / zoom.basesPerTile | 0;\n\n            var result = [];\n            var im;\n            for (var i = startTile; i <= endTile; i++) {\n                im = document.createElement(\"img\");\n                dojo.connect(im, \"onerror\", this.handleImageError);\n                im.src = this._imageSource(zoom, i);\n                //TODO: need image coord systems that don't start at 0?\n                im.startBase = i * zoom.basesPerTile; // + this.refSeq.start;\n                im.baseWidth = zoom.basesPerTile;\n                im.tileNum = i;\n\n                result.push(im);\n            }\n            callback(result);\n        },\n\n        /**\n         * Gives the image source for a given zoom (as returned by _getZoom())\n         * and tileIndex.\n         * @private\n         */\n        _imageSource: function _imageSource(zoom, tileIndex) {\n            return Util.resolveUrl(this.url, zoom.urlPrefix + tileIndex + \".png\");\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/TiledImage/Fixed.js?");

/***/ }),

/***/ "./src/JBrowse/Store/TiledImage/Fixed_v0.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/Store/TiledImage/Fixed_v0.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Store/TiledImage/Fixed */ \"./src/JBrowse/Store/TiledImage/Fixed.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Fixed, Util) {\n  return declare(Fixed,\n  /**\n   * Subclass of TiledImageStore.Fixed to provide backward-compatibility\n   * with image stores formatted with JBrowse 1.2.1.\n   * @lends JBrowse.Store.TiledImage.Fixed_v0\n   * @class\n   * @extends JBrowse.Store.TiledImage.Fixed\n   */\n  {\n    _imageSource: function _imageSource(zoom, tileIndex) {\n      return Util.resolveUrl(this.url, '../../' + zoom.urlPrefix + tileIndex + \".png\");\n    }\n  });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/TiledImage/Fixed_v0.js?");

/***/ }),

/***/ "./src/JBrowse/Store/TrackMetaData.js":
/*!********************************************!*\
  !*** ./src/JBrowse/Store/TrackMetaData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/data/util/simpleFetch */ \"./node_modules/dojo/data/util/simpleFetch.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Digest/Crc32 */ \"./src/JBrowse/Digest/Crc32.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, simpleFetch, Util, Crc32) {\n    var dojof = Util.dojof;\n    var Meta = declare(null,\n\n    /**\n     * @lends JBrowse.Store.TrackMetaData.prototype\n     */\n    {\n\n        _noDataValue: '(no data)',\n\n        /**\n         * Data store for track metadata, supporting faceted\n         * (parameterized) searching.  Keeps all of the track metadata,\n         * and the indexes thereof, in memory.\n         * @constructs\n         * @param args.trackConfigs {Array} array of track configuration\n         * @param args.indexFacets {Function|Array|String}\n         * @param args.onReady {Function}\n         * @param args.metadataStores {Array[dojox.data]}\n         */\n        constructor: function constructor(args) {\n            this.sortFacets = args.sortFacets !== undefined ? args.sortFacets : true;\n            // set up our facet name discrimination: what facets we will\n            // actually provide search on\n            var non_facet_attrs = ['conf'];\n            this._filterFacet = function () {\n                var filter = args.indexFacets || function () {\n                    return true;\n                };\n                // if we have a non-function filter, coerce to an array,\n                // then convert that array to a function\n                if (typeof filter == 'string') filter = [filter];\n                if (dojo.isArray(filter)) {\n                    var oldfilter = filter;\n                    filter = function filter(facetName) {\n                        return dojo.some(oldfilter, function (fn) {\n                            return facetName == fn.toLowerCase();\n                        });\n                    };\n                }\n                var ident_facets = this.getIdentityAttributes();\n                return function (facetName) {\n                    return (\n                        // always index ident facets\n                        dojo.some(ident_facets, function (n) {\n                            return n == facetName;\n                        })\n                        // otherwise, must pass the user filter AND not be one of our explicitly-blocked attrs\n                        || filter(facetName) && !dojo.some(non_facet_attrs, function (a) {\n                            return a == facetName;\n                        })\n                    );\n                };\n            }.call(this);\n\n            // set up our onReady callbacks to fire once the data is\n            // loaded\n            if (!dojo.isArray(args.onReady)) {\n                this.onReadyFuncs = args.onReady ? [args.onReady] : [];\n            } else {\n                this.onReadyFuncs = dojo.clone(args.onReady);\n            }\n\n            // interpret the track configurations themselves as a metadata store\n            this._indexItems({\n                store: this,\n                items: dojo.map(args.trackConfigs, dojo.hitch(this, '_trackConfigToItem'))\n            });\n\n            // fetch and index all the items from each of the stores\n            var stores_fetched_count = 0;\n            // filter out empty metadata store entries\n            args.metadataStores = dojo.filter(args.metadataStores, function (s) {\n                return s;\n            });\n            if (!args.metadataStores || !args.metadataStores.length) {\n                // if we don't actually have any stores besides the track\n                // confs, we're ready now.\n                this._finishLoad();\n            } else {\n                // index the track metadata from each of the stores\n\n                var storeFetchFinished = dojo.hitch(this, function () {\n                    if (++stores_fetched_count == args.metadataStores.length) this._finishLoad();\n                });\n                dojo.forEach(args.metadataStores, function (store) {\n                    store.fetch({\n                        scope: this,\n                        onComplete: dojo.hitch(this, function (items) {\n                            // build our indexes\n                            this._indexItems({ store: store, items: items, supplementalOnly: true });\n\n                            // if this is the last store to be fetched, call\n                            // our onReady callbacks\n                            storeFetchFinished();\n                        }),\n                        onError: function onError(e) {\n                            console.error(e, e.stack);\n                            storeFetchFinished();\n                        }\n                    });\n                }, this);\n            }\n\n            // listen for track-editing commands and update our track metadata accordingly\n            args.browser.subscribe('/jbrowse/v1/c/tracks/new', dojo.hitch(this, 'addTracks'));\n            args.browser.subscribe('/jbrowse/v1/c/tracks/replace', dojo.hitch(this, function (trackConfigs) {\n                this.deleteTracks(trackConfigs, 'no events');\n                this.addTracks(trackConfigs, 'no events');\n            }));\n            args.browser.subscribe('/jbrowse/v1/c/tracks/delete', dojo.hitch(this, 'deleteTracks'));\n        },\n\n        /**\n         * Convert a track config object into a data store item.\n         */\n        _trackConfigToItem: function _trackConfigToItem(conf) {\n            var metarecord = dojo.clone(conf.metadata || {});\n            metarecord.label = conf.label;\n            metarecord.key = conf.key;\n            metarecord.conf = conf;\n            metarecord['track type'] = conf.type;\n            if (conf.category) metarecord.category = conf.category;\n            return metarecord;\n        },\n\n        // map of special comparator functions for certain metadata items\n        comparatorMap: {\n            // for category metadata, split on \"/\" and compare\n            \"category\": function category(a, b) {\n                var acs = (a || 'Uncategorized').split(/\\s*\\/\\s*/);\n                var bcs = (b || 'Uncategorized').split(/\\s*\\/\\s*/);\n                var ac, bc, compresult;\n                while ((ac = acs.shift()) && (bc = bcs.shift())) {\n                    if (compresult = ac.localeCompare(bc)) return compresult;\n                }\n                return 0;\n            }\n        },\n\n        addTracks: function addTracks(trackConfigs, suppressEvents) {\n            if (trackConfigs.length) {\n                // clear the query cache\n                delete this.previousQueryFingerprint;\n                delete this.previousResults;\n            }\n\n            array.forEach(trackConfigs, function (conf) {\n                // insert in the indexes\n                this._indexItems({\n                    store: this,\n                    items: [this._trackConfigToItem(conf)]\n                });\n\n                var name = conf.label;\n                var item = this.fetchItemByIdentity(name);\n                if (!item) console.error('failed to add ' + name + ' track to track metadata store', conf);else if (!suppressEvents) this.onNew(item);\n            }, this);\n        },\n\n        deleteTracks: function deleteTracks(trackConfigs, suppressEvents) {\n            if (trackConfigs.length) {\n                // clear the query cache\n                delete this.previousQueryFingerprint;\n                delete this.previousResults;\n            }\n\n            // we don't actually delete things, we just mark them as\n            // deleted and filter out deleted ones when returning results.\n            array.forEach(trackConfigs, function (conf) {\n                var name = conf.label;\n                var item = this.fetchItemByIdentity(name);\n                if (item) {\n                    item.DELETED = true;\n                    if (!suppressEvents) this.onDelete(item);\n                }\n            }, this);\n        },\n\n        /**\n         * Set the store's state to be ready (i.e. loaded), and calls all\n         * our onReady callbacks.\n         * @private\n         */\n        _finishLoad: function _finishLoad() {\n            // sort the facet names\n            if (this.sortFacets) {\n                this.facets.sort();\n            }\n\n            // calculate the average bucket size for each facet index\n            dojo.forEach(dojof.values(this.facetIndexes.byName), function (bucket) {\n                bucket.avgBucketSize = bucket.itemCount / bucket.bucketCount;\n            });\n            // calculate the rank of the facets: make an array of\n            // facet names sorted by bucket size, descending\n            this.facetIndexes.facetRank = dojo.clone(this.facets).sort(dojo.hitch(this, function (a, b) {\n                return this.facetIndexes.byName[a].avgBucketSize - this.facetIndexes.byName[b].avgBucketSize;\n            }));\n\n            // sort the facet indexes by ident, so that we can do our\n            // kind-of-efficient N-way merging when querying.  also,\n            // uniqify them by identity.\n            var itemSortFunction = dojo.hitch(this, '_itemSortFunc');\n            dojo.forEach(dojof.values(this.facetIndexes.byName), function (facetIndex) {\n                dojo.forEach(dojof.values(facetIndex.byValue), function (valueIndex) {\n                    var uniqueItems = [];\n                    var seen = {};\n                    //NOTE: the first record loaded with a given identity always wins\n                    array.forEach(valueIndex.items, function (item) {\n                        var id = this.getIdentity(item);\n                        if (!seen[id]) {\n                            seen[id] = true;\n                            uniqueItems.push(item);\n                        }\n                    }, this);\n                    valueIndex.items = uniqueItems.sort(itemSortFunction);\n                }, this);\n            }, this);\n\n            this.ready = true;\n            this._onReady();\n        },\n\n        _itemSortFunc: function _itemSortFunc(a, b) {\n            var ai = this.getIdentity(a),\n                bi = this.getIdentity(b);\n            return ai == bi ? 0 : ai > bi ? 1 : ai < bi ? -1 : 0;\n        },\n\n        _indexItems: function _indexItems(args) {\n            // get our (filtered) list of facets we will index for\n            var store = args.store,\n                items = args.items;\n\n            var storeAttributes = {};\n\n            // convert the items to a uniform format\n            items = dojo.map(items, function (item) {\n                var itemattrs = store.getAttributes(item);\n\n                //convert the item into a uniform data format of plain objects\n                var newitem = {};\n                dojo.forEach(itemattrs, function (attr) {\n                    // stores sometimes emit undef attributes  >:-{\n                    if (!attr) return;\n\n                    var lcattr = attr.toLowerCase();\n                    storeAttributes[lcattr] = true;\n                    newitem[lcattr] = store.getValue(item, attr);\n                });\n                return newitem;\n            }, this);\n\n            // merge them with any existing records, filtering out ones\n            // that should be ignored if we were passed\n            // 'supplementalOnly', and update the identity index\n            this.identIndex = this.identIndex || {};\n            items = function () {\n                var seenInThisStore = {};\n                return dojo.map(items, function (item) {\n                    // merge the new item attributes with any existing\n                    // record for this item\n                    var ident = this.getIdentity(item);\n                    var existingItem = this.identIndex[ident];\n                    if (existingItem && existingItem.DELETED) delete existingItem.DELETED;\n\n                    // skip this item if we have already\n                    // seen it from this store, or if we\n                    // are supplementalOnly and it\n                    // does not already exist\n                    if (seenInThisStore[ident] || args.supplementalOnly && !existingItem) {\n                        return null;\n                    }\n                    seenInThisStore[ident] = true;\n\n                    return this.identIndex[ident] = dojo.mixin(existingItem || {}, item);\n                }, this);\n            }.call(this);\n\n            // filter out nulls\n            items = dojo.filter(items, function (i) {\n                return i;\n            });\n\n            // update our facet list to include any new attrs these\n            // items have\n            var store_facets = dojof.keys(storeAttributes);\n            var new_facets = this._addFacets(dojof.keys(storeAttributes));\n            var use_facets = array.filter(this.facets, function (f) {\n                return f in storeAttributes;\n            });\n\n            // initialize indexes for any new facets\n            this.facetIndexes = this.facetIndexes || { itemCount: 0, bucketCount: 0, byName: {} };\n            dojo.forEach(new_facets, function (facet) {\n                if (!this.facetIndexes.byName[facet]) {\n                    this.facetIndexes.bucketCount++;\n                    this.facetIndexes.byName[facet] = { itemCount: 0, bucketCount: 0, byValue: {} };\n                }\n            }, this);\n\n            // now update the indexes with the new data\n            if (use_facets.length) {\n                var gotDataForItem = {};\n                dojo.forEach(use_facets, function (f) {\n                    gotDataForItem[f] = {};\n                });\n\n                dojo.forEach(items, function (item) {\n                    this.facetIndexes.itemCount++;\n                    dojo.forEach(use_facets, function (facet) {\n                        var value = this.getValue(item, facet, undefined);\n                        if (typeof value == 'undefined') return;\n                        gotDataForItem[facet][this.getIdentity(item)] = 1;\n                        this._indexItem(facet, value, item);\n                    }, this);\n                }, this);\n\n                // index the items that do not have data for this facet\n                dojo.forEach(use_facets, function (facet) {\n                    dojo.forEach(dojof.values(this.identIndex), function (item) {\n                        if (!gotDataForItem[facet][this.getIdentity(item)]) {\n                            this._indexItem(facet, this._noDataValue, item);\n                        }\n                    }, this);\n                }, this);\n            }\n        },\n\n        /**\n         * Add an item to the indexes for the given facet name and value.\n         * @private\n         */\n        _indexItem: function _indexItem(facet, value, item) {\n            var facetValues = this.facetIndexes.byName[facet];\n            var bucket = facetValues.byValue[value];\n            if (!bucket) {\n                bucket = facetValues.byValue[value] = { itemCount: 0, items: [] };\n                facetValues.bucketCount++;\n            }\n            bucket.itemCount++;\n            facetValues.itemCount++;\n            bucket.items.push(item);\n        },\n\n        /**\n         * Given an array of string facet names, add records for them,\n         * initializing the necessary data structures.\n         * @private\n         * @returns {Array[String]} facet names that did not already exist\n         */\n        _addFacets: function _addFacets(facetNames) {\n            var old_facets = this.facets || [];\n            var seen = {};\n            this.facets = dojo.filter(old_facets.concat(facetNames), function (facetName) {\n                var take = this._filterFacet(facetName) && !seen[facetName];\n                seen[facetName] = true;\n                return take;\n            }, this);\n            return this.facets.slice(old_facets.length);\n        },\n\n        /**\n         * Get the number of items that matched the most recent query.\n         * @returns {Number} the item count, or undefined if there has not\n         * been any query so far.\n         */\n        getCount: function getCount() {\n            return this._fetchCount;\n        },\n\n        /**\n         * @param facetName {String} facet name\n         * @returns {Object}\n         */\n        getFacetCounts: function getFacetCounts(facetName) {\n            var context = this._fetchFacetCounts[facetName] || this._fetchFacetCounts['__other__'];\n            return context ? context[facetName] : undefined;\n        },\n\n        /**\n         * Get an array of the text names of the facets that are defined\n         * in this track metadata.\n         * @param callback {Function} called as callback( [facet,facet,...] )\n         */\n        getFacetNames: function getFacetNames(callback) {\n            return this.facets;\n        },\n\n        /**\n         * Get an Array of the distinct values for a given facet name.\n         * @param facetName {String} the facet name\n         * @returns {Array} distinct values for that facet\n         */\n        getFacetValues: function getFacetValues(facetName) {\n            var index = this.facetIndexes.byName[facetName];\n            if (!index) return [];\n\n            return dojof.keys(index.byValue);\n        },\n\n        /**\n         * Get statistics about the facet with the given name.\n         * @returns {Object} as: <code>{ itemCount: ##, bucketCount: ##, avgBucketSize: ## }</code>\n         */\n        getFacetStats: function getFacetStats(facetName) {\n            var index = this.facetIndexes.byName[facetName];\n            if (!index) return {};\n\n            var stats = {};\n            dojo.forEach(['itemCount', 'bucketCount', 'avgBucketSize'], function (attr) {\n                stats[attr] = index[attr];\n            });\n            return stats;\n        },\n\n        // dojo.data.api.Read support\n\n        getValue: function getValue(i, attr, defaultValue) {\n            var v = i[attr];\n            return typeof v == 'undefined' ? defaultValue : v;\n        },\n        getValues: function getValues(i, attr) {\n            var a = [i[attr]];\n            return typeof a[0] == 'undefined' ? [] : a;\n        },\n\n        getAttributes: function getAttributes(item) {\n            return dojof.keys(item);\n        },\n\n        hasAttribute: function hasAttribute(item, attr) {\n            return item.hasOwnProperty(attr);\n        },\n\n        containsValue: function containsValue(item, attribute, value) {\n            return item[attribute] == value;\n        },\n\n        isItem: function isItem(item) {\n            return (typeof item === 'undefined' ? 'undefined' : _typeof(item)) == 'object' && typeof item.label == 'string';\n        },\n\n        isItemLoaded: function isItemLoaded() {\n            return this.ready;\n        },\n\n        loadItem: function loadItem(args) {},\n\n        getItem: function getItem(label) {\n            if (this.ready) return this.identIndex[label];else return null;\n        },\n\n        // used by the dojo.data.util.simpleFetch mixin to implement fetch()\n        _fetchItems: function _fetchItems(keywordArgs, findCallback, errorCallback) {\n            if (!this.ready) {\n                this.onReady(dojo.hitch(this, '_fetchItems', keywordArgs, findCallback, errorCallback));\n                return;\n            }\n\n            var query = dojo.clone(keywordArgs.query || {});\n            // coerce query arguments to arrays if they are not already arrays\n            dojo.forEach(dojof.keys(query), function (qattr) {\n                if (!dojo.isArray(query[qattr])) {\n                    query[qattr] = [query[qattr]];\n                }\n            }, this);\n\n            var results;\n            var queryFingerprint = Crc32.objectFingerprint(query);\n            if (queryFingerprint == this.previousQueryFingerprint) {\n                results = this.previousResults;\n            } else {\n                this.previousQueryFingerprint = queryFingerprint;\n                this.previousResults = results = this._doQuery(query);\n            }\n\n            // and finally, hand them to the finding callback\n            findCallback(results, keywordArgs);\n            this.onFetchSuccess();\n        },\n\n        /**\n         * @private\n         */\n        _doQuery: function _doQuery( /**Object*/query) {\n\n            var textFilter = this._compileTextFilter(query.text);\n            delete query.text;\n\n            // algorithm pseudocode:\n            //\n            //    * for each individual facet, get a set of tracks that\n            //      matches its selected values.  sort each set by the\n            //      track's unique identifier.\n            //    * while still need to go through all the items in the filtered sets:\n            //          - if all the facets have the same track first in their sorted set:\n            //                 add it to the core result set.\n            //                 count it in the global counts\n            //          - if all the facets *but one* have the same track first:\n            //                 this track will need to be counted in the\n            //                 'leave-out' counts for the odd facet out.  count it.\n            //          - shift the lowest-labeled track off of whatever facets have it at the front\n\n            var results = []; // array of items that completely match the query\n\n            // construct the filtered sets (arrays of items) for each of\n            // our search criteria\n            var filteredSets = [];\n            if (textFilter) {\n                filteredSets.push(this._filterDeleted(array.filter(dojof.values(this.identIndex), textFilter)).sort(dojo.hitch(this, '_itemSortFunc')));\n                filteredSets[0].facetName = 'Contains text';\n            }\n            filteredSets.push.apply(filteredSets, dojo.map(dojof.keys(query), function (facetName) {\n                var values = query[facetName];\n                var items = [];\n                if (!this.facetIndexes.byName[facetName]) {\n                    console.error(\"No facet defined with name '\" + facetName + \"'.\");\n                    throw \"No facet defined with name '\" + facetName + \"', faceted search failed.\";\n                }\n                dojo.forEach(values, function (value) {\n                    var idx = this.facetIndexes.byName[facetName].byValue[value] || {};\n                    items.push.apply(items, this._filterDeleted(idx.items || []));\n                }, this);\n                items.facetName = facetName;\n                items.sort(dojo.hitch(this, '_itemSortFunc'));\n                return items;\n            }, this));\n            dojo.forEach(filteredSets, function (s) {\n                s.myOffset = 0;\n                s.topItem = function () {\n                    return this[this.myOffset];\n                };\n                s.shift = function () {\n                    this.myOffset++;\n                };\n            });\n\n            // init counts\n            var facetMatchCounts = {};\n\n            if (!filteredSets.length) {\n                results = this._filterDeleted(dojof.values(this.identIndex));\n            } else {\n                // calculate how many item records total we need to go through\n                var leftToProcess = 0;\n                dojo.forEach(filteredSets, function (s) {\n                    leftToProcess += s.length;\n                });\n\n                // do a sort of N-way merge of the filtered sets\n                while (leftToProcess) {\n\n                    // look at the top of each of our sets, seeing what items\n                    // we have there.  group the sets by the identity of their\n                    // topmost item.\n                    var setsByTopIdent = {},\n                        uniqueIdents = [],\n                        ident,\n                        item;\n                    dojo.forEach(filteredSets, function (set, i) {\n                        item = set.topItem();\n                        ident = item ? this.getIdentity(item) : '(at end of set)';\n                        if (setsByTopIdent[ident]) {\n                            setsByTopIdent[ident].push(set);\n                        } else {\n                            setsByTopIdent[ident] = [set];\n                            uniqueIdents.push(ident);\n                        }\n                    }, this);\n                    if (uniqueIdents.length == 1) {\n                        // each of our matched sets has the same item at the\n                        // top.  this means it is part of the core result set.\n                        results.push(item);\n                    } else {\n\n                        // ident we are operating on is always the\n                        // lexically-first one that is not the end-of-set\n                        // marker\n                        uniqueIdents.sort();\n                        var leftOutIndex;\n                        if (uniqueIdents[0] == '(at end of set)') {\n                            ident = uniqueIdents[1];\n                            leftOutIndex = 0;\n                        } else {\n                            ident = uniqueIdents[0];\n                            leftOutIndex = 1;\n                        }\n                        ident = uniqueIdents[0] == '(at end of set)' ? uniqueIdents[1] : uniqueIdents[0];\n\n                        if (uniqueIdents.length == 2 && setsByTopIdent[ident].length == filteredSets.length - 1) {\n                            // all of the matched sets except one has the same\n                            // item on top, and it is the lowest-labeled item\n\n                            var leftOutSet = setsByTopIdent[uniqueIdents[leftOutIndex]][0];\n                            this._countItem(facetMatchCounts, setsByTopIdent[ident][0].topItem(), leftOutSet.facetName);\n                        }\n                    }\n\n                    dojo.forEach(setsByTopIdent[ident], function (s) {\n                        s.shift();leftToProcess--;\n                    });\n                }\n            }\n\n            // each of the leave-one-out count sets needs to also have the\n            // core result set counted in it, and also make a counting set\n            // for the core result set (used by __other__ facets not\n            // involved in the query)\n            dojo.forEach(dojof.keys(facetMatchCounts).concat(['__other__']), function (category) {\n                dojo.forEach(results, function (item) {\n                    this._countItem(facetMatchCounts, item, category);\n                }, this);\n            }, this);\n\n            // in the case of just one filtered set, the 'leave-one-out'\n            // count for it is actually the count of all results, so we\n            // need to make a special little count of that attribute for\n            // the global result set.\n            if (filteredSets.length == 1) {\n                dojo.forEach(dojof.values(this.identIndex), function (item) {\n                    this._countItem(facetMatchCounts, item, filteredSets[0].facetName);\n                }, this);\n            }\n\n            this._fetchFacetCounts = facetMatchCounts;\n            this._fetchCount = results.length;\n            return results;\n        },\n\n        _countItem: function _countItem(facetMatchCounts, item, facetName) {\n            var facetEntry = facetMatchCounts[facetName];\n            if (!facetEntry) facetEntry = facetMatchCounts[facetName] = {};\n            var facets = facetName == '__other__' ? this.facets : [facetName];\n            dojo.forEach(facets, function (attrName) {\n                var value = this.getValue(item, attrName, this._noDataValue);\n                var attrEntry = facetEntry[attrName];\n                if (!attrEntry) {\n                    attrEntry = facetEntry[attrName] = {};\n                    attrEntry[value] = 0;\n                }\n                attrEntry[value] = (attrEntry[value] || 0) + 1;\n            }, this);\n        },\n\n        onReady: function onReady(scope, func) {\n            scope = scope || dojo.global;\n            func = dojo.hitch(scope, func);\n            if (!this.ready) {\n                this.onReadyFuncs.push(func);\n                return;\n            } else {\n                func();\n            }\n        },\n\n        /**\n         * Event hook called once when the store is initialized and has\n         * an initial set of data loaded.\n         */\n        _onReady: function _onReady() {\n            dojo.forEach(this.onReadyFuncs || [], function (func) {\n                func.call();\n            });\n        },\n\n        /**\n         * Event hook called after a fetch has been successfully completed\n         * on this store.\n         */\n        onFetchSuccess: function onFetchSuccess() {},\n\n        /**\n         * Event hook called when there are new items in the store.\n         */\n        onNew: function onNew(item) {},\n        /**\n         * Event hook called when something is deleted from the store.\n         */\n        onDelete: function onDelete(item) {},\n        /**\n         * Event hook called when one or more items in the store have changed their values.\n         */\n        onSet: function onSet(item, attribute, oldvalue, newvalue) {},\n\n        _filterDeleted: function _filterDeleted(items) {\n            return array.filter(items, function (i) {\n                return !i.DELETED;\n            });\n        },\n\n        /**\n         * Compile a text search string into a function that tests whether\n         * a given piece of text matches that search string.\n         * @private\n         */\n        _compileTextFilter: function _compileTextFilter(textString) {\n            if (textString === undefined) return null;\n\n            // parse out words and quoted words, and convert each into a regexp\n            var rQuotedWord = /\\s*[\"']([^\"']+)[\"']\\s*/g;\n            var rWord = /(\\S+)/g;\n            var parseWord = function parseWord() {\n                var word = rQuotedWord.exec(textString) || rWord.exec(textString);\n                if (word) {\n                    word = word[1];\n                    var lastIndex = Math.max(rQuotedWord.lastIndex, rWord.lastIndex);\n                    rWord.lastIndex = rQuotedWord.lastIndex = lastIndex;\n                }\n                return word;\n            };\n            var wordREs = [];\n            var currentWord;\n            while (currentWord = parseWord()) {\n                // escape regex control chars, and convert glob-like chars to\n                // their regex equivalents\n                currentWord = dojo.regexp.escapeString(currentWord, '*?').replace(/\\*/g, '.+').replace(/ /g, '\\\\s+').replace(/\\?/g, '.');\n                wordREs.push(new RegExp(currentWord, 'i'));\n            }\n\n            // return a function that takes on item and returns true if it\n            // matches the text filter\n            return dojo.hitch(this, function (item) {\n                return dojo.some(this.facets, function (facetName) {\n                    var text = this.getValue(item, facetName);\n                    return array.every(wordREs, function (re) {\n                        return re.test(text);\n                    });\n                }, this);\n            });\n        },\n\n        getFeatures: function getFeatures() {\n            return {\n                'dojo.data.api.Read': true,\n                'dojo.data.api.Identity': true,\n                'dojo.data.api.Notification': true\n            };\n        },\n        close: function close() {},\n\n        getLabel: function getLabel(i) {\n            return this.getValue(i, 'key', undefined);\n        },\n        getLabelAttributes: function getLabelAttributes(i) {\n            return ['key'];\n        },\n\n        // dojo.data.api.Identity support\n        getIdentityAttributes: function getIdentityAttributes() {\n            return ['label'];\n        },\n        getIdentity: function getIdentity(i) {\n            return this.getValue(i, 'label', undefined);\n        },\n        fetchItemByIdentity: function fetchItemByIdentity(id) {\n            return this.identIndex[id];\n        }\n    });\n    dojo.extend(Meta, simpleFetch);\n    return Meta;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Store/TrackMetaData.js?");

/***/ }),

/***/ "./src/JBrowse/TouchScreenSupport.js":
/*!*******************************************!*\
  !*** ./src/JBrowse/TouchScreenSupport.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    var startX;\n    var initialPane;\n\n    /**\n     * Utility functions for touch-screen device (smartphone and tablet) support.\n     *\n     * @lends JBrowse.TouchScreenSupport\n     */\n    var Touch;\n    Touch = {\n\n        CompareObjPos: function CompareObjPos(nodes, touch) {\n            var samePos = 0,\n                j = 0,\n                top = touch.pageY;\n\n            for (var i = 0; i < nodes.length; i++) {\n                samePos = j++;\n                var position = Touch.findPos(nodes[i]);\n                if (position.top > top) {\n                    break;\n                }\n            }\n            return samePos;\n        },\n\n        checkAvatarPosition: function checkAvatarPosition(first) {\n            var leftPane = document.getElementById(\"tracksAvail\"),\n                rightPane = document.getElementById(\"container\");\n\n            if (!leftPane) return rightPane;\n\n            if (first.pageX < leftPane.offsetLeft + leftPane.offsetWidth) {\n                return leftPane;\n            } else {\n                return rightPane;\n            }\n        },\n\n        removeTouchEvents: function removeTouchEvents() {\n\n            startX = null;\n        },\n\n        touchSimulated: function touchSimulated(event) {\n            if (event.touches.length <= 1) {\n\n                var touches = event.changedTouches,\n                    first = touches[0],\n                    type1 = \"\",\n                    type2 = \"mouseover\",\n                    objAvatar = document.getElementsByClassName(\"dojoDndAvatar\"),\n                    obj = {},\n                    pane = Touch.checkAvatarPosition(first),\n                    nodes = pane.getElementsByClassName(\"dojoDndItem\"),\n                    element = {},\n                    simulatedEvent_1 = document.createEvent(\"MouseEvent\"),\n                    simulatedEvent_2 = document.createEvent(\"MouseEvent\");\n\n                switch (event.type) {\n\n                    case \"touchstart\":\n                        startX = first.pageX;\n                        type1 = \"mousedown\";\n                        break;\n                    case \"touchmove\":\n                        event.preventDefault();\n                        type1 = \"mousemove\";\n                        break;\n                    default:\n                        return;\n                }\n\n                simulatedEvent_1.initMouseEvent(type1, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);\n\n                simulatedEvent_2.initMouseEvent(type2, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);\n\n                switch (event.type) {\n                    case \"touchstart\":\n                        first.target.dispatchEvent(simulatedEvent_1);\n                        first.target.dispatchEvent(simulatedEvent_2);\n                        initialPane = pane;\n                        break;\n                    case \"touchmove\":\n                        if (objAvatar.length > 0) {\n                            if (nodes.length > 0) {\n                                element = Touch.CompareObjPos(nodes, first);\n                                obj = nodes[element];\n                            }\n                            try {\n                                if (initialPane != pane) {\n                                    var simulatedEvent_3 = document.createEvent(\"MouseEvent\");\n                                    var type3 = \"mouseout\";\n                                    simulatedEvent_3.initMouseEvent(type3, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);\n                                    initialPane.dispatchEvent(simulatedEvent_3);\n                                }\n                                obj.dispatchEvent(simulatedEvent_2);\n                                obj.dispatchEvent(simulatedEvent_1);\n                            } catch (err) {\n                                //No Elements in the pane\n                                pane.dispatchEvent(simulatedEvent_2);\n                                pane.dispatchEvent(simulatedEvent_1);\n                            }\n                        }\n                        break;\n                    default:\n                        return;\n                }\n            } else {\n                Touch.removeTouchEvents();\n            }\n        },\n\n        touchEnd: function touchEnd(event) {\n            var touches = event.changedTouches,\n                first = touches[0],\n                type1 = \"mouseup\",\n                type2 = \"mouseover\",\n                objAvatar = document.getElementsByClassName(\"dojoDndAvatar\"),\n                obj = {},\n                pane = Touch.checkAvatarPosition(first),\n                nodes = pane.getElementsByClassName(\"dojoDndItem\"),\n                element = {},\n                simulatedEvent_1 = document.createEvent(\"MouseEvent\"),\n                simulatedEvent_2 = document.createEvent(\"MouseEvent\");\n\n            if (startX !== first.pageX) {\n                //slide ocurrs\n                event.preventDefault();\n            }\n\n            var test = Touch.findPos(first.target);\n\n            simulatedEvent_1.initMouseEvent(type1, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);\n\n            simulatedEvent_2.initMouseEvent(type2, true, true, window, 1, first.pageX, first.pageY, first.clientX, first.clientY, false, false, false, false, 0, null);\n\n            if (objAvatar.length > 0) {\n                if (nodes.length > 0) {\n                    element = Touch.CompareObjPos(nodes, first);\n                    obj = nodes[element];\n                }\n                try {\n                    obj.dispatchEvent(simulatedEvent_2);\n                    obj.dispatchEvent(simulatedEvent_1);\n                } catch (error) {\n                    first.target.dispatchEvent(simulatedEvent_2);\n                    pane.dispatchEvent(simulatedEvent_2);\n                }\n            } else {\n                first.target.dispatchEvent(simulatedEvent_1);\n                first.target.dispatchEvent(simulatedEvent_2);\n            }\n\n            Touch.removeTouchEvents();\n        },\n\n        touchHandle: function touchHandle(event) {\n            dojo.query(\".dojoDndItemAnchor\").connect(\"touchstart\", Touch.touchSimulated);\n            dojo.query(\".dojoDndItemAnchor\").connect(\"touchmove\", Touch.touchSimulated);\n            dojo.query(\".dojoDndItemAnchor\").connect(\"touchend\", Touch.touchEnd);\n            dojo.query(\".dojoDndItemAnchor\").connect(\"click\", function () {\n                void 0;\n            });\n\n            if (event.touches.length <= 1) {\n\n                var touches = event.changedTouches,\n                    first = touches[0],\n                    type = \"\";\n\n                switch (event.type) {\n                    case \"touchstart\":\n                        startX = first.pageX;\n                        type = \"mousedown\";\n                        break;\n\n                    case \"touchmove\":\n                        event.preventDefault();\n                        type = \"mousemove\";\n                        break;\n\n                    case \"touchend\":\n                        if (startX !== first.pageX) {\n                            //slide ocurrs\n                            event.preventDefault();\n                        }\n                        type = \"mouseup\";\n                        break;\n\n                    default:\n                        return;\n                }\n\n                var simulatedEvent = document.createEvent(\"MouseEvent\");\n\n                simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);\n\n                first.target.dispatchEvent(simulatedEvent);\n            } else {\n                Touch.removeTouchEvents();\n            }\n        },\n\n        touchinit: function touchinit() {\n            dojo.query(\".dojoDndItem\").connect(\"touchstart\", Touch.touchSimulated);\n            dojo.query(\".dojoDndItem\").connect(\"touchmove\", Touch.touchSimulated);\n            dojo.query(\".dojoDndItem\").connect(\"touchend\", Touch.touchEnd);\n\n            dojo.query(\".locationThumb\").connect(\"touchstart\", Touch.touchHandle);\n            dojo.query(\".locationThumb\").connect(\"touchmove\", Touch.touchHandle);\n            dojo.query(\".locationThumb\").connect(\"touchend\", Touch.touchHandle);\n\n            dojo.query(\".dojoDndItem\").connect(\"click\", function () {\n                void 0;\n            });\n\n            dojo.query(\".dojoDndTarget\").connect(\"touchstart\", Touch.touchHandle);\n            dojo.query(\".dojoDndTarget\").connect(\"touchmove\", Touch.touchHandle);\n            dojo.query(\".dojoDndTarget\").connect(\"touchend\", Touch.touchHandle);\n\n            dojo.query(\".dijitSplitter\").connect(\"touchstart\", Touch.touchHandle);\n            dojo.query(\".dijitSplitter\").connect(\"touchmove\", Touch.touchHandle);\n            dojo.query(\".dijitSplitter\").connect(\"touchend\", Touch.touchHandle);\n        },\n\n        loadTouch: function loadTouch() {\n            Touch.touchinit();\n            document.documentElement.style.webkitTouchCallout = \"none\";\n        },\n\n        findPos: function findPos(obj) {\n            var curtop = 0,\n                objP = {};\n\n            if (obj.offsetParent) {\n                do {\n                    curtop += obj.offsetTop;\n                } while (obj = obj.offsetParent);\n            }\n\n            objP.top = curtop;\n\n            return objP;\n        }\n    };\n\n    return Touch;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/TouchScreenSupport.js?");

/***/ }),

/***/ "./src/JBrowse/Track.js":
/*!******************************!*\
  !*** ./src/JBrowse/Track.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Component */ \"./src/JBrowse/Component.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Component) {\n\n    return declare(Component, {\n\n        /**\n         * Returns object holding the default configuration for this track\n         * type.  Might want to override in subclasses.\n         * @private\n         */\n        configSchema: {\n            slots: [{ name: 'maxFeatureSizeForUnderlyingRefSeq', type: 'integer', defaultValue: 250000 }, { name: 'pinned', type: 'boolean', defaultValue: false }, { name: 'metadata', type: 'object', defaultValue: {} }, { name: 'style.trackLabelCss', type: 'string' }, { name: 'label', type: 'string' }, { name: 'query', type: 'object', defaultValue: {}, shortDesc: \"track-specific query variables to pass to the store\" }, { name: 'store', type: 'string|object', shortDesc: 'the name of the store to use with this track' }, { name: 'type', type: 'string', shortDesc: 'the JavaScript type of this track' }]\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Track.js?");

/***/ }),

/***/ "./src/JBrowse/Util/FastPromise.js":
/*!*****************************************!*\
  !*** ./src/JBrowse/Util/FastPromise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Very minimal and fast implementation of a promise, used in\n * performance-critical code.  Dojo Deferred is too heavy for some\n * uses.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    var fastpromise = function fastpromise() {\n        this.callbacks = [];\n    };\n\n    fastpromise.prototype.then = function (callback) {\n        if ('value' in this) callback(this.value);else this.callbacks.push(callback);\n    };\n\n    fastpromise.prototype.resolve = function (value) {\n        this.value = value;\n        var c = this.callbacks;\n        delete this.callbacks;\n        for (var i = 0; i < c.length; i++) {\n            c[i](this.value);\n        }\n    };\n\n    return fastpromise;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Util/FastPromise.js?");

/***/ }),

/***/ "./src/JBrowse/Util/FeatureFilters.js":
/*!********************************************!*\
  !*** ./src/JBrowse/Util/FeatureFilters.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Standard filtering subroutines that operate on feature objects.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    return {\n        plusStrand: function plusStrand(feature) {\n            var strand = feature.get('strand');\n            if (strand == 1 || strand == '+') {\n                return true;\n            } else {\n                return false;\n            }\n        },\n        minusStrand: function minusStrand(feature) {\n            var strand = feature.get('strand');\n            if (strand == -1 || strand == '-') {\n                return true;\n            } else {\n                return false;\n            }\n        },\n        all: function all(feature) {\n            return true;\n        },\n        none: function none(feature) {\n            return false;\n        }\n    };\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Util/FeatureFilters.js?");

/***/ }),

/***/ "./src/JBrowse/Util/GTF.js":
/*!*********************************!*\
  !*** ./src/JBrowse/Util/GTF.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Fast, low-level functions for parsing and formatting GFF3.\n * JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (array) {\n    var gff3_field_names = 'seq_id source type start end score strand phase attributes'.split(' ');\n\n    return {\n\n        parse_feature: function parse_feature(line) {\n            var f = array.map(line.split(\"\\t\"), function (a) {\n                if (a == '.') {\n                    return null;\n                }\n                return a;\n            });\n\n            // unescape only the ref and source columns\n            f[0] = this.unescape(f[0]);\n            f[1] = this.unescape(f[1]);\n\n            f[8] = this.parse_attributes(f[8]);\n            var parsed = {};\n            for (var i = 0; i < gff3_field_names.length; i++) {\n                parsed[gff3_field_names[i]] = f[i] == '.' ? null : f[i];\n            }\n            if (parsed.start !== null) parsed.start = parseInt(parsed.start, 10);\n            if (parsed.end !== null) parsed.end = parseInt(parsed.end, 10);\n            if (parsed.score !== null) parsed.score = parseFloat(parsed.score, 10);\n            if (parsed.strand !== null) parsed.strand = { '+': 1, '-': -1 }[parsed.strand] || 0;\n\n            return parsed;\n        },\n\n        parse_directive: function parse_directive(line) {\n            var match = /^\\s*\\#\\#\\s*(\\S+)\\s*(.*)/.exec(line);\n            if (!match) return null;\n            var name = match[1],\n                contents = match[2];\n\n            var parsed = { directive: name };\n            if (contents.length) {\n                contents = contents.replace(/\\r?\\n$/, '');\n                parsed.value = contents;\n            }\n\n            // do a little additional parsing for sequence-region and genome-build directives\n            if (name == 'sequence-region') {\n                var c = contents.split(/\\s+/, 3);\n                parsed.seq_id = c[0];\n                parsed.start = c[1].replace(/\\D/g, '');\n                parsed.end = c[2].replace(/\\D/g, '');\n            } else if (name == 'genome-build') {\n                var c = contents.split(/\\s+/, 2);\n                parsed.source = c[0];\n                parsed.buildname = c[1];\n            }\n\n            return parsed;\n        },\n\n        unescape: function unescape(s) {\n            if (s === null) return null;\n\n            return s.replace(/%([0-9A-Fa-f]{2})/g, function (match, seq) {\n                return String.fromCharCode(parseInt(seq, 16));\n            });\n        },\n\n        escape: function escape(s) {\n            return s.replace(/[\\n\\r\\t;=%&,\\x00-\\x1f\\x7f-\\xff]/g, function (ch) {\n                var hex = ch.charCodeAt(0).toString(16).toUpperCase();\n                if (hex.length < 2) // lol, apparently there's no native function for fixed-width hex output\n                    hex = '0' + hex;\n                return '%' + hex;\n            });\n        },\n\n        parse_attributes: function parse_attributes(attrString) {\n\n            if (!(attrString && attrString.length) || attrString == '.') return {};\n\n            attrString = attrString.replace(/\\r?\\n$/, '');\n\n            var attrs = {};\n            var attr_pat = /^\\s*(.+)\\s+\"(.+)\"/;\n            array.forEach(attrString.split(';'), function (a) {\n                var m;\n                var nv = (m = attr_pat.exec(a)) ? m.slice(1) : [];\n                //var nv = a.trim().replace(/\\\"+|\\'+/g,'').split(/\\s+/,2);\n                if (!(nv[1] && nv[1].length)) return;\n                var arec = attrs[nv[0]];\n                if (!arec) arec = attrs[nv[0]] = [];\n\n                arec.push.apply(arec, array.map(nv[1].split(','), this.unescape));\n            }, this);\n\n            return attrs;\n        },\n\n        format_feature: function format_feature(f) {\n            var attrString = f.attributes === null || typeof f.attributes == 'undefined' ? '.' : this.format_attributes(f.attributes);\n\n            var translate_strand = ['-', '.', '+'];\n            var fields = [];\n            for (var i = 0; i < 8; i++) {\n                var val = f[gff3_field_names[i]];\n                if (i == 6) // deserialize strand\n                    fields[i] = val === null || val === undefined ? '.' : translate_strand[val + 1];else fields[i] = val === null || val === undefined ? '.' : this.escape('' + val);\n            }\n            fields[8] = attrString;\n\n            return fields.join(\"\\t\") + \"\\n\";\n        },\n\n        format_attributes: function format_attributes(attrs) {\n            var attrOrder = [];\n            for (var tag in attrs) {\n                var val = attrs[tag];\n                var valstring = val.hasOwnProperty('toString') ? this.escape(val.toString()) : val.values ? function (val) {\n                    return val instanceof Array ? array.map(val, this.escape).join(',') : this.escape(val);\n                }.call(this, val.values) : val instanceof Array ? array.map(val, this.escape).join(',') : this.escape(val);\n                attrOrder.push(this.escape(tag) + '=' + valstring);\n            }\n            return attrOrder.length ? attrOrder.join(';') : '.';\n        }\n    };\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Util/GTF.js?");

/***/ }),

/***/ "./src/JBrowse/Util/RejectableFastPromise.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/Util/RejectableFastPromise.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Fast implementation of a promise, used in performance-critical code\n * that still needs to be able to reject promises.  Dojo Deferred is\n * too heavy for some uses.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n    var fastpromise = function fastpromise() {\n        this.callbacks = [];\n        this.errbacks = [];\n    };\n\n    fastpromise.prototype.then = function (callback, errback) {\n        if ('value' in this) callback(this.value);else if ('error' in this) errback(this.error);else {\n            this.callbacks.push(callback);\n            this.errbacks.push(errback);\n        }\n    };\n\n    fastpromise.prototype.resolve = function (value) {\n        this.value = value;\n        delete this.errbacks;\n        var c = this.callbacks;\n        delete this.callbacks;\n        for (var i = 0; i < c.length; i++) {\n            c[i](this.value);\n        }\n    };\n\n    fastpromise.prototype.reject = function (error) {\n        this.error = error;\n        delete this.callbacks;\n        var c = this.errbacks;\n        delete this.errbacks;\n        for (var i = 0; i < c.length; i++) {\n            c[i](error);\n        }\n    };\n\n    return fastpromise;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/Util/RejectableFastPromise.js?");

/***/ }),

/***/ "./src/JBrowse/View/Animation.js":
/*!***************************************!*\
  !*** ./src/JBrowse/View/Animation.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    /**\n     * @class\n     */\n    function Animation(subject, callback, time) {\n        //subject: what's being animated\n        //callback: function to call at the end of the animation\n        //time: time for the animation to run\n        if (subject === undefined) return;\n        //don't want a zoom and a slide going on at the same time\n        if (\"animation\" in subject) subject.animation.stop();\n        this.index = 0;\n        this.time = time;\n        this.subject = subject;\n        this.callback = callback;\n\n        var myAnim = this;\n        this.animFunction = function () {\n            myAnim.animate();\n        };\n        // number of milliseconds between frames (e.g., 33ms at 30fps)\n        this.animID = setTimeout(this.animFunction, 33);\n\n        this.frames = 0;\n\n        subject.animation = this;\n    }\n\n    Animation.prototype.animate = function () {\n        if (this.finished) {\n            this.stop();\n            return;\n        }\n\n        // number of milliseconds between frames (e.g., 33ms at 30fps)\n        var nextTimeout = 33;\n        var elapsed = 0;\n        if (!(\"startTime\" in this)) {\n            this.startTime = new Date().getTime();\n        } else {\n            elapsed = new Date().getTime() - this.startTime;\n            //set the next timeout to be the average of the\n            //frame times we've achieved so far.\n            //The goal is to avoid overloading the browser\n            //and getting a jerky animation.\n            nextTimeout = Math.max(33, elapsed / this.frames);\n        }\n\n        if (elapsed < this.time) {\n            this.step(elapsed / this.time);\n            this.frames++;\n        } else {\n            this.step(1);\n            this.finished = true;\n            //console.log(\"final timeout: \" + nextTimeout);\n        }\n        this.animID = setTimeout(this.animFunction, nextTimeout);\n    };\n\n    Animation.prototype.stop = function () {\n        clearTimeout(this.animID);\n        delete this.subject.animation;\n        this.callback.call(this.subject, this);\n    };\n    return Animation;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Animation.js?");

/***/ }),

/***/ "./src/JBrowse/View/Animation/Slider.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/Animation/Slider.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/View/Animation */ \"./src/JBrowse/View/Animation.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Animation) {\n\n    /**\n     * @class\n     */\n    function Slider(view, callback, time, distance) {\n        Animation.call(this, view, callback, time);\n        this.slideStart = view.getX();\n        this.slideDistance = distance;\n    }\n\n    Slider.prototype = new Animation();\n\n    Slider.prototype.step = function (pos) {\n        var newX = this.slideStart - this.slideDistance * (\n        //cos will go from 1 to -1, we want to go from 0 to 1\n        -0.5 * Math.cos(pos * Math.PI) + 0.5) | 0;\n\n        newX = Math.max(Math.min(this.subject.maxLeft - this.subject.offset, newX), this.subject.minLeft - this.subject.offset);\n        this.subject.setX(newX);\n    };\n\n    return Slider;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Animation/Slider.js?");

/***/ }),

/***/ "./src/JBrowse/View/Animation/Zoomer.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/Animation/Zoomer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/View/Animation */ \"./src/JBrowse/View/Animation.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Animation) {\n\n    /**\n     * @class\n     */\n    function Zoomer(scale, toScroll, callback, time, zoomLoc) {\n        Animation.call(this, toScroll, callback, time);\n        this.toZoom = toScroll.zoomContainer;\n        var cWidth = this.toZoom.clientWidth;\n\n        this.initialWidth = cWidth;\n\n        // the container width when zoomFraction is 0\n        this.width0 = cWidth * Math.min(1, scale);\n        // the container width when zoomFraction is 1\n        var width1 = cWidth * Math.max(1, scale);\n        this.distance = width1 - this.width0;\n        this.zoomingIn = scale > 1;\n        //this.zoomLoc = zoomLoc;\n        this.center = (toScroll.getX() + toScroll.elem.clientWidth * zoomLoc) / toScroll.scrollContainer.clientWidth;\n\n        // initialX and initialLeft can differ when we're scrolling\n        // using scrollTop and scrollLeft\n        this.initialX = this.subject.getX();\n        this.initialLeft = parseInt(this.toZoom.style.left);\n    };\n\n    Zoomer.prototype = new Animation();\n\n    Zoomer.prototype.step = function (pos) {\n        var zoomFraction = this.zoomingIn ? pos : 1 - pos;\n        var newWidth = zoomFraction * zoomFraction * this.distance + this.width0;\n        var newLeft = this.center * this.initialWidth - this.center * newWidth;\n        this.toZoom.style.width = newWidth + \"px\";\n        this.toZoom.style.left = this.initialLeft + newLeft + \"px\";\n        var forceRedraw = this.toZoom.offsetTop;\n\n        if (this.subject.updateStaticElements) this.subject.updateStaticElements({ x: this.initialX - newLeft });\n    };\n\n    return Zoomer;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Animation/Zoomer.js?");

/***/ }),

/***/ "./src/JBrowse/View/ConfirmDialog.js":
/*!*******************************************!*\
  !*** ./src/JBrowse/View/ConfirmDialog.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, focus, ActionBarDialog, on, dijitButton) {\n\n    return declare(ActionBarDialog,\n\n    /**\n     * Dijit Dialog subclass that pops up a yes/no confirmation\n     * more pleasant for use as an information popup.\n     * @lends JBrowse.View.ConfirmDialog\n     */\n    {\n        autofocus: false,\n\n        constructor: function constructor(args) {\n            this.message = args.message || 'Do you really want to do this?';\n            this.confirmLabel = args.confirmLabel || 'Yes';\n            this.denyLabel = args.denyLabel || 'No';\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            var thisB = this;\n            new dijitButton({ className: 'yes',\n                label: this.confirmLabel,\n                onClick: function onClick() {\n                    thisB.callback(true);\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n            new dijitButton({ className: 'no',\n                label: this.denyLabel,\n                onClick: function onClick() {\n                    thisB.callback(false);\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n        },\n\n        show: function show(callback) {\n            this.callback = callback || function () {};\n\n            this.set('content', this.message);\n\n            this.inherited(arguments);\n\n            focus.focus(this.closeButtonNode);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/ConfirmDialog.js?");

/***/ }),

/***/ "./src/JBrowse/View/DetailsMixin.js":
/*!******************************************!*\
  !*** ./src/JBrowse/View/DetailsMixin.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Mixin that provides generic functions for displaying nested data.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/dom-class */ \"./node_modules/dojo/dom-class.js\"), __webpack_require__(/*! dstore/Memory */ \"./node_modules/dojo-dstore/Memory.js\"), __webpack_require__(/*! dgrid/OnDemandGrid */ \"./node_modules/dgrid/OnDemandGrid.js\"), __webpack_require__(/*! dgrid/extensions/DijitRegistry */ \"./node_modules/dgrid/extensions/DijitRegistry.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, query, domConstruct, domClass, MemoryStore, DGrid, DGridDijitRegistry, Util) {\n\n    // make a DGrid that registers itself as a dijit widget\n    var Grid = declare([DGrid, DGridDijitRegistry]);\n\n    return declare(null, {\n\n        renderDetailField: function renderDetailField(parentElement, title, val, f, class_) {\n            var externalFieldMeta = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n            var unsafe = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n            if (val === null || val === undefined) return '';\n\n            // if this object has a 'fmtDetailFooField' function, delegate to that\n            var fieldSpecificFormatter;\n            if (fieldSpecificFormatter = this['fmtDetail' + Util.ucFirst(title) + 'Field']) return fieldSpecificFormatter.apply(this, arguments);\n\n            // otherwise, use default formatting\n\n            class_ = class_ || title.replace(/\\W/g, '_').toLowerCase();\n\n            var formatted_title = title;\n            // if this object has a config value 'fmtDetailField_Foo' function, apply it to field title\n            if ((fieldSpecificFormatter = this.config['fmtDetailField_' + title]) && f) {\n                formatted_title = fieldSpecificFormatter(title, f);\n                if (!formatted_title) return ''; // if the callback returns null, remove field from dialog\n            } else if ((fieldSpecificFormatter = this.config['fmtMetaField_' + title]) && !f) {\n                formatted_title = fieldSpecificFormatter(title);\n                if (!formatted_title) return ''; // if the callback returns null, remove field from dialog\n            }\n\n            // special case for values that include metadata about their\n            // meaning, which are formed like { values: [], meta:\n            // {description: }.  break it out, putting the meta description in a `title`\n            // attr on the field name so that it shows on mouseover, and\n            // using the values as the new field value.\n            var fieldMeta;\n            if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object' && !Array.isArray(val) && 'values' in val) {\n                fieldMeta = (val.meta || {}).description || (val.meta || {}).Description;\n                // join the description if it is an array\n                if (lang.isArray(fieldMeta)) fieldMeta = fieldMeta.join(', ');\n\n                val = val.values;\n            } else {\n                fieldMeta = externalFieldMeta.description;\n            }\n\n            if ((fieldSpecificFormatter = this.config['fmtDetailDescription_' + title]) && f) {\n                fieldMeta = fieldSpecificFormatter(fieldMeta);\n            } else if ((fieldSpecificFormatter = this.config['fmtMetaDescription_' + title]) && !f) {\n                fieldMeta = fieldSpecificFormatter(fieldMeta);\n            }\n            var titleAttr = fieldMeta ? ' title=\"' + fieldMeta + '\"' : '';\n            var fieldContainer = domConstruct.create('div', { className: 'field_container',\n                innerHTML: '<h2 class=\"field ' + class_ + '\"' + titleAttr + '>' + formatted_title + '</h2>'\n            }, parentElement);\n            var valueContainer = domConstruct.create('div', { className: 'value_container ' + class_\n            }, fieldContainer);\n\n            var count = this.renderDetailValue(valueContainer, title, val, f, class_, unsafe);\n            if (typeof count == 'number' && count > 4) {\n                query('h2', fieldContainer)[0].innerHTML = formatted_title + ' (' + count + ')';\n            }\n\n            return fieldContainer;\n        },\n\n        renderDetailValue: function renderDetailValue(parent, title, val, f, class_) {\n            var _this = this;\n\n            var unsafe = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n            var thisB = this;\n\n            if (!lang.isArray(val) && val && val.values) val = val.values;\n\n            // if this object has a 'fmtDetailFooValue' function, delegate to that\n            var fieldSpecificFormatter;\n            if (fieldSpecificFormatter = this['fmtDetail' + Util.ucFirst(title) + 'Value']) return fieldSpecificFormatter.apply(this, arguments);\n\n            // otherwise, use default formatting\n\n            // if this object has a config value 'fmtDetailValue_Foo' function, apply it to val\n            if ((fieldSpecificFormatter = this.config['fmtDetailValue_' + title]) && f) {\n                unsafe = true;\n                val = fieldSpecificFormatter(val, f);\n                if (!val) val = '';\n                if (val.length == 1) val = val[0]; // avoid recursion when an array of length 1 is returned\n            } else if ((fieldSpecificFormatter = this.config['fmtMetaValue_' + title]) && !f) {\n                unsafe = true;\n                val = fieldSpecificFormatter(val);\n                if (val.length == 1) val = val[0];\n            }\n\n            var valType = typeof val === 'undefined' ? 'undefined' : _typeof(val);\n            if (valType == 'object' && val === null) val = '';\n            if (typeof val.toHTML == 'function') val = val.toHTML();\n            if (valType == 'boolean') val = val ? 'yes' : 'no';else if (valType == 'undefined' || val === null) return 0;else if (lang.isArray(val)) {\n                var vals;\n                if (val.length > 0 && lang.isObject(val[0])) {\n                    parent.style.width = '90%';\n                    vals = val.map(function (v) {\n                        var itemContainer = domConstruct.create('div', {\n                            className: 'value_container ' + class_,\n                            style: { width: '100%' }\n                        }, parent);\n                        _this.renderDetailValue(itemContainer, title, v, f, class_, unsafe);\n                        return itemContainer;\n                    });\n                } else {\n                    vals = array.map(val, function (v) {\n                        return this.renderDetailValue(parent, title, v, f, class_, unsafe);\n                    }, this);\n                }\n                if (vals.length > 1) domClass.add(parent, 'multi_value');\n                if (vals.length > 10) domClass.add(parent, 'big');\n                return vals.length;\n            } else if (valType == 'object') {\n                var keys = Util.dojof.keys(val).sort();\n                var count = keys.length;\n                if (count > 5) {\n                    this.renderDetailValueGrid(parent, title, f,\n                    // iterator\n                    function () {\n                        if (!keys.length) return null;\n                        var k = keys.shift();\n                        var value = val[k];\n\n                        var item = { id: k };\n\n                        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {\n                            for (var field in value) {\n                                item[field] = thisB._valToString(value[field]);\n                            }\n                        } else {\n                            item.value = value;\n                        }\n\n                        return item;\n                    }, { descriptions: function () {\n                            if (!keys.length) return {};\n\n                            var subValue = val[keys[0]];\n                            var descriptions = {};\n                            for (var k in subValue) {\n                                descriptions[k] = subValue[k].meta && subValue[k].meta.description || null;\n                            }\n                            return descriptions;\n                        }()\n                    });\n                    return count;\n                } else {\n                    array.forEach(keys, function (k) {\n                        return this.renderDetailField(parent, k, val[k], f, class_, {}, unsafe);\n                    }, this);\n                    return keys.length;\n                }\n            }\n\n            domConstruct.create('div', { className: 'value ' + (val.length > 70 && val.indexOf(' ') == -1 ? 'long ' : '') + class_, innerHTML: unsafe || this.config.unsafePopup ? val : Util.escapeHTML(val) }, parent);\n            return 1;\n        },\n\n        renderDetailValueGrid: function renderDetailValueGrid(parent, title, f, iterator, attrs) {\n            var thisB = this;\n            var rows = [];\n            var item;\n            var descriptions = attrs.descriptions || {};\n            var cellRenderers = attrs.renderCell || {};\n            while (item = iterator()) {\n                rows.push(item);\n            }if (!rows.length) return document.createElement('span');\n\n            function defaultRenderCell(field, value, node, options) {\n\n                thisB.renderDetailValue(node, '', value, f, '');\n            }\n\n            var columns = [];\n            for (var field in rows[0]) {\n                (function (field) {\n                    var column = {\n                        label: { id: 'Name' }[field] || Util.ucFirst(field),\n                        field: field,\n                        renderCell: cellRenderers[field] || defaultRenderCell,\n                        renderHeaderCell: function renderHeaderCell(contentNode) {\n                            if (descriptions[field]) contentNode.title = descriptions[field];\n                            contentNode.appendChild(document.createTextNode(column.label || column.field));\n                        }\n                    };\n                    columns.push(column);\n                })(field);\n            }\n\n            // create the grid\n            parent.style.overflow = 'hidden';\n            parent.style.width = '90%';\n            var grid = new Grid({\n                columns: columns,\n                collection: new MemoryStore({ data: rows })\n            }, parent);\n\n            return parent;\n        },\n\n        _valToString: function _valToString(val) {\n            if (!val) return '';\n            if (lang.isArray(val)) {\n                return array.map(val, lang.hitch(this, '_valToString')).join(' ');\n            } else if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object') {\n                if ('values' in val) return this._valToString(val.values);else return JSON.stringify(val);\n            }\n            return '' + val;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/DetailsMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Dialog/OpenDirectory.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/Dialog/OpenDirectory.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dom, focus, dijitTextBox, ActionBarDialog, on, Button, Location, Util) {\n\n    return declare(ActionBarDialog,\n\n    /**\n     * Dijit Dialog subclass that pops up prompt for the user to\n     * manually set a new highlight.\n     * @lends JBrowse.View.InfoDialog\n     */\n    {\n        autofocus: false,\n        title: 'Open directory',\n\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.setCallback = args.setCallback || function () {};\n            this.cancelCallback = args.cancelCallback || function () {};\n            this.datadir = \"\";\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            var thisB = this;\n            new Button({ iconClass: 'dijitIconDelete', label: 'Cancel',\n                onClick: function onClick() {\n                    thisB.cancelCallback && thisB.cancelCallback();\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n            new Button({ iconClass: 'dijitIconFolderOpen',\n                label: 'Open',\n                onClick: function onClick() {\n                    thisB.setCallback && thisB.setCallback(thisB.datadir);\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n        },\n\n        show: function show(callback) {\n            dojo.addClass(this.domNode, 'fileDialog');\n\n            var remoteURLsControl = this._makeRemoteURLsControl();\n            var localFilesControl = this._makeLocalFileControl();\n\n            var div = function div(attr, children) {\n                var d = dom.create('div', attr);\n                array.forEach(children, dojo.hitch(d, 'appendChild'));\n                return d;\n            };\n            var content = [dom.create('div', { className: 'intro', innerHTML: 'Select a data directory to load, either from a \"track hub\" on the web, or from a local folder on your filesystem' }), div({ className: 'resourceControls' }, [localFilesControl.domNode, remoteURLsControl.domNode]), dom.create('div', { className: 'files', id: 'data_dir', innerHTML: '<b>Result</b>:<br/><div id=\"data_dir_list\"></div>' })];\n            this.set('content', content);\n            this.inherited(arguments);\n        },\n\n        _makeRemoteURLsControl: function _makeRemoteURLsControl() {\n            var container = dom.create('div', { className: 'remoteURLsControl' });\n            var thisB = this;\n\n            // make the input elements\n            dom.create('h3', { innerHTML: 'Remote URLs - <smaller>one per line</smaller>' }, container);\n\n            // the onChange here will be connected to by the other parts\n            // of the dialog to propagate changes to the text in the box\n            var self = { domNode: container,\n                onChange: function onChange(urls) {\n                    //console.log('urls changed');\n                }\n            };\n            self.input = dom.create('textarea', {\n                className: 'urlInput',\n                placeHolder: \"http://jbrowse.org/data_hub\",\n                cols: 25,\n                rows: 5,\n                spellcheck: false\n            }, container);\n\n            on(self.input, 'change', function (here) {\n                console.log(self.input.value);\n                dojo.byId('data_dir_list').innerHTML = self.input.value;\n                thisB.datadir = self.input.value;\n            });\n            var checkFrequency = 900;\n            var checkForChange = function checkForChange() {\n                // compare with all whitespace changed to commas so that\n                // we are insensitive to changes in whitespace\n                if (self.input.value != thisB.datadir && !thisB.localopened) {\n                    dojo.byId('data_dir_list').innerHTML = self.input.value;\n                    thisB.datadir = self.input.value;\n                }\n                window.setTimeout(checkForChange, checkFrequency);\n            };\n            window.setTimeout(checkForChange, checkFrequency);\n\n            return self;\n        },\n\n        _makeLocalFileControl: function _makeLocalFileControl() {\n            var container = dom.create('div', { className: 'localFilesControl', style: { width: '50%' } });\n            var header = dom.create('h3', { innerHTML: 'Local data directories' }, container);\n            var dragArea = dom.create('div', { className: 'dragArea' }, container);\n            var fileBox;\n            if (Util.isElectron()) {\n                fileBox = dom.create('input', { type: 'button', value: 'Select directory...', id: 'openFile' }, dragArea);\n            } else {\n                fileBox = new dojox.form.Uploader({\n                    multiple: true\n                });\n                fileBox.placeAt(dragArea);\n                if (this.browserSupports.dnd) {\n                    // let the uploader process any files dragged into the dialog\n                    fileBox.addDropTarget(this.domNode);\n\n                    // add a message saying you can drag files in\n                    dom.create('div', {\n                        className: 'dragMessage',\n                        innerHTML: 'Select or drag files here.'\n                    }, dragArea);\n                }\n            }\n\n            var thisB = this;\n            on(fileBox, 'click', function () {\n                var dialog = electronRequire('electron').remote.dialog;\n                var ret = dialog.showOpenDialog({ properties: ['openDirectory'] });\n                if (ret) {\n                    var paths = array.map(ret, function (replace) {\n                        return Util.replacePath(replace);\n                    });\n                    thisB.datadir = paths[0];\n                    thisB.localopened = true;\n                    dojo.byId('data_dir_list').innerHTML = paths[0];\n                }\n            });\n\n            return { domNode: container };\n        },\n\n        hide: function hide() {\n            this.inherited(arguments);\n            window.setTimeout(dojo.hitch(this, 'destroyRecursive'), 500);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Dialog/OpenDirectory.js?");

/***/ }),

/***/ "./src/JBrowse/View/Dialog/Preferences.js":
/*!************************************************!*\
  !*** ./src/JBrowse/View/Dialog/Preferences.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dom, focus, dijitTextBox, ActionBarDialog, on, Button, Location, Util) {\n\n    return declare(ActionBarDialog,\n\n    /**\n     * Dijit Dialog subclass that pops up prompt for the user to\n     * manually set a new highlight.\n     * @lends JBrowse.View.InfoDialog\n     */\n    {\n        autofocus: false,\n        title: 'Open plugin',\n\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.setCallback = args.setCallback || function () {};\n            this.cancelCallback = args.cancelCallback || function () {};\n            this.plugins = [];\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            var thisB = this;\n            new Button({ iconClass: 'dijitIconDelete', label: 'Cancel',\n                onClick: function onClick() {\n                    thisB.cancelCallback && thisB.cancelCallback();\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n            new Button({ iconClass: 'dijitIconFolderOpen',\n                label: 'Open',\n                onClick: function onClick() {\n                    thisB.setCallback && thisB.setCallback(thisB.plugins);\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n        },\n\n        show: function show(callback) {\n            dojo.addClass(this.domNode, 'jbrowse fileDialog');\n\n            var container = dom.create('div', { className: 'localFilesControl', style: { width: '100%' } });\n            var dragArea = dom.create('div', { className: 'dragArea' }, container);\n            var fileBox;\n            if (Util.isElectron()) {\n                fileBox = dom.create('input', { type: 'button', value: 'Select files...', id: 'openFile' }, dragArea);\n            } else {\n                fileBox = new dojox.form.Uploader({\n                    multiple: true\n                });\n                fileBox.placeAt(dragArea);\n                if (this.browserSupports.dnd) {\n                    // let the uploader process any files dragged into the dialog\n                    fileBox.addDropTarget(this.domNode);\n\n                    // add a message saying you can drag files in\n                    dom.create('div', {\n                        className: 'dragMessage',\n                        innerHTML: 'Select or drag files here.'\n                    }, dragArea);\n                }\n            }\n\n            var thisB = this;\n            on(fileBox, 'click', function () {\n                var dialog = electronRequire('electron').remote.dialog;\n                var ret = dialog.showOpenDialog({ properties: ['openDirectory'] });\n                if (ret) {\n                    var paths = array.map(ret, function (replace) {\n                        return Util.replacePath(replace);\n                    });\n                    thisB.plugins.push(paths[0]);\n                    dojo.byId('plugins_list').innerHTML += paths + \"<br/>\";\n                }\n            });\n\n            var div = function div(attr, children) {\n                var d = dom.create('div', attr);\n                array.forEach(children, dojo.hitch(d, 'appendChild'));\n                return d;\n            };\n            var content = [dom.create('div', { className: 'intro', innerHTML: 'Select plugin directories to load. Note: The name of the directory will also be used as the name of the plugin, which is sometimes important for the plugin loader' }), div({ className: 'resourceControls', style: { width: '100%' } }, [container]), dom.create('div', { className: 'files', id: 'plugins_list', innerHTML: 'Plugins:<br/>' })];\n            this.set('content', content);\n            this.inherited(arguments);\n        },\n\n        hide: function hide() {\n            this.inherited(arguments);\n            window.setTimeout(dojo.hitch(this, 'destroyRecursive'), 500);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Dialog/Preferences.js?");

/***/ }),

/***/ "./src/JBrowse/View/Dialog/QuickHelp.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/Dialog/QuickHelp.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/InfoDialog */ \"./src/JBrowse/View/InfoDialog.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, InfoDialog) {\n    return declare(InfoDialog, {\n\n        title: \"JBrowse Help\",\n\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.defaultContent = this._makeDefaultContent();\n\n            if (!args.content && !args.href) {\n                // make a div containing our help text\n                this.content = this.defaultContent;\n            }\n        },\n\n        _makeDefaultContent: function _makeDefaultContent() {\n            return '' + '<div class=\"jbrowse help_dialog\">' + '<div class=\"main\" style=\"float: left; width: 49%;\">' + '<dl>' + '<dt>Moving</dt>' + '<dd><ul>' + '    <li>Move the view by clicking and dragging in the track area, or by clicking <img class=\"icon nav\" id=\"moveLeftSmall\" src=\"' + this.browser.resolveUrl('img/Empty.png') + '\">  or <img class=\"icon nav\" id=\"moveRightSmall\" src=\"' + this.browser.resolveUrl('img/Empty.png') + '\"> in the navigation bar, or by pressing the left and right arrow keys.</li>' + '    <li>Center the view at a point by clicking on either the track scale bar or overview bar, or by shift-clicking in the track area.</li>' + '</ul></dd>' + '<dt>Zooming</dt>' + '<dd><ul>' + '    <li>Zoom in and out by clicking <img class=\"icon nav\" id=\"zoomInSmall\" src=\"' + this.browser.resolveUrl('img/Empty.png') + '\"> or <img class=\"icon nav\" id=\"zoomOutSmall\" src=\"' + this.browser.resolveUrl('img/Empty.png') + '\"> in the navigation bar, or by pressing the up and down arrow keys while holding down \"shift\".</li>' + '    <li>Select a region and zoom to it (\"rubber-band\" zoom) by clicking and dragging in the overview or track scale bar, or shift-clicking and dragging in the track area.</li>' + '    </ul>' + '</dd>' + '<dt>Showing Tracks</dt>' + '<dd><ul><li>Turn a track on by dragging its track label from the \"Available Tracks\" area into the genome area, or double-clicking it.</li>' + '        <li>Turn a track off by dragging its track label from the genome area back into the \"Available Tracks\" area.</li>' + '    </ul>' + '</dd>' + '</dl>' + '</div>' + '<div class=\"main\" style=\"float: right; width: 49%;\">' + '<dl>' + '<dt>Searching</dt>' + '<dd><ul>' + '    <li>Jump to a feature or reference sequence by typing its name in the location box and pressing Enter.</li>' + '    <li>Jump to a specific region by typing the region into the location box as: <span class=\"example\">ref:start..end</span>.</li>' + '    </ul>' + '</dd>' + '<dt>Example Searches</dt>' + '<dd>' + '    <dl class=\"searchexample\">' + '        <dt>uc0031k.2</dt><dd>searches for the feature named <span class=\"example\">uc0031k.2</span>.</dd>' + '        <dt>chr4</dt><dd>jumps to chromosome 4</dd>' + '        <dt>chr4:79,500,000..80,000,000</dt><dd>jumps the region on chromosome 4 between 79.5Mb and 80Mb.</dd>' + '        <dt>5678</dt><dd>centers the display at base 5,678 on the current sequence</dd>' + '    </dl>' + '</dd>' + '<dt>JBrowse Documentation</dt>' + '<dd><ul><li><a target=\"_blank\" href=\"docs/tutorial/\">Quick-start tutorial</a></li>' + '        <li><a target=\"_blank\" href=\"http://gmod.org/wiki/JBrowse\">JBrowse Configuration Guide</a></li>' + '    </ul>' + '</dd>' + '</dl>' + '</div>' + '</div>';\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Dialog/QuickHelp.js?");

/***/ }),

/***/ "./src/JBrowse/View/Dialog/Search.js":
/*!*******************************************!*\
  !*** ./src/JBrowse/View/Dialog/Search.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! JBrowse/View/LocationList */ \"./src/JBrowse/View/LocationList.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dom, on, aspect, Dialog, Button, TextBox, dijitFocus, LocationListView, Util) {\n    return declare(null, {\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.config = dojo.clone(args.config || {});\n            this.locationChoices = [{ label: 'Search results...', description: ' ', start: 0, end: 100, ref: 'chr' }];\n            this.title = args.title || 'Choose location';\n            this.prompt = args.prompt || 'Search for features';\n            this.goCallback = args.goCallback;\n            this.showCallback = args.showCallback;\n        },\n\n        show: function show() {\n            var dialog = this.dialog = new Dialog({\n                title: this.title,\n                className: 'locationChoiceDialog',\n                style: { width: '70%' }\n            });\n            var container = dom.create('div', {});\n\n            if (this.prompt) {\n                dom.create('div', {\n                    className: 'prompt',\n                    innerHTML: this.prompt\n                }, container);\n                var subcontainer = dojo.create('div', { style: { 'padding': '20px' } }, container);\n                dojo.create('img', { width: '16px', src: 'img/search.png', style: { 'padding-right': '5px' } }, subcontainer);\n                this.searchBox = new TextBox({ intermediateChanges: true }).placeAt(subcontainer);\n                dojo.create('label', { style: { marginLeft: '20px' }, for: 'exact_match', innerHTML: 'Exact?' }, subcontainer);\n                this.exactCheckbox = dojo.create('input', { type: 'checkbox', id: 'exact_match' }, subcontainer);\n\n                on(this.searchBox, 'change', dojo.hitch(this, 'searchBoxProcess'));\n                on(this.exactCheckbox, 'change', dojo.hitch(this, 'searchBoxProcess'));\n            }\n            var browser = this.browser;\n            this.locationListView = new LocationListView({\n                browser: browser,\n                locations: this.locationChoices,\n                buttons: [{\n                    className: 'show',\n                    innerHTML: 'Show',\n                    onClick: this.showCallback || function (location) {\n                        browser.showRegionAfterSearch(location);\n                    }\n                }, {\n                    className: 'go',\n                    innerHTML: 'Go',\n                    onClick: this.goCallback || function (location) {\n                        dialog.hide();\n                        browser.showRegionAfterSearch(location);\n                    }\n                }]\n            }, dom.create('div', {\n                className: 'locationList',\n                style: { maxHeight: 0.5 * this.browser.container.offsetHeight + 'px' }\n            }, container));\n\n            this.actionBar = dojo.create('div', { className: 'infoDialogActionBar dijitDialogPaneActionBar' });\n            new Button({\n                iconClass: 'dijitIconDelete',\n                label: 'Cancel',\n                onClick: dojo.hitch(dialog, 'hide')\n            }).placeAt(this.actionBar);\n\n            this.numResults = dojo.create('div', { id: 'numResults', style: { margin: '10px' } }, container);\n            this.errResults = dojo.create('div', { id: 'errResults', style: { margin: '10px', color: 'red' } }, container);\n            dialog.set('content', [container, this.actionBar]);\n\n            var g = this.locationListView.grid;\n            (g.store || g.collection).setData([]);\n            g.refresh();\n            dialog.show();\n\n            aspect.after(dialog, 'hide', dojo.hitch(this, function () {\n                if (dijitFocus.curNode) {\n                    dijitFocus.curNode.blur();\n                }\n                setTimeout(function () {\n                    dialog.destroyRecursive();\n                }, 500);\n            }));\n        },\n        searchBoxProcess: function searchBoxProcess() {\n            var _this = this;\n\n            var loc = this.searchBox.get('value');\n            this.numResults.innerHTML = '';\n            if (!this.exactCheckbox.checked) {\n                loc += \"*\";\n            }\n            function handleError(error) {\n                console.error(error);\n                var g = this.locationListView.grid;\n                (g.store || g.collection).setData([]);\n                g.refresh();\n                this.errResults.innerHTML = 'Error: failed to load results';\n                this.numResults.innerHTML = '';\n            }\n            this.browser.nameStore.query({ name: loc }).then(function (nameMatches) {\n                var promises = nameMatches.map(function (match) {\n                    return _this.browser.nameStore.query({ name: match.name });\n                });\n                Promise.all(promises).then(function (res) {\n                    var grid = [];\n                    for (var i = 0; i < res.length; i++) {\n                        var elt = res[i];\n                        if (elt.length) {\n                            elt = elt[0];\n                            if (elt.multipleLocations) {\n                                for (var j = 0; j < elt.multipleLocations.length; j++) {\n                                    var track = elt.multipleLocations[j].tracks.length ? elt.multipleLocations[j].tracks[0] : {};\n                                    grid.push({\n                                        locstring: Util.assembleLocString(elt.multipleLocations[j]),\n                                        location: elt.multipleLocations[j],\n                                        label: elt.name,\n                                        description: track.key || track.label || 'Unknown track',\n                                        tracks: track\n                                    });\n                                }\n                            } else {\n                                var track = (elt.location.tracks || []).length ? elt.location.tracks[0] : {};\n                                grid.push({\n                                    locstring: Util.assembleLocString(elt.location),\n                                    location: elt.location,\n                                    label: elt.location.objectName,\n                                    description: track.key || track.label || 'Unknown track',\n                                    tracks: track\n                                });\n                            }\n                        }\n                    }\n                    _this.numResults.innerHTML = \"Num. results: \" + grid.length;\n                    var g = _this.locationListView.grid;\n                    (g.store || g.collection).setData(grid);\n                    g.refresh();\n                    _this.errResults.innerHTML = '';\n                }, dojo.hitch(_this, handleError));\n            }, dojo.hitch(this, handleError));\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Dialog/Search.js?");

/***/ }),

/***/ "./src/JBrowse/View/Dialog/SetHighlight.js":
/*!*************************************************!*\
  !*** ./src/JBrowse/View/Dialog/SetHighlight.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, focus, dijitTextBox, ActionBarDialog, on, Button, Location) {\n\n    return declare(ActionBarDialog,\n\n    /**\n     * Dijit Dialog subclass that pops up prompt for the user to\n     * manually set a new highlight.\n     * @lends JBrowse.View.InfoDialog\n     */\n    {\n        autofocus: false,\n        title: 'Set highlight',\n\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.setCallback = args.setCallback || function () {};\n            this.cancelCallback = args.cancelCallback || function () {};\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            var thisB = this;\n            new Button({ iconClass: 'dijitIconDelete', label: 'Cancel',\n                onClick: function onClick() {\n                    thisB.cancelCallback && thisB.cancelCallback();\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n            new Button({ iconClass: 'dijitIconFilter',\n                label: 'Highlight',\n                onClick: function onClick() {\n                    thisB.setCallback && thisB.setCallback(thisB.getLocation());\n                    thisB.hide();\n                }\n            }).placeAt(actionBar);\n        },\n\n        show: function show(callback) {\n            var thisB = this;\n\n            dojo.addClass(this.domNode, 'setHighlightDialog');\n\n            var visibleLocation = this.browser.view.visibleRegionLocString();\n            if (visibleLocation) visibleLocation += ' (current view)';\n\n            this.highlightInput = new dijitTextBox({\n                id: 'newhighlight_locstring',\n                value: (this.browser.getHighlight() || '').toString() || visibleLocation || '',\n                placeHolder: visibleLocation || 'ctgA:1234..5678'\n            });\n\n            this.set('content', [dom.create('label', { \"for\": 'newhighlight_locstring', innerHTML: 'Location' }), this.highlightInput.domNode]);\n\n            this.inherited(arguments);\n        },\n\n        getLocation: function getLocation() {\n            // have to use onChange to get the value of the text box to work around a bug in dijit\n            return new Location(this.highlightInput.get('value'));\n        },\n\n        hide: function hide() {\n            this.inherited(arguments);\n            window.setTimeout(dojo.hitch(this, 'destroyRecursive'), 500);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Dialog/SetHighlight.js?");

/***/ }),

/***/ "./src/JBrowse/View/Dialog/SetTrackHeight.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/View/Dialog/SetTrackHeight.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! dijit/form/NumberSpinner */ \"./node_modules/dijit/form/NumberSpinner.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, focus, NumberSpinner, ActionBarDialog, on, Button, Location) {\n\n    return declare(ActionBarDialog, {\n        /**\n         * Dijit Dialog subclass that pops up prompt for the user to\n         * manually set a new track height.\n         * @lends JBrowse.View.InfoDialog\n         */\n        title: 'Set new track height',\n\n        constructor: function constructor(args) {\n            this.height = args.height || 100;\n            this.browser = args.browser;\n            this.setCallback = args.setCallback || function () {};\n            this.cancelCallback = args.cancelCallback || function () {};\n            this.heightConstraints = { min: 10, max: args.maxHeight || 750 };\n            this.msg = args.msg;\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            var ok_button = new Button({\n                label: \"OK\",\n                onClick: dojo.hitch(this, function () {\n                    var height = parseInt(this.heightSpinner.getValue());\n                    if (isNaN(height) || height < this.heightConstraints.min || height > this.heightConstraints.max) return;\n                    this.setCallback && this.setCallback(height);\n                    this.hide();\n                })\n            }).placeAt(actionBar);\n\n            var cancel_button = new Button({\n                label: \"Cancel\",\n                onClick: dojo.hitch(this, function () {\n                    this.cancelCallback && this.cancelCallback();\n                    this.hide();\n                })\n            }).placeAt(actionBar);\n        },\n\n        show: function show(callback) {\n            dojo.addClass(this.domNode, 'setTrackHeightDialog');\n\n            this.heightSpinner = new NumberSpinner({\n                value: this.height,\n                smallDelta: 10,\n                constraints: this.heightConstraints\n            });\n\n            this.set('content', [dom.create('label', { \"for\": 'newhighlight_locstring', innerHTML: '' }), this.heightSpinner.domNode, dom.create('span', { innerHTML: this.msg || ' pixels' })]);\n\n            this.inherited(arguments);\n        },\n\n        hide: function hide() {\n            this.inherited(arguments);\n            window.setTimeout(dojo.hitch(this, 'destroyRecursive'), 500);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Dialog/SetTrackHeight.js?");

/***/ }),

/***/ "./src/JBrowse/View/Dialog/WithActionBar.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/Dialog/WithActionBar.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * A dialog with an action bar at the bottom for buttons.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-geometry */ \"./node_modules/dojo/dom-geometry.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, domGeom, dijitDialog) {\n\n    return declare(dijitDialog, {\n        constructor: function constructor() {\n            dojo.connect(this, 'onLoad', this, '_addActionBar');\n        },\n\n        _addActionBar: function _addActionBar() {\n            var that = this;\n            if (this.containerNode && !this.actionBar) {\n                this.actionBar = dojo.create('div', { className: 'infoDialogActionBar dijitDialogPaneActionBar' });\n\n                this._fillActionBar(this.actionBar);\n                this.containerNode.appendChild(this.actionBar);\n            }\n        },\n\n        _fillActionBar: function _fillActionBar(actionBar) {},\n\n        show: function show(callback) {\n            this._addActionBar();\n            this.inherited(arguments);\n            var titleDims = domGeom.position(this.titleBar);\n            this.domNode.style.width = titleDims.w + 'px';\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Dialog/WithActionBar.js?");

/***/ }),

/***/ "./src/JBrowse/View/Export.js":
/*!************************************!*\
  !*** ./src/JBrowse/View/Export.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array) {\n\n    return declare(null, {\n        /**\n         * Data export driver base class.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            args = args || {};\n            this.printFunc = args.print || function (line) {\n                this.output += line;\n            };\n            this.refSeq = args.refSeq;\n            this.output = '';\n            this.track = args.track;\n            this.store = args.store;\n        },\n\n        // will need to override this if you're not exporting regular features\n        exportRegion: function exportRegion(region, callback) {\n            var output = '';\n            this.store.getFeatures(region, dojo.hitch(this, 'writeFeature'), dojo.hitch(this, function () {\n                callback(this.output);\n            }), dojo.hitch(this, function (error) {\n                console.error(error);\n            }));\n        },\n\n        print: function print(l) {\n            if (lang.isArray(l)) {\n                array.forEach(l, this.printFunc, this);\n            } else {\n                this.printFunc(l);\n            }\n        },\n\n        /**\n         * Write the feature to the GFF3 under construction.\n         * @returns nothing\n         */\n        writeFeature: function writeFeature(feature) {\n            this.print(this.formatFeature(feature));\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Export.js?");

/***/ }),

/***/ "./src/JBrowse/View/Export/BED.js":
/*!****************************************!*\
  !*** ./src/JBrowse/View/Export/BED.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Export */ \"./src/JBrowse/View/Export.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, ExportBase) {\n\n    return declare(ExportBase,\n\n    /**\n     * @lends JBrowse.View.Export.BED.prototype\n     */\n    {\n\n        /**\n         * Data export driver for BED format.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this._printHeader();\n        },\n\n        /**\n         * print the BED track definition line\n         * @private\n         */\n        _printHeader: function _printHeader() {\n            // print the BED header\n            this.print('track');\n            if (this.track) {\n                if (this.track.name) this.print(' name=\"' + this.track.name + '\"');\n                var metadata = this.track.getMetadata();\n                if (metadata.key) this.print(' description=\"' + metadata.key + '\"');\n            }\n            this.print(' useScore=0');\n            this.print(\"\\n\");\n        },\n\n        bed_field_names: ['seq_id', 'start', 'end', 'name', 'score', 'strand', 'thickStart', 'thickEnd', 'itemRgb', 'blockCount', 'blockSizes', 'blockStarts'],\n\n        /**\n         * Format a feature into a string.\n         * @param {Object} feature feature object (like those returned from JBrowse/Store/SeqFeature/*)\n         * @returns {String} BED string representation of the feature\n         */\n        formatFeature: function formatFeature(feature) {\n            var fields = array.map([feature.get('seq_id') || this.refSeq.name].concat(dojo.map(this.bed_field_names.slice(1, 11), function (field) {\n                return feature.get(field);\n            }, this)), function (data) {\n                var t = typeof data === 'undefined' ? 'undefined' : _typeof(data);\n                if (t == 'string' || t == 'number') return data;\n                return '';\n            }, this);\n\n            // normalize the strand field\n            fields[5] = { '1': '+', '-1': '-', '0': '+' }[fields[5]] || fields[5];\n            return fields.join(\"\\t\") + \"\\n\";\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Export/BED.js?");

/***/ }),

/***/ "./src/JBrowse/View/Export/FASTA.js":
/*!******************************************!*\
  !*** ./src/JBrowse/View/Export/FASTA.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Export */ \"./src/JBrowse/View/Export.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, ExportBase, Util) {\n\n    return declare(ExportBase,\n\n    /**\n     * @lends JBrowse.View.Export.FASTA.prototype\n     */\n    {\n\n        /**\n         * Data export driver for FASTA format.\n         * @constructs\n         */\n        constructor: function constructor(args) {},\n\n        // will need to override this if you're not exporting regular features\n        exportRegion: function exportRegion(region, callback) {\n            this.store.getReferenceSequence(region, dojo.hitch(this, function (seq) {\n                callback(this._formatFASTA(region, seq));\n            }));\n        },\n\n        _formatFASTA: function _formatFASTA(region, seq) {\n            return '>' + this.refSeq.name + ' ' + Util.assembleLocString(region) + \"\\n\" + this._wrap(seq, 78);\n        },\n\n        _wrap: function _wrap(string, length) {\n            length = length || 78;\n            return string.replace(new RegExp('(.{' + length + '})', 'g'), \"$1\\n\");\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Export/FASTA.js?");

/***/ }),

/***/ "./src/JBrowse/View/Export/GFF3.js":
/*!*****************************************!*\
  !*** ./src/JBrowse/View/Export/GFF3.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _gff = __webpack_require__(/*! @gmod/gff */ \"./node_modules/@gmod/gff/dist/index.js\");\n\nvar _gff2 = _interopRequireDefault(_gff);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Export */ \"./src/JBrowse/View/Export.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, ExportBase) {\n\n    return declare(ExportBase,\n    /**\n     * @lends JBrowse.View.Export.GFF3.prototype\n     */\n    {\n\n        /**\n         * Data export driver for GFF3 format.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this._idCounter = 0;\n            this.lastSync = 0;\n        },\n\n        gff3_field_names: ['seq_id', 'source', 'type', 'start', 'end', 'score', 'strand', 'phase', 'attributes'],\n\n        gff3_reserved_attributes: ['ID', 'Name', 'Alias', 'Parent', 'Target', 'Gap', 'Derives_from', 'Note', 'Dbxref', 'Ontology_term', 'Is_circular'],\n\n        /**\n         * @returns false if the field goes in tabular portion of gff3, true otherwise\n         * @private\n         */\n        _is_not_gff3_tab_field: function _is_not_gff3_tab_field(fieldname) {\n            if (!this._gff3_fields_by_name) {\n                var fields = {};\n                dojo.forEach(this.gff3_field_names, function (f) {\n                    fields[f] = true;\n                });\n                this._gff3_fields_by_name = fields;\n            }\n\n            return !this._gff3_fields_by_name[fieldname.toLowerCase()];\n        },\n\n        /**\n         * @returns the capitalized attribute name if the given field name\n         * corresponds to a GFF3 reserved attribute\n         * @private\n         */\n        _gff3_reserved_attribute: function _gff3_reserved_attribute(fieldname) {\n            if (!this._gff3_reserved_attributes_by_lcname) {\n                var fields = {};\n                dojo.forEach(this.gff3_reserved_attributes, function (f) {\n                    fields[f.toLowerCase()] = f;\n                });\n                this._gff3_reserved_attributes_by_lcname = fields;\n            }\n\n            return this._gff3_reserved_attributes_by_lcname[fieldname.toLowerCase()];\n        },\n\n        exportRegion: function exportRegion(region, callback) {\n            this.print(\"##gff-version 3\\n\");\n            this.print('##sequence-region ' + region.ref + ' ' + (region.start + 1) + ' ' + region.end + '\\n');\n            this.inherited(arguments);\n        },\n\n\n        /**\n         * Format a feature into a string.\n         * @param {Object} feature feature object (like those returned from JBrowse/Store/SeqFeature/*)\n         * @returns {String} GFF3 string representation of the feature\n         */\n        formatFeature: function formatFeature(feature, parentID) {\n            var fields = dojo.map([feature.get('seq_id') || this.refSeq.name].concat(dojo.map(this.gff3_field_names.slice(1, 8), function (field) {\n                return feature.get(field);\n            }, this)), function (data) {\n                var dt = typeof data === 'undefined' ? 'undefined' : _typeof(data);\n                return _gff2.default.util.escapeColumn(dt == 'string' || dt == 'number' ? data : '.');\n            }, this);\n\n            // convert back from interbase\n            if (typeof parseInt(fields[3]) == 'number') fields[3]++;\n            // normalize the strand field\n            fields[6] = { '1': '+', '-1': '-', '0': '.' }[fields[6]] || fields[6];\n\n            // format the attributes\n            var attr = this._gff3_attributes(feature);\n            if (parentID) attr.Parent = parentID;else delete attr.Parent;\n\n            var subfeatures = array.map(feature.get('subfeatures') || [], function (feat) {\n                if (!attr.ID) {\n                    attr.ID = ++this._idCounter;\n                }\n                return this.formatFeature(feat, attr.ID);\n            }, this);\n\n            // need to format the attrs after doing the subfeatures,\n            // because the subfeature formatting might have autocreated an\n            // ID for the parent\n            fields[8] = this._gff3_format_attributes(attr);\n\n            var fl = fields.join(\"\\t\") + \"\\n\";\n            subfeatures.unshift(fl);\n            return subfeatures.join('');\n        },\n\n        /**\n         * Write the feature to the GFF3 under construction.\n         * @returns nothing\n         */\n        writeFeature: function writeFeature(feature) {\n            var fmt = this.formatFeature(feature);\n            this.print(fmt);\n\n            // avoid printing sync marks more than every 10 lines\n            if (this.lastSync >= 9) {\n                this.lastSync = 0;\n                this.print(\"###\\n\");\n            } else {\n                this.lastSync += fmt.length || 1;\n            }\n        },\n\n        /**\n         * Extract a key-value object of gff3 attributes from the given\n         * feature.  Attribute names will have proper capitalization.\n         * @private\n         */\n        _gff3_attributes: function _gff3_attributes(feature) {\n            var tags = array.filter(feature.tags(), dojo.hitch(this, function (f) {\n                f = f.toLowerCase();\n                return this._is_not_gff3_tab_field(f) && f != 'subfeatures';\n            }));\n            var attrs = {};\n            array.forEach(tags, function (tag) {\n                var val = feature.get(tag);\n                var valtype = typeof val === 'undefined' ? 'undefined' : _typeof(val);\n                if (valtype == 'boolean') val = val ? 1 : 0;else if (valtype == 'undefined') return;\n                tag = this._gff3_reserved_attribute(tag) || this._ensure_non_reserved(tag);\n                attrs[tag] = val;\n            }, this);\n            return attrs;\n        },\n\n        // ensure that an attribute name is not reserved.  currently does\n        // this by adding a leading underscore to attribute names that\n        // have initial capital letters.\n        _ensure_non_reserved: function _ensure_non_reserved(str) {\n            return str.replace(/^[A-Z]/, function () {\n                return '_' + str[0];\n            });\n        },\n\n        /**\n         * @private\n         * @returns {String} formatted attribute string\n         */\n        _gff3_format_attributes: function _gff3_format_attributes(attrs) {\n            var attrOrder = [];\n            for (var tag in attrs) {\n                var val = attrs[tag];\n                if (!val) {\n                    continue;\n                }\n\n                var valstring = val.hasOwnProperty('toString') ? _gff2.default.util.escape(val.toString()) : val instanceof Array ? array.map(val, function (s) {\n                    return _gff2.default.util.escape(s);\n                }).join(',') : val instanceof Object ? _gff2.default.util.escape(JSON.stringify(val)) : val.values ? val instanceof Array ? array.map(val, function (s) {\n                    return _gff2.default.util.escape(s);\n                }).join(',') : _gff2.default.util.escape(val) : _gff2.default.util.escape(val);\n                attrOrder.push(_gff2.default.util.escape(tag) + '=' + valstring);\n            }\n            return attrOrder.join(';') || '.';\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Export/GFF3.js?");

/***/ }),

/***/ "./src/JBrowse/View/Export/SequinTable.js":
/*!************************************************!*\
  !*** ./src/JBrowse/View/Export/SequinTable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Support for Sequin Feature table export.  See\n * http://www.ncbi.nlm.nih.gov/Sequin/table.html.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Export */ \"./src/JBrowse/View/Export.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, ExportBase) {\n\n    return declare(ExportBase, {\n        /**\n         * Data export driver for BED format.\n         * @constructs\n         */\n        // constructor: function( args ) {\n        // },\n\n        /**\n         * print the BED track definition line\n         * @private\n         */\n        _printHeader: function _printHeader(feature) {\n            // print the BED header\n            this.print('>Feature ' + (feature.get('seq_id') || this.refSeq.name) + \"\\n\");\n            return true;\n        },\n\n        /**\n         * Format a feature into a string.\n         * @param {Object} feature feature object (like those returned from JBrowse/Store/SeqFeature/*)\n         * @returns {String} BED string representation of the feature\n         */\n        formatFeature: function formatFeature(feature) {\n            var _this = this;\n\n            var thisB = this;\n            if (!this.headerPrinted) this.headerPrinted = this._printHeader(feature);\n\n            var featLine = [feature.get('start') + 1, feature.get('end'), feature.get('type') || 'region'];\n            if (feature.get('strand') == -1) {\n                var t = featLine[0];\n                featLine[0] = featLine[1];\n                featLine[1] = t;\n            }\n\n            // make the qualifiers\n            var qualifiers = array.map(array.filter(feature.tags(), function (t) {\n                return !{ start: 1, end: 1, type: 1, strand: 1, seq_id: 1, subfeatures: 1 }[t.toLowerCase()];\n            }), function (tag) {\n                return [tag.toLowerCase(), thisB.stringifyAttributeValue(feature.get(tag))];\n            }).filter(function (t) {\n                return !!t[1];\n            });\n\n            return featLine.join(\"\\t\") + \"\\n\" + array.map(qualifiers, function (q) {\n                return \"\\t\\t\\t\" + q.join(\"\\t\") + \"\\n\";\n            }).join('') + array.map(feature.children(), function (f) {\n                return _this.formatFeature(f);\n            }).join('');\n        },\n\n        stringifyAttributeValue: function stringifyAttributeValue(val) {\n            if (val == null) return null;\n            return val.hasOwnProperty('toString') ? val.toString() : val instanceof Array ? val.join(',') : val.values instanceof Array ? val.join(',') : val;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Export/SequinTable.js?");

/***/ }),

/***/ "./src/JBrowse/View/Export/Wiggle.js":
/*!*******************************************!*\
  !*** ./src/JBrowse/View/Export/Wiggle.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Export */ \"./src/JBrowse/View/Export.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, ExportBase) {\n\n    return declare(ExportBase,\n    /**\n     * @lends JBrowse.View.Export.Wiggle.prototype\n     */\n    {\n        /**\n         * Data export driver for Wiggle format.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            // print the track definition\n            this.print('track type=wiggle_0');\n            if (this.track) {\n                if (this.track.name) this.print(' name=\"' + this.track.name + '\"');\n                var metadata = this.track.getMetadata();\n                if (metadata.key) this.print(' description=\"' + metadata.key + '\"');\n            }\n            this.print(\"\\n\");\n        },\n\n        /**\n         * print the Wiggle step\n         * @private\n         */\n        _printStep: function _printStep(span, ref) {\n            this.print('variableStep' + (ref ? ' chrom=' + ref : '') + ' span=' + span + \"\\n\");\n        },\n\n        exportRegion: function exportRegion(region, callback) {\n            var curspan;\n            var curref;\n            this.store.getFeatures(region, dojo.hitch(this, function (f) {\n                var span = f.get('end') - f.get('start');\n                var ref = f.get('seq_id') || this.refSeq.name;\n                if (!(curspan == span && ref == curref)) {\n                    this._printStep(span, ref == curref ? null : ref);\n                    curref = ref;\n                    curspan = span;\n                }\n                this.print(f.get('start') + 1 + \"\\t\" + f.get('score') + \"\\n\");\n            }), dojo.hitch(this, function () {\n                callback(this.output);\n            }));\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Export/Wiggle.js?");

/***/ }),

/***/ "./src/JBrowse/View/Export/bedGraph.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/View/Export/bedGraph.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Export/BED */ \"./src/JBrowse/View/Export/BED.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, bedExport) {\n\n    return declare(bedExport,\n    /**\n     * @lends JBrowse.View.Export.bedGraph.prototype\n     */\n    {\n        /**\n         * Data export driver for bedGraph format.\n         * @constructs\n         */\n        constructor: function constructor(args) {},\n\n        _printHeader: function _printHeader() {\n            // print the track definition\n            this.print('track type=bedGraph');\n            if (this.track) {\n                if (this.track.name) this.print(' name=\"' + this.track.name + '\"');\n                var metadata = this.track.getMetadata();\n                if (metadata.key) this.print(' description=\"' + metadata.key + '\"');\n            }\n            this.print(\"\\n\");\n        },\n\n        formatFeature: function formatFeature(f) {\n            return [f.get('seq_id') || this.refSeq.name, f.get('start'), f.get('end'), f.get('score')].join(\"\\t\") + \"\\n\";\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Export/bedGraph.js?");

/***/ }),

/***/ "./src/JBrowse/View/FASTA.js":
/*!***********************************!*\
  !*** ./src/JBrowse/View/FASTA.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/Toolbar */ \"./node_modules/dijit/Toolbar.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, Toolbar, Button, Util, has) {\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n\n            if (typeof args === 'undefined') {\n                this.width = 78;\n                return;\n            };\n\n            this.width = args.width || 78;\n            this.htmlMaxRows = args.htmlMaxRows || 15;\n            this.track = args.track;\n            this.canSaveFiles = args.track && args.track._canSaveFiles && args.track._canSaveFiles();\n\n            // hook point\n            if (typeof this.initData === 'function') this.initData(args);\n        },\n        renderHTML: function renderHTML(region, seq, parent) {\n            var thisB = this;\n            var text = this.renderText(region, seq);\n            var lineCount = text.match(/\\n/g).length + 1;\n            var container = dom.create('div', { className: 'fastaView' }, parent);\n\n            if (this.canSaveFiles) {\n                var toolbar = new Toolbar().placeAt(container);\n                var thisB = this;\n\n                // hook point\n                if (typeof thisB.addButtons === 'function') thisB.addButtons(region, seq, toolbar);\n\n                toolbar.addChild(new Button({ iconClass: 'dijitIconSave',\n                    label: 'FASTA',\n                    title: 'save as FASTA',\n                    disabled: !has('save-generated-files'),\n                    onClick: function onClick() {\n                        thisB.track._fileDownload({ format: 'FASTA',\n                            filename: Util.assembleLocString(region) + '.fasta',\n                            data: text\n                        });\n                    }\n                }));\n            }\n\n            var textArea = dom.create('textarea', {\n                className: 'fasta',\n                cols: this.width,\n                rows: Math.min(lineCount, this.htmlMaxRows),\n                readonly: true\n            }, container);\n            var c = 0;\n            textArea.innerHTML = text.replace(/\\n/g, function () {\n                return c++ ? '' : \"\\n\";\n            });\n            return container;\n        },\n        /**\n         * returns FASTA formatted string\n         * @param {region object} region - fasta formated text string\n         * @param {string} seq - unformated sequence\n         * @returns {String} - fasta formated string\n         */\n        renderText: function renderText(region, seq) {\n            return '>' + region.ref + ' ' + Util.assembleLocString(region) + (region.type ? ' class=' + region.type : '') + ' length=' + (region.end - region.start) + \"\\n\" + this._wrap(seq, this.width);\n        },\n        _wrap: function _wrap(string, length) {\n            length = length || this.width;\n            return string.replace(new RegExp('(.{' + length + '})', 'g'), \"$1\\n\");\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FASTA.js?");

/***/ }),

/***/ "./src/JBrowse/View/FastaFileDialog.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/View/FastaFileDialog.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dijit/form/RadioButton */ \"./node_modules/dijit/form/RadioButton.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/View/FileDialog */ \"./src/JBrowse/View/FileDialog.js\"), __webpack_require__(/*! ./FileDialog/TrackList/BgzipIndexedFASTADriver */ \"./src/JBrowse/View/FileDialog/TrackList/BgzipIndexedFASTADriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/IndexedFASTADriver */ \"./src/JBrowse/View/FileDialog/TrackList/IndexedFASTADriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/TwoBitDriver */ \"./src/JBrowse/View/FileDialog/TrackList/TwoBitDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/ChromSizesDriver */ \"./src/JBrowse/View/FileDialog/TrackList/ChromSizesDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Button, RadioButton, dom, FileDialog, BgzipIndexedFASTADriver, IndexedFASTADriver, TwoBitDriver, ChromSizesDriver) {\n\n    return declare(FileDialog, {\n\n        constructor: function constructor(args) {\n            this.inherited(arguments);\n            this._fileTypeDrivers = [new BgzipIndexedFASTADriver(), new IndexedFASTADriver(), new TwoBitDriver(), new ChromSizesDriver()];\n            return this;\n        },\n\n        show: function show(args) {\n            args.introMsg = \"Select a FASTA file (.fa), indexed FASTA (.fa and .fai), bgzip indexed FASTA (.fa, .fai, and .gzi), twobit (.2bit) file, or a chrom.sizes file (tab separated refseq name and length)\";\n            this.inherited(arguments);\n            this.dialog.set('title', 'Open sequence file');\n        },\n\n        _makeActionBar: function _makeActionBar(openCallback, cancelCallback) {\n            var _this = this;\n\n            var actionBar = dom.create('div', {\n                className: 'dijitDialogPaneActionBar'\n            });\n            var disChoices = this.refSeqOrderChoice = [new RadioButton({ id: 'sortAlpha',\n                value: 'sortAlpha',\n                checked: true\n            }), new RadioButton({ id: 'sortLength',\n                value: 'sortLength'\n            }), new RadioButton({ id: 'noSort',\n                value: 'noSort'\n            })];\n\n            var aux = dom.create('div', { className: 'aux' }, actionBar);\n            disChoices[0].placeAt(aux);\n            dom.create('label', { \"for\": 'sortAlpha', innerHTML: 'Sort refseqs by name' }, aux), disChoices[1].placeAt(aux);\n            dom.create('label', { \"for\": 'sortLength', innerHTML: 'Sort refseqs by length' }, aux);\n            disChoices[2].placeAt(aux);\n            dom.create('label', { \"for\": 'noSort', innerHTML: 'Use order from file' }, aux);\n\n            new Button({ iconClass: 'dijitIconDelete', label: 'Cancel',\n                onClick: dojo.hitch(this, function () {\n                    cancelCallback && cancelCallback();\n                    this.dialog.hide();\n                })\n            }).placeAt(actionBar);\n\n            new Button({\n                iconClass: 'dijitIconFolderOpen',\n                label: 'Open',\n                onClick: function onClick() {\n                    if (openCallback) {\n                        openCallback({\n                            trackConfs: _this.trackList.getTrackConfigurations(),\n                            refSeqOrder: _this.refSeqOrderChoice[0].checked ? \"alphabetic descending\" : _this.refSeqOrderChoice[1].checked ? \"length descending\" : undefined\n                        }).then(function () {\n                            return _this.dialog.hide();\n                        }, function (err) {\n                            console.error(err);\n                        });\n                    }\n                }\n            }).placeAt(actionBar);\n\n            return { domNode: actionBar };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FastaFileDialog.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph.js":
/*!******************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! JBrowse/Component */ \"./src/JBrowse/Component.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, aspect, Component) {\n\n    return declare(Component, {\n        constructor: function constructor(args) {\n            this.track = args.track;\n            this.booleanAlpha = 0.17;\n\n            // This allows any features that are completely masked to have their transparency set before being rendered,\n            // saving the hassle of clearing and rerendering later on.\n            aspect.before(this, 'renderFeature', function (context, fRect) {\n                if (fRect.m) {\n                    var l = Math.floor(fRect.l);\n                    var w = Math.ceil(fRect.w + fRect.l) - l;\n                    fRect.m.sort(function (a, b) {\n                        return a.l - b.l;\n                    });\n                    var m = fRect.m[0];\n                    if (m.l <= l) {\n                        // Determine whether the feature is entirely masked.\n                        var end = fRect.m[0].l;\n                        for (var i in fRect.m) {\n                            var m = fRect.m[i];\n                            if (m.l > end) break;\n                            end = m.l + m.w;\n                        }\n                        if (end >= l + w) {\n                            context.globalAlpha = this.booleanAlpha;\n                            fRect.noMask = true;\n                        }\n                    }\n                }\n            }, true);\n\n            // after rendering the features, do masking if required\n            aspect.after(this, 'renderFeature', function (context, fRect) {\n                if (fRect.m && !fRect.noMask) {\n                    this.maskBySpans(context, fRect);\n                } else if (fRect.noMask) {\n                    delete fRect.noMask;\n                    context.globalAlpha = 1;\n                }\n            }, true);\n        },\n\n        getStyle: function getStyle(feature, name) {\n            return this.getConfForFeature('style.' + name, feature);\n        },\n\n        /**\n         * Like getConf, but get a conf value that explicitly can vary\n         * feature by feature.  Provides a uniform function signature for\n         * user-defined callbacks.\n         */\n        getConfForFeature: function getConfForFeature(path, feature) {\n            return this.getConf(path, [feature, path, this, this.track]);\n        },\n\n        mouseoverFeature: function mouseoverFeature(context, fRect) {\n            this.renderFeature(context, fRect);\n\n            // highlight the feature rectangle if we're moused over\n            context.fillStyle = this.getStyle(fRect.f, 'mouseovercolor');\n            context.fillRect(fRect.rect.l, fRect.t, fRect.rect.w, fRect.rect.h);\n        },\n\n        /**\n         * Get the dimensions of the rendered feature in pixels.\n         */\n        _getFeatureRectangle: function _getFeatureRectangle(viewInfo, feature) {\n            var block = viewInfo.block;\n            var fRect = {\n                l: block.bpToX(feature.get('start')),\n                h: this._getFeatureHeight(viewInfo, feature),\n                viewInfo: viewInfo,\n                f: feature,\n                glyph: this\n            };\n\n            fRect.w = block.bpToX(feature.get('end')) - fRect.l;\n\n            this._addMasksToRect(viewInfo, feature, fRect);\n        },\n\n        _addMasksToRect: function _addMasksToRect(viewArgs, feature, fRect) {\n            // if the feature has masks, add them to the fRect.\n            var block = viewArgs.block;\n\n            if (feature.masks) {\n                fRect.m = [];\n                array.forEach(feature.masks, function (m) {\n                    var tempM = { l: block.bpToX(m.start) };\n                    tempM.w = block.bpToX(m.end) - tempM.l;\n                    fRect.m.push(tempM);\n                });\n            }\n\n            return fRect;\n        },\n\n        layoutFeature: function layoutFeature(viewArgs, layout, feature) {\n            var fRect = this._getFeatureRectangle(viewArgs, feature);\n\n            var scale = viewArgs.scale;\n            var leftBase = viewArgs.leftBase;\n            var startbp = fRect.l / scale + leftBase;\n            var endbp = (fRect.l + fRect.w) / scale + leftBase;\n            fRect.t = layout.addRect(feature.id(), startbp, endbp, fRect.h, feature);\n            if (fRect.t === null) return null;\n\n            fRect.f = feature;\n\n            return fRect;\n        },\n\n        //stub\n        renderFeature: function renderFeature(context, fRect) {},\n\n        /* If it's a boolean track, mask accordingly */\n        maskBySpans: function maskBySpans(context, fRect) {\n            var canvasHeight = context.canvas.height;\n\n            var thisB = this;\n\n            // make a temporary canvas to store image data\n            var tempCan = dojo.create('canvas', { height: canvasHeight, width: context.canvas.width });\n            var ctx2 = tempCan.getContext('2d');\n            var l = Math.floor(fRect.l);\n            var w = Math.ceil(fRect.w + fRect.l) - l;\n\n            /* note on the above: the rightmost pixel is determined\n               by l+w. If either of these is a float, then canvas\n               methods will not behave as desired (i.e. clear and\n               draw will not treat borders in the same way).*/\n            array.forEach(fRect.m, function (m) {\n                try {\n                    if (m.l < l) {\n                        m.w += m.l - l;\n                        m.l = l;\n                    }\n                    if (m.w > w) m.w = w;\n                    if (m.l < 0) {\n                        m.w += m.l;\n                        m.l = 0;\n                    }\n                    if (m.l + m.w > l + w) m.w = w + l - m.l;\n                    if (m.l + m.w > context.canvas.width) m.w = context.canvas.width - m.l;\n                    ctx2.drawImage(context.canvas, m.l, fRect.t, m.w, fRect.h, m.l, fRect.t, m.w, fRect.h);\n                    context.globalAlpha = thisB.booleanAlpha;\n                    // clear masked region and redraw at lower opacity.\n                    context.clearRect(m.l, fRect.t, m.w, fRect.h);\n                    context.drawImage(tempCan, m.l, fRect.t, m.w, fRect.h, m.l, fRect.t, m.w, fRect.h);\n                    context.globalAlpha = 1;\n                } catch (e) {};\n            });\n        },\n\n        _getFeatureHeight: function _getFeatureHeight(viewArgs, feature) {\n            return this.getStyle(feature, 'height');\n        },\n\n        updateStaticElements: function updateStaticElements(context, fRect, viewArgs) {}\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/Alignment.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/Alignment.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Box */ \"./src/JBrowse/View/FeatureGlyph/Box.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/AlignmentColoring */ \"./src/JBrowse/View/FeatureGlyph/AlignmentColoring.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_MismatchesMixin */ \"./src/JBrowse/Store/SeqFeature/_MismatchesMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, BoxGlyph, AlignmentColoring, MismatchesMixin) {\n\n    return declare([BoxGlyph, MismatchesMixin], {\n\n        constructor: function constructor() {\n\n            // if showMismatches is false, stub out this object's\n            // _drawMismatches to be a no-op\n            if (!this.config.style.showMismatches) this._drawMismatches = function () {};\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(dojo.clone(this.inherited(arguments)), {\n                //maxFeatureScreenDensity: 400\n                style: {\n                    color: AlignmentColoring.colorAlignment,\n                    color_fwd_strand_not_proper: '#ECC8C8',\n                    color_rev_strand_not_proper: '#BEBED8',\n                    color_fwd_strand: '#EC8B8B',\n                    color_rev_strand: '#8F8FD8',\n                    color_fwd_missing_mate: '#D11919',\n                    color_rev_missing_mate: '#1919D1',\n                    color_fwd_diff_chr: '#000000',\n                    color_rev_diff_chr: '#969696',\n                    color_pair_lr: 'grey',\n                    color_pair_rr: 'navy',\n                    color_pair_rl: 'teal',\n                    color_pair_ll: 'green',\n                    color_nostrand: '#999999',\n                    color_interchrom: 'orange',\n                    color_longinsert: 'red',\n                    color_shortinsert: 'pink',\n                    border_color: null,\n\n                    strandArrow: false,\n                    height: 7,\n                    marginBottom: 1,\n                    showMismatches: true,\n                    mismatchFont: 'bold 10px Courier New,monospace',\n                    orientationType: 'fr' // default illumina adapter sequence --> <--\n                }\n            });\n        },\n\n        renderFeature: function renderFeature(context, fRect) {\n\n            this.inherited(arguments);\n\n            // draw some mismatches if the feature is more than 3px wide:\n            //     draw everything if zoomed in past 0.2 px/bp, otherwise\n            //     draw only skips and deletions (the mismatches that\n            //     might be large enough to see)\n            if (fRect.w > 2) {\n                if (fRect.viewInfo.scale > 0.2) this._drawMismatches(context, fRect, this._getMismatches(fRect.f));else this._drawMismatches(context, fRect, this._getSkipsAndDeletions(fRect.f));\n            }\n        },\n\n        // draw both gaps and mismatches\n        _drawMismatches: function _drawMismatches(context, fRect, mismatches, f) {\n            var feature = f || fRect.f;\n            var block = fRect.viewInfo.block;\n            var scale = block.scale;\n\n            var charSize = this.getCharacterMeasurements(context);\n            context.textBaseline = 'middle'; // reset to alphabetic (the default) after loop\n\n            array.forEach(mismatches, function (mismatch) {\n                var start = feature.get('start') + mismatch.start;\n                var end = start + mismatch.length;\n\n                var mRect = {\n                    h: (fRect.rect || {}).h || fRect.h,\n                    l: block.bpToX(start),\n                    t: fRect.rect.t\n                };\n                mRect.w = Math.max(block.bpToX(end) - mRect.l, 1);\n\n                if (mismatch.type == 'mismatch' || mismatch.type == 'deletion') {\n                    context.fillStyle = this.track.colorForBase(mismatch.type == 'deletion' ? 'deletion' : mismatch.base);\n                    context.fillRect(mRect.l, mRect.t, mRect.w, mRect.h);\n\n                    if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n                        context.font = this.config.style.mismatchFont;\n                        context.fillStyle = mismatch.type == 'deletion' ? 'white' : 'black';\n                        context.fillText(mismatch.base, mRect.l + (mRect.w - charSize.w) / 2 + 1, mRect.t + mRect.h / 2);\n                    }\n                } else if (mismatch.type == 'insertion') {\n                    context.fillStyle = 'purple';\n                    context.fillRect(mRect.l - 1, mRect.t + 1, 2, mRect.h - 2);\n                    context.fillRect(mRect.l - 2, mRect.t, 4, 1);\n                    context.fillRect(mRect.l - 2, mRect.t + mRect.h - 1, 4, 1);\n                    if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n                        context.font = this.config.style.mismatchFont;\n                        context.fillText('(' + mismatch.base + ')', mRect.l + 2, mRect.t + mRect.h / 2);\n                    }\n                } else if (mismatch.type == 'hardclip' || mismatch.type == 'softclip') {\n                    context.fillStyle = mismatch.type == 'hardclip' ? 'red' : 'blue';\n                    context.fillRect(mRect.l - 1, mRect.t + 1, 2, mRect.h - 2);\n                    context.fillRect(mRect.l - 2, mRect.t, 4, 1);\n                    context.fillRect(mRect.l - 2, mRect.t + mRect.h - 1, 4, 1);\n                    if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n                        context.font = this.config.style.mismatchFont;\n                        context.fillText('(' + mismatch.base + ')', mRect.l + 2, mRect.t + mRect.h / 2);\n                    }\n                } else if (mismatch.type == 'skip') {\n                    context.clearRect(mRect.l, mRect.t, mRect.w, mRect.h);\n                    context.fillStyle = '#333';\n                    context.fillRect(mRect.l, mRect.t + (mRect.h - 2) / 2, mRect.w, 2);\n                }\n            }, this);\n\n            context.textBaseline = 'alphabetic';\n        },\n\n        getCharacterMeasurements: function getCharacterMeasurements(context) {\n            return this.charSize = this.charSize || function () {\n                var fpx;\n\n                try {\n                    fpx = (this.config.style.mismatchFont.match(/(\\d+)px/i) || [])[1];\n                } catch (e) {}\n\n                fpx = fpx || Infinity;\n                return { w: fpx, h: fpx };\n            }.call(this);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/Alignment.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/AlignmentColoring.js":
/*!************************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/AlignmentColoring.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Util) {\n\n    var c = {\n        colorAlignment: function colorAlignment(feature, score, glyph, track) {\n            var strand = feature.get('strand');\n            if (Math.abs(strand) != 1 && strand != '+' && strand != '-') {\n                return track.colorForBase('reference');\n            } else if (track.config.colorByOrientationAndSize) {\n                return c.colorByOrientationAndSize.apply(null, arguments);\n            } else if (track.config.colorByOrientation) {\n                return c.colorByOrientation.apply(null, arguments);\n            } else if (track.config.colorBySize) {\n                return c.colorByInsertSizePercentile.apply(null, arguments);\n            } else if (track.config.useXS) {\n                return c.colorByXS.apply(null, arguments);\n            } else if (track.config.useTS) {\n                return c.colorByTS.apply(null, arguments);\n            } else if (track.config.colorByMAPQ) {\n                return c.colorByMAPQ.apply(null, arguments);\n            } else if (track.config.defaultColor || track.config.useReverseTemplate) {\n                if (feature.get('multi_segment_template')) {\n                    var revflag = feature.get('multi_segment_first');\n                    if (feature.get('multi_segment_all_correctly_aligned')) {\n                        if (revflag || !track.config.useReverseTemplate) {\n                            return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_fwd_strand') : glyph.getStyle(feature, 'color_rev_strand');\n                        } else {\n                            return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_rev_strand') : glyph.getStyle(feature, 'color_fwd_strand');\n                        }\n                    }\n                    if (feature.get('multi_segment_next_segment_unmapped')) {\n                        if (revflag || !track.config.useReverseTemplate) {\n                            return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_fwd_missing_mate') : glyph.getStyle(feature, 'color_rev_missing_mate');\n                        } else {\n                            return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_rev_missing_mate') : glyph.getStyle(feature, 'color_fwd_missing_mate');\n                        }\n                    }\n                    if (feature.get('seq_id') == feature.get('next_seq_id')) {\n                        if (revflag || !track.config.useReverseTemplate) {\n                            return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_fwd_strand_not_proper') : glyph.getStyle(feature, 'color_rev_strand_not_proper');\n                        } else {\n                            return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_rev_strand_not_proper') : glyph.getStyle(feature, 'color_fwd_strand_not_proper');\n                        }\n                    }\n                    // should only leave aberrant chr\n                    return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_fwd_diff_chr') : glyph.getStyle(feature, 'color_rev_diff_chr');\n                }\n                return strand == 1 || strand == '+' ? glyph.getStyle(feature, 'color_fwd_strand') : glyph.getStyle(feature, 'color_rev_strand');\n            } else return glyph.getStyle(feature, 'color_nostrand');\n        },\n        getOrientation: function getOrientation(feature, score, glyph, track) {\n            var type = Util.orientationTypes[track.config.orientationType];\n            var orientation = type[feature.get('pair_orientation')];\n            var map = {\n                'LR': 'color_pair_lr',\n                'RR': 'color_pair_rr',\n                'RL': 'color_pair_rl',\n                'LL': 'color_pair_ll'\n            };\n            return map[orientation];\n        },\n        colorByOrientation: function colorByOrientation(feature, score, glyph, track) {\n            var p = c.getOrientation.apply(null, arguments);\n            return glyph.getStyle(feature, p || 'color_nostrand');\n        },\n        colorByOrientationAndSize: function colorByOrientationAndSize(feature, score, glyph, track) {\n            var p = c.getInsertSizePercentile.apply(null, arguments);\n            if (!p) {\n                return c.colorByOrientation.apply(null, arguments);\n            }\n            return glyph.getStyle(feature, p);\n        },\n        getInsertSizePercentile: function getInsertSizePercentile(feature, score, glyph, track) {\n            if (feature.get('is_paired')) {\n                var len = Math.abs(feature.get('template_length'));\n                if (feature.get('seq_id') != feature.get('next_seq_id')) {\n                    return 'color_interchrom';\n                } else if (track.insertSizeStats.upper < len) {\n                    return 'color_longinsert';\n                } else if (track.insertSizeStats.lower > len) {\n                    return 'color_shortinsert';\n                }\n            }\n            return null;\n        },\n        colorByInsertSizePercentile: function colorByInsertSizePercentile(feature, score, glyph, track) {\n            var p = c.getInsertSizePercentile.apply(null, arguments);\n            return glyph.getStyle(feature, p || 'color_nostrand');\n        },\n        colorByInsertSize: function colorByInsertSize(feature, score, glyph, track) {\n            if (feature.get('is_paired') && feature.get('seq_id') != feature.get('next_seq_id')) {\n                return glyph.getStyle(feature, 'color_interchrom');\n            }\n            var s = Math.abs(score / 10);\n            return 'hsl(' + s + ',50%,50%)';\n        },\n        colorArcs: function colorArcs(feature, score, glyph, track) {\n            if (track.config.colorByOrientationAndSize) {\n                return c.colorByOrientationAndSize.apply(null, arguments);\n            } else if (track.config.colorBySize) {\n                return c.colorByInsertSizePercentile.apply(null, arguments);\n            } else if (track.config.colorByOrientation) {\n                return c.colorByOrientation.apply(null, arguments);\n            } else if (track.config.colorByMAPQ) {\n                return c.colorByMAPQ.apply(null, arguments);\n            } else {\n                return c.colorByInsertSize.apply(null, arguments);\n            }\n        },\n        connectorColor: function connectorColor(feature, score, glyph, track) {\n            if (track.config.colorByOrientation) {\n                return c.colorByOrientation.apply(null, arguments);\n            } else if (track.config.colorByOrientationAndSize) {\n                return c.colorByOrientationAndSize.apply(null, arguments);\n            } else {\n                return 'black';\n            }\n        },\n        colorByXS: function colorByXS(feature, score, glyph, track) {\n            var map = {\n                '-': 'color_rev_strand',\n                '+': 'color_fwd_strand'\n            };\n            return glyph.getStyle(feature, map[feature.get('xs') || feature.get('tags').XS] || 'color_nostrand');\n        },\n\n\n        // TS is flipped from XS\n        colorByTS: function colorByTS(feature, score, glyph, track) {\n            var map = {\n                '-': feature.get('strand') === -1 ? 'color_fwd_strand' : 'color_rev_strand',\n                '+': feature.get('strand') === -1 ? 'color_rev_strand' : 'color_fwd_strand'\n            };\n            return glyph.getStyle(feature, map[feature.get('ts') || feature.get('tags').TS] || 'color_nostrand');\n        },\n\n\n        // assumes score cap at 60, which is used by bwa-mem and other tools. some cap at 37\n        colorByMAPQ: function colorByMAPQ(feature, score, glyph, track) {\n            var c = Math.min(feature.get('score') * 4, 200);\n            return 'rgb(' + c + ',' + c + ',' + c + ')';\n        }\n    };\n\n    return c;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/AlignmentColoring.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/Box.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/Box.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Util/FastPromise */ \"./src/JBrowse/Util/FastPromise.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph */ \"./src/JBrowse/View/FeatureGlyph.js\"), __webpack_require__(/*! ./_FeatureLabelMixin */ \"./src/JBrowse/View/FeatureGlyph/_FeatureLabelMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, FastPromise, FeatureGlyph, FeatureLabelMixin, Util) {\n\n    return declare([FeatureGlyph, FeatureLabelMixin], {\n\n        constructor: function constructor() {\n            this._embeddedImagePromises = {};\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(this.inherited(arguments), {\n                style: {\n                    maxDescriptionLength: 70,\n\n                    color: 'goldenrod',\n                    mouseovercolor: 'rgba(0,0,0,0.3)',\n                    borderColor: null,\n                    borderWidth: 0.5,\n                    height: 11,\n                    marginBottom: 2,\n\n                    strandArrow: true,\n\n                    label: 'name, id',\n                    textFont: 'normal 12px Univers,Helvetica,Arial,sans-serif',\n                    textColor: 'black',\n                    text2Color: 'blue',\n                    text2Font: 'normal 12px Univers,Helvetica,Arial,sans-serif',\n\n                    description: 'note, description'\n                }\n            });\n        },\n\n        _getFeatureHeight: function _getFeatureHeight(viewArgs, feature) {\n            var h = this.getStyle(feature, 'height');\n\n            if (viewArgs.displayMode == 'compact') h = Math.round(0.45 * h);\n\n            if (this.getStyle(feature, 'strandArrow')) {\n                var strand = feature.get('strand');\n                if (strand == 1) h = Math.max(this._embeddedImages.plusArrow.height, h);else if (strand == -1) h = Math.max(this._embeddedImages.minusArrow.height, h);\n            }\n\n            return h;\n        },\n\n        _getFeatureRectangle: function _getFeatureRectangle(viewArgs, feature) {\n            var block = viewArgs.block;\n            var fRect = {\n                l: block.bpToX(feature.get('start')),\n                h: this._getFeatureHeight(viewArgs, feature),\n                viewInfo: viewArgs,\n                f: feature,\n                glyph: this\n            };\n\n            fRect.w = block.bpToX(feature.get('end')) - fRect.l;\n\n            // save the original rect in `rect` as the dimensions\n            // we'll use for the rectangle itself\n            fRect.rect = { l: fRect.l, h: fRect.h, w: Math.max(fRect.w, 2), t: 0 };\n            fRect.w = fRect.rect.w; // in case it was increased\n            if (viewArgs.displayMode != 'compact') fRect.h += this.getStyle(feature, 'marginBottom') || 0;\n            // if we are showing strand arrowheads, expand the frect a little\n            if (this.getStyle(feature, 'strandArrow')) {\n                var strand = fRect.strandArrow = feature.get('strand');\n\n                if (strand == -1) {\n                    var i = this._embeddedImages.minusArrow;\n                    fRect.w += i.width;\n                    fRect.l -= i.width;\n                } else {\n                    var i = this._embeddedImages.plusArrow;\n                    fRect.w += i.width;\n                }\n            }\n\n            // no labels or descriptions if displayMode is collapsed, so stop here\n            if (viewArgs.displayMode == \"collapsed\") return fRect;\n\n            this._expandRectangleWithLabels(viewArgs, feature, fRect);\n            this._addMasksToRect(viewArgs, feature, fRect);\n\n            return fRect;\n        },\n\n        layoutFeature: function layoutFeature(viewArgs, layout, feature) {\n            var rect = this.inherited(arguments);\n            if (!rect) return rect;\n\n            // need to set the top of the inner rect\n            rect.rect.t = rect.t;\n\n            return rect;\n        },\n\n        // given an under-construction feature layout rectangle, expand it\n        // to accomodate a label and/or a description\n        _expandRectangleWithLabels: function _expandRectangleWithLabels(viewArgs, feature, fRect) {\n            // maybe get the feature's name, and update the layout box\n            // accordingly\n            if (viewArgs.showLabels) {\n                var label = this.makeFeatureLabel(feature, fRect);\n                if (label) {\n                    fRect.h += label.h;\n                    fRect.w = Math.max(label.w, fRect.w);\n                    fRect.label = label;\n                    label.yOffset = fRect.rect.h + label.h;\n                }\n            }\n\n            // maybe get the feature's description if available, and\n            // update the layout box accordingly\n            if (viewArgs.showDescriptions) {\n                var description = this.makeFeatureDescriptionLabel(feature, fRect);\n                if (description) {\n                    fRect.description = description;\n                    fRect.h += description.h;\n                    fRect.w = Math.max(description.w, fRect.w);\n                    description.yOffset = fRect.h - (this.getStyle(feature, 'marginBottom') || 0);\n                }\n            }\n        },\n\n        _embeddedImages: {\n            plusArrow: {\n                data: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAYAAACXU8ZrAAAATUlEQVQIW2NkwATGQKFYIG4A4g8gacb///+7AWlBmNq+vj6V4uLiJiD/FRBXA/F8xu7u7kcVFRWyMEVATQz//v0Dcf9CxaYRZxIxbgIARiAhmifVe8UAAAAASUVORK5CYII=\",\n                width: 9,\n                height: 5\n            },\n\n            minusArrow: {\n                data: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAFCAYAAACXU8ZrAAAASklEQVQIW2NkQAABILMBiBcD8VkkcQZGIAeEE4G4FYjFent764qKiu4gKXoPUjAJiLOggsxMTEwMjIwgYQjo6Oh4TLRJME043QQA+W8UD/sdk9IAAAAASUVORK5CYII=\",\n                width: 9,\n                height: 5\n            }\n        },\n\n        /**\n         * Returns a promise for an Image object for the image with the\n         * given name.  Image data comes from a data URL embedded in this\n         * source code.\n         */\n        getEmbeddedImage: function getEmbeddedImage(name) {\n            return this._embeddedImagePromises[name] || function () {\n                var p = new FastPromise();\n                var imgRec = this._embeddedImages[name];\n                if (!imgRec) {\n                    p.resolve(null);\n                } else {\n                    var i = new Image();\n                    var thisB = this;\n                    i.onload = function () {\n                        p.resolve(this);\n                    };\n                    i.src = imgRec.data;\n                }\n                return this._embeddedImagePromises[name] = p;\n            }.call(this);\n        },\n\n        renderFeature: function renderFeature(context, fRect) {\n            if (this.track.displayMode != 'collapsed') context.clearRect(Math.floor(fRect.l), fRect.t, Math.ceil(fRect.w - Math.floor(fRect.l) + fRect.l), fRect.h);\n\n            this.renderBox(context, fRect.viewInfo, fRect.f, fRect.t, fRect.rect.h, fRect.f);\n            this.renderLabel(context, fRect);\n            this.renderDescription(context, fRect);\n            this.renderArrowhead(context, fRect);\n        },\n\n        // top and height are in px\n        renderBox: function renderBox(context, viewInfo, feature, top, overallHeight, parentFeature, style) {\n            var left = viewInfo.block.bpToX(feature.get('start'));\n            var width = viewInfo.block.bpToX(feature.get('end')) - left;\n            //left = Math.round( left );\n            //width = Math.round( width );\n\n            style = style || lang.hitch(this, 'getStyle');\n\n            var height = this._getFeatureHeight(viewInfo, feature);\n            if (!height) return;\n            if (height != overallHeight) top += Math.round((overallHeight - height) / 2);\n\n            // background\n            var bgcolor = style(feature, 'color');\n            if (bgcolor) {\n                context.fillStyle = bgcolor;\n                context.fillRect(left, top, Math.max(1, width), height);\n            } else {\n                context.clearRect(left, top, Math.max(1, width), height);\n            }\n\n            // foreground border\n            var borderColor, lineWidth;\n            if ((borderColor = style(feature, 'borderColor')) && (lineWidth = style(feature, 'borderWidth'))) {\n                if (width > 3) {\n                    context.lineWidth = lineWidth;\n                    context.strokeStyle = borderColor;\n\n                    // need to stroke a smaller rectangle to remain within\n                    // the bounds of the feature's overall height and\n                    // width, because of the way stroking is done in\n                    // canvas.  thus the +0.5 and -1 business.\n                    context.strokeRect(left + lineWidth / 2, top + lineWidth / 2, width - lineWidth, height - lineWidth);\n                } else {\n                    context.globalAlpha = lineWidth * 2 / width;\n                    context.fillStyle = borderColor;\n                    context.fillRect(left, top, Math.max(1, width), height);\n                    context.globalAlpha = 1;\n                }\n            }\n        },\n\n        // feature label is handled by updateStaticElements\n        renderLabel: function renderLabel(context, fRect) {},\n\n        // feature description is handled by updateStaticElements\n        renderDescription: function renderDescription(context, fRect) {},\n\n        // strand arrowhead is sometimes drawn normally, sometimes *also* as a static element\n        renderArrowhead: function renderArrowhead(context, fRect) {\n            if (fRect.strandArrow) {\n                if (fRect.strandArrow == 1 && fRect.rect.l + fRect.rect.w <= context.canvas.width) {\n                    this.getEmbeddedImage('plusArrow').then(function (img) {\n                        context.imageSmoothingEnabled = false;\n                        context.drawImage(img, fRect.rect.l + fRect.rect.w, fRect.t + (fRect.rect.h - img.height) / 2);\n                    });\n                } else if (fRect.strandArrow == -1 && fRect.rect.l >= 0) {\n                    this.getEmbeddedImage('minusArrow').then(function (img) {\n                        context.imageSmoothingEnabled = false;\n                        context.drawImage(img, fRect.rect.l - 9, fRect.t + (fRect.rect.h - img.height) / 2);\n                    });\n                }\n            }\n        },\n\n        updateStaticElements: function updateStaticElements(context, fRect, viewArgs) {\n            var vMin = viewArgs.minVisible;\n            var vMax = viewArgs.maxVisible;\n            var block = fRect.viewInfo.block;\n\n            var bpToPx = viewArgs.bpToPx;\n            var feature = fRect.f;\n\n            var fMin = feature.get('start');\n            var fMax = feature.get('end');\n            var bMin = block.startBase;\n            var bMax = block.endBase;\n\n            if (fRect.strandArrow) {\n                if (fRect.strandArrow == 1 && fMax >= vMax && fMin <= vMax) {\n                    this.getEmbeddedImage('plusArrow').then(function (img) {\n                        context.imageSmoothingEnabled = false;\n                        context.drawImage(img, bpToPx(vMax) - bpToPx(vMin) - 9, fRect.t + (fRect.rect.h - img.height) / 2);\n                    });\n                } else if (fRect.strandArrow == -1 && fMin <= vMin && fMax >= vMin) {\n                    this.getEmbeddedImage('minusArrow').then(function (img) {\n                        context.imageSmoothingEnabled = false;\n                        context.drawImage(img, 0, fRect.t + (fRect.rect.h - img.height) / 2);\n                    });\n                }\n            }\n\n            // if the feature is within the view and within this block\n            if (fMin < vMax && fMax > vMin && fMin < bMax && fMax > bMin) {\n                var fRectLeft = fRect.l + bpToPx(block.startBase - vMin + 1);\n\n                var clamp = function clamp(val, min, max) {\n                    return Math.min(Math.max(val, min), max);\n                };\n                var renderText = function renderText(fLabelRecord) {\n                    var maxLabelLeft = fRectLeft + fRect.w - fLabelRecord.w;\n                    var labelTop = fRect.t + (fLabelRecord.yOffset || 0);\n                    var labelLeft = fRectLeft + (fLabelRecord.xOffset || 0);\n                    labelLeft = clamp(labelLeft, 0, maxLabelLeft);\n\n                    context.font = fLabelRecord.font;\n                    context.fillStyle = fLabelRecord.fill;\n                    context.textBaseline = fLabelRecord.baseline;\n\n                    var clearTop = void 0;\n                    if (fLabelRecord.baseline === 'bottom') {\n                        clearTop = labelTop - fLabelRecord.h;\n                    } else if (fLabelRecord.baseline === 'top') {\n                        clearTop = labelTop;\n                    } else if (fLabelRecord.baseline === 'middle') {\n                        clearTop = labelTop - fLabelRecord.h / 2;\n                    }\n                    if (clearTop) context.clearRect(labelLeft, clearTop, fLabelRecord.w, fLabelRecord.h);\n\n                    context.fillText(fLabelRecord.text, labelLeft, labelTop);\n                };\n\n                if (fRect.label) {\n                    renderText(fRect.label);\n                }\n                if (fRect.description) {\n                    renderText(fRect.description);\n                }\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/Box.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/Diamond.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/Diamond.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! ./Box */ \"./src/JBrowse/View/FeatureGlyph/Box.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Box) {\n\n    return declare(Box, {\n\n        renderBox: function renderBox(context, viewInfo, feature, top, overallHeight, parentFeature, style) {\n\n            var left = viewInfo.block.bpToX(feature.get('start'));\n            var width = viewInfo.block.bpToX(feature.get('end')) - left;\n            //left = Math.round( left );\n            //width = Math.round( width );\n\n            style = style || lang.hitch(this, 'getStyle');\n\n            var height = this._getFeatureHeight(viewInfo, feature);\n            if (!height) return;\n            if (height != overallHeight) top += Math.round((overallHeight - height) / 2);\n\n            // background\n            var bgcolor = style(feature, 'color');\n            if (bgcolor) {\n                context.fillStyle = bgcolor;\n                context.beginPath();\n                context.moveTo(left, top + height / 2);\n                context.lineTo(left + Math.max(1, width) / 2, top);\n                context.lineTo(left + Math.max(1, width), top + height / 2);\n                context.lineTo(left + Math.max(1, width) / 2, top + height);\n                context.closePath();\n                context.fill();\n            } else {\n                context.clearRect(left, top, Math.max(1, width), height);\n            }\n\n            // foreground border\n            var borderColor, lineWidth;\n            if ((borderColor = style(feature, 'borderColor')) && (lineWidth = style(feature, 'borderWidth'))) {\n                if (width > 3) {\n                    context.lineWidth = lineWidth;\n                    context.strokeStyle = borderColor;\n\n                    // need to stroke a smaller rectangle to remain within\n                    // the bounds of the feature's overall height and\n                    // width, because of the way stroking is done in\n                    // canvas.  thus the +0.5 and -1 business.\n                    //context.stroke();\n                    context.beginPath();\n                    context.moveTo(left, top + height / 2);\n                    context.lineTo(left + Math.max(1, width) / 2, top);\n                    context.lineTo(left + Math.max(1, width), top + height / 2);\n                    context.lineTo(left + Math.max(1, width) / 2, top + height);\n                    context.closePath();\n                    context.stroke();\n                } else {\n                    context.globalAlpha = lineWidth * 2 / width;\n                    context.fillStyle = borderColor;\n                    context.beginPath();\n                    context.moveTo(left, top + height / 2);\n                    context.lineTo(left + Math.max(1, width) / 2, top);\n                    context.lineTo(left + Math.max(1, width), top + height / 2);\n                    context.lineTo(left + Math.max(1, width) / 2, top + height);\n                    context.closePath();\n                    context.fill();\n                    context.globalAlpha = 1;\n                }\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/Diamond.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/Gene.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/Gene.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Box */ \"./src/JBrowse/View/FeatureGlyph/Box.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/UnprocessedTranscript */ \"./src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/ProcessedTranscript */ \"./src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, BoxGlyph, UnprocessedTranscript, ProcessedTranscriptGlyph) {\n\n    return declare(BoxGlyph, {\n\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(this.inherited(arguments), {\n                transcriptType: 'mRNA',\n                noncodingType: ['ncRNA', 'lnc_RNA', 'lncRNA', 'miRNA'],\n                style: {\n                    transcriptLabelFont: 'normal 10px Univers,Helvetica,Arial,sans-serif',\n                    transcriptLabelColor: 'black',\n                    textFont: 'bold 12px Univers,Helvetica,Arial,sans-serif'\n                },\n                labelTranscripts: true,\n                marginBottom: 0\n            });\n        },\n\n        _boxGlyph: function _boxGlyph() {\n            return this.__boxGlyph || (this.__boxGlyph = new BoxGlyph({ track: this.track, browser: this.browser, config: this.config }));\n        },\n        _ntGlyph: function _ntGlyph() {\n            return this.__ntGlyph || (this.__ntGlyph = new UnprocessedTranscript({ track: this.track, browser: this.browser, config: this.config }));\n        },\n        _ptGlyph: function _ptGlyph() {\n            return this.__ptGlyph || (this.__ptGlyph = new ProcessedTranscriptGlyph({ track: this.track, browser: this.browser, config: this.config }));\n        },\n\n        _getFeatureRectangle: function _getFeatureRectangle(viewArgs, feature) {\n\n            // we need to lay out rects for each of the subfeatures\n            var subArgs = lang.mixin({}, viewArgs);\n            subArgs.showDescriptions = subArgs.showLabels = false;\n            var subfeatures = feature.children();\n\n            // if this gene weirdly has no subfeatures, just render as a box\n            if (!subfeatures || !subfeatures.length) return this.inherited(arguments);\n\n            // get the rects for the children\n            var padding = 1;\n            var fRect = {\n                l: 0,\n                h: 0,\n                r: 0,\n                w: 0,\n                subRects: [],\n                viewInfo: viewArgs,\n                f: feature,\n                glyph: this\n            };\n            if (subfeatures && subfeatures.length) {\n                // sort the children by name\n                subfeatures.sort(function (a, b) {\n                    return (a.get('name') || a.get('id') || '').localeCompare(b.get('name') || b.get('id') || '');\n                });\n\n                fRect.l = Infinity;\n                fRect.r = -Infinity;\n\n                var transcriptType = this.getConfForFeature('transcriptType', feature);\n                var noncodingType = this.getConfForFeature('noncodingType', feature);\n                for (var i = 0; i < subfeatures.length; i++) {\n                    var subRect = (subfeatures[i].get('type') == transcriptType ? this._ptGlyph() : noncodingType.includes(subfeatures[i].get('type')) ? this._ntGlyph() : this._boxGlyph())._getFeatureRectangle(subArgs, subfeatures[i]);\n\n                    padding = i == subfeatures.length - 1 ? 0 : 1;\n                    subRect.t = subRect.rect.t = fRect.h && viewArgs.displayMode != 'collapsed' ? fRect.h + padding : 0;\n\n                    if (viewArgs.showLabels && this.getConfForFeature('labelTranscripts', subfeatures[i])) {\n                        var transcriptLabel = this.makeSideLabel(this.getFeatureLabel(subfeatures[i]), this.getStyle(subfeatures[i], 'transcriptLabelFont'), subRect);\n                        if (transcriptLabel) {\n                            transcriptLabel.fill = this.getStyle(subfeatures[i], 'transcriptLabelColor');\n                            subRect.label = transcriptLabel;\n                            subRect.l -= transcriptLabel.w;\n                            subRect.w += transcriptLabel.w;\n                            if (transcriptLabel.h > subRect.h) subRect.h = transcriptLabel.h;\n                            transcriptLabel.yOffset = Math.floor(subRect.h / 2);\n                            transcriptLabel.xOffset = 0;\n                        }\n                    }\n\n                    fRect.subRects.push(subRect);\n                    fRect.r = Math.max(fRect.r, subRect.l + subRect.w - 1);\n                    fRect.l = Math.min(fRect.l, subRect.l);\n                    fRect.h = subRect.t + subRect.h + padding;\n                }\n            }\n\n            // calculate the width\n            fRect.w = Math.max(fRect.r - fRect.l + 1, 2);\n            delete fRect.r;\n            fRect.rect = { l: fRect.l, h: fRect.h, w: fRect.w };\n            if (viewArgs.displayMode != 'compact') fRect.h += this.getStyle(feature, 'marginBottom') || 0;\n\n            // no labels or descriptions if displayMode is collapsed, so stop here\n            if (viewArgs.displayMode == \"collapsed\") return fRect;\n\n            // expand the fRect to accommodate labels if necessary\n            this._expandRectangleWithLabels(viewArgs, feature, fRect);\n            this._addMasksToRect(viewArgs, feature, fRect);\n\n            return fRect;\n        },\n\n\n        layoutFeature: function layoutFeature(viewInfo, layout, feature) {\n            var fRect = this.inherited(arguments);\n            if (fRect) array.forEach(fRect.subRects, function (subrect) {\n                subrect.t += fRect.t;\n                subrect.rect.t += fRect.t;\n            });\n            return fRect;\n        },\n\n        renderFeature: function renderFeature(context, fRect) {\n            var subRects = fRect.subRects;\n            if (!subRects || subRects.length === 0) return this.inherited(arguments);\n\n            if (fRect.viewInfo.displayMode != 'collapsed') context.clearRect(Math.floor(fRect.l), fRect.t, Math.ceil(fRect.w - Math.floor(fRect.l) + fRect.l), fRect.h);\n\n            for (var i = 0; i < subRects.length; i++) {\n                subRects[i].glyph.renderFeature(context, subRects[i]);\n            }\n\n            this.renderLabel(context, fRect);\n            this.renderDescription(context, fRect);\n        },\n\n\n        updateStaticElements: function updateStaticElements(context, fRect, viewArgs) {\n            this.inherited(arguments);\n\n            var subRects = fRect.subRects || [];\n            for (var i = 0; i < subRects.length; i++) {\n                subRects[i].glyph.updateStaticElements(context, subRects[i], viewArgs);\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/Gene.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/PairedAlignment.js":
/*!**********************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/PairedAlignment.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Alignment */ \"./src/JBrowse/View/FeatureGlyph/Alignment.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/AlignmentColoring */ \"./src/JBrowse/View/FeatureGlyph/AlignmentColoring.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, Alignment, AlignmentColoring, Util) {\n\n    return declare(Alignment, {\n        clearFeat: function clearFeat(context, fRect) {\n            if (this.track.displayMode != 'collapsed') context.clearRect(Math.floor(fRect.l), fRect.t, Math.ceil(fRect.w), fRect.h);\n        },\n        renderFeature: function renderFeature(context, fRect) {\n            var f = fRect.f;\n            this.clearFeat(context, fRect);\n\n            if (f.pairedFeature()) {\n                this.renderConnector(context, fRect);\n                this.renderSegments(context, fRect);\n                if (fRect.w > 2) {\n                    if (fRect.viewInfo.scale > 0.2) {\n                        this._drawMismatches(context, fRect, this._getMismatches(f.read1), f.read1);\n                        this._drawMismatches(context, fRect, this._getMismatches(f.read2), f.read2);\n                    } else {\n                        this._drawMismatches(context, fRect, this._getSkipsAndDeletions(f.read1), f.read1);\n                        this._drawMismatches(context, fRect, this._getSkipsAndDeletions(f.read2), f.read2);\n                    }\n                }\n                var x1 = f.read1.get('start');\n                var x2 = f.read1.get('end');\n                var y1 = f.read2.get('start');\n                var y2 = f.read2.get('end');\n                if (Util.intersect(x1, x2, y1, y2)) {\n                    var s1 = x2 > y2 ? x1 : y1;\n                    var s2 = x1 > y1 ? y2 : x2;\n                    var block = fRect.viewInfo.block;\n                    var l = block.bpToX(s1);\n                    var r = block.bpToX(s2);\n                    // avoid drawing small overlaps\n                    if (r - l > 2) {\n                        context.fillStyle = this.getStyle(f, 'overlapColor');\n                        context.fillRect(l, // left\n                        fRect.rect.t, r - l, // width\n                        fRect.rect.h);\n\n                        var s = this.getStyle(f, 'overlapStroke');\n                        if (s) {\n                            context.strokeStyle = s;\n                            context.strokeRect(l, // left\n                            fRect.rect.t, r - l, // width\n                            fRect.rect.h);\n                        }\n                        if (fRect.viewInfo.scale > 0.2) {\n                            var m1 = this._getMismatches(f.read1);\n                            var m2 = this._getMismatches(f.read2);\n                            if (!m1 && !m2) {\n                                return;\n                            } else {\n                                var mismatches = [];\n                                for (var i = 0; i < m1.length; i++) {\n                                    var foundMatching = false;\n                                    for (var j = 0; j < m2.length; j++) {\n                                        if (x1 + m1[i].start == y1 + m2[j].start && s1 <= x1 + m1[i].start && s2 >= x1 + m1[i].start) {\n                                            foundMatching = true;\n                                            mismatches.push({ start: m1[i].start, base1: m1[i].base, base2: m2[j].base, type: 'mismatch', length: 1 });\n                                        }\n                                    }\n                                    if (m1[i].type == 'mismatch' && s1 <= x1 + m1[i].start && s2 >= x1 + m1[i].start && !foundMatching) {\n                                        mismatches.push({ start: m1[i].start, base1: m1[i].base, base2: '-', type: 'mismatch', length: 1 });\n                                    }\n                                }\n                                if (mismatches.length !== 0) {\n                                    this._drawOverlappingMismatches(context, fRect, mismatches, x1);\n                                }\n                                mismatches = [];\n                                for (var i = 0; i < m2.length; i++) {\n                                    var _foundMatching = false;\n                                    for (var j = 0; j < m1.length; j++) {\n                                        if (x1 + m1[j].start == y1 + m2[i].start && s1 <= y1 + m2[i].start && s2 >= y1 + m2[i].start) {\n                                            //    mismatches.push({ start: m2[i].start, base1: m2[i].base, base2: m1[j].base, type: 'mismatch', length: 1 });\n                                            //    would have been found in above loop also previous iteration\n                                            _foundMatching = true;\n                                        }\n                                    }\n                                    if (m2[i].type == 'mismatch' && s1 <= y1 + m2[i].start && s2 >= y1 + m2[i].start && !_foundMatching) {\n                                        mismatches.push({ start: m2[i].start, base1: m2[i].base, base2: '-', type: 'mismatch', length: 1 });\n                                    }\n                                }\n                                if (mismatches.length !== 0) {\n                                    this._drawOverlappingMismatches(context, fRect, mismatches, y1);\n                                }\n                            }\n                        }\n                    }\n                }\n            } else {\n                this.inherited(arguments);\n            }\n        },\n        renderSegments: function renderSegments(context, fRect) {\n            this.renderBox(context, fRect.viewInfo, fRect.f.read1, fRect.t, fRect.rect.h, fRect.f);\n            this.renderBox(context, fRect.viewInfo, fRect.f.read2, fRect.t, fRect.rect.h, fRect.f);\n        },\n        renderConnector: function renderConnector(context, fRect) {\n            // connector\n            var connectorColor = this.getStyle(fRect.f, 'connectorColor');\n            if (connectorColor) {\n                context.fillStyle = connectorColor;\n                var connectorThickness = this.getStyle(fRect.f, 'connectorThickness');\n                context.fillRect(fRect.rect.l, // left\n                Math.round(fRect.rect.t + (fRect.rect.h - connectorThickness) / 2), // top\n                fRect.rect.w, // width\n                connectorThickness);\n            }\n        },\n\n\n        // draw both gaps and mismatches\n        _drawOverlappingMismatches: function _drawOverlappingMismatches(context, fRect, mismatches, fstart) {\n            var block = fRect.viewInfo.block;\n            var scale = block.scale;\n\n            var charSize = this.getCharacterMeasurements(context);\n            context.textBaseline = 'middle'; // reset to alphabetic (the default) after loop\n\n            array.forEach(mismatches, function (mismatch) {\n                var start = fstart + mismatch.start;\n                var end = fstart + mismatch.start + mismatch.length;\n\n                var mRect = {\n                    h: (fRect.rect || {}).h || fRect.h,\n                    l: block.bpToX(start),\n                    t: fRect.rect.t\n                };\n                mRect.w = Math.max(block.bpToX(end) - mRect.l, 1);\n\n                if (mismatch.type == 'mismatch') {\n                    if (mismatch.base1 == mismatch.base2) {\n                        context.fillStyle = this.track.colorForBase(mismatch.type == 'deletion' ? 'deletion' : mismatch.base1);\n                    } else {\n                        context.fillStyle = 'black';\n                    }\n                    context.fillRect(mRect.l, mRect.t, mRect.w, mRect.h);\n\n                    if (mRect.w >= charSize.w && mRect.h >= charSize.h - 3) {\n                        context.font = this.config.style.mismatchFont;\n                        if (mismatch.base1 == mismatch.base2) {\n                            context.fillStyle = 'black';\n                            context.fillText(mismatch.base1, mRect.l + (mRect.w - charSize.w) / 2 + 1, mRect.t + mRect.h / 2);\n                        } else if (scale >= 10) {\n                            context.fillStyle = 'white';\n                            context.fillText(mismatch.base1 + '/' + mismatch.base2, mRect.l + (mRect.w - charSize.w * 2) / 2 + 1, mRect.t + mRect.h / 2);\n                        }\n                    }\n                }\n            }, this);\n\n            context.textBaseline = 'alphabetic';\n        },\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(dojo.clone(this.inherited(arguments)), {\n                style: {\n                    connectorColor: AlignmentColoring.connectorColor,\n                    connectorThickness: 1,\n                    overlapColor: 'lightgrey',\n                    overlapStroke: 'grey'\n                }\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/PairedAlignment.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/PairedArc.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/PairedArc.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Alignment */ \"./src/JBrowse/View/FeatureGlyph/Alignment.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/AlignmentColoring */ \"./src/JBrowse/View/FeatureGlyph/AlignmentColoring.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, FeatureGlyph, AlignmentColoring) {\n    return declare(FeatureGlyph, {\n\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(lang.clone(this.inherited(arguments)), {\n                style: {\n                    color: AlignmentColoring.colorArcs,\n                    mouseovercolor: 'rgba(0,0,0,0)',\n                    strandArrow: false,\n                    orientationType: 'fr' // default illumina adapter sequence --> <--\n                }\n            });\n        },\n\n        renderFeature: function renderFeature(context, fRect) {\n            var r = this.getRadius(fRect.f, fRect.viewInfo.block);\n            if (!r.r || Math.abs(r.r) < 1) {\n                return;\n            }\n            var f = fRect.f;\n\n            if (f.get('is_paired')) {\n                if (f.get('seq_id') !== f.get('next_seq_id')) {\n                    if (this.track.config.showInterchromosomalArcs) {\n                        context.beginPath();\n                        context.strokeStyle = this.getConf('style.color', [f, r.span, this, this.track]);\n                        context.moveTo(r.drawFrom, 0);\n                        context.lineTo(r.drawFrom, 1000);\n                        context.stroke();\n                    }\n                } else {\n                    // draw a vertical line for very very large arcs\n                    if (this.track.config.showLargeArcs && Math.abs(r.drawTo + r.r) > 100000) {\n                        context.beginPath();\n                        context.strokeStyle = this.getConf('style.color', [f, r.span, this, this.track]);\n                        context.moveTo(r.drawTo, 0);\n                        context.lineTo(r.drawTo, 1000);\n                        context.stroke();\n                    } else if (Math.abs(r.span) < this.track.config.maxInsertSize || this.track.config.showLargeArcs) {\n                        context.beginPath();\n                        context.strokeStyle = this.getConf('style.color', [f, r.span, this, this.track]);\n                        context.arc(r.drawTo + r.r, 0, Math.abs(r.r), 0, Math.PI);\n                        context.stroke();\n                    }\n                }\n            }\n        },\n        getRadius: function getRadius(feature, block) {\n            var n = feature.get('end') - feature.get('start');\n            var chr = feature.get('seq_id');\n            if (!n) {\n                return {};\n            }\n\n            var s = feature.get('start');\n            var e = feature.get('end');\n            var drawTo = block.bpToX(e);\n            var drawFrom = block.bpToX(s);\n            return {\n                r: (drawFrom - drawTo) / 2,\n                drawTo: drawTo,\n                drawFrom: drawFrom,\n                span: Math.abs(s - e)\n            };\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/PairedArc.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/PairedReadCloud.js":
/*!**********************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/PairedReadCloud.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/PairedAlignment */ \"./src/JBrowse/View/FeatureGlyph/PairedAlignment.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, PairedAlignment) {\n\n    return declare(PairedAlignment, {\n        clearFeat: function clearFeat(context, fRect) {/* do nothing since drawings overlap, overrides parent */},\n        layoutFeature: function layoutFeature(viewArgs, layout, feature) {\n            var rect = this.inherited(arguments);\n            if (!rect) {\n                return rect;\n            }\n\n            if (feature.pairedFeature()) {\n                var tlen = Math.abs(feature.read1.get('template_length'));\n\n                var k = void 0;\n                if (this.track.config.readCloudLogScale) {\n                    // max is set to upper percentile because it can handle things above this value\n                    k = Math.log(tlen + 1) / Math.log(this.track.config.readCloudYScaleMax || this.track.insertSizeStats.max + 1);\n                    k /= 2; // squish by 2 means theres space above the maxHeight for things larger than the estimated insert size stats/readcloud max\n                } else {\n                    // max set to literal max or a configurable readCloudYScaleMax\n                    k = tlen / (this.track.config.readCloudYScaleMax || this.track.insertSizeStats.upper);\n                    k /= 3; // squish by 3 means theres space above the maxHeight for things larger than the estimated insert size stats, higher for linear\n                }\n\n                k *= this.track.config.maxHeight;\n\n                // use compact view for additional linear compression\n                if (this.track.config.displayMode === 'compact') {\n                    k /= 4;\n                }\n\n                rect.rect.t = k;\n                rect.t = k;\n            } else {\n                rect.t = 0;\n                rect.rect.t = 0;\n            }\n\n            return rect;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/PairedReadCloud.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js":
/*!**************************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojox/color/Palette */ \"./node_modules/dojox/color/Palette.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Segments */ \"./src/JBrowse/View/FeatureGlyph/Segments.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Palette, SimpleFeature, SegmentsGlyph) {\n\n    return declare(SegmentsGlyph, {\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(this.inherited(arguments), {\n                style: {\n                    utrColor: function utrColor(feature, variable, glyph, track) {\n                        return glyph._utrColor(glyph.getStyle(feature.parent(), 'color')).toString();\n                    },\n\n                    utrHeightPercent: 65\n                },\n\n                subParts: 'CDS, UTR, five_prime_UTR, three_prime_UTR',\n\n                impliedUTRs: false,\n\n                inferCdsParts: false,\n                subSubParts: function subSubParts() {\n                    return true;\n                } // render sub-subparts by default\n\n            });\n        },\n\n        _getSubparts: function _getSubparts(f) {\n            var c = f.children();\n            if (!c) return [];\n\n            if (c && this.config.inferCdsParts) c = this._makeCDSs(f, c);\n\n            if (c && this.config.impliedUTRs) c = this._makeUTRs(f, c);\n\n            var filtered = [];\n            for (var i = 0; i < c.length; i++) {\n                if (this._filterSubpart(c[i])) filtered.push(c[i]);\n            }return filtered;\n        },\n\n        _makeCDSs: function _makeCDSs(parent, subparts) {\n            // infer CDS parts from exon coordinates\n\n            var codeStart = Infinity,\n                codeEnd = -Infinity;\n\n            var i;\n\n            // gather exons, find coding start and end\n            var type,\n                codeIndices = [],\n                exons = [];\n            for (i = 0; i < subparts.length; i++) {\n                type = subparts[i].get('type');\n                if (/^cds/i.test(type)) {\n                    // if any CDSs parts are present already,\n                    // bail and return all subparts as-is\n                    if (/:CDS:/i.test(subparts[i].get('name'))) return subparts;\n\n                    codeIndices.push(i);\n                    if (codeStart > subparts[i].get('start')) codeStart = subparts[i].get('start');\n                    if (codeEnd < subparts[i].get('end')) codeEnd = subparts[i].get('end');\n                } else {\n                    if (/exon/i.test(type)) {\n                        exons.push(subparts[i]);\n                    }\n                }\n            }\n\n            // splice out unspliced cds parts\n            codeIndices.sort(function (a, b) {\n                return b - a;\n            });\n            for (i = codeIndices.length - 1; i >= 0; i--) {\n                subparts.splice(codeIndices[i], 1);\n            } // bail if we don't have exons and cds\n            if (!(exons.length && codeStart < Infinity && codeEnd > -Infinity)) return subparts;\n\n            // make sure the exons are sorted by coord\n            exons.sort(function (a, b) {\n                return a.get('start') - b.get('start');\n            });\n\n            // iterate thru exons again, and calculate cds parts\n            var strand = parent.get('strand');\n            var codePartStart = Infinity,\n                codePartEnd = -Infinity;\n            for (i = 0; i < exons.length; i++) {\n                var start = exons[i].get('start');\n                var end = exons[i].get('end');\n\n                // CDS containing exon\n                if (codeStart >= start && codeEnd <= end) {\n                    codePartStart = codeStart;\n                    codePartEnd = codeEnd;\n                }\n                // 5' terminal CDS part\n                else if (codeStart >= start && codeStart < end) {\n                        codePartStart = codeStart;\n                        codePartEnd = end;\n                    }\n                    // 3' terminal CDS part\n                    else if (codeEnd > start && codeEnd <= end) {\n                            codePartStart = start;\n                            codePartEnd = codeEnd;\n                        }\n                        // internal CDS part\n                        else if (start < codeEnd && end > codeStart) {\n                                codePartStart = start;\n                                codePartEnd = end;\n                            }\n\n                // \"splice in\" the calculated cds part into subparts\n                // at beginning of _makeCDSs() method, bail if cds subparts are encountered\n                subparts.splice(i, 0, new SimpleFeature({ parent: parent,\n                    data: {\n                        start: codePartStart,\n                        end: codePartEnd,\n                        strand: strand,\n                        type: 'CDS',\n                        name: parent.get('uniqueID') + \":CDS:\" + i\n                    } }));\n            }\n\n            // make sure the subparts are sorted by coord\n            subparts.sort(function (a, b) {\n                return a.get('start') - b.get('start');\n            });\n\n            return subparts;\n        },\n\n        _makeUTRs: function _makeUTRs(parent, subparts) {\n            // based on Lincoln's UTR-making code in Bio::Graphics::Glyph::processed_transcript\n\n            var codeStart = Infinity,\n                codeEnd = -Infinity;\n\n            var i;\n\n            var haveLeftUTR, haveRightUTR;\n\n            // gather exons, find coding start and end, and look for UTRs\n            var type,\n                exons = [];\n            for (i = 0; i < subparts.length; i++) {\n                type = subparts[i].get('type');\n                if (/^cds/i.test(type)) {\n                    if (codeStart > subparts[i].get('start')) codeStart = subparts[i].get('start');\n                    if (codeEnd < subparts[i].get('end')) codeEnd = subparts[i].get('end');\n                } else if (/exon/i.test(type)) {\n                    exons.push(subparts[i]);\n                } else if (this._isUTR(subparts[i])) {\n                    haveLeftUTR = subparts[i].get('start') == parent.get('start');\n                    haveRightUTR = subparts[i].get('end') == parent.get('end');\n                }\n            }\n\n            // bail if we don't have exons and CDS\n            if (!(exons.length && codeStart < Infinity && codeEnd > -Infinity)) return subparts;\n\n            // make sure the exons are sorted by coord\n            exons.sort(function (a, b) {\n                return a.get('start') - b.get('start');\n            });\n\n            var strand = parent.get('strand');\n\n            // make the left-hand UTRs\n            var start, end;\n            if (!haveLeftUTR) for (i = 0; i < exons.length; i++) {\n                start = exons[i].get('start');\n                if (start >= codeStart) break;\n                end = codeStart > exons[i].get('end') ? exons[i].get('end') : codeStart;\n\n                subparts.unshift(new SimpleFeature({ parent: parent,\n                    data: {\n                        start: start,\n                        end: end,\n                        strand: strand,\n                        type: strand >= 0 ? 'five_prime_UTR' : 'three_prime_UTR'\n                    } }));\n            }\n\n            // make the right-hand UTRs\n            if (!haveRightUTR) for (i = exons.length - 1; i >= 0; i--) {\n                end = exons[i].get('end');\n                if (end <= codeEnd) break;\n\n                start = codeEnd < exons[i].get('start') ? exons[i].get('start') : codeEnd;\n                subparts.push(new SimpleFeature({ parent: parent,\n                    data: {\n                        start: start,\n                        end: end,\n                        strand: strand,\n                        type: strand >= 0 ? 'three_prime_UTR' : 'five_prime_UTR'\n                    } }));\n            }\n\n            return subparts;\n        },\n\n        _utrColor: function _utrColor(baseColor) {\n            return (this._palette || (this._palette = Palette.generate(baseColor, \"splitComplementary\"))).colors[1];\n        },\n\n        _isUTR: function _isUTR(feature) {\n            return (/(\\bUTR|_UTR|untranslated[_\\s]region)\\b/.test(feature.get('type') || '')\n            );\n        },\n\n        getStyle: function getStyle(feature, name) {\n            if (name == 'color') {\n                if (this._isUTR(feature)) {\n                    return this.getStyle(feature, 'utrColor');\n                }\n            }\n\n            return this.inherited(arguments);\n        },\n\n        _getFeatureHeight: function _getFeatureHeight(viewInfo, feature) {\n            var height = this.inherited(arguments);\n\n            if (this._isUTR(feature)) return height * this.getStyle(feature, 'utrHeightPercent') / 100;\n\n            return height;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/ProcessedTranscript.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/Segments.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/Segments.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/Color */ \"./node_modules/dojo/_base/Color.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Box */ \"./src/JBrowse/View/FeatureGlyph/Box.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Color, BoxGlyph) {\n\n    return declare(BoxGlyph, {\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(this.inherited(arguments), {\n                style: {\n                    connectorColor: '#333',\n                    connectorThickness: 1,\n                    borderColor: 'rgba( 0, 0, 0, 0.3 )'\n                },\n                subParts: function subParts() {\n                    return true;\n                }, // accept all subparts by default\n\n                subSubParts: function subSubParts() {\n                    return true;\n                } // render sub-subparts by default\n            });\n        },\n\n        renderFeature: function renderFeature(context, fRect) {\n            if (this.track.displayMode != 'collapsed') context.clearRect(Math.floor(fRect.l), fRect.t, Math.ceil(fRect.w), fRect.h);\n\n            this.renderConnector(context, fRect);\n            this.renderSegments(context, fRect);\n            this.renderLabel(context, fRect);\n            this.renderDescription(context, fRect);\n            this.renderArrowhead(context, fRect);\n        },\n\n        renderConnector: function renderConnector(context, fRect) {\n            // connector\n            var connectorColor = this.getStyle(fRect.f, 'connectorColor');\n            if (connectorColor) {\n                context.fillStyle = connectorColor;\n                var connectorThickness = this.getStyle(fRect.f, 'connectorThickness');\n                context.fillRect(fRect.rect.l, // left\n                Math.round(fRect.rect.t + (fRect.rect.h - connectorThickness) / 2), // top\n                fRect.rect.w, // width\n                connectorThickness);\n            }\n        },\n\n        renderSegments: function renderSegments(context, fRect) {\n            var _this = this;\n\n            var subparts = this._getSubparts(fRect.f);\n            if (!subparts.length) return;\n\n            var parentFeature = fRect.f;\n            var styleFunc = function styleFunc(feature, stylename) {\n                if (stylename === 'height') return _this._getFeatureHeight(fRect.viewInfo, feature);\n\n                return _this.getStyle(feature, stylename) || _this.getStyle(parentFeature, stylename);\n            };\n\n            for (var i = 0; i < subparts.length; ++i) {\n                this.renderSegment(context, fRect.viewInfo, subparts[i], fRect.t, fRect.rect.h, fRect.f, styleFunc);\n            }\n        },\n        renderSegment: function renderSegment(context, viewInfo, segmentFeature, topPx, heightPx, parentFeature, styleFunc) {\n            var _this2 = this;\n\n            this.renderBox(context, viewInfo, segmentFeature, topPx, heightPx, parentFeature, styleFunc);\n            // if we have sub-subparts (stop codons and the like), draw them as shaded boxes\n            var subsubParts = this._getSubSubparts(segmentFeature);\n            if (subsubParts.length) {\n                var subsubStyleFunc = function subsubStyleFunc(feature, stylename) {\n                    // use a subSubParts-specific style if one is configured\n                    var subsubSpecificStyle = styleFunc(feature, 'subSubPart_' + stylename);\n                    if (subsubSpecificStyle) return subsubSpecificStyle;\n\n                    // otherwise use the main style and darken it somewhat\n                    var style = styleFunc(feature, stylename);\n                    if (style && (stylename.includes('color') || stylename.includes('Color'))) {\n                        var originalColor = Color.fromString(style);\n                        if (originalColor) {\n                            style = String(Color.blendColors(originalColor, Color.fromArray([0, 0, 0, 1]), 0.25));\n                        }\n                    }\n\n                    return style;\n                };\n\n                subsubParts.forEach(function (subsubFeature) {\n                    _this2.renderBox(context, viewInfo, subsubFeature, topPx, heightPx, segmentFeature, subsubStyleFunc);\n                });\n            }\n        },\n        _getSubparts: function _getSubparts(feature) {\n            var children = feature.children() || [];\n            return children.filter(this._filterSubpart.bind(this));\n        },\n        _getSubSubparts: function _getSubSubparts(feature) {\n            var children = feature.children() || [];\n            return children.filter(this._filterSubSubpart.bind(this));\n        },\n        _filterSubpart: function _filterSubpart(feature) {\n            if (!this._subpartsFilter) this._subpartsFilter = this._makeSubpartsFilter('subParts');\n            return this._subpartsFilter(feature);\n        },\n        _filterSubSubpart: function _filterSubSubpart(feature) {\n            if (!this._subSubpartsFilter) this._subSubpartsFilter = this._makeSubpartsFilter('subSubParts');\n\n            return this._subSubpartsFilter(feature);\n        },\n\n\n        // make a function that will filter features features according to the\n        // subParts conf var\n        _makeSubpartsFilter: function _makeSubpartsFilter() {\n            var confKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'subParts';\n\n            var filter = this.getConf(confKey);\n\n            if (typeof filter == 'string')\n                // convert to array\n                filter = filter.split(/\\s*,\\s*/);\n\n            if (Array.isArray(filter)) {\n                var typeNames = filter.map(function (typeName) {\n                    return typeName.toLowerCase();\n                });\n                return function (feature) {\n                    return typeNames.includes(feature.get('type').toLowerCase());\n                };\n            } else if (typeof filter === 'function') {\n                return filter;\n            } else {\n                return function () {\n                    return true;\n                };\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/Segments.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/UCSC/BED.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/UCSC/BED.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Segments */ \"./src/JBrowse/View/FeatureGlyph/Segments.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, SegmentsGlyph) {\n\n    return declare(SegmentsGlyph, {\n\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(this.inherited(arguments), {\n                style: {\n                    connectorColor: '#333',\n                    connectorThickness: 1,\n                    borderColor: 'rgba( 0, 0, 0, 0.3 )'\n                },\n                itemRgb: true,\n                height: 11,\n                thinHeight: 5,\n                subParts: function subParts() {\n                    return false;\n                }, // UCSC BED-like features don't have formal subparts\n                subSubParts: function subSubParts() {\n                    return false;\n                } // UCSC BED-like features don't have formal subparts\n            });\n        },\n\n        parseItemRgb: function parseItemRgb(itemRgb) {\n            var stringEncoding = /(\\d+),(\\d+),(\\d+)/.exec(itemRgb);\n            var hex2 = function hex2(num) {\n                return num.toString(16).padStart(2, '0');\n            };\n            if (stringEncoding) {\n                var r = Number(stringEncoding[1]);\n                var g = Number(stringEncoding[2]);\n                var b = Number(stringEncoding[3]);\n                if (!isNaN(r) && !isNaN(g) && !isNaN(b) && (r || g || b)) return '#' + hex2(r) + hex2(g) + hex2(b);\n            } else {\n                var rgb = Number(itemRgb);\n                if (rgb) return '#' + rgb.toString(16).padStart(6, '0');\n            }\n        },\n        renderSegments: function renderSegments(context, fRect) {\n            var _this = this;\n\n            var styleFunc = function styleFunc(feature, stylename) {\n                if (stylename === 'height') return _this._getFeatureHeight(fRect.viewInfo, feature);else if (stylename === 'color' && _this.getConf('itemRgb', [feature, _this])) {\n                    var itemRgb = _this.parseItemRgb(feature.get('itemRgb') || feature.get('reserved'));\n                    if (itemRgb) return itemRgb;\n                }\n\n                return _this.getStyle(feature, stylename);\n            };\n\n            var thickStart = Number(fRect.f.get('thick_start'));\n            var thickEnd = Number(fRect.f.get('thick_end'));\n\n            var blockCount = Number(fRect.f.get('block_count'));\n\n            if (blockCount && fRect.f.get('end') - fRect.f.get('start') > 5) {\n                var sizes = fRect.f.get('block_sizes');\n                if (!Array.isArray(sizes)) sizes = sizes.split(',').map(function (str) {\n                    return Number(str);\n                });\n\n                var starts = fRect.f.get('chrom_starts');\n                if (!Array.isArray(starts)) starts = starts.split(',').map(function (str) {\n                    return Number(str);\n                });\n\n                var blocksOffset = fRect.f.get('start');\n\n                for (var b = 0; b < blockCount; b += 1) {\n                    var blockStart = (starts[b] | 0) + blocksOffset;\n                    var blockEnd = blockStart + (sizes[b] | 0);\n\n                    // render the sub-block, either as a rect, or as a stroked path\n                    this.renderSegment(context, fRect.viewInfo, blockStart, blockEnd, thickStart, thickEnd, fRect.t, fRect.rect.h, fRect.f, styleFunc);\n                }\n            } else {\n                // render the whole thing as a single block\n                this.renderSegment(context, fRect.viewInfo, fRect.f.get('start'), fRect.f.get('end'), thickStart, thickEnd, fRect.t, fRect.rect.h, fRect.f, styleFunc);\n            }\n        },\n        renderSegment: function renderSegment(context, viewInfo, start, end, thickStart, thickEnd, top, overallHeight, parentFeature, style) {\n            var left = viewInfo.block.bpToX(start);\n            var width = viewInfo.block.bpToX(end) - left;\n            var right = left + width;\n            var height = this._getFeatureHeight(viewInfo, parentFeature);\n            if (!height) return;\n            if (height !== overallHeight) top += Math.round((overallHeight - height) / 2);\n            var bottom = top + height;\n            var thickStartPx = viewInfo.block.bpToX(thickStart);\n            var thickEndPx = viewInfo.block.bpToX(thickEnd);\n\n            var widthClamped = Math.max(1, width);\n            var thinHeight = this.getConf('thinHeight', [parentFeature, this]);\n            var thinHeightDiff = (height - thinHeight) / 2;\n\n            var bgcolor = style(parentFeature, 'color');\n            var borderColor = style(parentFeature, 'borderColor');\n            var lineWidth = style(parentFeature, 'borderWidth');\n            var halfLineWidth = lineWidth / 2;\n\n            if (width > 3) {\n                var pathPoints = void 0;\n                var strokePoints = void 0;\n                if (thickStart <= start && thickEnd >= end) {\n                    // ===========\n                    pathPoints = [left, top, width, height];\n                    strokePoints = [left + halfLineWidth, top + halfLineWidth, width - lineWidth, height - lineWidth];\n                } else if (thickStart >= end || thickEnd <= start) {\n                    // -----------\n                    pathPoints = [left, top + thinHeightDiff, width, thinHeight];\n                    strokePoints = [left + halfLineWidth, top + halfLineWidth + thinHeightDiff, width - lineWidth, thinHeight - lineWidth];\n                } else if (thickStart <= start && thickEnd < end) {\n                    // ====-------\n                    pathPoints = [[left, top], [thickEndPx, top], [thickEndPx, top + thinHeightDiff], [right, top + thinHeightDiff], [right, bottom - thinHeightDiff], [thickEndPx, bottom - thinHeightDiff], [thickEndPx, bottom], [left, bottom]];\n                    strokePoints = [[left + halfLineWidth, top + halfLineWidth], [thickEndPx - halfLineWidth, top + halfLineWidth], [thickEndPx - halfLineWidth, top + thinHeightDiff + halfLineWidth], [right - halfLineWidth, top + thinHeightDiff + halfLineWidth], [right - halfLineWidth, bottom - thinHeightDiff - halfLineWidth], [thickEndPx - halfLineWidth, bottom - thinHeightDiff - halfLineWidth], [thickEndPx - halfLineWidth, bottom - halfLineWidth], [left + halfLineWidth, bottom - halfLineWidth]];\n                } else if (thickStart > start && thickEnd >= end) {\n                    // -----======\n                    pathPoints = [[left, top + thinHeightDiff], [thickStartPx, top + thinHeightDiff], [thickStartPx, top], [right, top], [right, bottom], [thickStartPx, bottom], [thickStartPx, bottom - thinHeightDiff], [left, bottom - thinHeightDiff]];\n                    strokePoints = [[left + halfLineWidth, top + thinHeightDiff + halfLineWidth], [thickStartPx + halfLineWidth, top + thinHeightDiff + halfLineWidth], [thickStartPx + halfLineWidth, top + halfLineWidth], [right - halfLineWidth, top + halfLineWidth], [right - halfLineWidth, bottom - halfLineWidth], [thickStartPx + halfLineWidth, bottom - halfLineWidth], [thickStartPx + halfLineWidth, bottom - thinHeightDiff - halfLineWidth], [left + halfLineWidth, bottom - thinHeightDiff - halfLineWidth]];\n                } else if (thickStart > start && thickEnd < end) {\n                    // ----====---\n                    pathPoints = [[left, top + thinHeightDiff], [thickStartPx, top + thinHeightDiff], [thickStartPx, top], [thickEndPx, top], [thickEndPx, top + thinHeightDiff], [right, top + thinHeightDiff], [right, bottom - thinHeightDiff], [thickEndPx, bottom - thinHeightDiff], [thickEndPx, bottom], [thickStartPx, bottom], [thickStartPx, bottom - thinHeightDiff], [left, bottom - thinHeightDiff]];\n                    strokePoints = [[left + halfLineWidth, top + thinHeightDiff + halfLineWidth], [thickStartPx + halfLineWidth, top + thinHeightDiff + halfLineWidth], [thickStartPx + halfLineWidth, top + halfLineWidth], [thickEndPx - halfLineWidth, top + halfLineWidth], [thickEndPx - halfLineWidth, top + thinHeightDiff + halfLineWidth], [right - halfLineWidth, top + thinHeightDiff + halfLineWidth], [right - halfLineWidth, bottom - thinHeightDiff - halfLineWidth], [thickEndPx - halfLineWidth, bottom - thinHeightDiff - halfLineWidth], [thickEndPx - halfLineWidth, bottom - halfLineWidth], [thickStartPx + halfLineWidth, bottom - halfLineWidth], [thickStartPx + halfLineWidth, bottom - thinHeightDiff - halfLineWidth], [left + halfLineWidth, bottom - thinHeightDiff - halfLineWidth]];\n                }\n\n                // background\n                if (bgcolor) {\n                    context.fillStyle = bgcolor;\n                    if (pathPoints[0].length) {\n                        context.beginPath();\n                        context.moveTo.apply(context, _toConsumableArray(pathPoints[0]));\n                        for (var i = 1; i < pathPoints.length; i += 1) {\n                            context.lineTo.apply(context, _toConsumableArray(pathPoints[i]));\n                        }\n                        context.fill();\n                    } else {\n                        context.fillRect.apply(context, _toConsumableArray(pathPoints));\n                    }\n                }\n\n                // foreground border\n                if (borderColor && lineWidth) {\n                    context.lineWidth = lineWidth;\n                    context.strokeStyle = borderColor;\n\n                    // need to stroke a smaller path to remain within\n                    // the bounds of the feature's overall height and\n                    // width, because of the way stroking is done in\n                    // canvas.  thus the +0.5 and -1 business.\n                    //context.strokeRect( left + lineWidth / 2, top + lineWidth / 2, width - lineWidth, height - lineWidth );\n                    if (strokePoints[0].length) {\n                        context.beginPath();\n                        context.moveTo.apply(context, _toConsumableArray(strokePoints[0]));\n                        for (var _i = 1; _i < strokePoints.length; _i += 1) {\n                            context.lineTo.apply(context, _toConsumableArray(strokePoints[_i]));\n                        }\n                        context.stroke();\n                    } else {\n                        context.strokeRect.apply(context, _toConsumableArray(strokePoints));\n                    }\n                }\n            } else {\n                // for very tiny features, just draw them as rectangles of blurry height, and shade them\n                context.globalAlpha = 1;\n                context.fillStyle = bgcolor;\n                if (thickStart <= start && thickEnd >= end) {\n                    context.fillRect(left, top, widthClamped, height);\n                    context.globalAlpha = lineWidth * 2 / width;\n                    context.fillStyle = borderColor;\n                    context.fillRect(left, top, widthClamped, height);\n                    context.globalAlpha = 1;\n                } else {\n                    context.fillRect(left, top + thinHeightDiff, widthClamped, thinHeight);\n                    context.globalAlpha = lineWidth * 2 / width;\n                    context.fillStyle = borderColor;\n                    context.fillRect(left, top + thinHeightDiff, widthClamped, thinHeight);\n                    context.globalAlpha = 1;\n                }\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/UCSC/BED.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js":
/*!****************************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/View/FeatureGlyph/Segments */ \"./src/JBrowse/View/FeatureGlyph/Segments.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Segments) {\n\n    return declare(Segments, {\n        _defaultConfig: function _defaultConfig() {\n            return this._mergeConfigs(this.inherited(arguments), {\n                style: {\n                    unprocessedTranscriptColor: 'red'\n                }\n            });\n        },\n        renderBox: function renderBox(context, viewInfo, feature, top, overallHeight, parentFeature, style) {\n            style = style || lang.hitch(this, 'getStyle');\n            return this.inherited(arguments, [context, viewInfo, feature, top, overallHeight, parentFeature, function (feat, attr) {\n                if (attr == 'color') return style(parentFeature, 'unprocessedTranscriptColor');\n                return style(feat, attr);\n            }]);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/UnprocessedTranscript.js?");

/***/ }),

/***/ "./src/JBrowse/View/FeatureGlyph/_FeatureLabelMixin.js":
/*!*************************************************************!*\
  !*** ./src/JBrowse/View/FeatureGlyph/_FeatureLabelMixin.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/View/_FeatureDescriptionMixin */ \"./src/JBrowse/View/_FeatureDescriptionMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, FeatureDescriptionMixin) {\n    var fontMeasurementsCache = {};\n\n    return declare(FeatureDescriptionMixin, {\n\n        /**\n         * Estimate the height and width, in pixels, of the given\n         * feature's label text, and trim it if necessary to fit within\n         * the track's maxFeatureGlyphExpansion limit.\n         */\n        makeFeatureLabel: function makeFeatureLabel(feature, fRect, text) {\n            var text = text || this.getFeatureLabel(feature);\n            if (!text) return null;\n            text = '' + text;\n            var font = this.getStyle(feature, 'textFont');\n            var l = fRect ? this.makeBottomOrTopLabel(text, font, fRect) : this.makePopupLabel(text, font);\n            l.fill = this.getStyle(feature, 'textColor');\n            return l;\n        },\n\n        /**\n         * Estimate the height and width, in pixels, of the given\n         * feature's description text, and trim it if necessary to fit\n         * within the track's maxFeatureGlyphExpansion limit.\n         */\n        makeFeatureDescriptionLabel: function makeFeatureDescriptionLabel(feature, fRect, text) {\n            var text = text || this.getFeatureDescription(feature);\n            if (!text) return null;\n            text = '' + text;\n            var font = this.getStyle(feature, 'text2Font');\n            var l = fRect ? this.makeBottomOrTopLabel(text, font, fRect) : this.makePopupLabel(text, font);\n            l.fill = this.getStyle(feature, 'text2Color');\n            return l;\n        },\n\n        /**\n         * Makes a label that sits on the left or right side of a feature,\n         * respecting maxFeatureGlyphExpansion.\n         */\n        makeSideLabel: function makeSideLabel(text, font, fRect) {\n            if (!text) return null;\n\n            var dims = this.measureFont(font);\n            var excessCharacters = Math.round((text.length * dims.w - this.track.getConf('maxFeatureGlyphExpansion')) / dims.w);\n            if (excessCharacters > 0) text = text.slice(0, text.length - excessCharacters - 1) + '…';\n\n            return {\n                text: text,\n                font: font,\n                baseline: 'middle',\n                w: dims.w * text.length,\n                h: dims.h\n            };\n        },\n\n        /**\n         * Makes a label that lays across the bottom edge of a feature,\n         * respecting maxFeatureGlyphExpansion.\n         */\n        makeBottomOrTopLabel: function makeBottomOrTopLabel(text, font, fRect) {\n            if (!text) return null;\n\n            var dims = this.measureFont(font);\n            var excessCharacters = Math.round((text.length * dims.w - fRect.w - this.track.getConf('maxFeatureGlyphExpansion')) / dims.w);\n            if (excessCharacters > 0) text = text.slice(0, text.length - excessCharacters - 1) + '…';\n\n            return {\n                text: text,\n                font: font,\n                baseline: 'bottom',\n                w: dims.w * text.length,\n                h: dims.h\n            };\n        },\n\n        /**\n         * Makes a label that can be put in a popup or tooltip,\n         * not respecting maxFeatureGlyphExpansion or the width of the fRect.\n         */\n        makePopupLabel: function makePopupLabel(text, font) {\n            if (!text) return null;\n            var dims = this.measureFont(font);\n            return {\n                text: text,\n                font: font,\n                w: dims.w * text.length,\n                h: dims.h\n            };\n        },\n\n        /**\n         * Return an object with average `h` and `w` of characters in the\n         * font described by the given string.\n         */\n        measureFont: function measureFont(font) {\n            return fontMeasurementsCache[font] || (fontMeasurementsCache[font] = function () {\n                var ctx = document.createElement('canvas').getContext('2d');\n                ctx.font = font;\n                var testString = \"MMMMMMMMMMMMXXXXXXXXXX1234567890-.CGCC12345\";\n                var m = ctx.measureText(testString);\n                return {\n                    h: m.height || parseInt(font.match(/(\\d+)px/)[1]),\n                    w: m.width / testString.length\n                };\n            }.call(this));\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FeatureGlyph/_FeatureLabelMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog.js":
/*!****************************************!*\
  !*** ./src/JBrowse/View/FileDialog.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dijit/form/RadioButton */ \"./node_modules/dijit/form/RadioButton.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dojox/form/Uploader */ \"./node_modules/dojox/form/Uploader.js\"), __webpack_require__(/*! ./FileDialog/TrackList/BAMDriver */ \"./src/JBrowse/View/FileDialog/TrackList/BAMDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/CRAMDriver */ \"./src/JBrowse/View/FileDialog/TrackList/CRAMDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/BigWigDriver */ \"./src/JBrowse/View/FileDialog/TrackList/BigWigDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/GFF3Driver */ \"./src/JBrowse/View/FileDialog/TrackList/GFF3Driver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/GTFDriver */ \"./src/JBrowse/View/FileDialog/TrackList/GTFDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/VCFTabixDriver */ \"./src/JBrowse/View/FileDialog/TrackList/VCFTabixDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/VCFTribbleDriver */ \"./src/JBrowse/View/FileDialog/TrackList/VCFTribbleDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/BEDTabixDriver */ \"./src/JBrowse/View/FileDialog/TrackList/BEDTabixDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/GFF3TabixDriver */ \"./src/JBrowse/View/FileDialog/TrackList/GFF3TabixDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/BEDDriver */ \"./src/JBrowse/View/FileDialog/TrackList/BEDDriver.js\"), __webpack_require__(/*! ./FileDialog/TrackList/BigBedDriver */ \"./src/JBrowse/View/FileDialog/TrackList/BigBedDriver.js\"), __webpack_require__(/*! ./FileDialog/ResourceList */ \"./src/JBrowse/View/FileDialog/ResourceList.js\"), __webpack_require__(/*! ./FileDialog/TrackList */ \"./src/JBrowse/View/FileDialog/TrackList.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, aspect, on, dijitFocus, Button, RadioButton, dom, Dialog, Uploaded, BAMDriver, CRAMDriver, BigWigDriver, GFF3Driver, GTFDriver, VCFTabixDriver, VCFTribbleDriver, BEDTabixDriver, GFF3TabixDriver, BEDDriver, BigBedDriver, ResourceList, TrackList, Util) {\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.config = dojo.clone(args.config || {});\n            this.browserSupports = {\n                dnd: 'draggable' in document.createElement('span')\n            };\n\n            this._fileTypeDrivers = [new BAMDriver(), new CRAMDriver(), new BigWigDriver(), new GFF3Driver(), new GTFDriver(), new VCFTabixDriver(), new VCFTribbleDriver(), new BEDTabixDriver(), new GFF3TabixDriver(), new BEDDriver(), new BigBedDriver()];\n        },\n\n        addFileTypeDriver: function addFileTypeDriver(d) {\n            this._fileTypeDrivers.unshift(d);\n        },\n        getFileTypeDrivers: function getFileTypeDrivers() {\n            return this._fileTypeDrivers.slice();\n        },\n\n        _makeActionBar: function _makeActionBar(openCallback, cancelCallback) {\n            var actionBar = dom.create('div', {\n                className: 'dijitDialogPaneActionBar'\n            });\n\n            var disChoices = this.trackDispositionChoice = [new RadioButton({ id: 'openImmediately',\n                value: 'openImmediately',\n                checked: true\n            }), new RadioButton({ id: 'addToTrackList',\n                value: 'addToTrackList'\n            })];\n\n            var aux = dom.create('div', { className: 'aux' }, actionBar);\n            disChoices[0].placeAt(aux);\n            dom.create('label', { \"for\": 'openImmediately', innerHTML: 'Open immediately' }, aux), disChoices[1].placeAt(aux);\n            dom.create('label', { \"for\": 'addToTrackList', innerHTML: 'Add to tracks' }, aux);\n\n            new Button({ iconClass: 'dijitIconDelete', label: 'Cancel',\n                onClick: dojo.hitch(this, function () {\n                    cancelCallback && cancelCallback();\n                    this.dialog.hide();\n                })\n            }).placeAt(actionBar);\n            new Button({ iconClass: 'dijitIconFolderOpen',\n                label: 'Open',\n                onClick: dojo.hitch(this, function () {\n                    openCallback && openCallback({\n                        trackConfs: this.trackList.getTrackConfigurations(),\n                        trackDisposition: this.trackDispositionChoice[0].checked ? this.trackDispositionChoice[0].value : this.trackDispositionChoice[1].checked ? this.trackDispositionChoice[1].value : undefined\n                    });\n                    this.dialog.hide();\n                })\n            }).placeAt(actionBar);\n\n            return { domNode: actionBar };\n        },\n\n        show: function show(args) {\n            var dialog = this.dialog = new Dialog({ title: \"Open files\", className: 'fileDialog' });\n\n            var localFilesControl = this._makeLocalFilesControl();\n            var remoteURLsControl = this._makeRemoteURLsControl();\n            var resourceListControl = this._makeResourceListControl();\n            var trackListControl = this._makeTrackListControl();\n            var actionBar = this._makeActionBar(args.openCallback, args.cancelCallback);\n\n            // connect the local files control to the resource list\n            dojo.connect(localFilesControl.uploader, 'onChange', function () {\n                if (Util.isElectron()) {\n                    var arr = [].concat(_toConsumableArray(localFilesControl.uploader._files)).map(function (file) {\n                        return Util.replacePath(file.path);\n                    });\n                    resourceListControl.addURLs(arr);\n                } else {\n                    resourceListControl.addLocalFiles(localFilesControl.uploader._files);\n                }\n            });\n\n            // connect the remote URLs control to the resource list\n            dojo.connect(remoteURLsControl, 'onChange', function (urls) {\n                resourceListControl.clearURLs();\n                resourceListControl.addURLs(urls);\n            });\n\n            // connect the resource list to the track list\n            dojo.connect(resourceListControl, 'onChange', function (resources) {\n                trackListControl.update(resources);\n            });\n\n            var div = function div(attr, children) {\n                var d = dom.create('div', attr);\n                array.forEach(children, dojo.hitch(d, 'appendChild'));\n                return d;\n            };\n            var content = [dom.create('div', { className: 'intro', innerHTML: args.introMsg || 'Add any combination of data files and URLs, and JBrowse will automatically suggest tracks to display their contents.' }), div({ className: 'resourceControls' }, [localFilesControl.domNode, remoteURLsControl.domNode]), resourceListControl.domNode, trackListControl.domNode, actionBar.domNode];\n            dialog.set('content', content);\n            dialog.show();\n\n            aspect.after(dialog, 'hide', dojo.hitch(this, function () {\n                dijitFocus.curNode && dijitFocus.curNode.blur();\n                setTimeout(function () {\n                    dialog.destroyRecursive();\n                }, 500);\n            }));\n        },\n\n        _makeLocalFilesControl: function _makeLocalFilesControl() {\n            var container = dom.create('div', { className: 'localFilesControl' });\n\n            dom.create('h3', { innerHTML: 'Local files' }, container);\n\n            var dragArea = dom.create('div', { className: 'dragArea' }, container);\n            var fileBox;\n\n            fileBox = new dojox.form.Uploader({\n                multiple: true\n            });\n            fileBox.placeAt(dragArea);\n            if (this.browserSupports.dnd) {\n                // let the uploader process any files dragged into the dialog\n                fileBox.addDropTarget(this.dialog.domNode);\n\n                // add a message saying you can drag files in\n                dom.create('div', {\n                    className: 'dragMessage',\n                    innerHTML: 'Select or drag files here.'\n                }, dragArea);\n            }\n\n            // little elements used to show pipeline-like connections between the controls\n            dom.create('div', { className: 'connector', innerHTML: '&nbsp;' }, container);\n\n            return { domNode: container, uploader: fileBox };\n        },\n\n        _makeRemoteURLsControl: function _makeRemoteURLsControl() {\n            var container = dom.create('div', { className: 'remoteURLsControl' });\n\n            // make the input elements\n            dom.create('h3', { innerHTML: 'Remote URLs - <smaller>one per line</smaller>' }, container);\n\n            // the onChange here will be connected to by the other parts\n            // of the dialog to propagate changes to the text in the box\n            var self = { domNode: container,\n                onChange: function onChange(urls) {\n                    //console.log('urls changed');\n                }\n            };\n            self.input = dom.create('textarea', {\n                className: 'urlInput',\n                placeHolder: \"http://paste.urls.here/example.bam\",\n                cols: 25,\n                rows: 5,\n                spellcheck: false\n            }, container);\n\n            // set up the handlers to propagate changes\n            var realChange = function realChange() {\n                var text = dojo.trim(self.input.value);\n                var urls = text.length ? text.split(/\\s+/) : [];\n                self.onChange(urls);\n            };\n            // watch the input text for changes.  just do it every 900ms\n            // because there are many ways that text can get changed (like\n            // pasting), not all of which fire the same events.  not using\n            // the onchange event, because that doesn't fire until the\n            // textarea loses focus.\n            var previousText = '';\n            var checkFrequency = 900;\n            var checkForChange = function checkForChange() {\n                // compare with all whitespace changed to commas so that\n                // we are insensitive to changes in whitespace\n                if (self.input.value.replace(/\\s+/g, ',') != previousText) {\n                    realChange();\n                    previousText = self.input.value.replace(/\\s+/g, ',');\n                }\n                window.setTimeout(checkForChange, checkFrequency);\n            };\n            window.setTimeout(checkForChange, checkFrequency);\n\n            // little elements used to show pipeline-like connections between the controls\n            dom.create('div', { className: 'connector', innerHTML: '&nbsp;' }, container);\n\n            return self;\n        },\n\n        _makeResourceListControl: function _makeResourceListControl() {\n            var rl = new ResourceList({ dialog: this });\n            return rl;\n        },\n        _makeTrackListControl: function _makeTrackListControl() {\n            var tl = new TrackList({ browser: this.browser, fileDialog: this });\n            this.trackList = tl;\n            return tl;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/ResourceList.js":
/*!*****************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/ResourceList.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/form/Select */ \"./node_modules/dijit/form/Select.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dom, Select) {\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            this.dialog = args.dialog;\n            this.domNode = dom.create('div', { className: 'resourceList' });\n            this._updateView();\n        },\n\n        clearLocalFiles: function clearLocalFiles() {\n            this._resources = array.filter(this._resources || [], function (res) {\n                return !res.file;\n            });\n            this._notifyChange();\n        },\n\n        _notifyChange: function _notifyChange() {\n            this.onChange(array.map(this._resources || [], function (res) {\n                var r = {};\n                if (res.file) r.file = res.file;\n                if (res.url) r.url = res.url;\n                r.type = res.type.get('value');\n                return r;\n            }));\n        },\n\n        _addResources: function _addResources(resources) {\n            var seenFile = {};\n            var allRes = (this._resources || []).concat(resources);\n            this._resources = array.filter(allRes.reverse(), function (res) {\n                var key = res.file && res.file.name || res.url;\n                if (seenFile[key]) {\n                    return false;\n                }\n                seenFile[key] = true;\n                return true;\n            }).reverse();\n\n            this._updateView();\n            this._notifyChange();\n        },\n\n        addLocalFiles: function addLocalFiles(fileList) {\n            this._addResources(array.map(fileList, function (file) {\n                return { file: file };\n            }));\n        },\n\n        clearURLs: function clearURLs() {\n            this._resources = array.filter(this._resources || [], function (res) {\n                return !res.url;\n            });\n            this._notifyChange();\n        },\n        addURLs: function addURLs(urls) {\n            this._addResources(array.map(urls, function (u) {\n                return { url: u };\n            }));\n        },\n\n        // old-style handler stub\n        onChange: function onChange() {},\n\n        _updateView: function _updateView() {\n            var container = this.domNode;\n            dom.empty(container);\n\n            dom.create('h3', { innerHTML: 'Files and URLs' }, container);\n\n            if ((this._resources || []).length) {\n                var table = dom.create('table', {}, container);\n\n                // render rows in the resource table for each resource in our\n                // list\n                array.forEach(this._resources, function (res, i) {\n                    var that = this;\n                    var tr = dom.create('tr', {}, table);\n                    var name = res.url || res.file.name;\n\n                    // make a selector for the resource's type\n                    var typeSelect = new Select({\n                        options: [{ label: '<span class=\"ghosted\">file type?</span>', value: null }, { label: \"GFF3\", value: \"gff3\" }, { label: \"GTF\", value: \"gtf\" }, { label: \"BigWig\", value: \"bigwig\" }, { label: \"BAM\", value: \"bam\" }, { label: \"BAM index\", value: \"bam.bai\" }, { label: \"FASTA\", value: \"fasta\" }, { label: \"FASTA index\", value: \"fai\" }, { label: \"BGZIP FASTA\", value: \"fasta.gz\" }, { label: \"BGZIP FASTA index (.gz.fai)\", value: \"fasta.gz.fai\" }, { label: \"BGZIP index (.gz.gzi)\", value: \"gzi\" }, { label: \"2bit\", value: \"2bit\" }, { label: \"BigBed\", value: \"bb\" }, { label: \"VCF+bgzip\", value: \"vcf.gz\" }, { label: \"VCF\", value: \"vcf\" }, { label: \"IGV/GATK Index\", value: \"idx\" }, { label: \"BED+bgzip\", value: \"bed.gz\" }, { label: \"BED\", value: \"bed\" }, { label: \"GFF3+bgzip\", value: \"gff3.gz\" }, { label: \"VCF+Tabix index\", value: \"vcf.gz.tbi\" }, { label: \"GFF3+Tabix index\", value: \"gff3.gz.tbi\" }, { label: \"BED+Tabix index\", value: \"bed.gz.tbi\" }, { label: \"BED+CSI index\", value: \"bed.gz.csi\" }, { label: \"VCF+CSI index\", value: \"vcf.gz.csi\" }, { label: \"GFF3+CSI index\", value: \"gff3.gz.csi\" }, { label: \"BAM+CSI index\", value: \"bam.csi\" }, { label: \"CRAM\", value: \"cram\" }, { label: \"CRAM index\", value: \"cram.crai\" }, { label: \"Chrom sizes\", value: \"chrom.sizes\" }],\n                        value: this.guessType(name),\n                        onChange: function onChange() {\n                            that._rememberedTypes = that._rememberedTypes || {};\n                            that._rememberedTypes[name] = this.get('value');\n                            that._notifyChange();\n                        }\n                    });\n                    typeSelect.placeAt(dojo.create('td', { width: '4%' }, tr));\n                    res.type = typeSelect;\n\n                    dojo.create('td', {\n                        width: '1%',\n                        innerHTML: '<div class=\"' + (res.file ? 'dijitIconFile' : 'jbrowseIconLink') + '\"></div>'\n                    }, tr);\n                    dojo.create('td', { innerHTML: name }, tr);\n                    dojo.create('td', {\n                        width: '1%',\n                        innerHTML: '<div class=\"dijitIconDelete\"></div>',\n                        onclick: function onclick(e) {\n                            e.preventDefault && e.preventDefault();\n                            that.deleteResource(res);\n                        }\n                    }, tr);\n                }, this);\n            } else {\n                dom.create('div', { className: 'emptyMessage',\n                    innerHTML: 'Add files and URLs using the controls above.'\n                }, container);\n            }\n\n            // little elements used to show pipeline-like connections between the controls\n            dom.create('div', { className: 'connector', innerHTML: '&nbsp;' }, container);\n        },\n\n        deleteResource: function deleteResource(resource) {\n            this._resources = array.filter(this._resources || [], function (res) {\n                return res !== resource;\n            });\n            this._updateView();\n            this._notifyChange();\n        },\n\n        guessType: function guessType(name) {\n            return (this._rememberedTypes || {})[name] || (/\\.bam$/i.test(name) ? 'bam' : /\\.bai$/i.test(name) ? 'bam.bai' : /\\.gff3?$/i.test(name) ? 'gff3' : /\\.gtf?$/i.test(name) ? 'gtf' : /\\.(bw|bigwig)$/i.test(name) ? 'bigwig' : /\\.(fa|fasta|fna|mfa)$/i.test(name) ? 'fasta' : /\\.(fa|fasta|fna|mfa)\\.gz$/i.test(name) ? 'fasta.gz' : /\\.(fa|fasta|fna|mfa)\\.gz\\.fai$/i.test(name) ? 'fasta.gz.fai' : /\\.2bit$/i.test(name) ? '2bit' : /\\.fai$/i.test(name) ? 'fai' : /\\.idx$/i.test(name) ? 'idx' : /\\.vcf$/i.test(name) ? 'vcf' : /\\.vcf\\.gz$/i.test(name) ? 'vcf.gz' : /\\.bed\\.gz$/i.test(name) ? 'bed.gz' : /\\.gzi$/i.test(name) ? 'gzi' : /\\.gff3?\\.gz$/i.test(name) ? 'gff3.gz' : /\\.bed$/i.test(name) ? 'bed' : /\\.(bb|bigbed)$/i.test(name) ? 'bb' : /\\.gff3?\\.gz.tbi$/i.test(name) ? 'gff3.gz.tbi' : /\\.vcf.gz.tbi$/i.test(name) ? 'vcf.gz.tbi' : /\\.bed.gz.tbi$/i.test(name) ? 'bed.gz.tbi' : /\\.bed.gz.csi/i.test(name) ? 'bed.gz.csi' : /\\.gff3?\\.gz.csi$/i.test(name) ? 'gff3.gz.csi' : /\\.vcf.gz.csi$/i.test(name) ? 'vcf.gz.csi' : /\\.bam.csi$/i.test(name) ? 'bam.csi' : /\\.cram$/i.test(name) ? 'cram' : /\\.crai$/i.test(name) ? 'cram.crai' : /\\.sizes$/i.test(name) ? 'chrom.sizes' : null);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/ResourceList.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! dijit/form/Select */ \"./node_modules/dijit/form/Select.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/View/TrackConfigEditor */ \"./src/JBrowse/View/TrackConfigEditor.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dom, Util, TextBox, Select, Button, TrackConfigEditor) {\n\n    var uniqCounter = 0;\n\n    return declare(null, {\n\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.fileDialog = args.fileDialog;\n            this.domNode = dom.create('div', { className: 'trackList', innerHTML: 'track list!' });\n\n            this._updateDisplay();\n        },\n\n        getTrackConfigurations: function getTrackConfigurations() {\n            return Util.dojof.values(this.trackConfs || {});\n        },\n\n        update: function update(resources) {\n            this.storeConfs = {};\n            this.trackConfs = {};\n\n            this._makeStoreConfs(resources);\n\n            // make some track configurations from the store configurations\n            this._makeTrackConfs();\n\n            this._updateDisplay();\n        },\n\n        _makeStoreConfs: function _makeStoreConfs(resources) {\n            // when called, rebuild the store and track configurations that we are going to add\n            this.storeConfs = this.storeConfs || {};\n\n            var typeDrivers = this.fileDialog.getFileTypeDrivers();\n\n            // anneal the given resources into a set of data store\n            // configurations by offering each file to each type driver in\n            // turn until no more are being accepted\n            var lastLength = 0;\n            while (resources.length && resources.length != lastLength) {\n                resources = array.filter(resources, function (resource) {\n                    return !array.some(typeDrivers, function (typeDriver) {\n                        return typeDriver.tryResource(this.storeConfs, resource);\n                    }, this);\n                }, this);\n\n                lastLength = resources.length;\n            }\n\n            array.forEach(typeDrivers, function (typeDriver) {\n                typeDriver.finalizeConfiguration(this.storeConfs);\n            }, this);\n\n            if (resources.length) console.warn(\"Not all resources could be assigned to tracks.  Unused resources:\", resources);\n        },\n\n        _makeTrackConfs: function _makeTrackConfs() {\n            // object that maps store type -> default track type to use for the store\n            var typeMap = this.browser.getTrackTypes().trackTypeDefaults;\n\n            // find any store configurations that appear to be coverage stores\n            var coverageStores = {};\n            for (var n in this.storeConfs) {\n                if (this.storeConfs[n].fileBasename) {\n                    var baseBase = this.storeConfs[n].fileBasename.replace(/\\.(coverage|density|histograms?)$/, '');\n                    if (baseBase != this.storeConfs[n].fileBasename) {\n                        coverageStores[baseBase] = { store: this.storeConfs[n], name: n, used: false };\n                    }\n                }\n            }\n\n            // make track configurations for each store configuration\n            for (var n in this.storeConfs) {\n                var store = this.storeConfs[n];\n                var trackType = typeMap[store.type] || 'JBrowse/View/Track/CanvasFeatures';\n\n                this.trackConfs = this.trackConfs || {};\n\n                this.trackConfs[n] = {\n                    store: this.storeConfs[n],\n                    label: n,\n                    key: n.replace(/_\\d+$/, '').replace(/_/g, ' '),\n                    type: trackType,\n                    category: \"Local tracks\",\n                    autoscale: \"local\" // make locally-opened BigWig tracks default to local autoscaling\n                };\n\n                // if we appear to have a coverage store for this one, use it\n                // and mark it to have its track removed after all the tracks are made\n                var cov = coverageStores[store.fileBasename];\n                if (cov) {\n                    this.trackConfs[n].histograms = {\n                        store: cov.store,\n                        description: cov.store.fileBasename\n                    };\n                    cov.used = true;\n                }\n            }\n\n            // delete the separate track confs for any of the stores that were\n            // incorporated into other tracks as histograms\n            for (var n in coverageStores) {\n                if (coverageStores[n].used) delete this.trackConfs[coverageStores[n].name];\n            }\n        },\n\n        _delete: function _delete(trackname) {\n            delete (this.trackConfs || {})[trackname];\n            this._updateDisplay();\n        },\n\n        _updateDisplay: function _updateDisplay() {\n            var that = this;\n\n            // clear it\n            dom.empty(this.domNode);\n\n            dom.create('h3', { innerHTML: 'New Tracks' }, this.domNode);\n\n            if (!Util.dojof.keys(this.trackConfs || {}).length) {\n                dom.create('div', { className: 'emptyMessage',\n                    innerHTML: 'None'\n                }, this.domNode);\n            } else {\n                var table = dom.create('table', { innerHTML: '<tr class=\"head\"><th>Name</th><th>Display</th><th></th></tr>' }, this.domNode);\n\n                var trackTypes = this.browser.getTrackTypes();\n\n                Object.entries(this.trackConfs).forEach(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                        n = _ref2[0],\n                        t = _ref2[1];\n\n                    var r = dom.create('tr', {}, table);\n                    new TextBox({\n                        value: t.key,\n                        onChange: function onChange() {\n                            t.key = this.get('value');\n                        }\n                    }).placeAt(dom.create('td', { className: 'name' }, r));\n                    new Select({\n                        options: array.map(trackTypes.knownTrackTypes, function (t) {\n                            var l = trackTypes.trackTypeLabels[t] || t.replace('JBrowse/View/Track/', '').replace(/\\//g, ' ');\n                            return { label: l, value: t };\n                        }),\n                        value: t.type,\n                        onChange: function onChange() {\n                            t.type = this.get('value');\n                        }\n                    }).placeAt(dom.create('td', { className: 'type' }, r));\n\n                    new Button({\n                        className: 'edit',\n                        title: 'edit configuration',\n                        innerHTML: 'Edit Configuration',\n                        onClick: function onClick() {\n                            new TrackConfigEditor(t).show(function (result) {\n                                dojo.mixin(t, result.conf);\n                                that._updateDisplay();\n                            });\n                        }\n                    }).placeAt(dom.create('td', { className: 'edit' }, r));\n\n                    dojo.create('td', {\n                        width: '1%',\n                        innerHTML: '<div class=\"dijitIconDelete\"></div>',\n                        onclick: function onclick(e) {\n                            e.preventDefault && e.preventDefault();\n                            that._delete(n);\n                        }\n                    }, r);\n\n                    dom.create('td', { className: 'type' }, r);\n                });\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/BEDDriver.js":
/*!************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/BEDDriver.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        storeType: 'JBrowse/Store/SeqFeature/BED',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == 'bed') {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', ['.bed']);\n                if (!basename) return false;\n\n                var newName = 'BED_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    fileBasename: basename,\n                    blob: this._makeBlob(resource),\n                    name: newName\n                };\n                return true;\n            } else return false;\n        },\n\n        finalizeConfiguration: function finalizeConfiguration(configs) {},\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf.blob || conf.urlTemplate;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/BEDDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/BEDTabixDriver.js":
/*!*****************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/BEDTabixDriver.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! ./_IndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, IndexedFileDriver) {\n\n    return declare(IndexedFileDriver, {\n        name: 'BED+Tabix',\n        storeType: 'JBrowse/Store/SeqFeature/BEDTabix',\n\n        fileExtension: 'bed.gz',\n        fileConfKey: 'file',\n        fileUrlConfKey: 'urlTemplate',\n\n        indexExtension: 'bed.gz.tbi',\n        indexConfKey: 'tbi',\n        indexUrlConfKey: 'tbiUrlTemplate'\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/BEDTabixDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/BigBedDriver.js":
/*!***************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/BigBedDriver.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        storeType: 'JBrowse/Store/SeqFeature/BigBed',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == 'bb') {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', ['.bb']);\n                if (!basename) return false;\n\n                var newName = 'BigBed_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    fileBasename: basename,\n                    blob: this._makeBlob(resource),\n                    name: newName\n                };\n                return true;\n            } else return false;\n        },\n\n        finalizeConfiguration: function finalizeConfiguration(configs) {},\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf.blob || conf.urlTemplate;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/BigBedDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/BigWigDriver.js":
/*!***************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/BigWigDriver.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        storeType: 'JBrowse/Store/SeqFeature/BigWig',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == 'bigwig') {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', ['.bw', '.bigwig']);\n                if (!basename) return false;\n\n                var newName = 'BigWig_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    fileBasename: basename,\n                    type: this.storeType,\n                    blob: this._makeBlob(resource),\n                    name: newName\n                };\n                return true;\n            } else return false;\n        },\n\n        // try to merge any singleton BAM and BAI stores.  currently can only do this if there is one of each\n        finalizeConfiguration: function finalizeConfiguration(configs) {},\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf.blob || conf.urlTemplate;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/BigWigDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/CRAMDriver.js":
/*!*************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/CRAMDriver.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! ./_IndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, IndexedFileDriver) {\n\n    return declare(IndexedFileDriver, {\n        name: 'CRAM',\n        storeType: 'JBrowse/Store/SeqFeature/CRAM',\n\n        fileExtension: 'cram',\n        fileConfKey: 'cram',\n        fileUrlConfKey: 'urlTemplate',\n\n        indexExtension: 'cram.crai',\n        indexConfKey: 'crai',\n        indexUrlConfKey: 'craiUrlTemplate'\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/CRAMDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/ChromSizesDriver.js":
/*!*******************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/ChromSizesDriver.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        storeType: 'JBrowse/Store/SeqFeature/ChromSizes',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == 'chrom.sizes') {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', ['.sizes']);\n                if (!basename) return false;\n\n                var newName = 'REF_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    fileBasename: basename,\n                    blob: this._makeBlob(resource),\n                    name: newName\n                };\n                return true;\n            } else return false;\n        },\n\n        finalizeConfiguration: function finalizeConfiguration(configs) {},\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf.blob || conf.urlTemplate;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/ChromSizesDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/GFF3Driver.js":
/*!*************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/GFF3Driver.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        storeType: 'JBrowse/Store/SeqFeature/GFF3',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == 'gff3') {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', ['.gff3', '.gff']);\n                if (!basename) return false;\n\n                var newName = 'GFF3_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    fileBasename: basename,\n                    blob: this._makeBlob(resource),\n                    name: newName\n                };\n                return true;\n            } else return false;\n        },\n\n        finalizeConfiguration: function finalizeConfiguration(configs) {},\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf.blob || conf.urlTemplate;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/GFF3Driver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/GTFDriver.js":
/*!************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/GTFDriver.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        storeType: 'JBrowse/Store/SeqFeature/GTF',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == 'gtf') {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '');\n                if (!basename) return false;\n\n                var newName = 'GTF_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    type: this.storeType,\n                    blob: this._makeBlob(resource),\n                    name: newName\n                };\n                return true;\n            } else return false;\n        },\n\n        // try to merge any singleton BAM and BAI stores.  currently can only do this if there is one of each\n        finalizeConfiguration: function finalizeConfiguration(configs) {},\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf.blob || conf.urlTemplate;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/GTFDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/TwoBitDriver.js":
/*!***************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/TwoBitDriver.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Model/FileBlob */ \"./src/JBrowse/Model/FileBlob.js\"), __webpack_require__(/*! JBrowse/Model/XHRBlob */ \"./src/JBrowse/Model/XHRBlob.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Util, FileBlob, XHRBlob) {\n    var uniqCounter = 0;\n    return declare(null, {\n\n        storeType: 'JBrowse/Store/SeqFeature/TwoBit',\n\n        tryResource: function tryResource(configs, resource) {\n            if (resource.type == '2bit') {\n                var basename = Util.basename(resource.file ? resource.file.name : resource.url ? resource.url : '', ['.2bit']);\n                if (!basename) return false;\n\n                var newName = 'TwoBit_' + basename + '_' + uniqCounter++;\n                configs[newName] = {\n                    fileBasename: basename,\n                    type: this.storeType,\n                    blob: this._makeBlob(resource),\n                    name: newName\n                };\n                return true;\n            } else return false;\n        },\n\n        // try to merge any singleton BAM and BAI stores.  currently can only do this if there is one of each\n        finalizeConfiguration: function finalizeConfiguration(configs) {},\n\n        _makeBlob: function _makeBlob(resource) {\n            var r = resource.file ? new FileBlob(resource.file) : resource.url ? new XHRBlob(resource.url) : null;\n            if (!r) throw 'unknown resource type';\n            return r;\n        },\n\n        confIsValid: function confIsValid(conf) {\n            return conf.blob || conf.urlTemplate;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/TwoBitDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/VCFTabixDriver.js":
/*!*****************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/VCFTabixDriver.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! ./_MultiIndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_MultiIndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, MultiIndexedFileDriver) {\n    return declare(MultiIndexedFileDriver, {\n        name: 'VCF+Tabix',\n        storeType: 'JBrowse/Store/SeqFeature/VCFTabix',\n\n        fileExtension: 'vcf.gz',\n        fileConfKey: 'file',\n        fileUrlConfKey: 'urlTemplate',\n\n        indexTypes: [{\n            indexExtension: 'vcf.gz.tbi',\n            indexConfKey: 'tbi',\n            indexUrlConfKey: 'tbiUrlTemplate'\n        }, {\n            indexExtension: 'vcf.gz.csi',\n            indexConfKey: 'csi',\n            indexUrlConfKey: 'csiUrlTemplate'\n        }]\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/VCFTabixDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/FileDialog/TrackList/VCFTribbleDriver.js":
/*!*******************************************************************!*\
  !*** ./src/JBrowse/View/FileDialog/TrackList/VCFTribbleDriver.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! ./_IndexedFileDriver */ \"./src/JBrowse/View/FileDialog/TrackList/_IndexedFileDriver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, IndexedFileDriver) {\n    return declare(IndexedFileDriver, {\n        name: 'VCF+IDX',\n        storeType: 'JBrowse/Store/SeqFeature/VCFTribble',\n\n        fileExtension: 'vcf',\n        fileConfKey: 'file',\n        fileUrlConfKey: 'urlTemplate',\n\n        indexExtension: 'idx',\n        indexConfKey: 'idx',\n        indexUrlConfKey: 'idxUrlTemplate'\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/FileDialog/TrackList/VCFTribbleDriver.js?");

/***/ }),

/***/ "./src/JBrowse/View/InfoDialog.js":
/*!****************************************!*\
  !*** ./src/JBrowse/View/InfoDialog.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! JBrowse/View/Dialog/WithActionBar */ \"./src/JBrowse/View/Dialog/WithActionBar.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, focus, ActionBarDialog, on, dijitButton) {\n\n    return declare(ActionBarDialog,\n\n    /**\n     * JBrowse ActionDialog subclass with a few customizations that make it\n     * more pleasant for use as an information popup.\n     * @lends JBrowse.View.InfoDialog\n     */\n    {\n        refocus: false,\n        autofocus: false,\n\n        _fillActionBar: function _fillActionBar(actionBar) {\n            new dijitButton({\n                className: 'OK',\n                label: 'OK',\n                onClick: dojo.hitch(this, 'hide')\n            }).placeAt(actionBar);\n        },\n\n        show: function show() {\n\n            this.inherited(arguments);\n\n            var thisB = this;\n\n            // holds the handles for the extra events we are registering\n            // so we can clean them up in the hide() method\n            this._extraEvents = [];\n\n            // make it so that clicking outside the dialog (on the underlay) will close it\n            var underlay = ((dijit || {})._underlay || {}).domNode;\n            if (underlay) {\n                this._extraEvents.push(on(underlay, 'click', dojo.hitch(this, 'hideIfVisible')));\n            }\n\n            // also make ESCAPE or ENTER close the dialog box\n            this._extraEvents.push(on(document.body, 'keydown', function (evt) {\n                if ([dojo.keys.ESCAPE, dojo.keys.ENTER].indexOf(evt.keyCode) >= 0) thisB.hideIfVisible();\n            }));\n\n            focus.focus(this.closeButtonNode);\n        },\n\n        hideIfVisible: function hideIfVisible() {\n            if (this.get('open')) this.hide();\n        },\n\n        hide: function hide() {\n            this.inherited(arguments);\n\n            array.forEach(this._extraEvents, function (e) {\n                e.remove();\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/InfoDialog.js?");

/***/ }),

/***/ "./src/JBrowse/View/LocationChoiceDialog.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/LocationChoiceDialog.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Dialog box that prompts the user to choose between several\n * different available locations to navigate to.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dijit/focus */ \"./node_modules/dijit/focus.js\"), __webpack_require__(/*! JBrowse/View/LocationList */ \"./src/JBrowse/View/LocationList.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, aspect, Dialog, dijitButton, dijitFocus, LocationListView) {\n    return declare(null, {\n\n        /**\n         * @param args.browser the Browser object\n         * @param args.locationChoices [Array] array of Location objects\n         *   to choose from.  The locations can optionally have 'label',\n         *   'description', and/or 'score' attributes, which will be\n         *   displayed as columns.\n         * @param args.title optional title of the dialog box.\n         * @param args.prompt optional text prompt to show at the top of the dialog.\n         * @param args.goCallback optional function to call for executing a 'Go' action. gets ( location, value, node, options )\n         * @param args.showCallback optional function to call for executing a 'Show' action.  gets ( location, value, node, options)\n         */\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.config = dojo.clone(args.config || {});\n            this.locationChoices = args.locationChoices || [];\n            this.title = args.title || 'Choose location';\n            this.prompt = args.prompt;\n            this.goCallback = args.goCallback;\n            this.showCallback = args.showCallback;\n        },\n\n        show: function show() {\n            var dialog = this.dialog = new Dialog({ title: this.title,\n                className: 'locationChoiceDialog',\n                style: { width: '70%' }\n            });\n            var container = dom.create('div', {});\n\n            // show the description if there is one\n            if (this.prompt) {\n                dom.create('div', {\n                    className: 'prompt',\n                    innerHTML: this.prompt\n                }, container);\n            }\n\n            var browser = this.browser;\n            this.locationListView = new LocationListView({ browser: browser,\n                locations: this.locationChoices,\n                buttons: [{\n                    className: 'show',\n                    innerHTML: 'Show',\n                    onClick: this.showCallback || function (location) {\n                        browser.showRegionAfterSearch(location);\n                    }\n                }, {\n                    className: 'go',\n                    innerHTML: 'Go',\n                    onClick: this.goCallback || function (location) {\n                        dialog.hide();\n                        browser.showRegionAfterSearch(location);\n                    }\n                }]\n            }, dom.create('div', {\n                className: 'locationList',\n                style: { maxHeight: 0.5 * this.browser.container.offsetHeight + 'px' }\n            }, container));\n\n            this.actionBar = dojo.create('div', { className: 'infoDialogActionBar dijitDialogPaneActionBar' });\n            new dijitButton({ iconClass: 'dijitIconDelete',\n                label: 'Cancel', onClick: dojo.hitch(dialog, 'hide')\n            }).placeAt(this.actionBar);\n\n            dialog.set('content', [container, this.actionBar]);\n            dialog.show();\n            aspect.after(dialog, 'hide', dojo.hitch(this, function () {\n                dijitFocus.curNode && dijitFocus.curNode.blur();\n                setTimeout(function () {\n                    dialog.destroyRecursive();\n                }, 500);\n            }));\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/LocationChoiceDialog.js?");

/***/ }),

/***/ "./src/JBrowse/View/LocationList.js":
/*!******************************************!*\
  !*** ./src/JBrowse/View/LocationList.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Generic component that displays a list of genomic locations, along\n * with buttons to execute actions on them.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! dstore/Memory */ \"./node_modules/dojo-dstore/Memory.js\"), __webpack_require__(/*! dgrid/OnDemandGrid */ \"./node_modules/dgrid/OnDemandGrid.js\"), __webpack_require__(/*! dgrid/extensions/DijitRegistry */ \"./node_modules/dgrid/extensions/DijitRegistry.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, dom, dijitButton, Util, MemoryStore, DGrid, DGridDijitRegistry) {\n\n    var Grid = declare([DGrid, DGridDijitRegistry]);\n\n    return declare(null, {\n        constructor: function constructor(args, parent) {\n            var thisB = this;\n            this.browser = args.browser;\n\n            // transform our data first, so that it's sortable.\n            var locations = array.map(args.locations || [], function (l) {\n                return { locstring: Util.assembleLocString(l),\n                    location: l,\n                    label: l.label || l.objectName,\n                    description: l.description,\n                    score: l.score,\n                    tracks: array.map(array.filter(l.tracks || [], function (t) {\n                        return t;\n                    }), // remove nulls\n                    function (t) {\n                        return t.key || t.name || t.label || t;\n                    }).join(', ')\n                };\n            });\n\n            // build the column list\n            var columns = [];\n            if (array.some(locations, function (l) {\n                return l.label;\n            })) columns.unshift({ label: 'Name', field: 'label' });\n            if (array.some(locations, function (l) {\n                return l.description;\n            })) columns.unshift({ label: 'Description', field: 'description' });\n            if (array.some(locations, function (l) {\n                return l.score;\n            })) columns.unshift({ label: 'Score', field: 'score' });\n            columns.push({ label: 'Location', field: 'locstring' });\n            if (locations.length && locations[0].tracks) columns.push({ label: 'Track', field: 'tracks' });\n            if (args.buttons) {\n                columns.push({\n                    label: '',\n                    className: 'goButtonColumn',\n                    renderCell: function renderCell(object, value, node, options) {\n                        var container = dom.create('div');\n                        array.forEach(args.buttons, function (button) {\n                            var buttonArgs = dojo.mixin({}, button);\n                            buttonArgs.onClick = function () {\n                                button.onClick(object.location, value, node, options);\n                            };\n                            new dijitButton(buttonArgs).placeAt(container);\n                        });\n                        return container;\n                    }\n                });\n            }\n\n            // create the grid\n            this.grid = new Grid({\n                columns: columns,\n                collection: new MemoryStore({ data: locations })\n            }, parent);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/LocationList.js?");

/***/ }),

/***/ "./src/JBrowse/View/Ruler.js":
/*!***********************************!*\
  !*** ./src/JBrowse/View/Ruler.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! dojox/charting/Chart */ \"./node_modules/dojox/charting/Chart.js\"), __webpack_require__(/*! dojox/charting/axis2d/Default */ \"./node_modules/dojox/charting/axis2d/Default.js\"), __webpack_require__(/*! dojox/charting/plot2d/Bubble */ \"./node_modules/dojox/charting/plot2d/Bubble.js\"), __webpack_require__(/*! dojo/NodeList-dom */ \"./node_modules/dojo/NodeList-dom.js\"), __webpack_require__(/*! dojo/number */ \"./node_modules/dojo/number.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (query, Chart) {\n    /**\n     * Ruler, with ticks and numbers, drawn with HTML elements. Can be\n     * stretched to any length.\n     *\n     * @class\n     * @constructor\n     *\n     * @param {Number} args.min\n     * @param {Number} args.max\n     * @param {String} [args.direction=\"up\"] The direction of increasing numbers.\n     *   Either \"up\" or \"down\".\n     * @param {Boolean} args.leftBottom=true Should the ticks and labels be on the right\n     * or the left.\n     *\n     */\n\n    function Ruler(args) {\n        dojo.mixin(this, args);\n    };\n\n    Ruler.prototype.render_to = function (target_div) {\n        if (typeof target_div == 'string') target_div = dojo.byId(target_div);\n\n        var target_dims = dojo.position(target_div);\n\n        // make an inner container that's styled to compensate for the\n        // 12px edge-padding that dojox.charting has builtin that we can't\n        // change, making the tick marks align correctly with the images\n        var label_digits = Math.floor(Math.log(this.max + 1) / Math.log(10)) + 1;\n\n        var container = dojo.create('div', {\n            style: {\n                position: 'absolute',\n                left: \"-9px\",\n                bottom: \"-9px\",\n                width: '10px',\n                height: target_dims.h + 18 + \"px\"\n            }\n        }, target_div);\n\n        try {\n            var chart1 = new Chart(container, { fill: 'transparent' });\n            chart1.addAxis(\"y\", {\n                vertical: true,\n                fill: 'transparent',\n                min: this.min,\n                max: this.max,\n                fixLower: this.fixBounds ? typeof this.fixBounds == 'string' ? this.fixBounds : 'major' : 'none',\n                fixUpper: this.fixBounds ? typeof this.fixBounds == 'string' ? this.fixBounds : 'major' : 'none',\n                leftBottom: this.leftBottom\n                // minorTickStep: 0.5,\n                // majorTickStep: 1\n                //labels: [{value: 1, text: \"One\"}, {value: 3, text: \"Ten\"}]\n            });\n            chart1.addPlot(\"default\", { type: \"Bubble\", fill: 'transparent' });\n            chart1.render();\n\n            // hack to remove undesirable opaque white rectangles.  do\n            // this a little bit later\n            query('svg rect', chart1.domNode).orphan();\n\n            this.scaler = chart1.axes.y.scaler;\n        } catch (x) {\n            console.error(x + '');\n            console.error(\"Failed to draw Ruler with SVG, your browser may not support the necessary technology.\");\n            target_div.removeChild(container);\n        }\n    };\n\n    return Ruler;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Ruler.js?");

/***/ }),

/***/ "./src/JBrowse/View/StandaloneDatasetList.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/View/StandaloneDatasetList.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dijit/_WidgetBase */ \"./node_modules/dijit/_WidgetBase.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, _WidgetBase) {\n    return declare(_WidgetBase, {\n\n        baseClass: 'jbrowseStandaloneDatasetSelector',\n\n        buildRendering: function buildRendering() {\n            this.inherited(arguments);\n\n            var bdy = this.domNode;\n            var h2 = bdy.appendChild(document.createElement('h2'));\n            h2.innerHTML = \"Available Datasets\";\n            this.containerNode = bdy.appendChild(document.createElement('ul'));\n            var datasets = this.get('datasets');\n            var ul = bdy.appendChild(document.createElement('ul'));\n            for (var spp in datasets) {\n                if (!/^_/.test(spp)) {\n                    var sppData = datasets[spp];\n                    var li = document.createElement('li');\n                    var a = document.createElement('a');\n                    a.setAttribute('href', sppData.url);\n                    a.innerHTML = sppData.name;\n                    li.appendChild(a);\n                    ul.appendChild(li);\n                }\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/StandaloneDatasetList.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Alignments.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/Track/Alignments.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/Track/HTMLFeatures */ \"./src/JBrowse/View/Track/HTMLFeatures.js\"), __webpack_require__(/*! JBrowse/View/Track/_AlignmentsMixin */ \"./src/JBrowse/View/Track/_AlignmentsMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, all, Util, HTMLFeatures, AlignmentsMixin) {\n\n    // return declare( HTMLFeatures,\n    return declare([HTMLFeatures, AlignmentsMixin],\n    /**\n     * @lends JBrowse.View.Track.Alignments\n     */\n    {\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                maxFeatureScreenDensity: 1.5,\n                layoutPitchY: 4,\n\n                hideDuplicateReads: true,\n                hideQCFailingReads: true,\n                hideSecondary: true,\n                hideSupplementary: true,\n                hideMissingMatepairs: false,\n                hideImproperPairs: false,\n                hideUnmapped: true,\n                hideUnsplicedReads: false,\n                hideForwardStrand: false,\n                hideReverseStrand: false,\n\n                style: {\n                    _defaultLabelScale: 50,\n                    className: 'alignment',\n                    arrowheadClass: 'arrowhead',\n                    centerChildrenVertically: true,\n                    showMismatches: true,\n                    showSubfeatures: false,\n                    showLabels: false\n                }\n            });\n        },\n\n        renderFeature: function renderFeature(feature, uniqueId, block, scale, labelScale, descriptionScale, containerStart, containerEnd) {\n            var featDiv = this.inherited(arguments);\n            if (!featDiv) return null;\n\n            var displayStart = Math.max(feature.get('start'), containerStart);\n            var displayEnd = Math.min(feature.get('end'), containerEnd);\n            if (this.config.style.showMismatches) {\n                this._drawMismatches(feature, featDiv, scale, displayStart, displayEnd);\n            }\n\n            // if this feature is part of a multi-segment read, and not\n            // all of its segments are aligned, add missing_mate to its\n            // class\n            if (feature.get('multi_segment_template') && !feature.get('multi_segment_all_aligned')) featDiv.className += ' missing_mate';\n\n            return featDiv;\n        },\n\n        handleSubFeatures: function handleSubFeatures(feature, featDiv, displayStart, displayEnd, block) {\n            if (this.config.style.showSubfeatures) {\n                this.inherited(arguments);\n            }\n        },\n\n        /**\n         * draw base-mismatches on the feature\n         */\n        _drawMismatches: function _drawMismatches(feature, featDiv, scale, displayStart, displayEnd) {\n            var featLength = displayEnd - displayStart;\n            // recall: scale is pixels/basepair\n            if (featLength * scale > 1) {\n                var mismatches = this._getMismatches(feature);\n                var charSize = this.getCharacterMeasurements();\n                var drawChars = scale >= charSize.w;\n                array.forEach(mismatches, function (mismatch) {\n                    var start = feature.get('start') + mismatch.start;\n                    var end = start + mismatch.length;\n\n                    // if the feature has been truncated to where it doesn't cover\n                    // this mismatch anymore, just skip this mismatch\n                    if (end <= displayStart || start >= displayEnd) return;\n\n                    var base = mismatch.base;\n                    var mDisplayStart = Math.max(start, displayStart);\n                    var mDisplayEnd = Math.min(end, displayEnd);\n                    var mDisplayWidth = mDisplayEnd - mDisplayStart;\n                    var overall = dojo.create('span', {\n                        className: mismatch.type + ' base_' + base.toLowerCase(),\n                        style: {\n                            position: 'absolute',\n                            left: 100 * (mDisplayStart - displayStart) / featLength + '%',\n                            width: scale * mDisplayWidth > 1 ? 100 * mDisplayWidth / featLength + '%' : '1px'\n                        }\n                    }, featDiv);\n\n                    // give the mismatch a mouseover if not drawing a character with the mismatch base\n                    if (!drawChars) overall.title = base;\n\n                    if (drawChars && mismatch.length <= 20) {\n                        for (var i = 0; i < mismatch.length; i++) {\n                            var basePosition = start + i;\n                            if (basePosition >= mDisplayStart && basePosition <= mDisplayEnd) {\n                                dojo.create('span', {\n                                    className: 'base base_' + base.toLowerCase(),\n                                    style: {\n                                        position: 'absolute',\n                                        width: scale + 'px',\n                                        left: (basePosition - mDisplayStart) / mDisplayWidth * 100 + '%'\n                                    },\n                                    innerHTML: base\n                                }, overall);\n                            }\n                        }\n                    }\n                }, this);\n            }\n        },\n\n        /**\n         * @returns {Object} containing <code>h</code> and <code>w</code>,\n         *      in pixels, of the characters being used for sequences\n         */\n        getCharacterMeasurements: function getCharacterMeasurements() {\n            if (!this._measurements) this._measurements = this._measureSequenceCharacterSize(this.div);\n            return this._measurements;\n        },\n\n        /**\n         * Conducts a test with DOM elements to measure sequence text width\n         * and height.\n         */\n        _measureSequenceCharacterSize: function _measureSequenceCharacterSize(containerElement) {\n            var widthTest = dojo.create('div', {\n                innerHTML: '<span class=\"base mismatch\">A</span>' + '<span class=\"base mismatch\">C</span>' + '<span class=\"base mismatch\">T</span>' + '<span class=\"base mismatch\">G</span>' + '<span class=\"base mismatch\">N</span>',\n                style: {\n                    visibility: 'hidden',\n                    position: 'absolute',\n                    left: '0px'\n                }\n            }, containerElement);\n            var result = {\n                w: widthTest.clientWidth / 5,\n                h: widthTest.clientHeight\n            };\n            containerElement.removeChild(widthTest);\n            return result;\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            return all([this.inherited(arguments), this._alignmentsFilterTrackMenuOptions()]).then(function (options) {\n                var o = options.shift();\n                options.unshift({ type: 'dijit/MenuSeparator' });\n                return o.concat.apply(o, options);\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Alignments.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Alignments2.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/View/Track/Alignments2.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dijit/MenuItem */ \"./node_modules/dijit/MenuItem.js\"), __webpack_require__(/*! JBrowse/View/Dialog/SetTrackHeight */ \"./src/JBrowse/View/Dialog/SetTrackHeight.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/Track/CanvasFeatures */ \"./src/JBrowse/View/Track/CanvasFeatures.js\"), __webpack_require__(/*! JBrowse/View/Track/_AlignmentsMixin */ \"./src/JBrowse/View/Track/_AlignmentsMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, MenuItem, Dialog, Util, CanvasFeatureTrack, AlignmentsMixin) {\n\n    return declare([CanvasFeatureTrack, AlignmentsMixin], {\n        _defaultConfig: function _defaultConfig() {\n            var c = Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                glyph: 'JBrowse/View/FeatureGlyph/Alignment',\n                maxFeatureGlyphExpansion: 0,\n                maxFeatureScreenDensity: 15,\n                orientationType: 'fr',\n\n                hideDuplicateReads: true,\n                hideQCFailingReads: true,\n                hideSecondary: true,\n                hideSupplementary: true,\n                hideUnmapped: true,\n                hideUnsplicedReads: false,\n                hideMissingMatepairs: false,\n                hideImproperPairs: false,\n                hideForwardStrand: false,\n                hideReverseStrand: false,\n                useXS: false,\n                useTS: false,\n                useReverseTemplate: false,\n                useReverseTemplateOption: true,\n                viewAsPairs: false,\n                viewAsSpans: false,\n                maxInsertSize: 50000,\n                readCloudLogScale: true,\n                showInterchromosomalArcs: true,\n                showLargeArcs: true,\n\n                histograms: {\n                    description: 'coverage depth',\n                    binsPerBlock: 200\n                },\n\n                style: {\n                    showLabels: false\n                }\n            });\n            c.menuTemplate.push({\n                \"iconClass\": \"dijitIconUndo\",\n                \"url\": function url(track, feature) {\n                    return track.browser.makeCurrentViewURL({ loc: track._nextSegmentViewLoc(feature, 0.8),\n                        highlight: feature.get('next_segment_position'),\n                        tracklist: 0\n                    });\n                },\n                \"action\": \"iframeDialog\",\n                title: \"Open {next_segment_position} in a popup\",\n                disabled: function disabled(track, feature) {\n                    return !feature.get('next_segment_position') || feature.get('paired_feature');\n                },\n                \"label\": \"Quick-view mate/next location\"\n            }, {\n                \"iconClass\": \"dijitIconUndo\",\n                \"url\": function url(track, feature) {\n                    return track.browser.makeCurrentViewURL({ loc: track._nextSegmentViewLoc(feature),\n                        highlight: feature.get('next_segment_position')\n                    });\n                },\n                \"action\": \"newWindow\",\n                title: \"Open {next_segment_position} in a new tab\",\n                disabled: function disabled(track, feature) {\n                    return !feature.get('next_segment_position') || feature.get('paired_feature');\n                },\n                \"label\": \"Open mate/next location in new tab\"\n            });\n            return c;\n        },\n\n        _trackType: function _trackType() {},\n        // make a locstring for a view of the given feature's next segment\n        // (in a multi-segment read)\n        _nextSegmentViewLoc: function _nextSegmentViewLoc(feature, factor) {\n            var nextLocStr = feature.get('next_segment_position');\n            if (!nextLocStr) return undefined;\n\n            var s = nextLocStr.split(':');\n            var refName = s[0];\n            var start = parseInt(s[1]);\n\n            var visibleRegion = this.browser.view.visibleRegion();\n            var visibleRegionSize = Math.round((visibleRegion.end - visibleRegion.start + 1) * (factor || 1));\n\n            return Util.assembleLocString({ start: Math.round(start - visibleRegionSize / 2),\n                end: Math.round(start + visibleRegionSize / 2),\n                ref: refName\n            });\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var thisB = this;\n            var displayOptions = [];\n\n            var m = {\n                type: 'dijit/Menu',\n                label: 'Track visualization types',\n                children: []\n            };\n            var c = {\n                type: 'dijit/Menu',\n                label: 'Coloring options',\n                children: []\n            };\n\n            displayOptions.push(m);\n            displayOptions.push(c);\n\n            m.children.push({\n                label: 'View as unpaired',\n                type: 'dijit/RadioMenuItem',\n                checked: this.config.glyph == 'JBrowse/View/FeatureGlyph/Alignment',\n                onClick: function onClick(event) {\n                    thisB.config.glyph = 'JBrowse/View/FeatureGlyph/Alignment';\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n\n            m.children.push({\n                label: 'View as pairs',\n                type: 'dijit/RadioMenuItem',\n                checked: this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedAlignment',\n                onClick: function onClick(event) {\n                    thisB.config.glyph = 'JBrowse/View/FeatureGlyph/PairedAlignment';\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n\n            m.children.push({\n                label: 'View as arcs',\n                type: 'dijit/RadioMenuItem',\n                checked: this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc',\n                onClick: function onClick(event) {\n                    thisB.config.glyph = 'JBrowse/View/FeatureGlyph/PairedArc';\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n            m.children.push({\n                label: 'View as read cloud',\n                type: 'dijit/RadioMenuItem',\n                checked: this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud',\n                onClick: function onClick(event) {\n                    thisB.config.glyph = 'JBrowse/View/FeatureGlyph/PairedReadCloud';\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n\n            m.children.push({\n                label: 'View coverage',\n                type: 'dijit/RadioMenuItem',\n                checked: false,\n                onClick: function onClick(event) {\n                    thisB.config.type = 'JBrowse/View/Track/SNPCoverage';\n                    thisB.config._oldAlignmentsHeight = thisB.config.style.height;\n                    thisB.config.style.height = thisB.config._oldSnpCoverageHeight;\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n\n            c.children.push({\n                label: 'Color by default',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.defaultColor,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.defaultColor = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n            c.children.push({\n                label: 'Color by XS tag (RNA-seq orientation)',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.useXS,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.useXS = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n\n            c.children.push({\n                label: 'Color by TS tag (RNA-seq orientation)',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.useTS,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.useTS = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n            c.children.push({\n                label: 'Color mate pair as flipped (RNA-seq orientation)',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.useReverseTemplate,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.useReverseTemplate = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n\n            c.children.push({\n                label: 'Color by mapping quality',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.colorByMAPQ,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.colorByMAPQ = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n            c.children.push({\n                label: 'Color by orientation',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.colorByOrientation,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.colorByOrientation = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n            c.children.push({\n                label: 'Color by insert size',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.colorBySize,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.colorBySize = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n            c.children.push({\n                label: 'Color by orientation and insert size',\n                type: 'dijit/RadioMenuItem',\n                checked: !!this.config.colorByOrientationAndSize,\n                onClick: function onClick(event) {\n                    thisB.clearColorConfig();\n                    thisB.config.colorByOrientationAndSize = this.get('checked');\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n            if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud') {\n                displayOptions.push({\n                    type: 'dijit/Menu',\n                    label: 'Read cloud options',\n                    children: [{\n                        label: 'View log scale',\n                        type: 'dijit/CheckedMenuItem',\n                        checked: !!this.config.readCloudLogScale,\n                        onClick: function onClick(event) {\n                            thisB.config.readCloudLogScale = this.get('checked');\n                            thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                        }\n                    }, {\n                        label: 'Set Y-scale size',\n                        onClick: function onClick(event) {\n                            new Dialog({\n                                title: 'Set read cloud Y-scale in terms of the maximum expected insert size',\n                                msg: ' expected max insert size',\n                                maxHeight: Infinity,\n                                height: thisB.config.readCloudYScaleMax || 50000,\n                                setCallback: function setCallback(ret) {\n                                    thisB.config.readCloudYScaleMax = ret;\n                                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                                }\n                            }).show();\n                        }\n                    }]\n                });\n            }\n            if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc') {\n                displayOptions.push({\n                    type: 'dijit/Menu',\n                    label: 'Paired arc options',\n                    children: [{\n                        label: 'Show interchromosomal',\n                        type: 'dijit/CheckedMenuItem',\n                        checked: !!this.config.showInterchromosomalArcs,\n                        onClick: function onClick(event) {\n                            thisB.config.showInterchromosomalArcs = this.get('checked');\n                            thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                        }\n                    }, {\n                        label: 'Show large arcs',\n                        type: 'dijit/CheckedMenuItem',\n                        checked: !!this.config.showLargeArcs,\n                        onClick: function onClick(event) {\n                            thisB.config.showLargeArcs = this.get('checked');\n                            thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                        }\n                    }]\n                });\n            }\n\n            displayOptions.push({\n                type: 'dijit/MenuItem',\n                label: 'Re-estimate insert size stats',\n                onClick: function onClick(event) {\n                    thisB.insertSizeStats = null;\n                    thisB.store.cleanStatsCache();\n                    thisB.redraw();\n                }\n            });\n            return Promise.all([this.inherited(arguments), this._alignmentsFilterTrackMenuOptions(), displayOptions]).then(function (options) {\n                var o = options.shift();\n                options.unshift({ type: 'dijit/MenuSeparator' });\n                return o.concat.apply(o, options);\n            });\n        },\n        clearColorConfig: function clearColorConfig() {\n            Object.assign(this.config, {\n                defaultColor: false,\n                useTS: false,\n                useXS: false,\n                useReverseTemplate: false,\n                colorByMAPQ: false,\n                colorByOrientation: false,\n                colorBySize: false,\n                colorByOrientationAndSize: false\n            });\n        },\n\n\n        // override getLayout to access addRect method\n        _getLayout: function _getLayout() {\n            var layout = this.inherited(arguments);\n            if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud' || this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc') {\n                layout = declare.safeMixin(layout, {\n                    addRect: function addRect() {\n                        this.pTotalHeight = this.maxHeight;\n                        return 0;\n                    }\n                });\n            }\n            return layout;\n        },\n        fillFeatures: function fillFeatures(args) {\n            var _this = this;\n\n            var finishCallback = args.finishCallback;\n            var errorCallback = function errorCallback(e) {\n                console.error(e);\n                _this._handleError(e, args);\n                finishCallback(e);\n            };\n\n            if (this.config.viewAsPairs || this.config.viewAsSpans || this.config.colorByOrientationAndSize || this.config.colorBySize && !this.insertSizeStats) {\n                var supermethod = this.getInherited(arguments);\n                var blockLen = args.rightBase - args.leftBase;\n                var min = void 0;\n                var max = void 0;\n\n                if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc') {\n                    // paired arc the insert size can be large and therefore we request a number of neighboring blocks\n                    var numNeighboringBlockFetches = 6;\n                    min = Math.max(0, args.leftBase - Math.min(Math.max(blockLen * numNeighboringBlockFetches, this.config.maxInsertSize), 100000));\n                    max = args.rightBase + Math.min(Math.max(blockLen * numNeighboringBlockFetches, this.config.maxInsertSize), 100000);\n                } else {\n                    // otherwise we just request based on maxInsertSize\n                    min = Math.max(0, args.leftBase - this.config.maxInsertSize);\n                    max = args.rightBase + this.config.maxInsertSize;\n                }\n\n                var cachePromise = new Promise(function (resolve, reject) {\n                    _this.store.getFeatures({\n                        ref: _this.refSeq.name,\n                        start: min,\n                        end: max,\n                        viewAsPairs: _this.config.viewAsPairs,\n                        viewAsSpans: _this.config.viewAsSpans,\n                        maxInsertSize: _this.config.maxInsertSize\n                    }, function () {\n                        /* do nothing except initialize caches on store backend */\n                    }, function () {\n                        _this.insertSizeStats = _this.insertSizeStats || _this.store.getInsertSizeStats();\n                        resolve();\n                    }, reject);\n                });\n                cachePromise.then(function () {\n                    args.finishCallback = function () {\n                        finishCallback();\n                        _this.store.cleanFeatureCache({\n                            ref: _this.refSeq.name,\n                            start: min,\n                            end: max\n                        });\n                    };\n                    supermethod.call(_this, args);\n                }, errorCallback);\n            } else {\n                this.inherited(arguments);\n            }\n        },\n        constructor: function constructor() {\n            var _this2 = this;\n\n            // automatically set parameters for the track based on glyph types\n            if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc') {\n                this.config.viewAsSpans = true;\n                this.config.viewAsPairs = false;\n            } else if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedAlignment' || this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud') {\n                this.config.viewAsPairs = true;\n                this.config.viewAsSpans = false;\n            } else {\n                this.config.viewAsPairs = false;\n                this.config.viewAsSpans = false;\n            }\n            this.insertSizeStats = this.config.insertSizeStats;\n\n            // determine if alternate color scheme in use, otherwise make default\n            var elts = ['defaultColor', 'useXS', 'useTS', 'useReverseTemplate', 'colorByOrientation', 'colorBySize', 'colorByOrientationAndSize', 'colorByMAPQ'];\n\n            if (!elts.some(function (e) {\n                return _this2.config[e] == true;\n            })) {\n                this.config.defaultColor = true;\n            }\n        },\n        renderClickMap: function renderClickMap() {\n            if (this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedArc' || this.config.glyph == 'JBrowse/View/FeatureGlyph/PairedReadCloud') {\n                return;\n            } else {\n                this.inherited(arguments);\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Alignments2.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/BlockBased.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/Track/BlockBased.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/dom-geometry */ \"./node_modules/dojo/dom-geometry.js\"), __webpack_require__(/*! dojo/dom-class */ \"./node_modules/dojo/dom-class.js\"), __webpack_require__(/*! dojo/dom-style */ \"./node_modules/dojo/dom-style.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/when */ \"./node_modules/dojo/when.js\"), __webpack_require__(/*! dijit/Destroyable */ \"./node_modules/dijit/Destroyable.js\"), __webpack_require__(/*! JBrowse/View/InfoDialog */ \"./src/JBrowse/View/InfoDialog.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dijit/Menu */ \"./node_modules/dijit/Menu.js\"), __webpack_require__(/*! dijit/PopupMenuItem */ \"./node_modules/dijit/PopupMenuItem.js\"), __webpack_require__(/*! dijit/MenuItem */ \"./node_modules/dijit/MenuItem.js\"), __webpack_require__(/*! dijit/CheckedMenuItem */ \"./node_modules/dijit/CheckedMenuItem.js\"), __webpack_require__(/*! dijit/MenuSeparator */ \"./node_modules/dijit/MenuSeparator.js\"), __webpack_require__(/*! dijit/RadioMenuItem */ \"./node_modules/dijit/RadioMenuItem.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Component */ \"./src/JBrowse/Component.js\"), __webpack_require__(/*! JBrowse/FeatureFiltererMixin */ \"./src/JBrowse/FeatureFiltererMixin.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\"), __webpack_require__(/*! JBrowse/View/TrackConfigEditor */ \"./src/JBrowse/View/TrackConfigEditor.js\"), __webpack_require__(/*! JBrowse/View/ConfirmDialog */ \"./src/JBrowse/View/ConfirmDialog.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased/Block */ \"./src/JBrowse/View/Track/BlockBased/Block.js\"), __webpack_require__(/*! JBrowse/View/DetailsMixin */ \"./src/JBrowse/View/DetailsMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, JSON, aspect, domConstruct, domGeom, domClass, domStyle, query, on, when, Destroyable, InfoDialog, Dialog, dijitMenu, dijitPopupMenuItem, dijitMenuItem, dijitCheckedMenuItem, dijitMenuSeparator, dijitRadioMenuItem, Util, Component, FeatureFiltererMixin, Errors, Location, TrackConfigEditor, ConfirmDialog, Block, DetailsMixin) {\n\n    // we get `own` and `destroy` from Destroyable, see dijit/Destroyable docs\n\n    return declare([Component, DetailsMixin, FeatureFiltererMixin, Destroyable],\n    /**\n     * @lends JBrowse.View.Track.BlockBased.prototype\n     */\n    {\n        /**\n         * Base class for all JBrowse tracks.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            args = args || {};\n\n            this.refSeq = args.refSeq;\n            this.name = args.label || this.config.label;\n            this.key = args.key || this.config.key || this.name;\n\n            this._changedCallback = args.changeCallback || function () {};\n            this.height = 0;\n            this.shown = true;\n            this.empty = false;\n            this.browser = args.browser;\n\n            this.setFeatureFilterParentComponent(this.browser.view);\n\n            this.store = args.store;\n\n            // retrieve any user-set style info\n            lang.mixin(this.config.style, this.getUserStyles());\n        },\n\n        // get/set persistent per-user style information for this track\n        updateUserStyles: function updateUserStyles(settings) {\n            // set in this object\n            lang.mixin(this.config.style, settings);\n            // set in the saved style\n            var saved = JSON.parse(this.browser.cookie(\"track-style-\" + this.name) || '{}');\n            lang.mixin(saved, settings);\n            this.browser.cookie(\"track-style-\" + this.name, saved);\n            // redraw this track\n            this.redraw();\n        },\n        getUserStyles: function getUserStyles() {\n            return JSON.parse(this.browser.cookie(\"track-style-\" + this.name) || '{}');\n        },\n\n        /**\n         * Returns object holding the default configuration for this track\n         * type.  Might want to override in subclasses.\n         * @private\n         */\n        _defaultConfig: function _defaultConfig() {\n            return {\n                maxFeatureSizeForUnderlyingRefSeq: 250000,\n                subfeatureDetailLevel: 2\n            };\n        },\n\n        heightUpdate: function heightUpdate(height, blockIndex) {\n\n            if (!this.shown) {\n                this.heightUpdateCallback(0);\n                return;\n            }\n\n            if (blockIndex !== undefined) this.blockHeights[blockIndex] = height;\n\n            this.height = Math.max(this.height, height);\n\n            if (!this.inShowRange) {\n                this.heightUpdateCallback(Math.max(this.labelHeight, this.height));\n\n                // reposition any height-overflow markers in our blocks\n                query('.height_overflow_message', this.div).style('top', this.height - 16 + 'px');\n            }\n        },\n\n        setViewInfo: function setViewInfo(genomeView, heightUpdate, numBlocks, trackDiv, widthPct, widthPx, scale) {\n            this.genomeView = genomeView;\n            this.heightUpdateCallback = heightUpdate;\n            this.div = trackDiv;\n            this.widthPct = widthPct;\n            this.widthPx = widthPx;\n\n            this.leftBlank = document.createElement(\"div\");\n            this.leftBlank.className = \"blank-block\";\n            this.rightBlank = document.createElement(\"div\");\n            this.rightBlank.className = \"blank-block\";\n            this.div.appendChild(this.rightBlank);\n            this.div.appendChild(this.leftBlank);\n\n            this.sizeInit(numBlocks, widthPct);\n            this.labelHTML = \"\";\n            this.labelHeight = 0;\n\n            if (this.config.pinned) this.setPinned(true);\n\n            if (!this.label) {\n                this.makeTrackLabel();\n            }\n            this.setLabel(this.key);\n        },\n\n        makeTrackLabel: function makeTrackLabel() {\n\n            var params = {\n                className: \"track-label dojoDndHandle\",\n                id: \"label_\" + this.name,\n                style: {\n                    position: 'absolute'\n                }\n            };\n\n            if (typeof this.browser.config.trackLabels !== 'undefined' && this.browser.config.trackLabels === 'no-block') {\n                params.style.top = \"-30px\";\n            }\n\n            var labelDiv = dojo.create('div', params, this.div);\n\n            this.label = labelDiv;\n\n            if ((this.config.style || {}).trackLabelCss) {\n                labelDiv.style.cssText += \";\" + this.config.style.trackLabelCss;\n            }\n\n            var closeButton = dojo.create('div', {\n                className: 'track-close-button'\n            }, labelDiv);\n            this.own(on(closeButton, 'click', dojo.hitch(this, function (evt) {\n                this.browser.view.suppressDoubleClick(100);\n                this.browser.publish('/jbrowse/v1/v/tracks/hide', [this.config]);\n                evt.stopPropagation();\n            })));\n\n            var labelText = dojo.create('span', { className: 'track-label-text' }, labelDiv);\n            var menuButton = dojo.create('div', {\n                className: 'track-menu-button'\n            }, labelDiv);\n            dojo.create('div', {}, menuButton); // will be styled with an icon by CSS\n            this.labelMenuButton = menuButton;\n\n            // make the track menu with things like 'save as'\n            this.makeTrackMenu();\n        },\n\n        hide: function hide() {\n            if (this.shown) {\n                this.div.style.display = \"none\";\n                this.shown = false;\n            }\n        },\n\n        show: function show() {\n            if (!this.shown) {\n                this.div.style.display = \"block\";\n                this.shown = true;\n            }\n        },\n\n        initBlocks: function initBlocks() {\n            this.blocks = new Array(this.numBlocks);\n            this.blockHeights = new Array(this.numBlocks);\n            for (var i = 0; i < this.numBlocks; i++) {\n                this.blockHeights[i] = 0;\n            }this.firstAttached = null;\n            this.lastAttached = null;\n            this._adjustBlanks();\n        },\n\n        clear: function clear() {\n            if (this.blocks) {\n                for (var i = 0; i < this.numBlocks; i++) {\n                    this._hideBlock(i);\n                }\n            }\n            this.initBlocks();\n            this.makeTrackMenu();\n        },\n\n        setLabel: function setLabel(newHTML) {\n            if (this.label === undefined || this.labelHTML == newHTML) return;\n\n            this.labelHTML = newHTML;\n            query('.track-label-text', this.label).forEach(function (n) {\n                n.innerHTML = newHTML;\n            });\n            this.labelHeight = this.label.offsetHeight;\n        },\n\n        /**\n         * Stub.\n         */\n        transfer: function transfer() {},\n\n        /**\n         *  Stub.\n         */\n        startZoom: function startZoom(destScale, destStart, destEnd) {},\n\n        /**\n         * Stub.\n         */\n        endZoom: function endZoom(destScale, destBlockBases) {},\n\n        showRange: function showRange(first, last, startBase, bpPerBlock, scale, containerStart, containerEnd, finishCallback) {\n            var _this = this;\n\n            if (this.fatalError) {\n                this.showFatalError(this.fatalError);\n                return;\n            }\n\n            if (this.blocks === undefined || !this.blocks.length) return;\n\n            // this might make more sense in setViewInfo, but the label element\n            // isn't in the DOM tree yet at that point\n            if (this.labelHeight == 0 && this.label) this.labelHeight = this.label.offsetHeight;\n\n            this.inShowRange = true;\n            this.height = this.labelHeight;\n\n            var firstAttached = null == this.firstAttached ? last + 1 : this.firstAttached;\n            var lastAttached = null == this.lastAttached ? first - 1 : this.lastAttached;\n\n            var i, leftBase;\n            var maxHeight = 0;\n            var blockShowingPromises = [];\n            //fill left, including existing blocks (to get their heights)\n            for (i = lastAttached; i >= first; i--) {\n                leftBase = startBase + bpPerBlock * (i - first);\n                blockShowingPromises.push(new Promise(function (resolve, reject) {\n                    _this._showBlock(i, leftBase, leftBase + bpPerBlock, scale, containerStart, containerEnd, resolve);\n                }));\n            }\n            //fill right\n            for (i = lastAttached + 1; i <= last; i++) {\n                leftBase = startBase + bpPerBlock * (i - first);\n                blockShowingPromises.push(new Promise(function (resolve, reject) {\n                    _this._showBlock(i, leftBase, leftBase + bpPerBlock, scale, containerStart, containerEnd, resolve);\n                }));\n            }\n            // if we have a finishing callback, call it when we have finished all our _showBlock calls\n            if (finishCallback) Promise.all(blockShowingPromises).then(finishCallback, finishCallback);\n\n            //detach left blocks\n            var destBlock = this.blocks[first];\n            for (i = firstAttached; i < first; i++) {\n                this.transfer(this.blocks[i], destBlock, scale, containerStart, containerEnd);\n                this.cleanupBlock(this.blocks[i]);\n                this._hideBlock(i);\n            }\n            //detach right blocks\n            destBlock = this.blocks[last];\n            for (i = lastAttached; i > last; i--) {\n                this.transfer(this.blocks[i], destBlock, scale, containerStart, containerEnd);\n                this.cleanupBlock(this.blocks[i]);\n                this._hideBlock(i);\n            }\n\n            this.firstAttached = first;\n            this.lastAttached = last;\n            this._adjustBlanks();\n            this.inShowRange = false;\n\n            this.heightUpdate(this.height);\n            this.updateStaticElements(this.genomeView.getPosition());\n        },\n\n        cleanupBlock: function cleanupBlock(block) {\n            if (block) block.destroy();\n        },\n\n        /**\n         * Called when this track object is destroyed.  Cleans up things\n         * to avoid memory leaks.\n         */\n        destroy: function destroy() {\n            array.forEach(this.blocks || [], function (block) {\n                this.cleanupBlock(block);\n            }, this);\n            delete this.blocks;\n            delete this.div;\n\n            this.inherited(arguments);\n        },\n\n        _hideBlock: function _hideBlock(blockIndex) {\n            if (this.blocks[blockIndex]) {\n                this.div.removeChild(this.blocks[blockIndex].domNode);\n                this.cleanupBlock(this.blocks[blockIndex]);\n                this.blocks[blockIndex] = undefined;\n                this.blockHeights[blockIndex] = 0;\n            }\n        },\n\n        _adjustBlanks: function _adjustBlanks() {\n            if (this.firstAttached === null || this.lastAttached === null) {\n                this.leftBlank.style.left = \"0px\";\n                this.leftBlank.style.width = \"50%\";\n                this.rightBlank.style.left = \"50%\";\n                this.rightBlank.style.width = \"50%\";\n            } else {\n                this.leftBlank.style.width = this.firstAttached * this.widthPct + \"%\";\n                this.rightBlank.style.left = (this.lastAttached + 1) * this.widthPct + \"%\";\n                this.rightBlank.style.width = (this.numBlocks - this.lastAttached - 1) * this.widthPct + \"%\";\n            }\n        },\n\n        hideAll: function hideAll() {\n            if (null == this.firstAttached) return;\n            for (var i = this.firstAttached; i <= this.lastAttached; i++) {\n                this._hideBlock(i);\n            }this.firstAttached = null;\n            this.lastAttached = null;\n            this._adjustBlanks();\n        },\n\n        // hides all blocks that overlap the given region/location\n        hideRegion: function hideRegion(location) {\n            if (null == this.firstAttached) return;\n            // hide all blocks that overlap the given region\n            for (var i = this.firstAttached; i <= this.lastAttached; i++) {\n                if (this.blocks[i] && location.ref == this.refSeq.name && !(this.blocks[i].leftBase > location.end || this.blocks[i].rightBase < location.start)) this._hideBlock(i);\n            }this._adjustBlanks();\n        },\n\n        /**\n         *   _changeCallback invoked here is passed in constructor,\n         *         and typically is GenomeView.showVisibleBlocks()\n         */\n        changed: function changed() {\n            this.hideAll();\n            if (this._changedCallback) this._changedCallback();\n        },\n\n        _makeLoadingMessage: function _makeLoadingMessage() {\n            var msgDiv = dojo.create('div', {\n                className: 'loading',\n                innerHTML: '<div class=\"text\">Loading</span>',\n                title: 'Loading data...',\n                style: { visibility: 'hidden' }\n            });\n            window.setTimeout(function () {\n                msgDiv.style.visibility = 'visible';\n            }, 200);\n            return msgDiv;\n        },\n\n        showFatalError: function showFatalError(error) {\n            query('.block', this.div).concat(query('.blank-block', this.div)).concat(query('.error', this.div)).orphan();\n            this.blocks = [];\n            this.blockHeights = [];\n\n            this.fatalErrorMessageElement = this._renderErrorMessage(error || this.fatalError, this.div);\n            this.heightUpdate(domGeom.position(this.fatalErrorMessageElement).h);\n            this.updateStaticElements(this.genomeView.getPosition());\n        },\n\n        // generic handler for all types of errors\n        _handleError: function _handleError(error, viewArgs) {\n            var errorContext = dojo.mixin({}, error);\n            dojo.mixin(errorContext, viewArgs);\n\n            var isObject = (typeof error === 'undefined' ? 'undefined' : _typeof(error)) == 'object';\n\n            if (isObject && error instanceof Errors.TimeOut && errorContext.block) this.fillBlockTimeout(errorContext.blockIndex, errorContext.block, error);else if (isObject && error instanceof Errors.DataOverflow) {\n                if (errorContext.block) this.fillTooManyFeaturesMessage(errorContext.blockIndex, errorContext.block, viewArgs.scale, error);else array.forEach(this.blocks, function (block, blockIndex) {\n                    if (block) this.fillTooManyFeaturesMessage(blockIndex, block, viewArgs.scale, error);\n                }, this);\n            } else {\n                console.error(error.stack || '' + error, error);\n                this.fatalError = error;\n                this.showFatalError(error);\n            }\n        },\n\n        fillBlockError: function fillBlockError(blockIndex, block, error) {\n            error = error || this.fatalError || this.error;\n\n            domConstruct.empty(block.domNode);\n            var msgDiv = this._renderErrorMessage(error, block.domNode);\n            this.heightUpdate(dojo.position(msgDiv).h, blockIndex);\n        },\n\n        _renderErrorMessage: function _renderErrorMessage(message, parent) {\n            return domConstruct.create('div', {\n                className: 'error',\n                innerHTML: '<h2>Error</h2><div class=\"text\">An error was encountered when displaying this track.</div>' + (message ? '<div class=\"codecaption\">Diagnostic message</div><code>' + message + '</code>' : ''),\n                title: 'An error occurred'\n            }, parent);\n        },\n\n        fillTooManyFeaturesMessage: function fillTooManyFeaturesMessage(blockIndex, block, scale, error) {\n            var message = (error && error.message || 'Too much data to show').replace(/\\.$/, '');\n\n            this.fillMessage(blockIndex, block, message + (scale >= this.browser.view.maxPxPerBp ? '' : '; zoom in to see detail') + '.');\n        },\n\n        redraw: function redraw() {\n            this.clear();\n            this.genomeView.showVisibleBlocks(true);\n        },\n\n        markBlockHeightOverflow: function markBlockHeightOverflow(block) {\n            if (block.heightOverflowed) return;\n\n            block.heightOverflowed = true;\n            domClass.add(block.domNode, 'height_overflow');\n            domConstruct.create('div', {\n                className: 'height_overflow_message',\n                innerHTML: 'Max height reached',\n                style: {\n                    top: this.height - 16 + 'px',\n                    height: '16px'\n                }\n            }, block.domNode);\n        },\n\n        _showBlock: function _showBlock(blockIndex, startBase, endBase, scale, containerStart, containerEnd, finishCallback) {\n            if (this.empty || this.fatalError) {\n                this.heightUpdate(this.labelHeight);\n                if (finishCallback) finishCallback();\n                return;\n            }\n\n            if (this.blocks[blockIndex]) {\n                this.heightUpdate(this.blockHeights[blockIndex], blockIndex);\n                if (finishCallback) finishCallback();\n                return;\n            }\n\n            var block = new Block({\n                startBase: startBase,\n                endBase: endBase,\n                scale: scale,\n                node: {\n                    className: 'block',\n                    style: {\n                        left: blockIndex * this.widthPct + \"%\",\n                        width: this.widthPct + \"%\"\n                    }\n                }\n            });\n            this.blocks[blockIndex] = block;\n            this.div.appendChild(block.domNode);\n\n            var args = [blockIndex, block, this.blocks[blockIndex - 1], this.blocks[blockIndex + 1], startBase, endBase, scale, this.widthPx, containerStart, containerEnd];\n\n            if (this.fatalError) {\n                this.fillBlockError(blockIndex, block);\n                if (finishCallback) finishCallback();\n                return;\n            }\n\n            // loadMessage is an opaque mask div that we place over the\n            // block until the fillBlock finishes\n            var loadMessage = this._makeLoadingMessage();\n            block.domNode.appendChild(loadMessage);\n\n            var finish = function finish() {\n                if (block && loadMessage.parentNode) block.domNode.removeChild(loadMessage);\n                if (finishCallback) finishCallback();\n            };\n\n            var viewargs = {\n                blockIndex: blockIndex,\n                block: block,\n                leftBlock: this.blocks[blockIndex - 1],\n                rightBlock: this.blocks[blockIndex + 1],\n                leftBase: startBase,\n                rightBase: endBase,\n                scale: scale,\n                stripeWidth: this.widthPx,\n                containerStart: containerStart,\n                containerEnd: containerEnd,\n                finishCallback: finish\n            };\n            try {\n                this.fillBlock(viewargs);\n            } catch (e) {\n                this._handleError(e, viewargs);\n                finish();\n            }\n        },\n\n        moveBlocks: function moveBlocks(delta) {\n            var newBlocks = new Array(this.numBlocks);\n            var newHeights = new Array(this.numBlocks);\n            var i;\n            for (i = 0; i < this.numBlocks; i++) {\n                newHeights[i] = 0;\n            }var destBlock;\n            if (this.lastAttached + delta < 0 || this.firstAttached + delta >= this.numBlocks) {\n                this.firstAttached = null;\n                this.lastAttached = null;\n            } else {\n                this.firstAttached = Math.max(0, Math.min(this.numBlocks - 1, this.firstAttached + delta));\n                this.lastAttached = Math.max(0, Math.min(this.numBlocks - 1, this.lastAttached + delta));\n                if (delta < 0) destBlock = this.blocks[this.firstAttached - delta];else destBlock = this.blocks[this.lastAttached - delta];\n            }\n\n            for (i = 0; i < this.blocks.length; i++) {\n                var newIndex = i + delta;\n                if (newIndex < 0 || newIndex >= this.numBlocks) {\n                    //We're not keeping this block around, so delete\n                    //the old one.\n                    if (destBlock && this.blocks[i]) this.transfer(this.blocks[i], destBlock);\n                    this._hideBlock(i);\n                } else {\n                    //move block\n                    newBlocks[newIndex] = this.blocks[i];\n                    if (newBlocks[newIndex]) newBlocks[newIndex].domNode.style.left = newIndex * this.widthPct + \"%\";\n\n                    newHeights[newIndex] = this.blockHeights[i];\n                }\n            }\n            this.blocks = newBlocks;\n            this.blockHeights = newHeights;\n            this._adjustBlanks();\n        },\n\n        sizeInit: function sizeInit(numBlocks, widthPct, blockDelta) {\n            var i, oldLast;\n            this.numBlocks = numBlocks;\n            this.widthPct = widthPct;\n            if (blockDelta) this.moveBlocks(-blockDelta);\n            if (this.blocks && this.blocks.length > 0) {\n                //if we're shrinking, clear out the end blocks\n                var destBlock = this.blocks[numBlocks - 1];\n                for (i = numBlocks; i < this.blocks.length; i++) {\n                    if (destBlock && this.blocks[i]) this.transfer(this.blocks[i], destBlock);\n                    this._hideBlock(i);\n                }\n                oldLast = this.blocks.length;\n                this.blocks.length = numBlocks;\n                this.blockHeights.length = numBlocks;\n                //if we're expanding, set new blocks to be not there\n                for (i = oldLast; i < numBlocks; i++) {\n                    this.blocks[i] = undefined;\n                    this.blockHeights[i] = 0;\n                }\n                this.lastAttached = Math.min(this.lastAttached, numBlocks - 1);\n                if (this.firstAttached > this.lastAttached) {\n                    //not sure if this can happen\n                    this.firstAttached = null;\n                    this.lastAttached = null;\n                }\n\n                if (this.blocks.length != numBlocks) throw new Error(\"block number mismatch: should be \" + numBlocks + \"; blocks.length: \" + this.blocks.length);\n\n                for (i = 0; i < numBlocks; i++) {\n                    if (this.blocks[i]) {\n                        //if (!this.blocks[i].style) console.log(this.blocks);\n                        this.blocks[i].domNode.style.left = i * widthPct + \"%\";\n                        this.blocks[i].domNode.style.width = widthPct + \"%\";\n                    }\n                }\n            } else {\n                this.initBlocks();\n            }\n\n            this.makeTrackMenu();\n        },\n\n        fillMessage: function fillMessage(blockIndex, block, message, class_) {\n            domConstruct.empty(block.domNode);\n            var msgDiv = dojo.create('div', {\n                className: class_ || 'message',\n                innerHTML: message\n            }, block.domNode);\n            this.heightUpdate(domGeom.getMarginBox(msgDiv, domStyle.getComputedStyle(msgDiv)).h, blockIndex);\n        },\n\n        /**\n         * Called by GenomeView when the view is scrolled: communicates the\n         * new x, y, width, and height of the view.  This is needed by tracks\n         * for positioning stationary things like axis labels.\n         */\n        updateStaticElements: function updateStaticElements( /**Object*/coords) {\n            this.window_info = dojo.mixin(this.window_info || {}, coords);\n            if (this.fatalErrorMessageElement) {\n                this.fatalErrorMessageElement.style.width = this.window_info.width * 0.6 + 'px';\n                if ('x' in coords) this.fatalErrorMessageElement.style.left = coords.x + this.window_info.width * 0.2 + 'px';\n            }\n\n            if (this.label && 'x' in coords) this.label.style.left = coords.x + 'px';\n        },\n\n        /**\n         * Render a dijit menu from a specification object.\n         *\n         * @param menuTemplate definition of the menu's structure\n         * @param context {Object} optional object containing the context\n         *   in which any click handlers defined in the menu should be\n         *   invoked, containing thing like what feature is being operated\n         *   upon, the track object that is involved, etc.\n         * @param parent {dijit.Menu|...} parent menu, if this is a submenu\n         */\n        _renderContextMenu: function _renderContextMenu( /**Object*/menuStructure, /** Object */context, /** dijit.Menu */parent) {\n            if (!parent) {\n                parent = new dijitMenu();\n                this.own(parent);\n            }\n\n            for (var key in menuStructure) {\n                var spec = menuStructure[key];\n                try {\n                    if (spec.children) {\n                        var child = new dijitMenu();\n                        parent.addChild(child);\n                        parent.addChild(new dijitPopupMenuItem({\n                            popup: child,\n                            label: spec.label\n                        }));\n                        this._renderContextMenu(spec.children, context, child);\n                    } else {\n                        var menuConf = dojo.clone(spec);\n                        if (menuConf.action || menuConf.url || menuConf.href) {\n                            menuConf.onClick = this._makeClickHandler(spec, context);\n                        }\n                        // only draw other menu items if they do something when clicked.\n                        // drawing menu items that do nothing when clicked\n                        // would frustrate users.\n                        if (menuConf.label && !menuConf.onClick) menuConf.disabled = true;\n\n                        // currently can only use preloaded types\n                        var class_ = {\n                            'dijit/MenuItem': dijitMenuItem,\n                            'dijit/CheckedMenuItem': dijitCheckedMenuItem,\n                            'dijit/RadioMenuItem': dijitRadioMenuItem,\n                            'dijit/MenuSeparator': dijitMenuSeparator\n                        }[spec.type] || dijitMenuItem;\n\n                        parent.addChild(new class_(menuConf));\n                    }\n                } catch (e) {\n                    console.error('failed to render menu item ' + key, e);\n                }\n            }\n            return parent;\n        },\n\n        _makeClickHandler: function _makeClickHandler(inputSpec, context) {\n            var track = this;\n\n            if (typeof inputSpec == 'function') {\n                inputSpec = { action: inputSpec };\n            } else if (typeof inputSpec == 'undefined') {\n                console.error(\"Undefined click specification, cannot make click handler\");\n                return function () {};\n            } else if (inputSpec.action == 'defaultDialog') {\n                inputSpec.action = 'contentDialog';\n                inputSpec.content = dojo.hitch(this, 'defaultFeatureDetail');\n            }\n\n            var handler = function handler(evt) {\n                if (track.genomeView.dragging) return;\n\n                var ctx = context || this;\n                var spec = track._processMenuSpec(dojo.clone(inputSpec), ctx);\n                var url = spec.url || spec.href;\n                spec.url = url;\n                var style = dojo.clone(spec.style || {});\n\n                // try to understand the `action` setting\n                spec.action = spec.action || (url ? 'iframeDialog' : spec.content ? 'contentDialog' : false);\n                spec.title = spec.title || spec.label;\n\n                if (typeof spec.action == 'string') {\n                    // treat `action` case-insensitively\n                    spec.action = {\n                        iframedialog: 'iframeDialog',\n                        iframe: 'iframeDialog',\n                        contentdialog: 'contentDialog',\n                        content: 'contentDialog',\n                        baredialog: 'bareDialog',\n                        bare: 'bareDialog',\n                        xhrdialog: 'xhrDialog',\n                        xhr: 'xhrDialog',\n                        newwindow: 'newWindow',\n                        \"_blank\": 'newWindow',\n                        thiswindow: 'navigateTo',\n                        navigateto: 'navigateTo'\n                    }[('' + spec.action).toLowerCase()];\n\n                    if (spec.action == 'newWindow') window.open(url, '_blank');else if (spec.action == 'navigateTo') window.location = url;else if (spec.action in { iframeDialog: 1, contentDialog: 1, xhrDialog: 1, bareDialog: 1 }) track._openDialog(spec, evt, ctx);\n                } else if (typeof spec.action == 'function') {\n                    spec.action.call(ctx, evt);\n                } else {\n                    return;\n                }\n            };\n\n            // if there is a label, set it on the handler so that it's\n            // accessible for tooltips or whatever.\n            if (inputSpec.label) handler.label = inputSpec.label;\n\n            return handler;\n        },\n\n        /**\n         * @returns {Object} DOM element containing a rendering of the\n         *                   detailed metadata about this track\n         */\n        _trackDetailsContent: function _trackDetailsContent(additional) {\n            var details = domConstruct.create('div', { className: 'detail' });\n            var fmt = lang.hitch(this, 'renderDetailField', details);\n            fmt('Name', this.key || this.name);\n            var metadata = lang.clone(this.getMetadata());\n            delete metadata.key;\n            delete metadata.label;\n            if (_typeof(metadata.conf) == 'object') delete metadata.conf;\n            if (this.browser && this.browser.config && this.browser.config.trackSelector && this.browser.config.trackSelector.renameFacets) {\n                var metadataCopy = {};\n                for (var k in metadata) {\n                    var key = this.browser.config.trackSelector.renameFacets[k] || k;\n                    metadataCopy[key] = metadata[k];\n                }\n                metadata = metadataCopy;\n            }\n            var md_keys = [];\n            for (var k in metadata) {\n                md_keys.push(k);\n            }\n            md_keys.sort(function (a, b) {\n                return a.toLowerCase().localeCompare(b.toLowerCase());\n            });\n            for (var i = 0; i < md_keys.length; i++) {\n                var k = md_keys[i];\n                fmt(this.camelToTitleCase(k), metadata[k]);\n            }\n            for (var k in additional) {\n                fmt(k, additional[k]);\n            }\n            return details;\n        },\n\n        camelToTitleCase: function camelToTitleCase(str) {\n            if (str === str.toLowerCase()) {\n                return Util.ucFirst(str.replace(/_/g, \" \"));\n            } else {\n                return str;\n            }\n        },\n\n        getMetadata: function getMetadata() {\n            return this.config.metadata || this.browser && this.browser.trackMetaDataStore && this.browser.trackMetaDataStore.getItem(this.name) || {};\n        },\n\n        setPinned: function setPinned(p) {\n            this.config.pinned = !!p;\n\n            if (this.config.pinned) domClass.add(this.div, 'pinned');else domClass.remove(this.div, 'pinned');\n\n            return this.config.pinned;\n        },\n        isPinned: function isPinned() {\n            return !!this.config.pinned;\n        },\n\n        /**\n         * @returns {Array} menu options for this track's menu (usually contains save as, etc)\n         */\n        _trackMenuOptions: function _trackMenuOptions() {\n            var that = this;\n            return [{ label: 'About this track',\n                title: 'About track: ' + (this.key || this.name),\n                iconClass: 'jbrowseIconHelp',\n                action: 'contentDialog',\n                content: dojo.hitch(this, '_trackDetailsContent')\n            }, { label: 'Pin to top',\n                type: 'dijit/CheckedMenuItem',\n                title: \"make this track always visible at the top of the view\",\n                checked: that.isPinned(),\n                //iconClass: 'dijitIconDelete',\n                onClick: function onClick() {\n                    that.browser.publish('/jbrowse/v1/v/tracks/' + (this.checked ? 'pin' : 'unpin'), [that.name]);\n                }\n            }, { label: 'Edit config',\n                title: \"edit this track's configuration\",\n                iconClass: 'dijitIconConfigure',\n                action: function action() {\n                    new TrackConfigEditor(that.config).show(function (result) {\n                        // replace this track's configuration\n                        that.browser.publish('/jbrowse/v1/v/tracks/replace', [result.conf]);\n                    });\n                }\n            }, { label: 'Delete track',\n                title: \"delete this track\",\n                iconClass: 'dijitIconDelete',\n                action: function action() {\n                    new ConfirmDialog({ title: 'Delete track?', message: 'Really delete this track?' }).show(function (confirmed) {\n                        if (confirmed) that.browser.publish('/jbrowse/v1/v/tracks/delete', [that.config]);\n                    });\n                }\n            }];\n        },\n\n        _processMenuSpec: function _processMenuSpec(spec, context) {\n            for (var x in spec) {\n                if (spec.hasOwnProperty(x)) {\n                    if (_typeof(spec[x]) == 'object') spec[x] = this._processMenuSpec(spec[x], context);else spec[x] = this.template(context.feature, this._evalConf(context, spec[x], x));\n                }\n            }\n            return spec;\n        },\n\n        /**\n         * Get the value of a conf variable, evaluating it if it is a\n         * function.  Note: does not template it, that is a separate step.\n         *\n         * @private\n         */\n        _evalConf: function _evalConf(context, confVal, confKey) {\n\n            // list of conf vals that should not be run immediately on the\n            // feature data if they are functions\n            var dontRunImmediately = {\n                action: 1,\n                click: 1,\n                content: 1\n            };\n\n            return typeof confVal == 'function' && !dontRunImmediately[confKey] ? confVal.apply(context, context.callbackArgs || []) : confVal;\n        },\n\n        /**\n         * Like getConf, but get a conf value that explicitly can vary\n         * feature by feature.  Provides a uniform function signature for\n         * user-defined callbacks.\n         */\n        getConfForFeature: function getConfForFeature(path, feature) {\n            return this.getConf(path, [feature, path, null, null, this]);\n        },\n\n        isFeatureHighlighted: function isFeatureHighlighted(feature, name) {\n            var highlight = this.browser.getHighlight();\n            return highlight && highlight.objectName && highlight.objectName == name && highlight.ref == this.refSeq.name && !(feature.get('start') > highlight.end || feature.get('end') < highlight.start);\n        },\n\n        _openDialog: function _openDialog(spec, evt, context) {\n            context = context || {};\n            var type = spec.action;\n            type = type.replace(/Dialog/, '');\n            var featureName = context.feature && (context.feature.get('name') || context.feature.get('id'));\n            var dialogOpts = {\n                \"class\": \"popup-dialog popup-dialog-\" + type,\n                title: spec.title || spec.label || (featureName ? featureName + ' details' : \"Details\"),\n                style: dojo.clone(spec.style || {})\n            };\n            if (spec.dialog) declare.safeMixin(dialogOpts, spec.dialog);\n\n            var dialog;\n\n            function setContent(dialog, content) {\n                // content can be a promise or Deferred\n                if (typeof content.then == 'function') content.then(function (c) {\n                    dialog.set('content', c);\n                });\n                // or maybe it's just a regular object\n                else dialog.set('content', content);\n            }\n\n            // if dialog == xhr, open the link in a dialog\n            // with the html from the URL just shoved in it\n            if (type == 'xhr' || type == 'content') {\n                if (type == 'xhr') dialogOpts.href = spec.url;\n\n                dialog = new InfoDialog(dialogOpts);\n                context.dialog = dialog;\n\n                if (type == 'content') setContent(dialog, this._evalConf(context, spec.content, null));\n\n                Util.removeAttribute(context, 'dialog');\n            } else if (type == 'bare') {\n                dialog = new Dialog(dialogOpts);\n                context.dialog = dialog;\n\n                setContent(dialog, this._evalConf(context, spec.content, null));\n\n                Util.removeAttribute(context, 'dialog');\n            }\n            // open the link in a dialog with an iframe\n            else if (type == 'iframe') {\n                    var iframeDims = function () {\n                        var d = domGeom.position(this.browser.container);\n                        return { h: Math.round(d.h * 0.8), w: Math.round(d.w * 0.8) };\n                    }.call(this);\n\n                    dialog = new Dialog(dialogOpts);\n\n                    var iframe = dojo.create('iframe', {\n                        tabindex: \"0\",\n                        width: iframeDims.w,\n                        height: iframeDims.h,\n                        style: { border: 'none' },\n                        src: spec.url\n                    });\n\n                    dialog.set('content', iframe);\n                    if (!spec.hideIframeDialogUrl) {\n                        dojo.create('a', {\n                            href: spec.url,\n                            target: '_blank',\n                            className: 'dialog-new-window',\n                            title: 'open in new window',\n                            onclick: dojo.hitch(dialog, 'hide'),\n                            innerHTML: spec.url\n                        }, dialog.titleBar);\n                    }\n                    var updateIframeSize = function updateIframeSize() {\n                        // hitch a ride on the dialog box's\n                        // layout function, which is called on\n                        // initial display, and when the window\n                        // is resized, to keep the iframe\n                        // sized to fit exactly in it.\n                        var cDims = domGeom.position(dialog.containerNode);\n                        var width = cDims.w;\n                        var height = cDims.h - domGeom.position(dialog.titleBar).h;\n                        iframe.width = width;\n                        iframe.height = height;\n                    };\n                    aspect.after(dialog, 'layout', updateIframeSize);\n                    aspect.after(dialog, 'show', updateIframeSize);\n                }\n\n            // destroy the dialog after it is hidden\n            aspect.after(dialog, 'hide', function () {\n                setTimeout(function () {\n                    dialog.destroyRecursive();\n                }, 500);\n            });\n\n            // show the dialog\n            dialog.show();\n        },\n\n        /**\n         * Given a string with template callouts, interpolate them with\n         * data from the given object.  For example, \"{foo}\" is replaced\n         * with whatever is returned by obj.get('foo')\n         */\n        template: function template( /** Object */obj, /** String */_template) {\n            if (typeof _template != 'string' || !obj) return _template;\n\n            var valid = true;\n            if (_template) {\n                return _template.replace(/\\{([^}]+)\\}/g, function (match, group) {\n                    var val = obj ? obj.get(group.toLowerCase()) : undefined;\n                    if (val !== undefined) return val;else {\n                        return '';\n                    }\n                });\n            }\n            return undefined;\n        },\n\n        /**\n         * Makes and installs the dropdown menu showing operations available for this track.\n         * @private\n         */\n        makeTrackMenu: function makeTrackMenu() {\n            var thisB = this;\n            when(this._trackMenuOptions()).then(function (options) {\n                if (options && options.length && thisB.label && thisB.labelMenuButton) {\n\n                    // remove our old track menu if we have one\n                    if (thisB.trackMenu) thisB.trackMenu.destroyRecursive();\n\n                    // render and bind our track menu\n                    var menu = thisB._renderContextMenu(options, { menuButton: thisB.labelMenuButton, track: thisB, browser: thisB.browser, refSeq: thisB.refSeq });\n                    menu.startup();\n                    menu.set('leftClickToOpen', true);\n                    menu.bindDomNode(thisB.labelMenuButton);\n                    menu.set('leftClickToOpen', false);\n                    menu.bindDomNode(thisB.label);\n                    thisB.trackMenu = menu;\n                    thisB.own(thisB.trackMenu);\n                }\n            });\n        },\n\n        // display a rendering-timeout message\n        fillBlockTimeout: function fillBlockTimeout(blockIndex, block) {\n            domConstruct.empty(block.domNode);\n            domClass.add(block.domNode, 'timed_out');\n            this.fillMessage(blockIndex, block, 'This region took too long' + ' to display, possibly because' + ' it contains too much data.' + ' Try zooming in to show a smaller region.');\n        },\n\n        renderRegionBookmark: function renderRegionBookmark(args, bookmarks, renderLabels) {\n            var thisB = this;\n            if (bookmarks.then) {\n                bookmarks.then(function (books) {\n                    array.forEach(books.features, function (bookmark) {\n                        if (bookmark.ref != this.refSeq.name) return;\n                        var loc = new Location(bookmark.refseq + \":\" + bookmark.start + \"..\" + bookmark.end);\n                        this.renderRegionHighlight(args, loc, bookmark.color, renderLabels ? bookmark.label : null, renderLabels ? bookmark.rlabel : null);\n                    }, thisB);\n                }, function (error) {\n                    console.log(\"Couldn't get bookmarks\");\n                });\n            } else {\n                array.forEach(bookmarks.features, function (bookmark) {\n                    if (bookmark.ref != this.refSeq.name) return;\n                    var loc = new Location(bookmark.refseq + \":\" + bookmark.start + \"..\" + bookmark.end);\n                    this.renderRegionHighlight(args, loc, bookmark.color, renderLabels ? bookmark.label : null, renderLabels ? bookmark.rlabel : null);\n                }, this);\n            }\n        },\n\n        renderRegionHighlight: function renderRegionHighlight(args, highlight, color, label, rlabel) {\n            // do nothing if the highlight does not overlap this region\n            if (highlight.start > args.rightBase || highlight.end < args.leftBase) return;\n\n            var block_span = args.rightBase - args.leftBase;\n\n            var left = highlight.start;\n            var right = highlight.end;\n\n            // trim left and right to avoid making a huge element that can cause problems\n            var trimLeft = args.leftBase - left;\n            if (trimLeft > 0) {\n                left += trimLeft;\n            }\n            var trimRight = right - args.rightBase;\n            if (trimRight > 0) {\n                right -= trimRight;\n            }\n\n            var width = (right - left) * 100 / block_span;\n            left = (left - args.leftBase) * 100 / block_span;\n            var highlight = domConstruct.create('div', {\n                className: (color ? 'global_highlight_mod' : 'global_highlight') + (trimLeft <= 0 ? ' left' : '') + (trimRight <= 0 ? ' right' : ''),\n                style: {\n                    left: left + '%',\n                    width: width + '%',\n                    height: '100%',\n                    background: color\n                }\n            }, args.block.domNode);\n\n            this.postRenderHighlight(highlight);\n\n            if (label) {\n                /*\n                //  vertical text, has bugs\n                if( trimLeft <= 0 ) {\n                    domConstruct.create('div', { className:'verticaltext', style: { top: '50px', left: left+'%',transformOrigin: left+'%'+' top' }, innerHTML: label }, args.block.domNode);\n                }\n                if( trimRight <= 0 ) {\n                    domConstruct.create('div', { className:'verticaltext', style: { top: '50px', left: left+width+'%',transformOrigin: left+width+'%'+' top' }, innerHTML: rlabel }, args.block.domNode);\n                }*/\n                if (trimLeft <= 0) {\n                    var d1 = domConstruct.create('div', { className: 'horizontaltext', style: { background: 'white', zIndex: 1000, left: left + '%' }, innerHTML: label }, args.block.domNode);\n                }\n                if (trimRight <= 0) {\n                    var d2 = domConstruct.create('div', { className: 'horizontaltext', style: { background: 'white', zIndex: 1000, left: left + width + '%' }, innerHTML: rlabel }, args.block.domNode);\n                }\n\n                var textWidth = d1.clientWidth + 1 + \"px\";\n                d1.style.left = 'calc(' + left + '% - ' + textWidth + ')';\n            }\n        },\n        postRenderHighlight: function postRenderHighlight(node) {}\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*\n\nCopyright (c) 2007-2009 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/BlockBased.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/BlockBased/Block.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/View/Track/BlockBased/Block.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dijit/Destroyable */ \"./node_modules/dijit/Destroyable.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Destroyable, Util) {\n    return declare(Destroyable, {\n\n        constructor: function constructor(args) {\n            dojo.mixin(this, args);\n            var nodeArgs = this.node || {};\n            delete this.node;\n            this.domNode = dojo.create('div', nodeArgs);\n            this.domNode.block = this;\n        },\n\n        containsBp: function containsBp(bp) {\n            return this.startBase <= bp && this.endBase >= bp;\n        },\n\n        bpToX: function bpToX(coord) {\n            //console.log(coord+\" \"+this.startBase+\" \"+this.scale+\" \"+(coord-this.startBase)*this.scale);\n            return (coord - this.startBase) * this.scale;\n        },\n\n        toString: function toString() {\n            return this.startBase + '..' + this.endBase;\n        },\n\n        destroy: function destroy() {\n            if (this.domNode) Util.removeAttribute(this.domNode, 'block');\n            this.inherited(arguments);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/BlockBased/Block.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/CanvasFeatures.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/Track/CanvasFeatures.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Feature track that draws features using HTML5 canvas elements.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/event */ \"./node_modules/dojo/_base/event.js\"), __webpack_require__(/*! dojo/mouse */ \"./node_modules/dojo/mouse.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/GranularRectLayout */ \"./src/JBrowse/View/GranularRectLayout.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\"), __webpack_require__(/*! JBrowse/View/Track/_ExportMixin */ \"./src/JBrowse/View/Track/_ExportMixin.js\"), __webpack_require__(/*! JBrowse/Errors */ \"./src/JBrowse/Errors.js\"), __webpack_require__(/*! JBrowse/View/Track/_FeatureDetailMixin */ \"./src/JBrowse/View/Track/_FeatureDetailMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_FeatureContextMenusMixin */ \"./src/JBrowse/View/Track/_FeatureContextMenusMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_YScaleMixin */ \"./src/JBrowse/View/Track/_YScaleMixin.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\"), __webpack_require__(/*! JBrowse/Model/SimpleFeature */ \"./src/JBrowse/Model/SimpleFeature.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, domEvent, mouse, domConstruct, Deferred, on, has, Util, Layout, BlockBasedTrack, ExportMixin, Errors, FeatureDetailMixin, FeatureContextMenuMixin, YScaleMixin, Location, SimpleFeature) {\n\n    /**\n     *  inner class that indexes feature layout rectangles (fRects) (which\n     *  include features) by unique ID.\n     *\n     *  We have one of these indexes in each block.\n     */\n    var FRectIndex = declare(null, {\n        constructor: function constructor(args) {\n            var height = args.h;\n            var width = args.w;\n\n            this.dims = { h: height, w: width };\n\n            this.byID = {};\n        },\n\n        getByID: function getByID(id) {\n            return this.byID[id];\n        },\n\n        addAll: function addAll(fRects) {\n            var byID = this.byID;\n            var cW = this.dims.w;\n            var cH = this.dims.h;\n            array.forEach(fRects, function (fRect) {\n                if (!fRect) return;\n\n                // by ID\n                byID[fRect.f.id()] = fRect;\n            }, this);\n        },\n\n        getAll: function getAll() {\n            var fRects = [];\n            for (var id in this.byID) {\n                fRects.push(this.byID[id]);\n            }\n            return fRects;\n        }\n    });\n\n    return declare([BlockBasedTrack, FeatureDetailMixin, ExportMixin, FeatureContextMenuMixin, YScaleMixin], {\n\n        constructor: function constructor(args) {\n            this.glyphsLoaded = {};\n            this.glyphsBeingLoaded = {};\n            this.regionStats = {};\n            this.showLabels = this.config.style.showLabels;\n            this.showTooltips = this.config.style.showTooltips;\n            this.displayMode = this.config.displayMode;\n            //setup displayMode style cookie\n            var cookie = this.browser.cookie(\"track-\" + this.name);\n            if (cookie) {\n                this.displayMode = cookie;\n            }\n\n            this._setupEventHandlers();\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(lang.clone(this.inherited(arguments)), {\n                maxFeatureScreenDensity: 0.5,\n                enableCollapsedMouseover: false,\n                disableCollapsedClick: false,\n\n                // default glyph class to use\n                glyph: lang.hitch(this, 'guessGlyphType'),\n\n                // maximum number of pixels on each side of a\n                // feature's bounding coordinates that a glyph is\n                // allowed to use\n                maxFeatureGlyphExpansion: 500,\n\n                // maximum height of the track, in pixels\n                maxHeight: 600,\n\n                histograms: {\n                    description: 'feature density',\n                    min: 0,\n                    height: 100,\n                    color: 'goldenrod',\n                    clip_marker_color: 'red'\n                },\n\n                style: {\n                    // not configured by users\n                    _defaultHistScale: 4,\n                    _defaultLabelScale: 30,\n                    _defaultDescriptionScale: 120,\n\n                    showLabels: true,\n                    showTooltips: true,\n                    label: 'name,id',\n                    description: 'note, description'\n                },\n\n                displayMode: 'normal',\n\n                events: {\n                    contextmenu: function contextmenu(feature, fRect, block, track, evt) {\n                        evt = domEvent.fix(evt);\n                        if (fRect && fRect.contextMenu) fRect.contextMenu._openMyself({ target: block.featureCanvas, coords: { x: evt.pageX, y: evt.pageY } });\n                        domEvent.stop(evt);\n                    }\n                },\n\n                menuTemplate: [{ label: 'View details',\n                    title: '{type} {name}',\n                    action: 'contentDialog',\n                    iconClass: 'dijitIconTask',\n                    content: dojo.hitch(this, 'defaultFeatureDetail')\n                }, {\n                    \"label\": function label() {\n                        return 'Zoom to this ' + (this.feature.get('type') || 'feature');\n                    },\n                    \"action\": function action() {\n                        var ref = this.track.refSeq;\n                        var paddingBp = Math.round(10 /*pixels*/ / this.viewInfo.scale /* px/bp */);\n                        var start = Math.max(ref.start, this.feature.get('start') - paddingBp);\n                        var end = Math.min(ref.end, this.feature.get('end') + paddingBp);\n                        this.track.genomeView.setLocation(ref, start, end);\n                    },\n                    \"iconClass\": \"dijitIconConnector\"\n                }, {\n                    label: function label() {\n                        return 'Highlight this ' + (this.feature.get('type') || 'feature');\n                    },\n                    action: function action() {\n                        var loc = new Location({ feature: this.feature, tracks: [this.track] });\n                        this.track.browser.setHighlightAndRedraw(loc);\n                    },\n                    iconClass: 'dijitIconFilter'\n                }]\n            });\n        },\n\n        setViewInfo: function setViewInfo(genomeView, heightUpdate, numBlocks, trackDiv, widthPct, widthPx, scale) {\n            this.inherited(arguments);\n            this.staticCanvas = domConstruct.create('canvas', { className: 'static-canvas', style: { height: \"100%\", cursor: \"default\", position: \"absolute\", zIndex: 15 } }, trackDiv);\n            var ctx = this.staticCanvas.getContext('2d');\n            var ratio = Util.getResolution(ctx, this.browser.config.highResolutionMode);\n            this.staticCanvas.height = this.staticCanvas.offsetHeight * ratio;\n\n            this._makeLabelTooltip();\n        },\n\n        guessGlyphType: function guessGlyphType(feature) {\n            // first try to guess by its SO type\n            var guess = {\n                'gene': 'Gene',\n                'mRNA': 'ProcessedTranscript',\n                'transcript': 'ProcessedTranscript',\n                'ncRNA': 'UnprocessedTranscript',\n                'lncRNA': 'UnprocessedTranscript',\n                'lnc_RNA': 'UnprocessedTranscript',\n                'miRNA': 'UnprocessedTranscript'\n            }[feature.get('type')];\n\n            // otherwise, make it Segments if it has children,\n            // a BED if it has block_count/thick_start,\n            // or a Box otherwise\n            if (!guess) {\n                var children = feature.children();\n                if (children && children.length) guess = 'Segments';else if (feature.get('block_count') || feature.get('thick_start')) guess = 'UCSC/BED';else guess = 'Box';\n            }\n\n            return 'JBrowse/View/FeatureGlyph/' + guess;\n        },\n\n        fillBlock: function fillBlock(args) {\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n            var scale = args.scale;\n\n            if (!has('canvas')) {\n                this.fatalError = 'This browser does not support HTML canvas elements.';\n                this.fillBlockError(blockIndex, block, this.fatalError);\n                return;\n            }\n\n            var fill = lang.hitch(this, function (stats) {\n\n                // calculate some additional view parameters that\n                // might depend on the feature stats and add them to\n                // the view args we pass down\n                var renderArgs = lang.mixin({\n                    stats: stats,\n                    displayMode: this.displayMode,\n                    showFeatures: scale >= (this.config.style.featureScale || (stats.featureDensity || 0) / this.config.maxFeatureScreenDensity),\n                    showLabels: this.showLabels && this.displayMode == \"normal\" && scale >= (this.config.style.labelScale || (stats.featureDensity || 0) * this.config.style._defaultLabelScale),\n                    showDescriptions: this.showLabels && this.displayMode == \"normal\" && scale >= (this.config.style.descriptionScale || (stats.featureDensity || 0) * this.config.style._defaultDescriptionScale)\n                }, args);\n\n                if (renderArgs.showFeatures) {\n                    this.setLabel(this.key);\n                    this.removeYScale();\n                    this.noYScale = true;\n                    this.fillFeatures(renderArgs);\n                } else if (this.config.histograms.store || this.store.getRegionFeatureDensities) {\n                    this.noYScale = false;\n                    this.fillHistograms(renderArgs);\n                } else {\n                    this.setLabel(this.key);\n                    this.fillTooManyFeaturesMessage(blockIndex, block, scale);\n                    args.finishCallback();\n                }\n            });\n\n            this.store.getGlobalStats(fill, dojo.hitch(this, function (e) {\n                this._handleError(e, args);\n                args.finishCallback(e);\n            }));\n        },\n\n        // override the base error handler to try to draw histograms if\n        // it's a data overflow error and we know how to draw histograms\n        _handleError: function _handleError(error, viewArgs) {\n\n            if ((typeof error === 'undefined' ? 'undefined' : _typeof(error)) == 'object' && error instanceof Errors.DataOverflow && (this.config.histograms.store || this.store.getRegionFeatureDensities)) {\n                this.fillHistograms(viewArgs);\n            } else this.inherited(arguments);\n        },\n\n        // create the layout if we need to, and if we can\n        _getLayout: function _getLayout(scale) {\n            if (!this.layout || this._layoutpitchX != 1 / scale) {\n                // if no layoutPitchY configured, calculate it from the\n                // height and marginBottom (parseInt in case one or both are functions), or default to 3 if the\n                // calculation didn't result in anything sensible.\n                var pitchY = this.getConf('layoutPitchY') || 4;\n                this.layout = new Layout({ pitchX: 1 / scale, pitchY: pitchY, maxHeight: this.getConf('maxHeight'), displayMode: this.displayMode });\n                this._layoutpitchX = 1 / scale;\n            }\n\n            return this.layout;\n        },\n\n        _clearLayout: function _clearLayout() {\n            delete this.layout;\n        },\n\n        hideAll: function hideAll() {\n            this._clearLayout();\n            return this.inherited(arguments);\n        },\n\n        /**\n         * Returns a promise for the appropriate glyph for the given\n         * feature and args.\n         */\n        getGlyph: function getGlyph(viewArgs, feature, callback, errorCallback) {\n            var glyphClassName = this.getConfForFeature('glyph', feature);\n            var glyph, interestedParties;\n            if (glyph = this.glyphsLoaded[glyphClassName]) {\n                callback(glyph);\n            } else if (interestedParties = this.glyphsBeingLoaded[glyphClassName]) {\n                interestedParties.push(callback);\n            } else {\n                var thisB = this;\n                this.glyphsBeingLoaded[glyphClassName] = [callback];\n\n                dojo.global.require([glyphClassName], function (GlyphClass) {\n                    if (typeof GlyphClass == 'string') {\n                        thisB.fatalError = \"could not load glyph \" + glyphClassName;\n                        thisB.redraw();\n                        return;\n                    }\n                    // if this require came back after we are already destroyed, just ignore it\n                    if (thisB.destroyed) return;\n\n                    glyph = thisB.glyphsLoaded[glyphClassName] = new GlyphClass({ track: thisB, config: thisB.config, browser: thisB.browser });\n\n                    array.forEach(thisB.glyphsBeingLoaded[glyphClassName], function (cb) {\n                        cb(glyph);\n                    });\n\n                    delete thisB.glyphsBeingLoaded[glyphClassName];\n                });\n            }\n        },\n\n        fillHistograms: function fillHistograms(args) {\n            var _this = this;\n\n            // set the track label if we have a description\n            if (this.config.histograms.description) {\n                this.setLabel(this.key + ' <span class=\"feature-density\">(' + this.config.histograms.description + ')</span>');\n            } else {\n                this.setLabel(this.key);\n            }\n\n            var numBins = this.config.histograms.binsPerBlock || 25;\n            var blockSizeBp = Math.abs(args.rightBase - args.leftBase);\n            var basesPerBin = blockSizeBp / numBins;\n            var query = {\n                ref: this.refSeq.name,\n                start: args.leftBase,\n                end: args.rightBase,\n                basesPerSpan: basesPerBin,\n                basesPerBin: basesPerBin,\n                viewAsPairs: this.config.viewAsPairs,\n                viewAsSpans: this.config.viewAsSpans,\n                maxInsertSize: this.config.maxInsertSize\n            };\n\n            var handleError = this._handleError.bind(this);\n            if (!this.config.histograms.store && this.store.getRegionFeatureDensities) {\n                this.store.getRegionFeatureDensities(query, this._drawHistograms.bind(this, args), function (e) {\n                    console.log(e);\n                    _this._handleError(new Error(e.message), args);\n                });\n            } else {\n                var histData = { features: [], stats: {} };\n                this.browser.getStore(this.config.histograms.store, function (histStore) {\n                    histStore.getGlobalStats(function (stats) {\n                        histData.stats.max = stats.scoreMax;\n                        histStore.getFeatures(query, function (feature) {\n                            histData.features.push(feature);\n                        }, function () {\n                            _this._drawHistograms(args, histData);\n                            args.finishCallback();\n                        }, handleError);\n                    }, handleError);\n                });\n            }\n        },\n\n        _scaleCanvas: function _scaleCanvas(c) {\n            var pxWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : c.width;\n            var pxHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : c.height;\n\n            var ctx = c.getContext('2d');\n\n            var ratio = Util.getResolution(ctx, this.browser.config.highResolutionMode);\n\n            c.width = pxWidth * ratio;\n            c.height = pxHeight * ratio;\n\n            c.style.width = pxWidth + 'px';\n            c.style.height = pxHeight + 'px';\n\n            // now scale the context to counter\n            // the fact that we've manually scaled\n            // our canvas element\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.scale(ratio, ratio);\n        },\n\n\n        _drawHistograms: function _drawHistograms(viewArgs, histData) {\n            if (this.noYScale) {\n                return;\n            }\n\n            var maxScore = 'max' in this.config.histograms ? this.config.histograms.max : (histData.stats || {}).max;\n\n            // don't do anything if we don't know the score max\n            if (maxScore === undefined) {\n                console.warn('no stats.max in hist data, not drawing histogram for block ' + viewArgs.blockIndex);\n                return;\n            }\n\n            // don't do anything if we have no hist features\n            var features;\n            if (!((features = histData.features) || histData.bins && (features = this._histBinsToFeatures(viewArgs, histData)))) return;\n\n            var block = viewArgs.block;\n            var height = this.config.histograms.height;\n            var scale = viewArgs.scale;\n            var leftBase = viewArgs.leftBase;\n            var minVal = this.config.histograms.min;\n\n            domConstruct.empty(block.domNode);\n            var c = block.featureCanvas = domConstruct.create('canvas', { height: height,\n                width: block.domNode.offsetWidth + 1,\n                style: {\n                    cursor: 'default',\n                    height: height + 'px',\n                    position: 'absolute'\n                },\n                innerHTML: 'Your web browser cannot display this type of track.',\n                className: 'canvas-track canvas-track-histograms'\n            }, block.domNode);\n            this.heightUpdate(height, viewArgs.blockIndex);\n            var ctx = c.getContext('2d');\n\n            // scale the canvas to work well with the various device pixel ratios\n            this._scaleCanvas(c);\n\n            ctx.fillStyle = this.config.histograms.color;\n            for (var i = 0; i < features.length; i++) {\n                var feature = features[i];\n                var barHeight = feature.get('score') / maxScore * height;\n                var barWidth = Math.ceil((feature.get('end') - feature.get('start')) * scale);\n                var barLeft = Math.round((feature.get('start') - leftBase) * scale);\n                ctx.fillRect(barLeft, height - barHeight, barWidth, barHeight);\n                if (barHeight > height) {\n                    ctx.fillStyle = this.config.histograms.clip_marker_color;\n                    ctx.fillRect(barLeft, 0, barWidth, 3);\n                    ctx.fillStyle = this.config.histograms.color;\n                }\n            }\n\n            // make the y-axis scale for our histograms\n            this.makeHistogramYScale(height, minVal, maxScore);\n        },\n\n        _histBinsToFeatures: function _histBinsToFeatures(viewArgs, histData) {\n            var bpPerBin = parseFloat(histData.stats.basesPerBin);\n            var leftBase = viewArgs.leftBase;\n\n            return array.map(histData.bins, function (bin, i) {\n                return new SimpleFeature({ data: {\n                        start: leftBase + i * bpPerBin,\n                        end: leftBase + (i + 1) * bpPerBin,\n                        score: bin\n                    } });\n            });\n        },\n\n        makeHistogramYScale: function makeHistogramYScale(height, minVal, maxVal) {\n            if (this.yscale_params && this.yscale_params.height == height && this.yscale_params.max == maxVal && this.yscale_params.min == minVal) return;\n\n            this.yscale_params = { height: height, min: minVal, max: maxVal };\n            this.makeYScale({ min: minVal, max: maxVal });\n        },\n\n        fillFeatures: function fillFeatures(args) {\n            var _this2 = this;\n\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var blockWidthPx = block.domNode.offsetWidth;\n            var scale = args.scale;\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n            var finishCallback = args.finishCallback;\n\n            var fRects = [];\n\n            // count of how many features are queued up to be laid out\n            var featuresInProgress = 0;\n            // promise that resolved when all the features have gotten laid out by their glyphs\n            var featuresLaidOut = new Deferred();\n            // flag that tells when all features have been read from the\n            // store (not necessarily laid out yet)\n            var allFeaturesRead = false;\n\n            var errorCallback = function errorCallback(e) {\n                _this2._handleError(e, args);\n                finishCallback(e);\n            };\n\n            var layout = this._getLayout(scale);\n\n            // query for a slightly larger region than the block, so that\n            // we can draw any pieces of glyphs that overlap this block,\n            // but the feature of which does not actually lie in the block\n            // (long labels that extend outside the feature's bounds, for\n            // example)\n            var bpExpansion = Math.round(this.config.maxFeatureGlyphExpansion / scale);\n\n            var region = {\n                ref: this.refSeq.name,\n                start: Math.max(0, leftBase - bpExpansion),\n                end: rightBase + bpExpansion,\n                viewAsPairs: this.config.viewAsPairs,\n                viewAsSpans: this.config.viewAsSpans,\n                maxInsertSize: this.config.maxInsertSize\n            };\n\n            var featCallback = function featCallback(feature) {\n                if (_this2.destroyed || !_this2.filterFeature(feature)) return;\n                fRects.push(null); // put a placeholder in the fRects array\n                featuresInProgress++;\n                var rectNumber = fRects.length - 1;\n\n                // get the appropriate glyph object to render this feature\n                _this2.getGlyph(args, feature, function (glyph) {\n                    // have the glyph attempt\n                    // to add a rendering of\n                    // this feature to the\n                    // layout\n                    var fRect = glyph.layoutFeature(args, layout, feature);\n                    if (fRect === null) {\n                        // could not lay out, would exceed our configured maxHeight\n                        // mark the block as exceeding the max height\n                        block.maxHeightExceeded = true;\n                    } else {\n                        // laid out successfully\n                        if (!(fRect.l >= blockWidthPx || fRect.l + fRect.w < 0)) fRects[rectNumber] = fRect;\n                    }\n\n                    // this might happen after all the features have been sent from the store\n                    if (! --featuresInProgress && allFeaturesRead) {\n                        featuresLaidOut.resolve();\n                    }\n                }, errorCallback);\n            };\n\n            this.store.getFeatures(region, featCallback,\n            // callback when all features sent\n            function () {\n                if (_this2.destroyed) return;\n\n                allFeaturesRead = true;\n                if (!featuresInProgress && !featuresLaidOut.isFulfilled()) {\n                    featuresLaidOut.resolve();\n                }\n\n                featuresLaidOut.then(function () {\n                    var totalHeight = layout.getTotalHeight();\n                    var c = block.featureCanvas = domConstruct.create('canvas', { height: totalHeight,\n                        width: block.domNode.offsetWidth + 1,\n                        style: {\n                            cursor: 'default',\n                            height: totalHeight + 'px',\n                            position: 'absolute'\n                        },\n                        innerHTML: 'Your web browser cannot display this type of track.',\n                        className: 'canvas-track'\n                    }, block.domNode);\n                    var ctx = c.getContext('2d');\n                    // scale the canvas to work well with the various device pixel ratios\n                    _this2._scaleCanvas(c);\n\n                    if (block.maxHeightExceeded) _this2.markBlockHeightOverflow(block);\n\n                    _this2.heightUpdate(totalHeight, blockIndex);\n\n                    _this2.renderFeatures(args, fRects);\n\n                    _this2.renderClickMap(args, fRects);\n\n                    finishCallback();\n                });\n            }, errorCallback);\n        },\n\n        startZoom: function startZoom() {\n            this.zooming = true;\n            this.inherited(arguments);\n\n            array.forEach(this.blocks, function (b) {\n                try {\n                    b.featureCanvas.style.width = '100%';\n                } catch (e) {};\n            });\n        },\n\n        endZoom: function endZoom() {\n            array.forEach(this.blocks, function (b) {\n                try {\n                    delete b.featureCanvas.style.width;\n                } catch (e) {};\n            });\n\n            this.clear();\n            this.inherited(arguments);\n            this.zooming = false;\n        },\n\n        renderClickMap: function renderClickMap(args, fRects) {\n            var block = args.block;\n\n            // make an index of the fRects by ID, and by coordinate, and\n            // store it in the block\n            var index = new FRectIndex({ h: block.featureCanvas.height, w: block.featureCanvas.width });\n            block.fRectIndex = index;\n            index.addAll(fRects);\n\n            if (!block.featureCanvas || !block.featureCanvas.getContext('2d')) {\n                console.warn(\"No 2d context available from canvas\");\n                return;\n            }\n\n            this._attachMouseOverEvents();\n            if (this.displayMode != 'collapsed' || !this.config.disableCollapsedClick) {\n                // connect up the event handlers\n                this._connectEventHandlers(block);\n            }\n\n            this.updateStaticElements({ x: this.browser.view.getX() });\n        },\n\n        _attachMouseOverEvents: function _attachMouseOverEvents() {\n            var gv = this.browser.view;\n            var thisB = this;\n\n            if (this.displayMode == 'collapsed' && !this.config.enableCollapsedMouseover) {\n                if (this._mouseoverEvent) {\n                    this._mouseoverEvent.remove();\n                    delete this._mouseoverEvent;\n                }\n\n                if (this._mouseoutEvent) {\n                    this._mouseoutEvent.remove();\n                    delete this._mouseoutEvent;\n                }\n            } else if (this.displayMode != 'collapsed' || this.config.enableCollapsedMouseover) {\n                if (!this._mouseoverEvent) {\n                    this._mouseoverEvent = this.own(on(this.staticCanvas, 'mousemove', function (evt) {\n                        evt = domEvent.fix(evt);\n                        var bpX = gv.absXtoBp(evt.clientX);\n                        var feature = thisB.layout.getByCoord(bpX, evt.offsetY === undefined ? evt.layerY : evt.offsetY);\n                        thisB.mouseoverFeature(feature, evt);\n                    }))[0];\n                }\n\n                if (!this._mouseoutEvent) {\n                    this._mouseoutEvent = this.own(on(this.staticCanvas, 'mouseout', function (evt) {\n                        thisB.mouseoverFeature(undefined);\n                    }))[0];\n                }\n            }\n        },\n\n        _makeLabelTooltip: function _makeLabelTooltip() {\n\n            if (!this.showTooltips || this.labelTooltip) return;\n\n            var labelTooltip = this.labelTooltip = domConstruct.create('div', {\n                className: 'featureTooltip',\n                style: {\n                    position: 'fixed',\n                    display: 'none',\n                    zIndex: 19\n                }\n            }, this.browser.container);\n            domConstruct.create('span', {\n                className: 'tooltipLabel',\n                style: {\n                    display: 'block'\n                }\n            }, labelTooltip);\n            domConstruct.create('span', {\n                className: 'tooltipDescription',\n                style: {\n                    display: 'block'\n                }\n            }, labelTooltip);\n        },\n\n        _connectEventHandlers: function _connectEventHandlers(block) {\n            for (var event in this.eventHandlers) {\n                var handler = this.eventHandlers[event];\n                (function (event, handler) {\n                    var thisB = this;\n                    block.own(on(this.staticCanvas, event, function (evt) {\n                        evt = domEvent.fix(evt);\n                        var bpX = thisB.browser.view.absXtoBp(evt.clientX);\n                        if (block.containsBp(bpX)) {\n                            var feature = thisB.layout.getByCoord(bpX, evt.offsetY === undefined ? evt.layerY : evt.offsetY);\n                            if (feature) {\n                                var fRect = block.fRectIndex.getByID(feature.id());\n                                handler.call({\n                                    track: thisB,\n                                    feature: feature,\n                                    fRect: fRect,\n                                    block: block,\n                                    callbackArgs: [thisB, feature, fRect]\n                                }, feature, fRect, block, thisB, evt);\n                            }\n                        }\n                    }));\n                }).call(this, event, handler);\n            }\n        },\n\n        getRenderingContext: function getRenderingContext(viewArgs) {\n            if (!viewArgs.block || !viewArgs.block.featureCanvas) return null;\n            try {\n                var ctx = viewArgs.block.featureCanvas.getContext('2d');\n                // ctx.translate( viewArgs.block.offsetLeft - this.featureCanvas.offsetLeft, 0 );\n                // console.log( viewArgs.blockIndex, 'block offset', viewArgs.block.offsetLeft - this.featureCanvas.offsetLeft );\n                return ctx;\n            } catch (e) {\n                console.error(e, e.stack);\n                return null;\n            }\n        },\n\n        // draw the features on the canvas\n        renderFeatures: function renderFeatures(args, fRects) {\n            var context = this.getRenderingContext(args);\n            if (context) {\n                var thisB = this;\n                array.forEach(fRects, function (fRect) {\n                    if (fRect) thisB.renderFeature(context, fRect);\n                });\n            }\n        },\n\n        // given viewargs and a feature object, highlight that feature in\n        // all blocks.  if feature is undefined or null, unhighlight any currently\n        // highlighted feature\n        mouseoverFeature: function mouseoverFeature(feature, evt) {\n\n            if (this.lastMouseover == feature) return;\n\n            if (evt) var bpX = this.browser.view.absXtoBp(evt.clientX);\n\n            if (this.labelTooltip) this.labelTooltip.style.display = 'none';\n\n            array.forEach(this.blocks, function (block, i) {\n                if (!block) return;\n                var context = this.getRenderingContext({ block: block, leftBase: block.startBase, scale: block.scale });\n                if (!context) return;\n\n                if (this.lastMouseover && block.fRectIndex) {\n                    var r = block.fRectIndex.getByID(this.lastMouseover.id());\n                    if (r) this.renderFeature(context, r);\n                }\n\n                if (block.tooltipTimeout) window.clearTimeout(block.tooltipTimeout);\n\n                if (feature) {\n                    var fRect = block.fRectIndex && block.fRectIndex.getByID(feature.id());\n                    if (!fRect) return;\n\n                    if (block.containsBp(bpX)) {\n                        var renderTooltip = dojo.hitch(this, function () {\n                            if (!this.labelTooltip) return;\n\n                            var context = lang.mixin({ track: this, feature: feature, callbackArgs: [this, feature] });\n                            var text;\n                            text = this.template(feature, this._evalConf(context, (this.config.onClick || {}).label, \"label\"));\n                            var label = fRect.label || fRect.glyph.makeFeatureLabel(feature, undefined, text);\n                            text = this.template(feature, this._evalConf(context, (this.config.onClick || {}).label, \"description\"));\n                            var description = fRect.description || fRect.glyph.makeFeatureDescriptionLabel(feature, undefined, text);\n\n                            if (!label && !description) return;\n\n                            if (!this.ignoreTooltipTimeout) {\n                                this.labelTooltip.style.left = evt.clientX + \"px\";\n                                this.labelTooltip.style.top = evt.clientY + 15 + \"px\";\n                            }\n                            this.ignoreTooltipTimeout = true;\n                            this.labelTooltip.style.display = 'block';\n                            var labelSpan = this.labelTooltip.childNodes[0];\n                            var descriptionSpan = this.labelTooltip.childNodes[1];\n\n                            if (this.config.onClick && this.config.onClick.label) {\n                                labelSpan.style.display = 'block';\n                                labelSpan.style.font = label.font;\n                                labelSpan.style.color = label.fill;\n                                var t = this.template(feature, this._evalConf(context, this.config.onClick.label, \"label\"));\n                                labelSpan.innerHTML = this.config.unsafeMouseover ? t : Util.escapeHTML(t);\n                                return;\n                            }\n                            if (label) {\n                                labelSpan.style.display = 'block';\n                                labelSpan.style.font = label.font;\n                                labelSpan.style.color = label.fill;\n                                labelSpan.innerHTML = this.config.unsafeMouseover ? label.text : Util.escapeHTML(label.text);\n                            } else {\n                                labelSpan.style.display = 'none';\n                                labelSpan.innerHTML = '(no label)';\n                            }\n                            if (description) {\n                                descriptionSpan.style.display = 'block';\n                                descriptionSpan.style.font = description.font;\n                                descriptionSpan.style.color = description.fill;\n                                descriptionSpan.innerHTML = this.config.unsafeMouseover ? description.text : Util.escapeHTML(description.text);\n                            } else {\n                                descriptionSpan.style.display = 'none';\n                                descriptionSpan.innerHTML = '(no description)';\n                            }\n                        });\n                        if (this.ignoreTooltipTimeout) renderTooltip();else block.tooltipTimeout = window.setTimeout(renderTooltip, 600);\n                    }\n\n                    fRect.glyph.mouseoverFeature(context, fRect);\n                    this._refreshContextMenu(fRect);\n                } else {\n                    block.tooltipTimeout = window.setTimeout(dojo.hitch(this, function () {\n                        this.ignoreTooltipTimeout = false;\n                    }), 200);\n                }\n            }, this);\n\n            this.lastMouseover = feature;\n        },\n\n        cleanupBlock: function cleanupBlock(block) {\n            this.inherited(arguments);\n\n            // garbage collect the layout\n            if (block && this.layout) this.layout.discardRange(block.startBase, block.endBase);\n        },\n\n        // draw each feature\n        renderFeature: function renderFeature(context, fRect) {\n            fRect.glyph.renderFeature(context, fRect);\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var opts = this.inherited(arguments);\n            var thisB = this;\n\n            var displayModeList = [\"normal\", \"compact\", \"collapsed\"];\n            this.displayModeMenuItems = displayModeList.map(function (displayMode) {\n                return {\n                    label: displayMode,\n                    type: 'dijit/CheckedMenuItem',\n                    title: \"Render this track in \" + displayMode + \" mode\",\n                    checked: thisB.displayMode == displayMode,\n                    onClick: function onClick() {\n                        thisB.displayMode = displayMode;\n                        thisB._clearLayout();\n                        thisB.hideAll();\n                        thisB.genomeView.showVisibleBlocks(true);\n                        thisB.makeTrackMenu();\n                        // set cookie for displayMode\n                        thisB.browser.cookie('track-' + thisB.name, thisB.displayMode);\n                    }\n                };\n            });\n\n            var updateMenuItems = dojo.hitch(this, function () {\n                for (var index in this.displayModeMenuItems) {\n                    this.displayModeMenuItems[index].checked = this.displayMode == this.displayModeMenuItems[index].label;\n                }\n            });\n\n            opts.push.apply(opts, [{ type: 'dijit/MenuSeparator' }, {\n                label: \"Display mode\",\n                iconClass: \"dijitIconPackage\",\n                title: \"Make features take up more or less space\",\n                children: this.displayModeMenuItems\n            }, { label: 'Show labels',\n                type: 'dijit/CheckedMenuItem',\n                checked: !!('showLabels' in this ? this.showLabels : this.config.style.showLabels),\n                onClick: function onClick(event) {\n                    thisB.showLabels = this.checked;\n                    thisB.changed();\n                }\n            }]);\n\n            return opts;\n        },\n\n        _exportFormats: function _exportFormats() {\n            return [{ name: 'GFF3', label: 'GFF3', fileExt: 'gff3' }, { name: 'BED', label: 'BED', fileExt: 'bed' }, { name: 'SequinTable', label: 'Sequin Table', fileExt: 'sqn' }];\n        },\n\n        updateStaticElements: function updateStaticElements(coords) {\n            var _this3 = this;\n\n            this.inherited(arguments);\n\n            this.updateYScaleFromViewDimensions(coords);\n\n            if (coords.hasOwnProperty(\"x\")) {\n                var context = this.staticCanvas.getContext('2d');\n                var ratio = Util.getResolution(context, this.browser.config.highResolutionMode);\n                this.staticCanvas.width = this.browser.view.elem.clientWidth * ratio;\n                this.staticCanvas.style.width = this.browser.view.elem.clientWidth + \"px\";\n                this.staticCanvas.style.left = coords.x + \"px\";\n                context.setTransform(1, 0, 0, 1, 0, 0);\n                context.scale(ratio, ratio);\n                context.clearRect(0, 0, this.staticCanvas.width, this.staticCanvas.height);\n\n                var minVisible = this.browser.view.minVisible();\n                var maxVisible = this.browser.view.maxVisible();\n                var viewArgs = {\n                    minVisible: minVisible,\n                    maxVisible: maxVisible,\n                    bpToPx: dojo.hitch(this.browser.view, \"bpToPx\"),\n                    lWidth: this.label.offsetWidth\n                };\n\n                this.blocks.forEach(function (block) {\n                    if (!block || !block.fRectIndex || _this3.zooming) return;\n\n                    var idx = block.fRectIndex.byID;\n                    for (var id in idx) {\n                        var fRect = idx[id];\n                        fRect.glyph.updateStaticElements(context, fRect, viewArgs);\n                    }\n                });\n            }\n        },\n\n        heightUpdate: function heightUpdate(height, blockIndex) {\n            this.inherited(arguments);\n            if (this.staticCanvas) {\n                var ratio = Util.getResolution(this.staticCanvas.getContext('2d'), this.browser.config.highResolutionMode);\n                this.staticCanvas.height = this.staticCanvas.offsetHeight * ratio;\n            }\n        },\n\n        destroy: function destroy() {\n            this.destroyed = true;\n\n            domConstruct.destroy(this.staticCanvas);\n            delete this.staticCanvas;\n\n            delete this.layout;\n            delete this.glyphsLoaded;\n            this.inherited(arguments);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/CanvasFeatures.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/CanvasVariants.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/Track/CanvasVariants.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Just an HTMLFeatures track that uses the VariantDetailsMixin to\n * provide a variant-specific feature detail dialog.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/Track/CanvasFeatures */ \"./src/JBrowse/View/Track/CanvasFeatures.js\"), __webpack_require__(/*! JBrowse/View/Track/_VariantDetailMixin */ \"./src/JBrowse/View/Track/_VariantDetailMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, all, Util, CanvasFeatures, VariantDetailsMixin) {\n    return declare([CanvasFeatures, VariantDetailsMixin], {\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                style: { color: 'green' }\n            });\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            return all([this.inherited(arguments), this._variantsFilterTrackMenuOptions()]).then(function (options) {\n                var o = options.shift();\n                options.unshift({ type: 'dijit/MenuSeparator' });\n                return o.concat.apply(o, options);\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/CanvasVariants.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Combination.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/View/Track/Combination.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/dom-class */ \"./node_modules/dojo/dom-class.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! dojo/when */ \"./node_modules/dojo/when.js\"), __webpack_require__(/*! ./Combination/CombinationDialog */ \"./src/JBrowse/View/Track/Combination/CombinationDialog.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\"), __webpack_require__(/*! JBrowse/Model/BinaryTreeNode */ \"./src/JBrowse/Model/BinaryTreeNode.js\"), __webpack_require__(/*! dojo/dnd/move */ \"./node_modules/dojo/dnd/move.js\"), __webpack_require__(/*! dojo/dnd/Source */ \"./node_modules/dojo/dnd/Source.js\"), __webpack_require__(/*! dojo/dnd/Manager */ \"./node_modules/dojo/dnd/Manager.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/TrackConfigEditor */ \"./src/JBrowse/View/TrackConfigEditor.js\"), __webpack_require__(/*! JBrowse/View/Track/_ExportMixin */ \"./src/JBrowse/View/Track/_ExportMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, on, dom, domClass, Deferred, all, when, CombinationDialog, Dialog, BlockBased, TreeNode, dndMove, dndSource, dndManager, Util, TrackConfigEditor, ExportMixin) {\n    return declare([BlockBased, ExportMixin], {\n\n        /**\n         * Creates a track with a drag-and-drop interface allowing users to drag other tracks into it.\n         * Users select (using a dialog) a way to combine these tracks, and they are combined.\n         * Certain tracks (e.g. HTMLFeatures tracks) may be combined set-theoretically (union, intersection,etc ),\n         * while others (e.g. BigWig tracks) may be combined quantitatively (add scores, subtract scores, etc...).\n         * If one of the tracks is a set-based track and the other is not, track masking operations may be applied.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            // The \"default\" track of each type is the one at\n            // index 0 of the resultsTypes array.\n            // Many different kinds of tracks can be added.\n            // Each is supported by a different store, and\n            // some can be rendered in several ways.\n            // The trackClasses object stores information about what can be done with each of these types.\n            this.trackClasses = {\n                \"set\": {\n                    resultsTypes: [{\n                        name: \"HTMLFeatures\",\n                        path: \"JBrowse/View/Track/HTMLFeatures\"\n                    }],\n                    store: \"JBrowse/Store/SeqFeature/Combination\",\n                    allowedOps: [\"&\", \"U\", \"X\", \"S\"],\n                    defaultOp: \"&\"\n                },\n                \"quantitative\": {\n                    resultsTypes: [{\n                        name: \"XYPlot\",\n                        path: \"JBrowse/View/Track/Wiggle/XYPlot\"\n                    }, {\n                        name: \"Density\",\n                        path: \"JBrowse/View/Track/Wiggle/Density\"\n                    }],\n                    store: \"JBrowse/Store/SeqFeature/QuantitativeCombination\",\n                    allowedOps: [\"+\", \"-\", \"*\", \"/\"],\n                    defaultOp: \"+\"\n                },\n                \"mask\": {\n                    resultsTypes: [{\n                        name: \"XYPlot\",\n                        path: \"JBrowse/View/Track/Wiggle/XYPlot\"\n                    }, {\n                        name: \"Density\",\n                        path: \"JBrowse/View/Track/Wiggle/Density\"\n                    }],\n                    store: \"JBrowse/Store/SeqFeature/Mask\",\n                    allowedOps: [\"M\", \"N\"],\n                    defaultOp: \"M\"\n                },\n                \"BAM\": {\n                    resultsTypes: [{\n                        name: \"Detail\",\n                        path: \"JBrowse/View/Track/Alignments2\"\n                    }, {\n                        name: \"Summary\",\n                        path: \"JBrowse/View/Track/SNPCoverage\" //For now\n                    }],\n                    store: \"JBrowse/Store/SeqFeature/BAMCombination\",\n                    allowedOps: [\"U\"],\n                    defaultOp: \"U\"\n                }\n            };\n\n            this.errorCallback = dojo.hitch(this, function (error) {\n                this._handleError(error, {});\n            });\n\n            // inWords just stores, in words, what each possible operation does.  This is helpful for dialogs and menus that\n            // allow selection of different operations.\n            this.inWords = {\n                // These one-character codes symbolize operations between stores.\n                \"+\": \"addition\",\n                \"-\": \"subtraction\",\n                \"*\": \"multiplication\",\n                \"/\": \"division\",\n                \"&\": \"intersection\",\n                \"U\": \"union\",\n                \"X\": \"XOR\",\n                \"S\": \"set subtraction\",\n                \"M\": \"regular mask\",\n                \"N\": \"inverse mask\",\n                // These four-digit codes are used by the CombinationDialog object to differentiate different types of masking operations.\n                \"0000\": \"combine without masking\",\n                \"0020\": \"use new track as mask\",\n                \"0002\": \"use old track as mask\",\n                \"1111\": \"merge tracks\",\n                \"1001\": \"add new track to old track's displayed data\",\n                \"1010\": \"add new track to old track's mask\",\n                \"0101\": \"add old track to new track's displayed data\",\n                \"0110\": \"add old track to new track's mask\"\n            };\n\n            // Each store becomes associated with the name of a track that uses that store, so that users can read more easily.\n            if (!this.config.storeToKey) this.config.storeToKey = {};\n\n            // Shows which track or store types qualify as set-based, quantitative, etc.\n            this.supportedBy = {\n                \"JBrowse/View/Track/HTMLFeatures\": \"set\",\n                \"JBrowse/View/Track/HTMLVariants\": \"set\",\n                \"JBrowse/View/Track/CanvasFeatures\": \"set\",\n                \"JBrowse/View/Track/CanvasVariants\": \"set\",\n                \"CanvasFeatures\": \"set\",\n                \"HTMLFeatures\": \"set\",\n                \"HTMLVariants\": \"set\",\n                \"CanvasVariants\": \"set\",\n                \"NeatCanvasFeatures/View/Track/NeatFeatures\": \"set\",\n                \"NeatHTMLFeatures/View/Track/NeatFeatures\": \"set\",\n                \"JBrowse/View/Track/Alignments2\": \"BAM\",\n                \"JBrowse/View/Track/SNPCoverage\": \"BAM\",\n                \"JBrowse/Store/BigWig\": \"quantitative\",\n                \"JBrowse/Store/SeqFeature/BigWig\": \"quantitative\",\n                \"JBrowse/Store/SeqFeature/BAM\": \"BAM\",\n                \"JBrowse/Store/SeqFeature/BAMCombination\": \"BAM\",\n                \"JBrowse/Store/SeqFeature/Combination\": \"set\",\n                \"JBrowse/Store/SeqFeature/QuantitativeCombination\": \"quantitative\",\n                \"JBrowse/Store/SeqFeature/Mask\": \"mask\"\n            };\n\n            this.loaded = true;\n\n            // For CSS customization of the outer\n            this.divClass = args.divClass || \"combination\";\n\n            // Sets a bunch of variables to their initial values\n            this.reinitialize();\n\n            // When other tracks are dragged onto the combination, they don't disappear from their respective sources\n            // (in case the user wants to add the track separately, by itself).  These variables will be used in the DnD\n            // methods to support this functionality\n            this.currentDndSource = undefined;\n            this.sourceWasCopyOnly = undefined;\n\n            // This is used to avoid creating a feedback loop in the height-updating process.\n            this.onlyRefreshOuter = false;\n\n            this.heightResults = 0;\n\n            this.height = args.height || 0;\n\n            // This variable (which will later be a deferred) ensures that when multiple tracks are added simultaneously,\n            // The dialogs for each one don't render all at once.\n            this.lastDialogDone = [true];\n        },\n\n        setViewInfo: function setViewInfo(genomeView, heightUpdate, numBlocks, trackDiv, widthPct, widthPx, scale) {\n\n            this.inherited(arguments);\n            domClass.add(this.div, 'combination_track empty');\n\n            this.scale = scale;\n\n            // This track has a dnd source (to support dragging tracks into and out of it).\n            this.dnd = new dndSource(this.div, {\n                accept: [\"track\"], //Accepts only tracks\n                isSource: false,\n                withHandles: true,\n                creator: dojo.hitch(this, function (trackConfig, hint) {\n                    // Renders the results track div (or avatar, depending).\n                    // Code for ensuring that we don't have several results tracks\n                    // is handled later in the file.\n                    var data = trackConfig;\n                    if (trackConfig.resultsTrack) {\n                        data = trackConfig.resultsTrack;\n                        data.storeToKey = trackConfig.storeToKey;\n                    }\n                    return {\n                        data: data,\n                        type: [\"track\"],\n                        node: this.addTrack(data)\n                    };\n                })\n            });\n\n            // Attach dnd events\n            this._attachDndEvents();\n\n            // If config contains a config for the results track, use it. (This allows reloading when the track config is edited. )\n            if (this.config.resultsTrack) {\n                this.reloadStoreNames = true;\n                this.dnd.insertNodes(false, [this.config.resultsTrack]);\n            }\n        },\n\n        // This function ensure that the combination track's drag-and-drop interface works correctly.\n        _attachDndEvents: function _attachDndEvents() {\n            var thisB = this;\n\n            // What to do at the beginning of dnd process\n            on(thisB.dnd, \"DndStart\", function (source, nodes, copy) {\n                // Stores the information about whether the source was copy-only, for future reference\n                thisB.currentDndSource = source;\n                thisB.sourceWasCopyOnly = source.copyOnly;\n            });\n\n            // When other tracks are dragged onto the combination, they don't disappear from their respective sources\n            on(thisB.dnd, \"DraggingOver\", function () {\n                if (thisB.currentDndSource) {\n                    // Tracks being dragged onto this track are copied, not moved.\n                    thisB.currentDndSource.copyOnly = true;\n                }\n                this.currentlyOver = true;\n            });\n\n            var dragEndingEvents = [\"DraggingOut\", \"DndDrop\", \"DndCancel\"];\n\n            for (var eventName in dragEndingEvents) {\n                on(thisB.dnd, dragEndingEvents[eventName], function () {\n                    if (thisB.currentDndSource) {\n                        // Makes sure that the dndSource isn't permanently set to CopyOnly\n                        thisB.currentDndSource.copyOnly = thisB.sourceWasCopyOnly;\n                    }\n                    this.currentlyOver = false;\n                });\n            } // Bug fixer\n            dojo.subscribe(\"/dnd/drop/before\", function (source, nodes, copy, target) {\n                if (target == thisB.dnd && nodes[0]) {\n                    thisB.dnd.current = null;\n                }\n            });\n\n            on(thisB.dnd, \"OutEvent\", function () {\n                // Fixes a glitch wherein the trackContainer is disabled when the track we're dragging leaves the combination track\n                dndManager.manager().overSource(thisB.genomeView.trackDndWidget);\n            });\n\n            on(thisB.dnd, \"DndSourceOver\", function (source) {\n                // Fixes a glitch wherein tracks dragged into the combination track sometimes go to the trackContainer instead.\n                if (source != this && this.currentlyOver) {\n                    dndManager.manager().overSource(this);\n                }\n            });\n\n            // Further restricts what categories of tracks may be added to this track\n            // Should re-examine this\n\n            var oldCheckAcceptance = this.dnd.checkAcceptance;\n            this.dnd.checkAcceptance = function (source, nodes) {\n                // If the original acceptance checker fails, this one will too.\n                var accept = oldCheckAcceptance.call(thisB.dnd, source, nodes);\n\n                // Additional logic to disqualify bad tracks - if one node is unacceptable, the whole group is disqualified\n                for (var i = 0; accept && nodes[i]; i++) {\n                    var trackConfig = source.getItem(nodes[i].id).data;\n                    accept = accept && (trackConfig.resultsTrack || thisB.supportedBy[trackConfig.storeClass] || thisB.supportedBy[trackConfig.type]);\n                }\n\n                return accept;\n            };\n        },\n\n        // Reset a bunch of variables\n        reinitialize: function reinitialize() {\n            if (this.dnd) {\n                this.dnd.selectAll().deleteSelectedNodes();\n            }\n\n            // While there is no results track, we cannot export.\n            this.config.noExport = true;\n            this.exportFormats = [];\n\n            this.resultsDiv = undefined;\n            this.resultsTrack = undefined;\n            this.storeType = undefined;\n            this.oldType = undefined;\n            this.classIndex = {};\n            this.storeToShow = 0;\n            this.displayStore = undefined;\n            this.maskStore = undefined;\n            this.store = undefined;\n            this.opTree = undefined;\n        },\n\n        // Modifies the results track when a new track is added\n        addTrack: function addTrack(trackConfig) {\n            // Connect the track's name to its store for easy reading by user\n            if (trackConfig && trackConfig.key && trackConfig.store) {\n                this.config.storeToKey[trackConfig.store] = trackConfig.key;\n            }\n\n            if (trackConfig && trackConfig.storeToKey) {\n                lang.mixin(this.config.storeToKey, trackConfig.storeToKey);\n            }\n\n            // Creates the results div, if it hasn't already been created\n            if (!this.resultsDiv) {\n                this.resultsDiv = dom.create(\"div\");\n                this.resultsDiv.className = \"track\";\n                this.resultsDiv.id = this.name + \"_resultsDiv\";\n                domClass.remove(this.div, 'empty');\n            }\n\n            // Carry on the process of adding the track\n            this._addTrackStore(trackConfig);\n\n            // Because _addTrackStore has deferreds, the dnd node must be returned before it is filled\n            return this.resultsDiv;\n        },\n\n        // Obtains the store of the track that was just added.\n        _addTrackStore: function _addTrackStore(trackConfig) {\n            var storeName = trackConfig.store;\n            var thisB = this;\n            var haveStore = function () {\n                var d = new Deferred();\n                thisB.browser.getStore(storeName, function (store) {\n                    if (store) {\n                        d.resolve(store, true);\n                    } else {\n                        d.reject(\"store \" + storeName + \" not found\", true);\n                    }\n                });\n                return d.promise;\n            }();\n            // Once we have the store, it's time to open the dialog.\n            haveStore.then(function (store) {\n                thisB.runDialog(trackConfig, store);\n            });\n        },\n\n        // Runs the dialog that asks the user how to combine the track.\n        runDialog: function runDialog(trackConfig, store) {\n            // If this is the first track being added, it's not being combined with anything, so we don't need to ask - just adds the track alone\n            if (this.storeType === undefined) {\n                // Figure out which type of track (set, quant, etc) the user is adding\n                this.currType = this.supportedBy[trackConfig.storeClass] || this.supportedBy[trackConfig.type];\n                this.storeType = this.currType;\n                // What type of Combination store corresponds to the track just added\n                this.storeClass = this.trackClasses[this.currType].store;\n\n                // opTree can be directly reloaded from track config.  This is important (e.g.) when changing reference sequences\n                // to make sure that the right combinations of tracks are still included in this track.\n                if (store.isCombinationStore && !store.opTree && this.config.opTree) {\n                    this.loadTree(this.config.opTree).then(dojo.hitch(this, function (tree) {\n                        this.opTree = tree;\n                        this.displayType = this.config.displayType;\n                        if (this.getClassIndex(this.displayType || this.storeType) == undefined) {\n                            this.setTrackClass(trackConfig.type, this.displayType || this.storeType);\n                        }\n                        this._adjustStores(store, this.oldType, this.currType, this.config.store, this.config.maskStore, this.config.displayStore);\n                    }));\n                    return;\n                }\n                var opTree = store.isCombinationStore ? store.opTree.clone() : new TreeNode({ Value: store, leaf: true });\n                this.displayType = this.currType == \"mask\" ? this.supportedBy[store.stores.display.config.type] : undefined;\n                if (this.getClassIndex(this.displayType || this.storeType) == undefined) {\n                    this.setTrackClass(trackConfig.type, this.displayType || this.storeType);\n                }\n                this.opTree = opTree;\n                if (this.reloadStoreNames) {\n                    this.reloadStoreNames = false;\n                    this._adjustStores(store, this.oldType, this.currType, this.config.store, this.config.maskStore, this.config.displayStore);\n                    return;\n                }\n                this._adjustStores(store, this.oldType, this.currType);\n                return;\n            }\n            var d = new Deferred();\n\n            this.lastDialogDone.push(d);\n            // Once the last dialog has closed, opens a new one\n            when(this.lastDialogDone.shift(), dojo.hitch(this, function () {\n                if (this.preferencesDialog) this.preferencesDialog.destroyRecursive();\n                // Figure out which type of track (set, quant, etc) the user is adding\n                this.currType = this.supportedBy[trackConfig.storeClass] || this.supportedBy[trackConfig.type];\n                this.oldType = this.storeType;\n                // What type of Combination store corresponds to the track just added\n                this.storeClass = this.trackClasses[this.currType].store;\n                this.preferencesDialog = new CombinationDialog({\n                    trackConfig: trackConfig,\n                    store: store,\n                    track: this\n                });\n                // Once the results of the dialog are back, uses them to continue the process of rendering the results track\n                this.preferencesDialog.run(dojo.hitch(this, function (opTree, newstore, displayType) {\n                    this.opTree = opTree;\n                    this.displayType = displayType;\n                    this.storeType = this.oldType == \"mask\" || this.opTree.get() == \"M\" || this.opTree.get() == \"N\" ? \"mask\" : this.currType;\n                    if (this.getClassIndex(this.displayType || this.storeType) == undefined) {\n                        this.setTrackClass(trackConfig.type, this.displayType || this.storeType);\n                    }\n                    this._adjustStores(newstore, this.oldType, this.currType);\n                    d.resolve(true);\n                }), dojo.hitch(this, function () {\n                    d.resolve(true);\n                }));\n            }));\n        },\n\n        // If this track contains masked data, it uses three stores.  Otherwise, it uses one.\n        // This function ensures that all secondary stores (one for the mask, one for the display) have been loaded.\n        // If not, it loads them itself.  This function tries not to waste stores - if a store of a certain type already exists,\n        // it uses it rather than creating a new one.\n        _adjustStores: function _adjustStores(store, oldType, currType, storeName, maskStoreName, displayStoreName) {\n            var d = new Deferred();\n            if (oldType == \"mask\") {\n                this.maskStore.reload(this.opTree.leftChild);\n                this.displayStore.reload(this.opTree.rightChild);\n                this.store.reload(this.opTree, this.maskStore, this.displayStore);\n                d.resolve(true);\n            } else if (currType == \"mask\" || this.opTree.get() == \"M\" || this.opTree.get() == \"N\") {\n                var haveMaskStore = this._createStore(\"set\", maskStoreName);\n                haveMaskStore.then(dojo.hitch(this, function (newstore) {\n                    this.maskStore = newstore;\n                    this.maskStore.reload(this.opTree.leftChild);\n                }));\n                var haveDisplayStore = this._createStore(this.displayType, displayStoreName);\n\n                haveDisplayStore.then(dojo.hitch(this, function (newStore) {\n                    this.displayStore = newStore;\n                    this.displayStore.reload(this.opTree.rightChild);\n                }));\n                this.store = undefined;\n                d = all([haveMaskStore, haveDisplayStore]);\n            } else {\n                d.resolve(true);\n            }\n            d.then(dojo.hitch(this, function () {\n                this.createStore(storeName);\n            }));\n        },\n\n        // Checks if the primary store has been created yet.  If it hasn't, calls \"_createStore\" and makes it.\n        createStore: function createStore(storeName) {\n            var d = new Deferred();\n            var thisB = this;\n\n            if (!this.store) {\n                d = this._createStore(undefined, storeName);\n            } else {\n                d.resolve(this.store, true);\n            }\n            d.then(function (store) {\n                // All stores are now in place.  Make sure the operation tree of the store matches that of this track,\n                // and then we can render the results track.\n                thisB.store = store;\n                thisB.store.reload(thisB.opTree, thisB.maskStore, thisB.displayStore);\n                thisB.renderResultsTrack();\n            });\n        },\n\n        // Creates a store config and passes it to the browser, which creates the store and returns its name.\n        _createStore: function _createStore(storeType, storeName) {\n            var d = new Deferred();\n            if (!storeName) {\n                var storeConf = this._storeConfig(storeType);\n                storeName = this.browser.addStoreConfig(undefined, storeConf);\n                storeConf.name = storeName;\n            }\n\n            this.browser.getStore(storeName, function (store) {\n                d.resolve(store, true);\n            });\n            return d.promise;\n        },\n\n        // Uses the current settings of the combination track to create a store\n        _storeConfig: function _storeConfig(storeType) {\n            if (!storeType) storeType = this.storeType;\n            var storeClass = this.trackClasses[storeType].store;\n            this.config.storeClass = storeClass;\n\n            var op = this.trackClasses[storeType].defaultOp;\n            return {\n                browser: this.browser,\n                refSeq: this.browser.refSeq.name,\n                type: storeClass,\n                op: op\n            };\n        },\n\n        // This method is particularly useful when masked data is being displayed, and returns data which depends on\n        // which of (data, mask, masked data) is being currently displayed.\n        _visible: function _visible() {\n            var which = [this.displayType || this.storeType, \"set\", this.displayType];\n\n            var allTypes = [{ store: this.store,\n                tree: this.opTree }, { store: this.maskStore,\n                tree: this.opTree ? this.opTree.leftChild : undefined }, { store: this.displayStore,\n                tree: this.opTree ? this.opTree.rightChild : undefined }];\n            for (var i in which) {\n                allTypes[i].which = which[i];\n                if (which[i]) {\n                    var storeType = i == 0 && this.storeType == \"mask\" ? \"mask\" : which[i];\n                    allTypes[i].allowedOps = this.trackClasses[storeType].allowedOps;\n                    allTypes[i].trackType = this.trackClasses[which[i]].resultsTypes[this.getClassIndex(which[i]) || 0].path;\n                }\n            }\n            if (this.storeType != \"mask\") return allTypes[0];\n            return allTypes[this.storeToShow];\n        },\n\n        // Time to actually render the results track.\n        renderResultsTrack: function renderResultsTrack() {\n            if (this.resultsTrack) {\n                // Destroys the results track currently in place if it exists. We're going to create a new one.\n                this.resultsTrack.clear();\n                this.resultsTrack.destroy();\n                while (this.resultsDiv.firstChild) {\n                    // Use dojo.empty instead?\n                    this.resultsDiv.removeChild(this.resultsDiv.firstChild);\n                }\n            }\n            // Checks one last time to ensure we have a store before proceeding\n            if (this._visible().store) {\n                // Gets the path of the track to create\n                var trackClassName = this._visible().trackType;\n                var trackClass;\n\n                var thisB = this;\n                var config = this._resultsTrackConfig(trackClassName);\n\n                trackClassName = config.type;\n\n                // Once we have the object for the type of track we're creating, call this.\n                var makeTrack = function makeTrack() {\n                    // Construct a track with the relevant parameters\n                    thisB.resultsTrack = new trackClass({\n                        config: config,\n                        browser: thisB.browser,\n                        changeCallback: thisB._changedCallback,\n                        refSeq: thisB.refSeq,\n                        store: thisB._visible().store,\n                        trackPadding: 0 });\n\n                    // Removes all options from the results track's context menu.\n                    thisB.resultsTrackMenuOptions = thisB.resultsTrack._trackMenuOptions;\n\n                    thisB.resultsTrack._trackMenuOptions = function () {\n                        return [];\n                    };\n\n                    // This will be what happens when the results track updates its height - makes necessary changes to\n                    // outer track's height and then passes up to the heightUpdate callback specified as a parameter to this object\n                    var resultsHeightUpdate = function resultsHeightUpdate(height) {\n                        thisB.resultsDiv.style.height = height + \"px\";\n                        thisB.heightResults = height;\n                        thisB.height = height;\n                        thisB.onlyRefreshOuter = true;\n                        thisB.refresh();\n                        thisB.onlyRefreshOuter = false;\n                        thisB.heightUpdate(thisB.height);\n                        thisB.div.style.height = thisB.height + \"px\";\n                    };\n\n                    // setViewInfo on results track\n                    thisB.resultsTrack.setViewInfo(thisB.genomeView, resultsHeightUpdate, thisB.numBlocks, thisB.resultsDiv, thisB.widthPct, thisB.widthPx, thisB.scale);\n\n                    // Only do this when the masked data is selected\n                    // (we don't want editing the config to suddenly remove the data or the mask)\n                    thisB.config.opTree = thisB.flatten(thisB.opTree);\n                    thisB.config.store = thisB.store.name;\n                    thisB.config.maskStore = thisB.maskStore ? thisB.maskStore.name : undefined;\n                    thisB.config.displayStore = thisB.displayStore ? thisB.displayStore.name : undefined;\n\n                    if (thisB._visible().store == thisB.store) {\n                        // Refresh results track config, so that the track can be recreated when the config is edited\n                        thisB.config.resultsTrack = thisB.resultsTrack.config;\n                        thisB.config.displayType = thisB.displayType;\n\n                        thisB.browser.replaceTracks([thisB.config]);\n\n                        if (typeof thisB.resultsTrack._exportFormats == 'function') {\n                            thisB.config.noExport = false;\n                            thisB.exportFormats = thisB.resultsTrack._exportFormats();\n                        } else {\n                            thisB.config.noExport = true;\n                        }\n                    }\n\n                    thisB.refresh();\n                };\n\n                // Loads the track class from the specified path\n                dojo.global.require([trackClassName], function (tc) {\n                    trackClass = tc;\n                    if (trackClass) makeTrack();\n                });\n            }\n        },\n\n        // Generate the config of the results track\n        _resultsTrackConfig: function _resultsTrackConfig(trackClass) {\n            var config = {\n                store: this.store.name,\n                storeClass: this.store.config.type,\n                feature: [\"match\"],\n                key: \"Results\",\n                label: this.name + \"_results\",\n                metadata: { description: \"This track was created from a combination track.\" },\n                type: trackClass,\n                autoscale: \"local\"\n            };\n\n            if (this.config.resultsTrack) {\n                if ((this.config.resultsTrack.storeClass == config.storeClass || this.supportedBy[this.config.resultsTrack.storeClass] == this.displayType) && this._visible().store != this.maskStore) {\n                    config = this.config.resultsTrack;\n                    config.store = this.store.name;\n                    config.storeClass = this.store.config.type;\n                    return config;\n                }\n                config.key = this.config.resultsTrack.key;\n                config.label = this.config.resultsTrack.label;\n                config.metadata = this.config.resultsTrack.metadata;\n            }\n            return config;\n        },\n\n        // Refresh what the user sees on the screen for this track\n        refresh: function refresh(track) {\n            if (!track) {\n                track = this;\n            }\n            if (this._visible().store && !this.onlyRefreshOuter) {\n                // Reload the store if it's not too much trouble\n                this._visible().store.reload(this._visible().tree, this.maskStore, this.displayStore);\n            } else {\n                if (!this.onlyRefreshOuter) {\n                    // Causes the resultsTrack to be removed from the config when it has been removed\n                    delete this.config.resultsTrack;\n                    delete this.config.opTree;\n                }\n            }\n\n            // once the store is properly reloaded, make sure the track is showing data correctly\n            if (this.range) {\n                track.clear();\n                track.showRange(this.range.f, this.range.l, this.range.st, this.range.b, this.range.sc, this.range.cs, this.range.ce);\n            }\n            this.makeTrackMenu();\n        },\n\n        clear: function clear() {\n            this.inherited(arguments);\n            if (this.resultsTrack && !this.onlyRefreshOuter) {\n                this.resultsTrack.clear();\n            }\n        },\n\n        hideAll: function hideAll() {\n            this.inherited(arguments);\n            if (this.resultsTrack && !this.onlyRefreshOuter) {\n                this.resultsTrack.hideAll();\n            }\n        },\n\n        hideRegion: function hideRegion(location) {\n            this.inherited(arguments);\n            if (this.resultsTrack && !this.onlyRefreshOuter) {\n                this.resultsTrack.hideRegion(location);\n            }\n        },\n\n        sizeInit: function sizeInit(numBlocks, widthPct, blockDelta) {\n            this.inherited(arguments);\n            if (this.resultsTrack && !this.onlyRefreshOuter) {\n                this.resultsTrack.sizeInit(numBlocks, widthPct, blockDelta);\n            }\n        },\n\n        // Extends the BlockBased track's showRange function.\n        showRange: function showRange(first, last, startBase, bpPerBlock, scale, containerStart, containerEnd, finishCallback) {\n\n            this.range = { f: first, l: last, st: startBase,\n                b: bpPerBlock, sc: scale,\n                cs: containerStart, ce: containerEnd };\n            if (this.resultsTrack && !this.onlyRefreshOuter) {\n                // This is a workaround to a glitch that causes an opaque white rectangle to appear sometimes when a quantitative\n                // track is loaded.\n                var needsDiv = !this.resultsDiv.parentNode;\n                if (needsDiv) {\n                    this.div.appendChild(this.resultsDiv);\n                }\n\n                var loadedRegions = [];\n                var stores = [this.store, this.maskStore, this.displayStore];\n                for (var i in stores) {\n                    if (stores[i] && typeof stores[i].loadRegion == 'function') {\n                        var start = startBase;\n                        var end = startBase + (last + 1 - first) * bpPerBlock;\n                        var loadedRegion = stores[i].loadRegion({ ref: this.refSeq.name, start: start, end: end });\n                        loadedRegions.push(loadedRegion);\n                        loadedRegion.then(function () {}, this.errorCallback); // Add error callbacks to all deferred rejections\n                    }\n                }\n                when(all(loadedRegions), dojo.hitch(this, function (reloadedStores) {\n                    if (reloadedStores.length && reloadedStores.indexOf(this._visible().store) != -1) {\n                        this.resultsTrack.clear();\n                    }\n                    this.resultsTrack.showRange(first, last, startBase, bpPerBlock, scale, containerStart, containerEnd, finishCallback);\n                }), this.errorCallback);\n\n                if (needsDiv) {\n                    this.div.removeChild(this.resultsDiv);\n                }\n            }\n            // Run the method from BlockBased.js\n            this.inherited(arguments);\n            // Make sure the height of this track is right\n            this.heightUpdate(this.height);\n            this.div.style.height = this.height + \"px\";\n        },\n\n        // If moveBlocks is called on this track, should be called on the results track as well\n        moveBlocks: function moveBlocks(delta) {\n            this.inherited(arguments);\n            if (this.resultsTrack) this.resultsTrack.moveBlocks(delta);\n        },\n\n        // fillBlock in this renders all the relevant borders etc that surround the results track and let the user know\n        // that this is a combination track\n        fillBlock: function fillBlock(args) {\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n\n            if (!this.resultsTrack) {\n                this.fillMessage(blockIndex, block, 'Drag tracks here to combine them.');\n            } else {\n                this.heightUpdate(this.heightResults, blockIndex);\n            }\n            args.finishCallback();\n        },\n\n        // endZoom is passed down to resultsTrack\n        endZoom: function endZoom(destScale, destBlockBases) {\n            this.clear(); // Necessary?\n            if (this.resultsTrack) this.resultsTrack.endZoom();\n        },\n\n        //  updateStaticElements passed down to resultsTrack\n        updateStaticElements: function updateStaticElements(args) {\n            this.inherited(arguments);\n            if (this.resultsTrack) this.resultsTrack.updateStaticElements(args);\n        },\n\n        // When the results track can be shown in multiple different classes\n        // (e.g. XYPlot or Density), this allows users to choose between them\n        setClassIndex: function setClassIndex(index, type) {\n            if (!type) type = this._visible().which;\n            if (type == \"mask\" && this.displayStore) type = this.supportedBy[this.displayStore.config.type];\n            this.classIndex[type] = index;\n        },\n\n        // Like the setClassIndex function, but accepts the actual file path of the track in question\n        setTrackClass: function setTrackClass(tclass, type) {\n            var allPaths = this.trackClasses[type].resultsTypes.map(function (item) {\n                return item.path;\n            });\n            var index = allPaths.indexOf(tclass);\n            if (index >= 0) {\n                this.setClassIndex(index, type);\n            }\n        },\n\n        // When the results track can be shown in multiple different classes\n        // (e.g. XYPlot or Density), this tells us which one is currently\n        // chosen\n        getClassIndex: function getClassIndex(type) {\n            if (type == \"mask\" && this.displayStore) type = this.supportedBy[this.displayStore.config.type];\n            return this.classIndex[type];\n        },\n\n        // Adds options to the track context menu\n        _trackMenuOptions: function _trackMenuOptions() {\n\n            // Allows the combination track to \"mimic\" the menu options of its results track\n            var resultsTrackOptions = (this.resultsTrackMenuOptions || function () {\n                return undefined;\n            }).call(this.resultsTrack);\n            resultsTrackOptions = resultsTrackOptions || [];\n\n            var inheritedOptions = this.inherited(arguments);\n            var inheritedLabels = inheritedOptions.map(function (menuItem) {\n                return menuItem.label;\n            });\n\n            for (var i = 0; i < resultsTrackOptions.length; i++) {\n                if (resultsTrackOptions[i].label && inheritedLabels.indexOf(resultsTrackOptions[i].label) != -1) {\n                    resultsTrackOptions.splice(i--, 1);\n                }\n            }\n            var o = inheritedOptions.concat(resultsTrackOptions);\n\n            //var o = this.inherited(arguments);\n\n\n            var combTrack = this;\n\n            // If no tracks are added, we don't need to add any more options\n            if (!this.storeType) return o;\n\n            if (this.storeType == \"mask\") {\n                // If a masking track, enables users to toggle between viewing data, mask, and masked data\n                var maskOrDisplay = [\"masked data\", \"mask\", \"data only\"];\n                var maskOrDisplayItems = Object.keys(maskOrDisplay).map(function (i) {\n                    return {\n                        type: 'dijit/CheckedMenuItem',\n                        checked: combTrack.storeToShow == i,\n                        label: maskOrDisplay[i],\n                        title: \"View \" + maskOrDisplay[i],\n                        action: function action() {\n                            combTrack.storeToShow = i;\n                            combTrack.renderResultsTrack();\n                        }\n                    };\n                });\n                o.push.apply(o, [{\n                    type: 'dijit/MenuSeparator'\n                }, {\n                    children: maskOrDisplayItems,\n                    label: \"View\",\n                    title: \"switch between the mask, display data and masked data for this masking track\"\n                }]);\n            }\n\n            // User may choose which class to render results track (e.g. XYPlot or Density) if multiple options exist\n            var classes = this.trackClasses[this._visible().which].resultsTypes;\n\n            var classItems = Object.keys(classes).map(function (i) {\n                return {\n                    type: 'dijit/CheckedMenuItem',\n                    label: classes[i].name,\n                    checked: combTrack.classIndex[combTrack._visible().which] == i,\n                    title: \"Display as \" + classes[i].name + \" track\",\n                    action: function action() {\n                        combTrack.setClassIndex(i);\n                        delete combTrack.config.resultsTrack;\n                        combTrack.renderResultsTrack();\n                    }\n                };\n            });\n            o.push.apply(o, [{ type: 'dijit/MenuSeparator' }, {\n                children: classItems,\n                label: \"Track display\",\n                title: \"Change what type of track is being displayed\"\n            }]);\n\n            // Allow user to view the current track formula.\n            if (this.opTree) {\n                o.push.apply(o, [{ label: 'View formula',\n                    title: 'View the formula specifying this combination track',\n                    action: function action() {\n                        var formulaDialog = new Dialog({ title: \"View Formula\" });\n                        var content = [];\n                        var formulaDiv = dom.create(\"div\", { innerHTML: \"No operation formula defined\", className: \"formulaPreview\" });\n                        content.push(formulaDiv);\n                        if (combTrack.opTree) {\n                            formulaDiv.innerHTML = combTrack._generateTreeFormula(combTrack.opTree);\n                        }\n                        formulaDialog.set(\"content\", content);\n                        formulaDialog.show();\n                    }\n                }]);\n            }\n\n            // If the current view contains more than one track combined, user may change the last operation applied\n            if (this._visible().tree && this._visible().tree.getLeaves().length > 1) {\n                var operationItems = this._visible().allowedOps.map(function (op) {\n                    return {\n                        type: 'dijit/CheckedMenuItem',\n                        checked: combTrack._visible().tree.get() == op,\n                        label: combTrack.inWords[op],\n                        title: \"change operation of last track to \" + combTrack.inWords[op],\n                        action: function action() {\n                            if (combTrack.opTree) {\n                                combTrack._visible().tree.set(op);\n                                combTrack.refresh();\n                            }\n                        }\n                    };\n                });\n                o.push.apply(o, [{ children: operationItems,\n                    label: \"Change last operation\",\n                    title: \"change the operation applied to the last track added\"\n                }]);\n            }\n\n            return o;\n        },\n\n        // Turns an opTree into a formula to be better understood by the user.\n        _generateTreeFormula: function _generateTreeFormula(tree) {\n            if (!tree || tree === undefined) {\n                return '<span class=\"null\">NULL</span>';\n            }\n            if (tree.isLeaf()) {\n                return '<span class=\"leaf' + (tree.highlighted ? ' highlighted' : '') + '\">' + (tree.get().name ? this.config.storeToKey[tree.get().name] ? this.config.storeToKey[tree.get().name] : tree.get().name : tree.get()) + '</span>';\n            }\n            return '<span class=\"tree\">(' + this._generateTreeFormula(tree.left()) + ' <span class=\"op\" title=\"' + this.inWords[tree.get()] + '\">' + tree.get() + \"</span> \" + this._generateTreeFormula(tree.right()) + \")</span>\";\n        },\n\n        _exportFormats: function _exportFormats() {\n            return this.exportFormats || [];\n        },\n\n        // These methods are not currently in use, but they allow direct loading of the opTree into the config.\n\n        flatten: function flatten(tree) {\n            var newTree = {\n                leaf: tree.leaf\n            };\n            if (tree.leftChild) newTree.leftChild = this.flatten(tree.leftChild);\n            if (tree.rightChild) newTree.rightChild = this.flatten(tree.rightChild);\n            if (tree.get().name) newTree.store = tree.get().name;else newTree.op = tree.get();\n            return newTree;\n        },\n\n        loadTree: function loadTree(tree) {\n            var d = new Deferred();\n            var haveLeft;\n            var haveRight;\n            var thisB = this;\n\n            if (!tree) {\n                d.resolve(undefined, true);\n                return d.promise;\n            }\n\n            if (tree.leftChild) {\n                haveLeft = this.loadTree(tree.leftChild);\n            }\n            if (tree.rightChild) {\n                haveRight = this.loadTree(tree.rightChild);\n            }\n            when(all([haveLeft, haveRight]), function (results) {\n                var newTree = new TreeNode({ leftChild: results[0], rightChild: results[1], leaf: tree.leaf });\n                if (tree.store) {\n                    thisB.browser.getStore(tree.store, function (store) {\n                        newTree.set(store);\n                    });\n                    d.resolve(newTree, true);\n                } else {\n                    newTree.set(tree.op);\n                    d.resolve(newTree, true);\n                }\n            });\n            return d.promise;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Combination.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Combination/CombinationDialog.js":
/*!*****************************************************************!*\
  !*** ./src/JBrowse/View/Track/Combination/CombinationDialog.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dijit/form/RadioButton */ \"./node_modules/dijit/form/RadioButton.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/Model/BinaryTreeNode */ \"./src/JBrowse/Model/BinaryTreeNode.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, Dialog, RadioButton, Button, dom, TreeNode) {\n\n        return declare(null, {\n\n                // Produces a dialog box in which a user may enter settings for how they would like to combine tracks in a Combination Track.\n                constructor: function constructor(args) {\n\n                        this.newTrackKey = args.trackConfig ? args.trackConfig.key : args.key;\n                        this.track = args.track;\n                        this.newStore = args.store;\n                        this.opTree = this.track.opTree;\n\n                        this.currType = this.track.currType;\n                        this.oldType = this.track.oldType;\n                        this.supportedBy = this.track.supportedBy;\n                        this.displayType = this.track.displayType;\n\n                        this.storeToKey = this.track.config.storeToKey;\n\n                        this.newDisplayType = this.displayType;\n\n                        this.inWords = this.track.inWords;\n\n                        this.trackClasses = this.track.trackClasses;\n\n                        this.dialog = new Dialog({\n                                title: \"Combine with \" + this.newTrackKey,\n                                style: \"width: 475px;\",\n                                className: \"combinationDialog\"\n                        });\n                        var content = this._dialogContent(this.newStore);\n                        this.dialog.set('content', content);\n                },\n\n                _dialogContent: function _dialogContent(store) {\n                        var nodesToAdd = [];\n\n                        var opList = this._allAllowedOperations(store);\n                        if (!opList.length) {\n                                nodesToAdd.push(dom.create(\"div\", { innerHTML: \"No operations are possible for this track.\" }));\n                                var actionBar = this._createActionBar(false);\n                                nodesToAdd.push(actionBar);\n                                return nodesToAdd;\n                        }\n\n                        nodesToAdd.push(dom.create(\"div\", { className: 'intro', innerHTML: \"Adding \" + this.currType + \" track \" + this.newTrackKey + \" to the combination.\" }));\n\n                        var maskOpListDiv = dom.create(\"div\", { id: this.track.name + \"_maskOpList\" });\n\n                        var thisB = this;\n\n                        var maskOps = this._makeUnique(opList.map(function (item) {\n                                return item.substring(0, 4);\n                        }));\n                        nodesToAdd.push(maskOpListDiv);\n\n                        this.changingOpPanel = dom.create(\"div\", { id: this.track.name + \"_suffixLists\" });\n                        nodesToAdd.push(this.changingOpPanel);\n\n                        nodesToAdd.push(dom.create(\"h2\", { innerHTML: \"Combination formula\" }));\n\n                        this.formulaPreview = dom.create(\"div\", { innerHTML: \"(nothing currently selected)\", className: \"formulaPreview\" });\n                        nodesToAdd.push(this.formulaPreview);\n\n                        this.maskOpButtons = [];\n\n                        for (var i in maskOps) {\n                                var opButton = this._renderRadioButton(maskOpListDiv, maskOps[i], this.inWords[maskOps[i]]);\n                                this.maskOpButtons.push(opButton);\n\n                                opButton.on(\"change\", function (isSelected) {\n                                        if (isSelected) {\n                                                delete this.whichArg;\n                                                delete this.opValue;\n\n                                                thisB.maskOpValue = this.value;\n\n                                                var numOpLists = thisB.maskOpValue == \"1111\" ? 3 : 1;\n                                                thisB.opListDivs = [];\n                                                thisB.whichArgDivs = [];\n\n                                                thisB.opValue = [];\n                                                thisB.whichArg = [];\n\n                                                thisB.changingOpPanel.innerHTML = \"\";\n\n                                                for (var i = 0; i < numOpLists; i++) {\n\n                                                        var opDiv = dom.create(\"div\", { id: thisB.track.name + \"_suffix\" + i,\n                                                                style: { display: \"inline-block\", \"padding-left\": \"15px\", \"vertical-align\": \"top\" } }, thisB.changingOpPanel);\n                                                        if (numOpLists == 3) {\n                                                                var text = [\"Main\", \"Mask\", \"Display\"];\n                                                                dom.create(\"h2\", { innerHTML: text[i] }, opDiv);\n                                                        }\n\n                                                        var whichOpSpan = dom.create(\"h3\", { innerHTML: \"Combining operation\", style: { display: \"none\" } }, opDiv);\n\n                                                        thisB.opListDivs[i] = dom.create(\"div\", { id: thisB.track.name + \"_OpList\" + i }, opDiv);\n\n                                                        var leftRightSpan = dom.create(\"h3\", { innerHTML: \"Left or right?\", style: { display: \"none\" } }, opDiv);\n                                                        thisB.whichArgDivs[i] = dom.create(\"div\", { id: thisB.track.name + \"_whichArg\" + i }, opDiv);\n\n                                                        var opButtons = thisB._generateSuffixRadioButtons(this.value, opList, store, thisB.opListDivs[i], i);\n                                                        var leftRightButtons = thisB._maybeRenderWhichArgDiv(this.value, store, thisB.whichArgDivs[i], i);\n\n                                                        if (leftRightButtons.length && !thisB.whichOpArg) {\n                                                                leftRightButtons[0].set('checked', 'checked');\n                                                        }\n                                                        if (opButtons.length) {\n                                                                opButtons[0].set('checked', 'checked');\n                                                        }\n\n                                                        whichOpSpan.style.display = opButtons.length ? \"\" : \"none\";\n                                                        leftRightSpan.style.display = leftRightButtons.length ? \"\" : \"none\";\n                                                }\n                                        }\n                                });\n                        }\n\n                        if (maskOps[0]) this.maskOpButtons[0].set('checked', 'checked');\n\n                        if (maskOps.length <= 1) {\n                                if (!maskOps.length || maskOps[0] == \"0000\") {\n                                        maskOpListDiv.style.display = 'none';\n                                }\n                                this.maskOpButtons[0].set('disabled', 'disabled');\n                        }\n\n                        var actionBar = this._createActionBar();\n\n                        nodesToAdd.push(actionBar);\n\n                        return nodesToAdd;\n                },\n\n                _createActionBar: function _createActionBar(addingEnabled) {\n                        if (addingEnabled === undefined) addingEnabled = true;\n                        var actionBar = dom.create(\"div\", { className: \"dijitDialogPaneActionBar\" });\n                        new Button({\n                                iconClass: 'dijitIconDelete',\n                                label: \"Cancel\",\n                                onClick: dojo.hitch(this, function () {\n                                        this.shouldCombine = false;\n                                        this.dialog.hide();\n                                })\n                        }).placeAt(actionBar);\n\n                        var btnCombine = new Button({\n                                label: \"Combine tracks\",\n                                onClick: dojo.hitch(this, function () {\n                                        this.shouldCombine = true;\n                                        this.dialog.hide();\n                                })\n                        });\n\n                        btnCombine.placeAt(actionBar);\n\n                        if (!addingEnabled) btnCombine.set(\"disabled\", \"disabled\");\n                        return actionBar;\n                },\n\n                _generateSuffixRadioButtons: function _generateSuffixRadioButtons(prefix, stringlist, store, parent, offset) {\n                        offset = offset || 0;\n                        while (parent.firstChild) {\n                                if (dijit.byId(parent.firstChild.id)) dijit.byId(parent.firstChild.id).destroy();\n                                dom.destroy(parent.firstChild);\n                        }\n                        var buttons = [];\n\n                        var thisB = this;\n                        var allowedOps = this._generateSuffixList(prefix, stringlist, offset);\n                        for (var i in allowedOps) {\n                                var opButton = this._renderRadioButton(parent, allowedOps[i], this.inWords[allowedOps[i]]);\n                                buttons.push(opButton);\n                                opButton.on(\"change\", function (isSelected) {\n                                        if (isSelected) {\n                                                thisB.opValue[offset] = this.value;\n                                                var operation = thisB._getOperation();\n                                                thisB.previewTree = thisB._createPreviewTree(operation, store);\n                                                thisB.formulaPreview.innerHTML = thisB._generateTreeFormula(thisB.previewTree);\n                                        }\n                                });\n                        }\n                        return buttons;\n                },\n\n                _getOperation: function _getOperation() {\n                        var retString = this.maskOpValue;\n                        for (var i = 0; i < this.opListDivs.length; i++) {\n                                retString = retString + this.opValue[i] + this.whichArg[i];\n                        }\n                        return retString;\n                },\n\n                //Type checking necessary?\n                _generateSuffixList: function _generateSuffixList(prefix, stringlist, offset) {\n                        if (offset === undefined) offset = 0;\n                        return this._makeUnique(stringlist.filter(function (value) {\n                                return value.indexOf(prefix) != -1;\n                        }).map(function (item) {\n                                return item.substring(prefix.length + offset, prefix.length + offset + 1);\n                        }));\n                },\n\n                _maybeRenderWhichArgDiv: function _maybeRenderWhichArgDiv(prefix, store, parent, offset) {\n                        offset = offset || 0;\n                        while (parent.firstChild) {\n                                if (dijit.byId(parent.firstChild.id)) {\n                                        dijit.byId(parent.firstChild.id).destroy();\n                                }\n                                dom.destroy(parent.firstChild);\n                        }\n                        var leftRightButtons = [];\n                        var thisB = this;\n\n                        var whichArgChange = function whichArgChange(isSelected, value) {\n                                if (isSelected) {\n                                        thisB.whichArg[offset] = value === undefined ? this.value : value;\n                                        var operation = thisB._getOperation();\n                                        thisB.previewTree = thisB._createPreviewTree(operation, store);\n                                        thisB.formulaPreview.innerHTML = thisB._generateTreeFormula(thisB.previewTree);\n                                }\n                        };\n\n                        if (prefix == \"0020\") whichArgChange(true, \"L\");else if (prefix == \"0002\") whichArgChange(true, \"R\");else if (prefix == \"1111\" && offset == 0) whichArgChange(true, \"?\");else {\n                                var rbLeft = this._renderRadioButton(parent, \"L\", \"left\");\n                                var rbRight = this._renderRadioButton(parent, \"R\", \"right\");\n                                leftRightButtons.push(rbLeft);\n                                leftRightButtons.push(rbRight);\n                                rbLeft.on(\"change\", whichArgChange);\n                                rbRight.on(\"change\", whichArgChange);\n                        }\n\n                        return leftRightButtons;\n                },\n\n                _makeUnique: function _makeUnique(stringArray) {\n                        var unique = {};\n                        return stringArray.filter(function (value) {\n                                if (!unique[value]) {\n                                        unique[value] = true;\n                                        return true;\n                                }\n                                return false;\n                        });\n                },\n\n                _createPreviewTree: function _createPreviewTree(opString, store) {\n                        // Recursive cloning would probably be safer, but this seems to be working okay\n                        var newOpTree = store.opTree ? store.opTree.clone() : new TreeNode({ Value: store });\n                        if (newOpTree) {\n                                newOpTree.recursivelyCall(function (node) {\n                                        node.highlighted = true;\n                                });\n                        }\n                        var superior = new TreeNode(this.opTree);\n                        var firstChars = opString.substring(0, 2);\n                        var inferior = newOpTree;\n                        if (firstChars == \"01\") {\n                                superior = newOpTree;\n                                inferior = this.opTree;\n                        }\n                        return this._applyTreeTransform(opString.substring(2), superior, inferior);\n                },\n\n                _applyTreeTransform: function _applyTreeTransform(opString, superior, inferior) {\n                        var retTree = superior;\n                        var firstChars = opString.substring(0, 2);\n                        var childToUse;\n                        var opTree1 = superior;\n                        var opTree2 = inferior;\n                        switch (firstChars) {\n                                case \"10\":\n                                        opTree1 = superior.leftChild;\n                                        childToUse = \"leftChild\";\n                                        opTree2 = inferior;\n                                        break;\n                                case \"01\":\n                                        opTree1 = superior.rightChild;\n                                        childToUse = \"rightChild\";\n                                        opTree2 = inferior;\n                                        break;\n                                case \"11\":\n                                        retTree = new TreeNode({ Value: opString.substring(2, 3) });\n                                        retTree[\"leftChild\"] = this._transformTree(opString.substring(4), superior.leftChild, inferior.leftChild);\n                                        opString = opString.substring(4);\n                                        childToUse = \"rightChild\";\n                                        opTree1 = superior.rightChild;\n                                        opTree2 = inferior.rightChild;\n                                        break;\n                                case \"20\":\n                                        this.newDisplayType = this.oldType;\n                                        break;\n                                case \"02\":\n                                        this.newDisplayType = this.currType;\n                                        break;\n                        }\n                        var opNode = this._transformTree(opString.substring(2), opTree1, opTree2);\n                        if (childToUse == undefined) return opNode;\n\n                        retTree[childToUse] = opNode;\n                        return retTree;\n                },\n\n                _transformTree: function _transformTree(opString, opTree1, opTree2) {\n\n                        var op = opString.substring(0, 1);\n                        var opNode = new TreeNode({ Value: op });\n                        if (opString.substring(1, 2) == \"L\") {\n                                opNode.add(opTree2);\n                                opNode.add(opTree1);\n                        } else {\n                                opNode.add(opTree1);\n                                opNode.add(opTree2);\n                        }\n\n                        return opNode;\n                },\n\n                // This mess constructs a complete list of all operations that can be performed\n                _allAllowedOperations: function _allAllowedOperations(store) {\n                        var allowedList = [];\n                        var candidate = \"\";\n                        var allowedOps;\n                        candidate = candidate + (this.oldType == \"mask\" ? \"1\" : \"0\");\n                        candidate = candidate + (this.currType == \"mask\" ? \"1\" : \"0\");\n                        if (candidate == \"00\") {\n                                if (this.oldType == this.currType) {\n                                        var candidate2 = candidate + \"00\";\n                                        allowedOps = this.trackClasses[this.currType].allowedOps;\n                                        for (var i in allowedOps) {\n                                                allowedList.push(candidate2 + allowedOps[i]);\n                                        }\n                                }\n                                allowedOps = this.trackClasses[\"mask\"].allowedOps;\n                                if (this.currType == \"set\") {\n                                        var candidate2 = candidate + \"20\";\n                                        for (var i in allowedOps) {\n                                                allowedList.push(candidate2 + allowedOps[i]);\n                                        }\n                                }\n                                if (this.oldType == \"set\") {\n                                        var candidate2 = candidate + \"02\";\n                                        for (var i in allowedOps) {\n                                                allowedList.push(candidate2 + allowedOps[i]);\n                                        }\n                                }\n                        } else if (candidate == \"10\") {\n                                if (this.currType == \"set\") {\n                                        allowedOps = this.trackClasses[this.currType].allowedOps;\n                                        var candidate2 = candidate + \"10\";\n                                        for (var i in allowedOps) {\n                                                allowedList.push(candidate2 + allowedOps[i]);\n                                        }\n                                }\n                                if (this.currType == this.displayType) {\n                                        var candidate2 = candidate + \"01\";\n                                        allowedOps = this.trackClasses[this.currType].allowedOps;\n                                        for (var i in allowedOps) {\n                                                allowedList.push(candidate2 + allowedOps[i]);\n                                        }\n                                }\n                        } else if (candidate == \"01\") {\n                                if (this.oldType == \"set\") {\n                                        allowedOps = this.trackClasses[this.oldType].allowedOps;\n                                        var candidate2 = candidate + \"10\";\n                                        for (var i in allowedOps) {\n                                                allowedList.push(candidate2 + allowedOps[i]);\n                                        }\n                                }\n                                var displayType = this.supportedBy[store.stores.display.config.type];\n                                if (this.oldType == displayType) {\n                                        candidate = candidate + \"01\";\n                                        var allowedOps = this.trackClasses[displayType].allowedOps;\n                                        for (var i in allowedOps) {\n                                                allowedList.push(candidate + allowedOps[i]);\n                                        }\n                                }\n                        } else if (candidate == \"11\") {\n                                // Fix the logic of the tree manipulation to work with out the last L's and R's\n                                candidate = candidate + \"11\";\n                                allowedOps = this.trackClasses[\"set\"].allowedOps;\n                                for (var i in allowedOps) {\n                                        var displayType = this.supportedBy[store.stores.display.config.type];\n                                        var oldType = this.displayType;\n                                        if (displayType == oldType) {\n                                                var allowedOps2 = this.trackClasses[displayType].allowedOps;\n                                                for (var j in allowedOps2) {\n                                                        var allowedMaskOps = this.trackClasses[\"mask\"].allowedOps;\n                                                        for (var k in allowedMaskOps) {\n                                                                allowedList.push(candidate + allowedMaskOps[k] + allowedOps[i] + allowedOps2[j]);\n                                                        }\n                                                }\n                                        }\n                                }\n                        }\n\n                        return allowedList;\n                },\n\n                _renderRadioButton: function _renderRadioButton(parent, value, label) {\n                        var id = parent.id + \"_rb_\" + value;\n                        if (dijit.byId(id)) {\n                                dom.destroy(dijit.byId(id).domNode);\n                                dijit.byId(id).destroy();\n                        }\n\n                        label = label || value;\n                        var radioButton = new RadioButton({ name: parent.id + \"_rb\", id: id, value: value });\n                        parent.appendChild(radioButton.domNode);\n                        var radioButtonLabel = dom.create(\"label\", { \"for\": radioButton.id, innerHTML: label }, parent);\n                        parent.appendChild(dom.create(\"br\"));\n                        return radioButton;\n                },\n\n                run: function run(callback, cancelCallback, errorCallback) {\n                        this.dialog.show();\n                        var thisB = this;\n                        this.dialog.on(\"Hide\", function () {\n                                if (thisB.previewTree) {\n                                        thisB.previewTree.recursivelyCall(function (node) {\n                                                if (node.highlighted) delete node.highlighted;\n                                        });\n                                }\n                                if (thisB.shouldCombine) callback(thisB.previewTree, thisB.newStore, thisB.newDisplayType);else cancelCallback();\n                        });\n                },\n\n                _generateTreeFormula: function _generateTreeFormula(tree) {\n                        if (!tree || tree === undefined) {\n                                return '<span class=\"null\">NULL</span>';\n                        }\n                        if (tree.isLeaf()) {\n                                return '<span class=\"leaf' + (tree.highlighted ? ' highlighted' : '') + '\">' + (tree.get().name ? this.storeToKey[tree.get().name] ? this.storeToKey[tree.get().name] : tree.get().name : tree.get()) + '</span>';\n                        }\n                        return '<span class=\"tree\">(' + this._generateTreeFormula(tree.left()) + ' <span class=\"op\" title=\"' + this.inWords[tree.get()] + '\">' + tree.get() + \"</span> \" + this._generateTreeFormula(tree.right()) + \")</span>\";\n                },\n\n                destroyRecursive: function destroyRecursive() {\n                        this.dialog.destroyRecursive();\n                }\n\n        });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Combination/CombinationDialog.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/FeatureCoverage.js":
/*!***************************************************!*\
  !*** ./src/JBrowse/View/Track/FeatureCoverage.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Track/Wiggle/XYPlot */ \"./src/JBrowse/View/Track/Wiggle/XYPlot.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/Coverage */ \"./src/JBrowse/Store/SeqFeature/Coverage.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, WiggleXYPlot, Util, CoverageStore) {\n\n    return declare(WiggleXYPlot, {\n\n        constructor: function constructor(args) {\n            this.store = new CoverageStore({ store: this.store, browser: this.browser });\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                autoscale: 'local'\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/FeatureCoverage.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/FixedImage.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/Track/FixedImage.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, has, BlockBased) {\n\n    return declare(BlockBased,\n    /**\n     * @lends JBrowse.View.Track.FixedImage.prototype\n     */\n    {\n\n        /**\n         * A track that displays tiled images (PNGs, or other images) at fixed\n         * intervals along the reference sequence.\n         * @constructs\n         * @extends JBrowse.View.Track.BlockBased\n         */\n        constructor: function constructor(args) {\n            this.trackPadding = args.trackPadding || 0;\n        },\n\n        handleImageError: function handleImageError(ev) {\n            var img = ev.currentTarget || ev.srcElement;\n            img.style.display = \"none\";\n            dojo.stopEvent(ev);\n        },\n\n        /**\n         * @private\n         */\n        makeImageLoadHandler: function makeImageLoadHandler(img, blockIndex, blockWidth, composeCallback) {\n            var handler = dojo.hitch(this, function () {\n                this.imageHeight = img.height;\n                img.style.height = img.height + \"px\";\n                img.style.width = 100 * (img.baseWidth / blockWidth) + \"%\";\n                this.heightUpdate(img.height, blockIndex);\n                if (composeCallback) composeCallback();\n                return true;\n            });\n\n            if (has('ie'))\n                // in IE, have to delay calling it for a (arbitrary) 1/4\n                // second because the image's height is not always\n                // available when the onload event fires.  >:-{\n                return function () {\n                    window.setTimeout(handler, 250);\n                };else return handler;\n        },\n\n        fillBlock: function fillBlock(args) {\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n            var scale = args.scale;\n            var finishCallback = args.finishCallback || function () {};\n\n            var blockWidth = rightBase - leftBase;\n\n            this.store.getImages({ scale: scale, start: leftBase, end: rightBase }, dojo.hitch(this, function (images) {\n                dojo.forEach(images, function (im) {\n                    im.className = 'image-track';\n                    if (!(im.parentNode && im.parentNode.parentNode)) {\n                        im.style.position = \"absolute\";\n                        im.style.left = 100 * ((im.startBase - leftBase) / blockWidth) + \"%\";\n                        switch (this.config.align) {\n                            case \"top\":\n                                im.style.top = \"0px\";\n                                break;\n                            case \"bottom\":\n                            /* fall through */\n                            default:\n                                im.style.bottom = this.trackPadding + \"px\";\n                                break;\n                        }\n                        block.domNode.appendChild(im);\n                    }\n\n                    // make an onload handler for when the image is fetched that\n                    // will update the height and width of the track\n                    var loadhandler = this.makeImageLoadHandler(im, blockIndex, blockWidth);\n                    if (im.complete)\n                        // just call the handler ourselves if the image is already loaded\n                        loadhandler();else\n                        // otherwise schedule it\n                        im.onload = loadhandler;\n                }, this);\n                finishCallback();\n            }), dojo.hitch(this, function (error) {\n                if (error.status == 404) {\n                    finishCallback();\n                } else {\n                    this.fillBlockError(blockIndex, block, error);\n                }\n                finishCallback();\n            }));\n        },\n\n        startZoom: function startZoom(destScale, destStart, destEnd) {\n            if (this.empty) return;\n        },\n\n        endZoom: function endZoom(destScale, destBlockBases) {\n            this.clear();\n        },\n\n        clear: function clear() {\n            this.inherited(arguments);\n        },\n\n        transfer: function transfer(sourceBlock, destBlock, scale, containerStart, containerEnd) {\n            if (!(sourceBlock && destBlock)) return;\n\n            var children = sourceBlock.domNode.childNodes;\n            var destLeft = destBlock.startBase;\n            var destRight = destBlock.endBase;\n            var im;\n            for (var i = 0; i < children.length; i++) {\n                im = children[i];\n                if (\"startBase\" in im) {\n                    //if sourceBlock contains an image that overlaps destBlock,\n                    if (im.startBase < destRight && im.startBase + im.baseWidth > destLeft) {\n                        //move image from sourceBlock to destBlock\n                        im.style.left = 100 * ((im.startBase - destLeft) / (destRight - destLeft)) + \"%\";\n                        destBlock.domNode.appendChild(im);\n                    }\n                }\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/FixedImage.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/FixedImage/Wiggle.js":
/*!*****************************************************!*\
  !*** ./src/JBrowse/View/Track/FixedImage/Wiggle.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! JBrowse/View/Track/FixedImage */ \"./src/JBrowse/View/Track/FixedImage.js\"), __webpack_require__(/*! JBrowse/View/Track/_YScaleMixin */ \"./src/JBrowse/View/Track/_YScaleMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, FixedImage, YScaleMixin) {\n\n    var Wiggle = declare([FixedImage, YScaleMixin],\n    /**\n     * @lends JBrowse.View.Track.FixedImage.Wiggle.prototype\n     */\n    {\n\n        /**\n         * Tiled-image track subclass that displays images calculated from\n         * wiggle data.  Has a scale bar in addition to the images.\n         * @class\n         * @constructor\n         */\n        constructor: function constructor() {},\n\n        updateStaticElements: function updateStaticElements(coords) {\n            this.inherited(arguments);\n            this.updateYScaleFromViewDimensions(coords);\n        },\n\n        makeImageLoadHandler: function makeImageLoadHandler(img, blockIndex, blockWidth, composeCallback) {\n            return this.inherited(arguments, [img, blockIndex, blockWidth, dojo.hitch(this, function () {\n                this.makeWiggleYScale();\n                if (composeCallback) composeCallback();\n            })]);\n        },\n\n        makeWiggleYScale: function makeWiggleYScale() {\n            var thisB = this;\n            this.store.getGlobalStats(function (stats) {\n                if (!thisB.yscale) thisB.makeYScale({ min: stats.scoreMin, max: stats.scoreMax });\n            });\n        }\n    });\n\n    return Wiggle;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/FixedImage/Wiggle.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/GridLines.js":
/*!*********************************************!*\
  !*** ./src/JBrowse/View/Track/GridLines.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, BlockBased) {\n    return dojo.declare(BlockBased,\n    /**\n     * @lends JBrowse.View.Track.GridLines.prototype\n     */\n    {\n\n        /**\n         * This track draws vertical gridlines, which are divs with height\n         * 100%, absolutely positioned at the very top of all the tracks.\n         * @constructs\n         * @extends JBrowse.View.Track.BlockBased\n         */\n        constructor: function constructor(args) {\n            this.loaded = true;\n            this.name = 'gridlines';\n        },\n\n        // this track has no track label or track menu, stub them out\n        makeTrackLabel: function makeTrackLabel() {},\n        makeTrackMenu: function makeTrackMenu() {},\n\n        fillBlock: function fillBlock(args) {\n            this.renderGridlines(args.block, args.leftBase, args.rightBase);\n\n            var highlight = this.browser.getHighlight();\n            if (highlight && highlight.ref == this.refSeq.name) this.renderRegionHighlight(args, highlight);\n\n            var bookmarks = this.browser.getBookmarks();\n            if (bookmarks) {\n                this.renderRegionBookmark(args, bookmarks);\n            }\n\n            args.finishCallback();\n            this.heightUpdate(100, args.blockIndex);\n        },\n\n        renderGridlines: function renderGridlines(block, leftBase, rightBase) {\n\n            var base_span = rightBase - leftBase;\n            var minor_count = !(base_span % 20) ? 20 : !(base_span % 10) ? 10 : !(base_span % 5) ? 5 : !(base_span % 2) ? 2 : 5; // can happen at weird zoom levels (i.e. 13)\n            var major_count = base_span == 20 ? 2 : base_span > 0 ? 1 : 0;\n\n            var new_gridline = function new_gridline(glclass, position) {\n                var gridline = document.createElement(\"div\");\n                gridline.style.cssText = \"left: \" + position + \"%; width: 0px\";\n                gridline.className = \"gridline \" + glclass;\n                return gridline;\n            };\n\n            for (var i = 0; i < minor_count; i++) {\n                var pos = 100 / minor_count * i;\n                var cls = pos == 0 || minor_count == 20 && i == 10 ? \"gridline_major\" : \"gridline_minor\";\n\n                block.domNode.appendChild(new_gridline(cls, pos));\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/GridLines.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/HTMLFeatures.js":
/*!************************************************!*\
  !*** ./src/JBrowse/View/Track/HTMLFeatures.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/dom-geometry */ \"./node_modules/dojo/dom-geometry.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dijit/form/Select */ \"./node_modules/dijit/form/Select.js\"), __webpack_require__(/*! dijit/form/RadioButton */ \"./node_modules/dijit/form/RadioButton.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\"), __webpack_require__(/*! JBrowse/View/Track/_YScaleMixin */ \"./src/JBrowse/View/Track/_YScaleMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_ExportMixin */ \"./src/JBrowse/View/Track/_ExportMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_FeatureDetailMixin */ \"./src/JBrowse/View/Track/_FeatureDetailMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_TrackDetailsStatsMixin */ \"./src/JBrowse/View/Track/_TrackDetailsStatsMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/GranularRectLayout */ \"./src/JBrowse/View/GranularRectLayout.js\"), __webpack_require__(/*! JBrowse/Model/Location */ \"./src/JBrowse/Model/Location.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, array, dom, domGeom, on, query, has, dijitDialog, dijitSelect, dijitRadioButton, dijitButton, BlockBased, YScaleMixin, ExportMixin, FeatureDetailMixin, TrackDetailsStatsMixin, Util, Layout, Location) {\n\n    var HTMLFeatures = declare([BlockBased, YScaleMixin, ExportMixin, FeatureDetailMixin, TrackDetailsStatsMixin], {\n        /**\n         * A track that draws discrete features using `div` elements.\n         * @constructs\n         * @extends JBrowse.View.Track.BlockBased\n         * @param args.config {Object} track configuration. Must include key, label\n         * @param args.refSeq {Object} reference sequence object with name, start,\n         *   and end members.\n         * @param args.changeCallback {Function} optional callback for\n         *   when the track's data is loaded and ready\n         * @param args.trackPadding {Number} distance in px between tracks\n         */\n        constructor: function constructor(args) {\n            //number of histogram bins per block\n            this.numBins = lang.getObject('histogram.binsPerBlock', false, this.config) || 25;\n\n            this.defaultPadding = 5;\n            this.padding = this.defaultPadding;\n\n            this.glyphHeightPad = 1;\n            this.levelHeightPad = 2;\n            this.labelPad = 1;\n\n            // if calculated feature % width would be less than minFeatWidth, then set width to minFeatWidth instead\n            this.minFeatWidth = 1;\n\n            this.trackPadding = args.trackPadding;\n\n            this.heightCache = {}; // cache for the heights of some\n            // feature elements, indexed by the\n            // complete cassName of the feature\n\n            this.showLabels = this.config.style.showLabels;\n\n            this._setupEventHandlers();\n\n            // hook point\n            if (typeof this.extendedInit === 'function') this.extendedInit();\n        },\n\n        /**\n         * Returns object holding the default configuration for HTML-based feature tracks.\n         * @private\n         */\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(lang.clone(this.inherited(arguments)), {\n                maxFeatureScreenDensity: 0.5,\n\n                // maximum height of the track, in pixels\n                maxHeight: 1000,\n\n                style: {\n                    arrowheadClass: 'arrowhead',\n\n                    className: \"feature2\",\n\n                    // not configured by users\n                    _defaultHistScale: 4,\n                    _defaultLabelScale: 30,\n                    _defaultDescriptionScale: 120,\n\n                    minSubfeatureWidth: 6,\n                    maxDescriptionLength: 70,\n                    showLabels: true,\n\n                    label: 'name,id',\n                    description: 'note, description',\n\n                    centerChildrenVertically: true // by default use feature child centering\n                },\n                hooks: {\n                    create: function create(track, feat) {\n                        return document.createElement('div');\n                    }\n                },\n                events: {},\n                menuTemplate: [{ label: 'View details',\n                    title: '{type} {name}',\n                    action: 'contentDialog',\n                    iconClass: 'dijitIconTask',\n                    content: dojo.hitch(this, 'defaultFeatureDetail')\n                }, { label: function label() {\n                        return 'Highlight this ' + (this.feature && this.feature.get('type') ? this.feature.get('type') : 'feature');\n                    },\n                    action: function action() {\n                        var loc = new Location({ feature: this.feature, tracks: [this.track] });\n                        this.track.browser.setHighlightAndRedraw(loc);\n                    },\n                    iconClass: 'dijitIconFilter'\n                }]\n            });\n        },\n\n        /**\n         * Make life easier for event handlers by handing them some things\n         */\n        wrapHandler: function wrapHandler(handler) {\n            var track = this;\n            return function (event) {\n                event = event || window.event;\n                if (event.shiftKey) return;\n                var elem = event.currentTarget || event.srcElement;\n                //depending on bubbling, we might get the subfeature here\n                //instead of the parent feature\n                if (!elem.feature) elem = elem.parentElement;\n                if (!elem.feature) return; //shouldn't happen; just bail if it does\n                handler(track, elem, elem.feature, event);\n            };\n        },\n\n        fillHistograms: function fillHistograms(args) {\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n            var stripeWidth = args.stripeWidth;\n\n            var blockSizeBp = Math.abs(rightBase - leftBase);\n\n            // bases in each histogram bin that we're currently rendering\n            var basesPerBin = blockSizeBp / this.numBins;\n\n            var track = this;\n            this.store.getRegionFeatureDensities({ ref: this.refSeq.name,\n                start: args.leftBase,\n                end: args.rightBase,\n                basesPerBin: basesPerBin\n            }, function (histData) {\n                if (track._fillType != 'histograms') return; // we must have moved on\n\n                var hist = histData.bins;\n                var maxBin = 0;\n                for (var bin = 0; bin < track.numBins; bin++) {\n                    if (typeof hist[bin] == 'number' && isFinite(hist[bin])) {\n                        maxBin = Math.max(maxBin, hist[bin]);\n                    }\n                }\n\n                var logScale = histData.stats ? histData.stats.mean / histData.stats.max < 0.01 : false;\n                var pxPerCount = histData.stats ? 100 / (logScale ? Math.log(histData.stats.max) : histData.stats.max) : 2;\n                var dims = {\n                    basesPerBin: basesPerBin,\n                    pxPerCount: pxPerCount,\n                    logScale: logScale,\n                    stats: histData.stats\n                };\n\n                var binDiv;\n                for (bin = 0; bin < track.numBins; bin++) {\n                    if (!(typeof hist[bin] == 'number' && isFinite(hist[bin]))) continue;\n                    binDiv = document.createElement(\"div\");\n                    binDiv.className = \"hist feature-hist \" + track.config.style.className + \"-hist\";\n                    binDiv.style.cssText = \"left: \" + bin / track.numBins * 100 + \"%; \" + \"height: \" + dims.pxPerCount * (dims.logScale ? Math.log(hist[bin]) : hist[bin]) + \"px;\" + \"bottom: \" + track.trackPadding + \"px;\" + \"width: \" + (100 / track.numBins - 100 / stripeWidth) + \"%;\" + (track.config.style.histCss ? track.config.style.histCss : \"\");\n                    binDiv.setAttribute('value', hist[bin]);\n                    if (Util.is_ie6) binDiv.appendChild(document.createComment());\n                    block.domNode.appendChild(binDiv);\n                }\n\n                track.heightUpdate(dims.pxPerCount * (dims.logScale ? Math.log(maxBin) : maxBin), blockIndex);\n                track.makeHistogramYScale(blockSizeBp, dims, histData);\n            }, dojo.hitch(this, 'fillBlockError', blockIndex, block));\n\n            args.finishCallback();\n        },\n\n        endZoom: function endZoom(destScale, destBlockBases) {\n            this.clear();\n        },\n\n        updateStaticElements: function updateStaticElements(coords) {\n            this.inherited(arguments);\n            this.updateYScaleFromViewDimensions(coords);\n            this.updateFeatureLabelPositions(coords);\n            this.updateFeatureArrowPositions(coords);\n        },\n\n        updateFeatureArrowPositions: function updateFeatureArrowPositions(coords) {\n            if (!('x' in coords)) return;\n\n            var viewmin = this.browser.view.minVisible();\n            var viewmax = this.browser.view.maxVisible();\n\n            var blocks = this.blocks;\n\n            for (var blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n                var block = blocks[blockIndex];\n                if (!block) continue;\n                var childNodes = block.domNode.childNodes;\n                for (var i = 0; i < childNodes.length; i++) {\n                    var featDiv = childNodes[i];\n                    if (!featDiv.feature) continue;\n                    var feature = featDiv.feature;\n\n                    // Retrieve containerStart/End to resolve div truncation from renderFeature\n                    var containerStart = featDiv._containerStart;\n                    var containerEnd = featDiv._containerEnd;\n\n                    var strand = feature.get('strand');\n                    if (!strand) continue;\n\n                    var fmin = feature.get('start');\n                    var fmax = feature.get('end');\n                    var arrowhead;\n                    var featDivChildren;\n                    //borrow displayStart,displayEnd for arrowhead calculations because of truncations in renderFeat\n                    var displayStart = Math.max(fmin, containerStart);\n                    var displayEnd = Math.min(fmax, containerEnd);\n\n                    // minus strand\n                    if (strand < 0 && fmax > viewmin) {\n                        var minusArrowClass = 'minus-' + this.config.style.arrowheadClass;\n                        featDivChildren = featDiv.childNodes;\n                        for (var j = 0; j < featDivChildren.length; j++) {\n                            arrowhead = featDivChildren[j];\n                            if (typeof arrowhead.className === 'string') {\n                                if (arrowhead && arrowhead.className && arrowhead.className.indexOf(minusArrowClass) >= 0) {\n                                    arrowhead.style.left = (fmin < viewmin ? block.bpToX(viewmin) - block.bpToX(displayStart) : -this.minusArrowWidth) + 'px';\n                                };\n                            }\n                        }\n                    }\n                    // plus strand\n                    else if (strand > 0 && fmin < viewmax) {\n                            var plusArrowClass = 'plus-' + this.config.style.arrowheadClass;\n                            featDivChildren = featDiv.childNodes;\n                            for (var j = 0; j < featDivChildren.length; j++) {\n                                arrowhead = featDivChildren[j];\n                                if (typeof arrowhead.className === 'string') {\n                                    if (arrowhead && arrowhead.className && arrowhead.className.indexOf(plusArrowClass) >= 0) {\n                                        arrowhead.style.right = (fmax > viewmax ? block.bpToX(displayEnd) - block.bpToX(viewmax - 2) : -this.plusArrowWidth) + 'px';\n                                    }\n                                }\n                            }\n                        }\n                }\n            }\n        },\n\n        updateFeatureLabelPositions: function updateFeatureLabelPositions(coords) {\n            var showLabels = this.browser._showLabels;\n            if (!('x' in coords)) return;\n\n            array.forEach(this.blocks, function (block, blockIndex) {\n\n                // calculate the view left coord relative to the\n                // block left coord in units of pct of the block\n                // width\n                if (!block || !this.label) return;\n                var viewLeft = 100 * (this.label.offsetLeft + (showLabels ? this.label.offsetWidth : 0) - block.domNode.offsetLeft) / block.domNode.offsetWidth + 2;\n\n                // if the view start is unknown, or is to the\n                // left of this block, we don't have to worry\n                // about adjusting the feature labels\n                if (!viewLeft) return;\n\n                var blockWidth = block.endBase - block.startBase;\n\n                array.forEach(block.domNode.childNodes, function (featDiv) {\n                    if (!featDiv.label) return;\n                    var labelDiv = featDiv.label;\n                    var feature = featDiv.feature;\n\n                    // get the feature start and end in terms of block width pct\n                    var minLeft = parseInt(feature.get('start'));\n                    minLeft = 100 * (minLeft - block.startBase) / blockWidth;\n                    var maxLeft = parseInt(feature.get('end'));\n                    maxLeft = 100 * ((maxLeft - block.startBase) / blockWidth - labelDiv.offsetWidth / block.domNode.offsetWidth);\n\n                    // move our label div to the view start if the start is between the feature start and end\n                    labelDiv.style.left = Math.max(minLeft, Math.min(viewLeft, maxLeft)) + '%';\n                }, this);\n            }, this);\n        },\n\n        fillBlock: function fillBlock(args) {\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n            var scale = args.scale;\n            var containerStart = args.containerStart;\n            var containerEnd = args.containerEnd;\n\n            var region = { ref: this.refSeq.name, start: leftBase, end: rightBase };\n\n            this.store.getGlobalStats(dojo.hitch(this, function (stats) {\n\n                var density = stats.featureDensity;\n                var histScale = this.config.style.histScale || density * this.config.style._defaultHistScale;\n                var featureScale = this.config.style.featureScale || density / this.config.maxFeatureScreenDensity; // (feat/bp) / ( feat/px ) = px/bp )\n\n                // only update the label once for each block size\n                var blockBases = Math.abs(leftBase - rightBase);\n                if (this._updatedLabelForBlockSize != blockBases) {\n                    if (this.store.getRegionFeatureDensities && scale < histScale) {\n                        this.setLabel(this.key + ' <span class=\"feature-density\">per ' + Util.addCommas(Math.round(blockBases / this.numBins)) + ' bp</span>');\n                    } else {\n                        this.setLabel(this.key);\n                    }\n                    this._updatedLabelForBlockSize = blockBases;\n                }\n\n                // if our store offers density histograms, and we are zoomed out far enough, draw them\n                if (this.store.getRegionFeatureDensities && scale < histScale) {\n                    this._fillType = 'histograms';\n                    this.fillHistograms(args);\n                }\n                // if we have no histograms, check the predicted density of\n                // features on the screen, and display a message if it's\n                // bigger than maxFeatureScreenDensity\n                else if (scale < featureScale) {\n                        this.fillTooManyFeaturesMessage(blockIndex, block, scale);\n                        args.finishCallback();\n                    } else {\n                        // if we have transitioned to viewing features, delete the\n                        // y-scale used for the histograms\n                        this.removeYScale();\n                        this._fillType = 'features';\n                        this.fillFeatures(dojo.mixin({ stats: stats }, args));\n                    }\n            }), dojo.hitch(this, 'fillBlockError', blockIndex, block));\n        },\n\n        /**\n         * Creates a Y-axis scale for the feature histogram.  Must be run after\n         * the histogram bars are drawn, because it sometimes must use the\n         * track height to calculate the max value if there are no explicit\n         * histogram stats.\n         */\n        makeHistogramYScale: function makeHistogramYScale(blockSizeBp, dims, histData) {\n            if (dims.logScale) {\n                console.error(\"Log histogram scale axis labels not yet implemented.\");\n                return;\n            }\n            var maxval = this.height / dims.pxPerCount;\n            maxval = dims.logScale ? Math.log(maxval) : maxval;\n\n            // if we have a scale, and it has the same characteristics\n            // (including pixel height), don't redraw it.\n            if (this.yscale && this.yscale_params && this.yscale_params.maxval == maxval && this.yscale_params.height == this.height && this.yscale_params.blockbp == blockSizeBp) {\n                return;\n            } else {\n                this.removeYScale();\n                this.makeYScale({ min: 0, max: maxval });\n                this.yscale_params = {\n                    height: this.height,\n                    blockbp: blockSizeBp,\n                    maxval: maxval\n                };\n            }\n        },\n\n        destroy: function destroy() {\n            this._clearLayout();\n            this.inherited(arguments);\n        },\n\n        cleanupBlock: function cleanupBlock(block) {\n            if (block) {\n                // discard the layout for this range\n                if (this.layout) this.layout.discardRange(block.startBase, block.endBase);\n\n                if (block.featureNodes) for (var name in block.featureNodes) {\n                    var featDiv = block.featureNodes[name];\n                    array.forEach('track,feature,callbackArgs,_labelScale,_descriptionScale'.split(','), function (a) {\n                        Util.removeAttribute(featDiv, a);\n                    });\n                    if ('label' in featDiv) {\n                        array.forEach('track,feature,callbackArgs'.split(','), function (a) {\n                            Util.removeAttribute(featDiv.label, a);\n                        });\n                        Util.removeAttribute(featDiv, 'label');\n                    }\n                }\n            }\n\n            this.inherited(arguments);\n        },\n\n        /**\n         * Called when sourceBlock gets deleted.  Any child features of\n         * sourceBlock that extend onto destBlock should get moved onto\n         * destBlock.\n         */\n        transfer: function transfer(sourceBlock, destBlock, scale, containerStart, containerEnd) {\n\n            if (!(sourceBlock && destBlock)) return;\n\n            var destLeft = destBlock.startBase;\n            var destRight = destBlock.endBase;\n            var blockWidth = destRight - destLeft;\n            var sourceSlot;\n\n            var overlaps = sourceBlock.startBase < destBlock.startBase ? sourceBlock.rightOverlaps : sourceBlock.leftOverlaps;\n            overlaps = overlaps || [];\n\n            for (var i = 0; i < overlaps.length; i++) {\n                //if the feature overlaps destBlock,\n                //move to destBlock & re-position\n                sourceSlot = sourceBlock.featureNodes[overlaps[i]];\n                if (sourceSlot && sourceSlot.label && sourceSlot.label.parentNode) {\n                    sourceSlot.label.parentNode.removeChild(sourceSlot.label);\n                }\n                if (sourceSlot && sourceSlot.feature) {\n                    if (sourceSlot.layoutEnd > destLeft && sourceSlot.feature.get('start') < destRight) {\n\n                        sourceSlot.parentNode.removeChild(sourceSlot);\n\n                        delete sourceBlock.featureNodes[overlaps[i]];\n\n                        /* feature render, adding to block, centering refactored into addFeatureToBlock() */\n                        var featDiv = this.addFeatureToBlock(sourceSlot.feature, overlaps[i], destBlock, scale, sourceSlot._labelScale, sourceSlot._descriptionScale, containerStart, containerEnd);\n                        // if there are boolean coverage divs, modify feature accordingly.\n                        if (sourceSlot.booleanCovs) {\n                            this._maskTransfer(featDiv, sourceSlot, containerStart, containerEnd);\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Called by \"tranfer\" when sourceBlock gets deleted.  Ensures that any child features of\n         * sourceBlock that extend onto destBlock will remain masked when moved onto\n         * destBlock.\n         */\n        _maskTransfer: function _maskTransfer(featDiv, sourceSlot, containerStart, containerEnd) {\n            var subfeatures = [];\n            // remove subfeatures\n            while (featDiv.firstChild) {\n                subfeatures.push(featDiv.firstChild);\n                featDiv.removeChild(featDiv.firstChild);\n            }\n            var s = featDiv.featureEdges.s;\n            var e = featDiv.featureEdges.e;\n            for (var key in sourceSlot.booleanCovs) {\n                if (sourceSlot.booleanCovs.hasOwnProperty(key)) {\n                    // dynamically resize the coverage divs.\n                    var start = sourceSlot.booleanCovs[key].span.s;\n                    var end = sourceSlot.booleanCovs[key].span.e;\n                    if (end < containerStart || start > containerEnd) continue;\n                    // note: we should also remove it from booleanCovs at some point.\n                    sourceSlot.booleanCovs[key].style.left = 100 * (start - s) / (e - s) + '%';\n                    sourceSlot.booleanCovs[key].style.width = 100 * (end - start) / (e - s) + '%';\n                    featDiv.appendChild(sourceSlot.booleanCovs[key]);\n                }\n            }\n            // add the processed subfeatures, if in frame.\n            query('.basicSubfeature', sourceSlot).forEach(function (node, idx, arr) {\n                var start = node.subfeatureEdges.s;\n                var end = node.subfeatureEdges.e;\n                if (end < containerStart || start > containerEnd) return;\n                node.style.left = 100 * (start - s) / (e - s) + '%';\n                node.style.width = 100 * (end - start) / (e - s) + '%';\n                featDiv.appendChild(node);\n            });\n            if (this.config.style.arrowheadClass) {\n                // add arrowheads\n                var a = this.config.style.arrowheadClass;\n                query('.minus-' + a + ', .plus-' + a, sourceSlot).forEach(function (node, idx, arr) {\n                    featDiv.appendChild(node);\n                });\n            }\n            featDiv.className = 'basic';\n            featDiv.oldClassName = sourceSlot.oldClassName;\n            featDiv.booleanCovs = sourceSlot.booleanCovs;\n        },\n\n        /**\n         * arguments:\n         * @param args.block div to be filled with info\n         * @param args.leftBlock div to the left of the block to be filled\n         * @param args.rightBlock div to the right of the block to be filled\n         * @param args.leftBase starting base of the block\n         * @param args.rightBase ending base of the block\n         * @param args.scale pixels per base at the current zoom level\n         * @param args.containerStart don't make HTML elements extend further left than this\n         * @param args.containerEnd don't make HTML elements extend further right than this. 0-based.\n         */\n        fillFeatures: function fillFeatures(args) {\n            var _this = this;\n\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n            var scale = args.scale;\n            var stats = args.stats;\n            var containerStart = args.containerStart;\n            var containerEnd = args.containerEnd;\n            var finishCallback = args.finishCallback;\n            var browser = this.browser;\n\n            this.scale = scale;\n\n            block.featureNodes = {};\n\n            //determine the glyph height, arrowhead width, label text dimensions, etc.\n            if (!this.haveMeasurements) {\n                this.measureStyles();\n                this.haveMeasurements = true;\n            }\n\n            var labelScale = this.config.style.labelScale || stats.featureDensity * this.config.style._defaultLabelScale;\n            var descriptionScale = this.config.style.descriptionScale || stats.featureDensity * this.config.style._defaultDescriptionScale;\n\n            var curTrack = this;\n\n            var featCallback = function featCallback(feature) {\n                // feature rendering, adding to block, centering refactored into addFeatureToBlock()\n\n                var uniqueId = feature.id();\n\n                if (_this._featureIsRendered(uniqueId)) return;\n\n                if (!_this.filterFeature(feature)) return;\n\n                // deprecated Apollo hook point, need to schedule this block for removal\n                if (typeof _this.renderFilter === 'function') {\n                    // deprecation warning\n                    if (!_this._warnedAboutRenderFilterDeprecation) {\n                        console.warn('the HTMLFeatures.renderFilter is deprecated, please use the existing feature filtering functionality (addFeatureFilter)');\n                        _this._warnedAboutRenderFilterDeprecation = true;\n                    }\n\n                    var render = _this.renderFilter(feature);\n                    if (render === 1) _this.addFeatureToBlock(feature, uniqueId, block, scale, labelScale, descriptionScale, containerStart, containerEnd);\n                    return;\n                }\n\n                // normal case\n                _this.addFeatureToBlock(feature, uniqueId, block, scale, labelScale, descriptionScale, containerStart, containerEnd);\n            };\n\n            this.store.getFeatures({ ref: this.refSeq.name,\n                start: leftBase,\n                end: rightBase\n            }, featCallback, function (args) {\n                curTrack.heightUpdate(curTrack._getLayout(scale).getTotalHeight(), blockIndex);\n                if (args && args.maskingSpans) {\n                    //note: spans have to be inverted\n                    var invSpan = [];\n                    invSpan[0] = { start: leftBase };\n                    var i = 0;\n                    for (var span in args.maskingSpans) {\n                        if (args.maskingSpans.hasOwnProperty(span)) {\n                            span = args.maskingSpans[span];\n                            invSpan[i].end = span.start;\n                            i++;\n                            invSpan[i] = { start: span.end };\n                        }\n                    }\n                    invSpan[i].end = rightBase;\n                    if (invSpan[i].end <= invSpan[i].start) {\n                        invSpan.splice(i, 1);\n                    }\n                    if (invSpan[0].end <= invSpan[0].start) {\n                        invSpan.splice(0, 1);\n                    }\n                    curTrack.maskBySpans(invSpan, args.maskingSpans);\n                }\n                finishCallback();\n            }, function (error) {\n                console.error(error, error.stack);\n                curTrack.fillBlockError(blockIndex, block, error);\n                finishCallback();\n            });\n        },\n        /**\n         * template for renderFilter\n         * This hook allows filtering of features to render.\n         * @param {type} feature\n         * @returns true if render feature, false if not\n         */\n        /*\n         renderFilter: function(feature) {\n         return 1;\n         },\n         */\n        /**\n         *  Creates feature div, adds to block, and centers subfeatures.\n         *  Overridable by subclasses that need more control over the substructure.\n         */\n        addFeatureToBlock: function addFeatureToBlock(feature, uniqueId, block, scale, labelScale, descriptionScale, containerStart, containerEnd) {\n            var thisB = this;\n\n            if ((typeof this.browser.config.inferHTMLSubfeatures === 'undefined' || this.browser.config.inferHTMLSubfeatures === true) && feature.get('type') == 'gene' && feature.get('subfeatures')) {\n                var d = dojo.create('div');\n                var feats = feature.get('subfeatures');\n                if (!feats) {\n                    return null;\n                }\n                feats.forEach(function (feat) {\n                    if (!thisB._featureIsRendered(uniqueId + '_' + thisB.getId(feat))) {\n                        featDiv = thisB.renderFeature(feat, uniqueId + '_' + thisB.getId(feat), block, scale, labelScale, descriptionScale, containerStart, containerEnd);\n                        if (featDiv) {\n                            // In case the feature was not rendered (too many)\n                            d.appendChild(featDiv);\n                        }\n                    }\n                });\n                block.domNode.appendChild(d);\n                if (this.config.style.centerChildrenVertically) {\n                    d.childNodes.forEach(function (featDiv) {\n                        thisB._centerChildrenVertically(featDiv);\n                    });\n                }\n                return d;\n            } else {\n                var featDiv = this.renderFeature(feature, uniqueId, block, scale, labelScale, descriptionScale, containerStart, containerEnd);\n                if (!featDiv) return null;\n\n                block.domNode.appendChild(featDiv);\n                if (this.config.style.centerChildrenVertically) this._centerChildrenVertically(featDiv);\n            }\n            return featDiv;\n        },\n\n        fillBlockTimeout: function fillBlockTimeout(blockIndex, block) {\n            this.inherited(arguments);\n            block.featureNodes = {};\n        },\n\n        /**\n         * Returns true if a feature is visible and rendered someplace in the blocks of this track.\n         * @private\n         */\n        _featureIsRendered: function _featureIsRendered(uniqueId) {\n            var blocks = this.blocks;\n            for (var i = 0; i < blocks.length; i++) {\n                if (blocks[i] && blocks[i].featureNodes && blocks[i].featureNodes[uniqueId]) return true;\n            }\n            return false;\n        },\n\n        /**\n         * If spans are passed to the track (i.e. if it is a boolean track), mask features accordingly.\n         */\n        maskBySpans: function maskBySpans(invSpans, spans) {\n            var blocks = this.blocks;\n            for (var i in blocks) {\n                if (blocks.hasOwnProperty(i)) {\n                    // loop through all blocks\n                    if (!blocks[i]) continue;\n                    var block = blocks[i];\n                    var bs = block.startBase;\n                    var be = block.endBase;\n\n                    var overlaps = function overlaps(featStart, featEnd, spanStart, spanEnd) {\n                        // outputs start and end points of overlap\n                        var s = Math.max(featStart, spanStart);\n                        var e = Math.min(featEnd, spanEnd);\n                        if (s < e) {\n                            return { s: s, e: e };\n                        }\n                        return false;\n                    };\n\n                    var union = function union(start1, end1, start2, end2) {\n                        // outputs the endpoints of the union\n                        if (overlaps(start1, end1, start2, end2)) {\n                            return { s: Math.min(start1, start2),\n                                e: Math.max(end1, end2) };\n                        } else {\n                            return false;\n                        }\n                    };\n\n                    var makeDiv = function makeDiv(start, end, parentDiv, masked, voidClass) {\n                        // make a coverage div\n                        var coverageNode = dojo.create('div');\n                        var s = parentDiv.featureEdges ? parentDiv.featureEdges.s : parentDiv.subfeatureEdges.s;\n                        var e = parentDiv.featureEdges ? parentDiv.featureEdges.e : parentDiv.subfeatureEdges.e;\n                        coverageNode.span = { s: start, e: end };\n                        coverageNode.className = masked ? feat.className == voidClass ? feat.oldClassName + ' Boolean-transparent' : feat.className + ' Boolean-transparent' : feat.className == voidClass ? feat.oldClassName : feat.className;\n                        coverageNode.booleanDiv = true;\n                        coverageNode.style.left = 100 * (start - s) / (e - s) + '%';\n                        coverageNode.style.top = '0px';\n                        coverageNode.style.width = 100 * (end - start) / (e - s) + '%';\n                        return coverageNode;\n                    };\n\n                    var addDiv = function addDiv(start, end, parentDiv, masked, voidClass, isAdded) {\n                        // Loop through coverage Nodes, combining existing nodes so they don't overlap, and add new divs.\n                        isAdded = isAdded || false;\n                        for (var key in parentDiv.childNodes) {\n                            if (parentDiv.childNodes[key] && parentDiv.childNodes[key].booleanDiv) {\n                                var divStart = parentDiv.childNodes[key].span.s;\n                                var divEnd = parentDiv.childNodes[key].span.e;\n                                if (divStart <= start && divEnd >= end) {\n                                    isAdded = true;\n                                    break;\n                                }\n                                var u = union(start, end, divStart, divEnd);\n                                if (u) {\n                                    var coverageNode = makeDiv(u.s, u.e, parentDiv, masked, voidClass);\n                                    var tempIndex = parentDiv.booleanCovs.indexOf(parentDiv.childNodes[key]);\n                                    parentDiv.removeChild(parentDiv.childNodes[key]);\n                                    parentDiv.booleanCovs.splice(tempIndex, 1);\n                                    parentDiv.appendChild(coverageNode);\n                                    parentDiv.booleanCovs.push(coverageNode);\n                                    isAdded = true;\n                                    addDiv(u.s, u.e, parentDiv, masked, voidClass, true);\n                                    break;\n                                }\n                            }\n                        }\n                        if (!isAdded) {\n                            var coverageNode = makeDiv(start, end, parentDiv, masked, voidClass);\n                            parentDiv.appendChild(coverageNode);\n                            parentDiv.booleanCovs.push(coverageNode);\n                        }\n                    };\n\n                    var addOverlaps = function addOverlaps(s, e, feat, spans, invSpans, voidClass) {\n                        if (!feat.booleanCovs) {\n                            feat.booleanCovs = [];\n                        }\n                        // add opaque divs\n                        for (var index in invSpans) {\n                            if (invSpans.hasOwnProperty(index)) {\n                                var ov = overlaps(s, e, invSpans[index].start, invSpans[index].end);\n                                if (ov) {\n                                    addDiv(ov.s, ov.e, feat, false, voidClass);\n                                }\n                            }\n                        }\n                        // add masked divs\n                        for (var index in spans) {\n                            if (spans.hasOwnProperty(index)) {\n                                var ov = overlaps(s, e, spans[index].start, spans[index].end);\n                                if (ov) {\n                                    addDiv(ov.s, ov.e, feat, true, voidClass);\n                                }\n                            }\n                        }\n\n                        feat.oldClassName = feat.className == voidClass ? feat.oldClassName : feat.className;\n                        feat.className = voidClass;\n                    };\n\n                    for (var key in block.featureNodes) {\n                        if (block.featureNodes.hasOwnProperty(key)) {\n                            var feat = block.featureNodes[key];\n                            if (!feat.feature) {\n                                // If there is no feature property, than it is a subfeature\n                                var s = feat.subfeatureEdges.s;\n                                var e = feat.subfeatureEdges.e;\n                                addOverlaps(s, e, feat, spans, invSpans, 'basicSubfeature');\n                                continue;\n                            }\n                            var s = feat.feature.get('start');\n                            var e = feat.feature.get('end');\n                            addOverlaps(s, e, feat, spans, invSpans, 'basic');\n                        }\n                    }\n                }\n            }\n        },\n\n        measureStyles: function measureStyles() {\n            var container = this.browser.container;\n\n            //determine dimensions of labels (height, per-character width)\n            var heightTest = document.createElement(\"div\");\n            heightTest.className = \"feature-label\";\n            heightTest.style.height = \"auto\";\n            heightTest.style.visibility = \"hidden\";\n            heightTest.appendChild(document.createTextNode(\"1234567890\"));\n            container.appendChild(heightTest);\n            this.labelHeight = heightTest.clientHeight;\n            this.labelWidth = heightTest.clientWidth / 10;\n            container.removeChild(heightTest);\n\n            //measure the height of glyphs\n            var glyphBox;\n            heightTest = document.createElement(\"div\");\n            //cover all the bases: stranded or not, phase or not\n            heightTest.className = \"feature \" + this.config.style.className + \" plus-\" + this.config.style.className + \" plus-\" + this.config.style.className + \"1\";\n            if (this.config.style.featureCss) heightTest.style.cssText = this.config.style.featureCss;\n            heightTest.style.visibility = \"hidden\";\n            if (Util.is_ie6) heightTest.appendChild(document.createComment(\"foo\"));\n            container.appendChild(heightTest);\n            glyphBox = domGeom.getMarginBox(heightTest);\n            this.glyphHeight = Math.round(glyphBox.h);\n            this.padding = this.defaultPadding + glyphBox.w;\n            container.removeChild(heightTest);\n\n            //determine the width of the arrowhead, if any\n            if (this.config.style.arrowheadClass) {\n                var ah = document.createElement(\"div\");\n                ah.className = \"plus-\" + this.config.style.arrowheadClass;\n                if (Util.is_ie6) ah.appendChild(document.createComment(\"foo\"));\n                container.appendChild(ah);\n                glyphBox = domGeom.position(ah);\n                this.plusArrowWidth = glyphBox.w;\n                this.plusArrowHeight = glyphBox.h;\n                ah.className = \"minus-\" + this.config.style.arrowheadClass;\n                glyphBox = domGeom.position(ah);\n                this.minusArrowWidth = glyphBox.w;\n                this.minusArrowHeight = glyphBox.h;\n                container.removeChild(ah);\n            }\n        },\n\n        hideAll: function hideAll() {\n            this._clearLayout();\n            return this.inherited(arguments);\n        },\n\n        getFeatDiv: function getFeatDiv(feature) {\n            var id = this.getId(feature);\n            var gene_id;\n\n            if ((typeof this.browser.config.inferHTMLSubfeatures === 'undefined' || this.browser.config.inferHTMLSubfeatures === true) && feature.parent() && feature.parent().get('type') == \"gene\") {\n                gene_id = this.getId(feature.parent()) + '_' + this.getId(feature);\n            }\n\n            if (!id && !gene_id) return null;\n\n            for (var i = 0; i < this.blocks.length; i++) {\n                var b = this.blocks[i];\n                if (b && b.featureNodes) {\n                    var f = b.featureNodes[id];\n                    if (f) return f;\n                    f = b.featureNodes[gene_id];\n                    if (f) return f;\n                }\n            }\n\n            return null;\n        },\n\n        getId: function getId(f) {\n            return f.id();\n        },\n\n        renderFeature: function renderFeature(feature, uniqueId, block, scale, labelScale, descriptionScale, containerStart, containerEnd) {\n            //featureStart and featureEnd indicate how far left or right\n            //the feature extends in bp space, including labels\n            //and arrowheads if applicable\n\n            var featureEnd = feature.get('end');\n            var featureStart = feature.get('start');\n            if (typeof featureEnd == 'string') featureEnd = parseInt(featureEnd);\n            if (typeof featureStart == 'string') featureStart = parseInt(featureStart);\n            // layoutStart: start genome coord (at current scale) of horizontal space need to render feature,\n            //       including decorations (arrowhead, label, etc) and padding\n            var layoutStart = featureStart;\n            // layoutEnd: end genome coord (at current scale) of horizontal space need to render feature,\n            //       including decorations (arrowhead, label, etc) and padding\n            var layoutEnd = featureEnd;\n\n            //     JBrowse now draws arrowheads within feature genome coord bounds\n            //     For WebApollo we're keeping arrow outside of feature genome coord bounds,\n            //           because otherwise arrow can obscure edge-matching, CDS/UTR transitions, small inton/exons, etc.\n            //     Would like to implement arrowhead change in WebApollo plugin, but would need to refactor HTMLFeature more to allow for that\n            if (this.config.style.arrowheadClass) {\n                switch (feature.get('strand')) {\n                    case 1:\n                    case '+':\n                        layoutEnd += this.plusArrowWidth / scale;break;\n                    case -1:\n                    case '-':\n                        layoutStart -= this.minusArrowWidth / scale;break;\n                }\n            }\n\n            var levelHeight = this.glyphHeight + this.glyphHeightPad;\n\n            // if the label extends beyond the feature, use the\n            // label end position as the end position for layout\n            var name = this.getFeatureLabel(feature);\n            var description = scale > descriptionScale && this.getFeatureDescription(feature);\n            if (description && description.length > this.config.style.maxDescriptionLength) description = description.substr(0, this.config.style.maxDescriptionLength + 1).replace(/(\\s+\\S+|\\s*)$/, '') + String.fromCharCode(8230);\n\n            // add the label div (which includes the description) to the\n            // calculated height of the feature if it will be displayed\n            if (this.showLabels && scale >= labelScale && name) {\n                layoutEnd = Math.max(layoutEnd, layoutStart + ('' + name).length * this.labelWidth / scale);\n                levelHeight += this.labelHeight + this.labelPad;\n            }\n            if (this.showLabels && description) {\n                layoutEnd = Math.max(layoutEnd, layoutStart + ('' + description).length * this.labelWidth / scale);\n                levelHeight += this.labelHeight + this.labelPad;\n            }\n\n            layoutEnd += Math.max(1, this.padding / scale);\n\n            var top = this._getLayout(scale).addRect(uniqueId, layoutStart, layoutEnd, levelHeight);\n\n            if (top === null) {\n                // could not lay out, would exceed our configured maxHeight\n                // mark the block as exceeding the max height\n                this.markBlockHeightOverflow(block);\n                return null;\n            }\n\n            var featDiv = this.config.hooks.create(this, feature);\n            this._connectFeatDivHandlers(featDiv);\n            // NOTE ANY DATA SET ON THE FEATDIV DOM NODE NEEDS TO BE\n            // MANUALLY DELETED IN THE cleanupBlock METHOD BELOW\n            featDiv.track = this;\n            featDiv.feature = feature;\n            featDiv.layoutEnd = layoutEnd;\n\n            // border values used in positioning boolean subfeatures, if any.\n            featDiv.featureEdges = { s: Math.max(featDiv.feature.get('start'), containerStart),\n                e: Math.min(featDiv.feature.get('end'), containerEnd) };\n\n            // (callbackArgs are the args that will be passed to callbacks\n            // in this feature's context menu or left-click handlers)\n            featDiv.callbackArgs = [this, featDiv.feature, featDiv];\n\n            // save the label scale and description scale in the featDiv\n            // so that we can use them later\n            featDiv._labelScale = labelScale;\n            featDiv._descriptionScale = descriptionScale;\n\n            block.featureNodes[uniqueId] = featDiv;\n\n            // hook point\n            if (typeof this.featureHook1 === 'function') this.featureHook1(feature, featDiv);\n\n            // record whether this feature protrudes beyond the left and/or right side of the block\n            if (layoutStart < block.startBase) {\n                if (!block.leftOverlaps) block.leftOverlaps = [];\n                block.leftOverlaps.push(uniqueId);\n            }\n            if (layoutEnd > block.endBase) {\n                if (!block.rightOverlaps) block.rightOverlaps = [];\n                block.rightOverlaps.push(uniqueId);\n            }\n\n            dojo.addClass(featDiv, \"feature\");\n            var className = this.config.style.className;\n            if (className == \"{type}\") {\n                className = feature.get('type');\n            }\n            var strand = feature.get('strand');\n            switch (strand) {\n                case 1:\n                case '+':\n                    dojo.addClass(featDiv, \"plus-\" + className);break;\n                case -1:\n                case '-':\n                    dojo.addClass(featDiv, \"minus-\" + className);break;\n                default:\n                    dojo.addClass(featDiv, className);\n            }\n            var phase = feature.get('phase');\n            if (phase !== null && phase !== undefined)\n                //            featDiv.className = featDiv.className + \" \" + featDiv.className + \"_phase\" + phase;\n                dojo.addClass(featDiv, className + \"_phase\" + phase);\n\n            // check if this feature is highlighted\n            var highlighted = this.isFeatureHighlighted(feature, name);\n\n            // add 'highlighted' to the feature's class if its name\n            // matches the objectName of the global highlight and it's\n            // within the highlighted region\n            if (highlighted) dojo.addClass(featDiv, 'highlighted');\n\n            // Since some browsers don't deal well with the situation where\n            // the feature goes way, way offscreen, we truncate the feature\n            // to exist betwen containerStart and containerEnd.\n            // To make sure the truncated end of the feature never gets shown,\n            // we'll destroy and re-create the feature (with updated truncated\n            // boundaries) in the transfer method.\n            var displayStart = Math.max(featureStart, containerStart);\n            var displayEnd = Math.min(featureEnd, containerEnd);\n            var blockWidth = block.endBase - block.startBase;\n            var featwidth = Math.max(this.minFeatWidth, 100 * ((displayEnd - displayStart) / blockWidth));\n            featDiv.style.cssText = \"left:\" + 100 * (displayStart - block.startBase) / blockWidth + \"%;\" + \"top:\" + top + \"px;\" + \" width:\" + featwidth + \"%;\" + (this.config.style.featureCss ? this.config.style.featureCss : \"\");\n\n            // Store the containerStart/End so we can resolve the truncation\n            // when we are updating static elements\n            featDiv._containerStart = containerStart;\n            featDiv._containerEnd = containerEnd;\n\n            if (this.config.style.arrowheadClass) {\n                var ah = document.createElement(\"div\");\n                var featwidth_px = featwidth / 100 * blockWidth * scale;\n\n                switch (strand) {\n                    case 1:\n                    case '+':\n                        ah.className = \"plus-\" + this.config.style.arrowheadClass;\n                        ah.style.cssText = \"right: \" + -this.plusArrowWidth + \"px\";\n                        featDiv.appendChild(ah);\n                        break;\n                    case -1:\n                    case '-':\n                        ah.className = \"minus-\" + this.config.style.arrowheadClass;\n                        ah.style.cssText = \"left: \" + -this.minusArrowWidth + \"px\";\n                        featDiv.appendChild(ah);\n                        break;\n                }\n            }\n\n            // fill in the template parameters in the featDiv and also for the labelDiv (see below)\n            var context = lang.mixin({ track: this, feature: feature, callbackArgs: [this, feature] });\n            if (featDiv.title) {\n                featDiv.title = this.template(feature, this._evalConf(context, featDiv.title, \"label\"));\n            }\n\n            if ((name || description) && this.showLabels && scale >= labelScale) {\n                var labelDiv = dojo.create('div', {\n                    className: \"feature-label\" + (highlighted ? ' highlighted' : ''),\n                    innerHTML: (name ? '<div class=\"feature-name\">' + (this.config.unsafeHTMLFeatures ? name : Util.escapeHTML(name)) + '</div>' : '') + (description ? ' <div class=\"feature-description\">' + (this.config.unsafeHTMLFeatures ? description : Util.escapeHTML(description)) + '</div>' : ''),\n                    style: {\n                        top: top + this.glyphHeight + 2 + \"px\",\n                        left: 100 * (layoutStart - block.startBase) / blockWidth + '%'\n                    }\n                }, block.domNode);\n\n                this._connectFeatDivHandlers(labelDiv);\n\n                if (featDiv.title) labelDiv.title = featDiv.title;\n                featDiv.label = labelDiv;\n\n                // NOTE: ANY DATA ADDED TO THE labelDiv MUST HAVE A\n                // CORRESPONDING DELETE STATMENT IN cleanupBlock BELOW\n                labelDiv.feature = feature;\n                labelDiv.track = this;\n                // (callbackArgs are the args that will be passed to callbacks\n                // in this feature's context menu or left-click handlers)\n                labelDiv.callbackArgs = [this, featDiv.feature, featDiv];\n            }\n\n            if (featwidth > this.config.style.minSubfeatureWidth) {\n                this.handleSubFeatures(feature, featDiv, displayStart, displayEnd, block);\n            }\n\n            // render the popup menu if configured\n            if (this.config.menuTemplate) {\n                window.setTimeout(dojo.hitch(this, '_connectMenus', featDiv), 50 + Math.random() * 150);\n            }\n\n            if (typeof this.config.hooks.modify == 'function') {\n                this.config.hooks.modify(this, feature, featDiv);\n            }\n\n            return featDiv;\n        },\n\n        handleSubFeatures: function handleSubFeatures(feature, featDiv, displayStart, displayEnd, block) {\n            var subfeatures = feature.get('subfeatures');\n            if (subfeatures) {\n                for (var i = 0; i < subfeatures.length; i++) {\n                    this.renderSubfeature(feature, featDiv, subfeatures[i], displayStart, displayEnd, block);\n                    var subfeature = subfeatures[i];\n                    var subtype = subfeature.get('type');\n                    if (subtype == 'mRNA') {\n                        this.handleSubFeatures(subfeature, featDiv, displayStart, displayEnd, block);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Get the height of a div.  Caches div heights based on\n         * classname.\n         */\n        _getHeight: function _getHeight(theDiv) {\n            if (this.config.disableHeightCache) {\n                return theDiv.offsetHeight || 0;\n            } else {\n                var c = this.heightCache[theDiv.className];\n                if (c) return c;\n                c = theDiv.offsetHeight || 0;\n                this.heightCache[theDiv.className] = c;\n                return c;\n            }\n        },\n\n        /**\n         * Vertically centers all the child elements of a feature div.\n         * @private\n         */\n        _centerChildrenVertically: function _centerChildrenVertically( /**HTMLElement*/featDiv) {\n            if (featDiv.childNodes.length > 0) {\n                var parentHeight = this._getHeight(featDiv);\n                for (var i = 0; i < featDiv.childNodes.length; i++) {\n                    var child = featDiv.childNodes[i];\n                    // only operate on child nodes that can be styled,\n                    // i.e. HTML elements instead of text nodes or whatnot\n                    if (child.style) {\n                        // cache the height of elements, for speed.\n                        var h = this._getHeight(child);\n                        dojo.style(child, { marginTop: '0', top: (parentHeight - h) / 2 + 'px' });\n                        // recursively center any descendants\n                        if (child.childNodes.length > 0) {\n                            this._centerChildrenVertically(child);\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Connect our configured event handlers to a given html element,\n         * usually a feature div or label div.\n         */\n        _connectFeatDivHandlers: function _connectFeatDivHandlers( /** HTMLElement */div) {\n            for (var event in this.eventHandlers) {\n                this.own(on(div, event, this.eventHandlers[event]));\n            }\n            // if our click handler has a label, set that as a tooltip\n            if (this.eventHandlers.click && this.eventHandlers.click.label) div.setAttribute('title', this.eventHandlers.click.label);\n        },\n\n        _connectMenus: function _connectMenus(featDiv) {\n            // don't actually make the menu until the feature is\n            // moused-over.  pre-generating menus for lots and lots of\n            // features at load time is way too slow.\n            var refreshMenu = lang.hitch(this, '_refreshMenu', featDiv);\n            this.own(on(featDiv, 'mouseover', refreshMenu));\n            if (featDiv.label) {\n                this.own(on(featDiv.label, 'mouseover', refreshMenu));\n            }\n        },\n\n        _refreshMenu: function _refreshMenu(featDiv) {\n            // if we already have a menu generated for this feature,\n            // give it a new lease on life\n            if (!featDiv.contextMenu) {\n                featDiv.contextMenu = this._makeFeatureContextMenu(featDiv, this.config.menuTemplate);\n            }\n\n            // give the menu a timeout so that it's cleaned up if it's not used within a certain time\n            if (featDiv.contextMenuTimeout) {\n                window.clearTimeout(featDiv.contextMenuTimeout);\n            }\n            var timeToLive = 30000; // clean menus up after 30 seconds\n            featDiv.contextMenuTimeout = window.setTimeout(function () {\n                if (featDiv.contextMenu) {\n                    featDiv.contextMenu.destroyRecursive();\n                    Util.removeAttribute(featDiv, 'contextMenu');\n                }\n                Util.removeAttribute(featDiv, 'contextMenuTimeout');\n            }, timeToLive);\n        },\n\n        /**\n         * Make the right-click dijit menu for a feature.\n         */\n        _makeFeatureContextMenu: function _makeFeatureContextMenu(featDiv, menuTemplate) {\n            // interpolate template strings in the menuTemplate\n            menuTemplate = this._processMenuSpec(dojo.clone(menuTemplate), featDiv);\n\n            // render the menu, start it up, and bind it to right-clicks\n            // both on the feature div and on the label div\n            var menu = this._renderContextMenu(menuTemplate, featDiv);\n            menu.startup();\n            menu.bindDomNode(featDiv);\n            if (featDiv.label) menu.bindDomNode(featDiv.label);\n\n            return menu;\n        },\n\n        renderSubfeature: function renderSubfeature(feature, featDiv, subfeature, displayStart, displayEnd, block) {\n            var subStart = subfeature.get('start');\n            var subEnd = subfeature.get('end');\n            var featLength = displayEnd - displayStart;\n            var type = subfeature.get('type');\n            var className;\n            if (this.config.style.subfeatureClasses) {\n                className = this.config.style.subfeatureClasses[type];\n                // if no class mapping specified for type, default to subfeature.get('type')\n                if (className === undefined) {\n                    className = type;\n                }\n                // if subfeatureClasses specifies that subfeature type explicitly maps to null className\n                //     then don't render the feature\n                else if (className === null) {\n                        return null;\n                    }\n            } else {\n                // if no config.style.subfeatureClasses to specify subfeature class mapping, default to subfeature.get('type')\n                className = type;\n            }\n\n            // a className of 'hidden' causes things to not even be rendered\n            if (className == 'hidden') return null;\n\n            var subDiv = document.createElement(\"div\");\n            // used by boolean tracks to do positiocning\n            subDiv.subfeatureEdges = { s: subStart, e: subEnd };\n\n            dojo.addClass(subDiv, \"subfeature\");\n            // check for className to avoid adding \"null\", \"plus-null\", \"minus-null\"\n            if (className) {\n                switch (subfeature.get('strand')) {\n                    case 1:\n                    case '+':\n                        dojo.addClass(subDiv, \"plus-\" + className);break;\n                    case -1:\n                    case '-':\n                        dojo.addClass(subDiv, \"minus-\" + className);break;\n                    default:\n                        dojo.addClass(subDiv, className);\n                }\n            }\n\n            // if the feature has been truncated to where it doesn't cover\n            // this subfeature anymore, just skip this subfeature\n\n            var truncate = false;\n            if (typeof this.config.truncateFeatures !== 'undefined' && this.config.truncateFeatures === true) truncate = true;\n\n            if (truncate && (subEnd <= displayStart || subStart >= displayEnd)) return null;\n\n            if (Util.is_ie6) subDiv.appendChild(document.createComment());\n\n            subDiv.style.cssText = \"left: \" + 100 * ((subStart - displayStart) / featLength) + \"%;\" + \"width: \" + 100 * ((subEnd - subStart) / featLength) + \"%;\";\n            featDiv.appendChild(subDiv);\n\n            block.featureNodes[subfeature.id()] = subDiv;\n\n            return subDiv;\n        },\n\n        _getLayout: function _getLayout(scale) {\n\n            //determine the glyph height, arrowhead width, label text dimensions, etc.\n            if (!this.haveMeasurements) {\n                this.measureStyles();\n                this.haveMeasurements = true;\n            }\n\n            // create the layout if we need to, and we can\n            if ((!this.layout || this.layout.pitchX != 4 / scale) && scale) this.layout = new Layout({\n                pitchX: 4 / scale,\n                pitchY: this.config.layoutPitchY || this.glyphHeight + this.glyphHeightPad,\n                maxHeight: this.getConf('maxHeight')\n            });\n\n            return this.layout;\n        },\n        _clearLayout: function _clearLayout() {\n            delete this.layout;\n        },\n\n        clear: function clear() {\n            delete this.layout;\n            this.inherited(arguments);\n        },\n\n        /**\n         *   indicates a change to this track has happened that may require a re-layout\n         *   clearing layout here, and relying on superclass BlockBased.changed() call and\n         *   standard _changedCallback function passed in track constructor to trigger relayout\n         */\n        changed: function changed() {\n            this._clearLayout();\n            this.inherited(arguments);\n        },\n\n        _exportFormats: function _exportFormats() {\n            return [{ name: 'GFF3', label: 'GFF3', fileExt: 'gff3' }, { name: 'BED', label: 'BED', fileExt: 'bed' }, { name: 'SequinTable', label: 'Sequin Table', fileExt: 'sqn' }];\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var o = this.inherited(arguments);\n            var track = this;\n\n            o.push.apply(o, [{ type: 'dijit/MenuSeparator' }, { label: 'Show labels',\n                type: 'dijit/CheckedMenuItem',\n                checked: !!('showLabels' in this ? this.showLabels : this.config.style.showLabels),\n                onClick: function onClick(event) {\n                    track.showLabels = this.checked;\n                    track.changed();\n                }\n            }]);\n\n            return o;\n        }\n    });\n\n    return HTMLFeatures;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*\n\n Copyright (c) 2007-2010 The Evolutionary Software Foundation\n\n Created by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\n This package and its accompanying libraries are free software; you can\n redistribute it and/or modify it under the terms of the LGPL (either\n version 2.1, or at your option, any later version) or the Artistic\n License 2.0.  Refer to LICENSE for the full license text.\n\n */\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/HTMLFeatures.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/HTMLVariants.js":
/*!************************************************!*\
  !*** ./src/JBrowse/View/Track/HTMLVariants.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Just an HTMLFeatures track that uses the VariantDetailsMixin to\n * provide a variant-specific feature detail dialog.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/View/Track/HTMLFeatures */ \"./src/JBrowse/View/Track/HTMLFeatures.js\"), __webpack_require__(/*! JBrowse/View/Track/_VariantDetailMixin */ \"./src/JBrowse/View/Track/_VariantDetailMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, all, HTMLFeatures, VariantDetailsMixin) {\n    return declare([HTMLFeatures, VariantDetailsMixin], {\n        _trackMenuOptions: function _trackMenuOptions() {\n            return all([this.inherited(arguments), this._variantsFilterTrackMenuOptions()]).then(function (options) {\n                var o = options.shift();\n                options.unshift({ type: 'dijit/MenuSeparator' });\n                return o.concat.apply(o, options);\n            });\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/HTMLVariants.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/LocationScale.js":
/*!*************************************************!*\
  !*** ./src/JBrowse/View/Track/LocationScale.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, dom, BlockBased, Util) {\n    return declare(BlockBased,\n    /**\n     * @lends JBrowse.View.Track.LocationScale.prototype\n     */\n    {\n\n        /**\n         * This track is for (e.g.) position and sequence information that should\n         * always stay visible at the top of the view.\n         * @constructs\n         */\n\n        constructor: function constructor(args) {\n            //name, labelClass, posHeight) {\n            this.loaded = true;\n            this.labelClass = args.labelClass;\n            this.posHeight = args.posHeight;\n            this.height = Math.round(args.posHeight * 1.2);\n        },\n\n        // this track has no track label or track menu, stub them out\n        makeTrackLabel: function makeTrackLabel() {},\n        makeTrackMenu: function makeTrackMenu() {},\n\n        fillBlock: function fillBlock(args) {\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n            var scale = args.scale;\n            var thisB = this;\n\n            // find the number that is within 2 px of the left boundary of\n            // the block that ends with the most zeroes, or a 5 if no\n            // zeroes\n            var labelNumber = this.chooseLabel(args);\n            var labelOffset = (leftBase + 1 - labelNumber) * scale / 10;\n            // console.log( leftBase+1, labelNumber, labelOffset );\n\n            var posLabel = document.createElement(\"div\");\n            var numtext = Util.addCommas(labelNumber);\n            posLabel.className = this.labelClass;\n\n            // give the position label a negative left offset in ex's to\n            // more-or-less center it over the left boundary of the block\n            posLabel.style.left = \"-\" + Number(numtext.length) / 1.7 + labelOffset + \"ex\";\n\n            posLabel.appendChild(document.createTextNode(numtext));\n            block.domNode.appendChild(posLabel);\n\n            var highlight = this.browser.getHighlight();\n            if (highlight && highlight.ref == this.refSeq.name) {\n                this.renderRegionHighlight(args, highlight);\n            }\n\n            var bookmarks = this.browser.getBookmarks();\n            if (bookmarks) {\n                this.renderRegionBookmark(args, bookmarks, this.refSeq.name, true);\n            }\n\n            this.heightUpdate(Math.round(this.posHeight * 1.2), blockIndex);\n            args.finishCallback();\n        },\n\n        chooseLabel: function chooseLabel(viewArgs) {\n            var left = viewArgs.leftBase + 1;\n            var width = viewArgs.rightBase - left + 1;\n            var scale = viewArgs.scale;\n            for (var mod = 1000000; mod > 0; mod /= 10) {\n                if (left % mod * scale <= 3) return left - left % mod;\n            }\n            return left;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/LocationScale.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/SNPCoverage.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/View/Track/SNPCoverage.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! JBrowse/View/Track/Wiggle/XYPlot */ \"./src/JBrowse/View/Track/Wiggle/XYPlot.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/Track/_AlignmentsMixin */ \"./src/JBrowse/View/Track/_AlignmentsMixin.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/SNPCoverage */ \"./src/JBrowse/Store/SeqFeature/SNPCoverage.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, WiggleXY, Util, AlignmentsMixin, SNPCoverageStore) {\n\n    var dojof = Util.dojof;\n\n    return declare([WiggleXY, AlignmentsMixin], {\n        constructor: function constructor() {\n            // force conf variables that are meaningless for this kind of track, and maybe harmful\n            delete this.config.bicolor_pivot;\n            delete this.config.scale;\n            delete this.config.align;\n\n            var thisB = this;\n            this.store = new SNPCoverageStore({ store: this.store,\n                config: {\n                    mismatchScale: this.config.mismatchScale,\n                    indicatorProp: this.config.indicatorProp,\n                    indicatorDepth: this.config.indicatorDepth\n                },\n                browser: this.browser,\n                filter: function filter(f) {\n                    return thisB.filterFeature(f);\n                }\n            });\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                autoscale: 'local',\n                min_score: 0,\n\n                mismatchScale: 1 / 10,\n                indicatorProp: 0.5,\n                indicatorDepth: 1,\n\n                hideDuplicateReads: true,\n                logScaleOption: false,\n                hideQCFailingReads: true,\n                hideSecondary: true,\n                hideSupplementary: true,\n                hideMissingMatepairs: false,\n                hideImproperPairs: false,\n                hideUnmapped: true\n            });\n        },\n\n        /*\n         * Draw a set of features on the canvas.\n         * @private\n         */\n        _drawFeatures: function _drawFeatures(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale) {\n            var thisB = this;\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n\n            var ratio = Util.getResolution(context, this.browser.config.highResolutionMode);\n            var toY = dojo.hitch(this, function (val) {\n                return canvasHeight * (1 - dataScale.normalize(val)) / ratio;\n            });\n            var originY = toY(dataScale.origin);\n\n            // a canvas element below the histogram that will contain indicators of likely SNPs\n            var snpCanvasHeight = 20;\n            var snpCanvas = dojo.create('canvas', { height: snpCanvasHeight,\n                width: canvas.width,\n                style: {\n                    cursor: 'default',\n                    width: \"100%\",\n                    height: snpCanvasHeight + \"px\"\n                },\n                innerHTML: 'Your web browser cannot display this type of track.',\n                className: 'SNP-indicator-track'\n            }, block.domNode);\n            var snpContext = snpCanvas.getContext('2d');\n\n            // finally query the various pixel ratios\n            var ratio = Util.getResolution(snpContext, this.browser.config.highResolutionMode);\n            // upscale canvas if the two ratios don't match\n            if (this.browser.config.highResolutionMode != 'disabled' && ratio != 1) {\n\n                var oldWidth = snpCanvas.width;\n                var oldHeight = snpCanvas.height;\n\n                snpCanvas.width = oldWidth * ratio;\n                snpCanvas.height = oldHeight * ratio;\n\n                //c.style.width = oldWidth + 'px';\n                snpCanvas.style.height = oldHeight + 'px';\n\n                // now scale the context to counter\n                // the fact that we've manually scaled\n                // our canvas element\n                snpContext.scale(ratio, ratio);\n            }\n\n            var negColor = this.config.style.neg_color;\n            var clipColor = this.config.style.clip_marker_color;\n            var bgColor = this.config.style.bg_color;\n            var disableClipMarkers = this.config.disable_clip_markers;\n\n            var drawRectangle = function drawRectangle(ID, yPos, height, fRect) {\n                if (yPos <= canvasHeight) {\n                    // if the rectangle is visible at all\n                    context.fillStyle = thisB.colorForBase(ID);\n                    if (yPos <= originY) {\n                        // bar goes upward\n                        thisB._fillRectMod(context, fRect.l, yPos, fRect.w, height);\n                        if (!disableClipMarkers && yPos < 0) {\n                            // draw clip marker if necessary\n                            context.fillStyle = clipColor || negColor;\n                            thisB._fillRectMod(context, fRect.l, 0, fRect.w, 2);\n                        }\n                    } else {\n                        // bar goes downward\n                        thisB._fillRectMod(context, fRect.l, originY, fRect.w, height);\n                        if (!disableClipMarkers && yPos >= canvasHeight) {\n                            // draw clip marker if necessary\n                            context.fillStyle = clipColor || thisB.colorForBase(ID);\n                            thisB._fillRectMod(context, fRect.l, canvasHeight - 3, fRect.w, 2);\n                        }\n                    }\n                }\n            };\n\n            // Note: 'reference' is done first to ensure the grey part of the graph is on top\n            dojo.forEach(features, function (f, i) {\n                var fRect = featureRects[i];\n                var score = f.get('score');\n\n                // draw the background color if we are configured to do so\n                if (bgColor) {\n                    context.fillStyle = bgColor;\n                    thisB._fillRectMod(context, fRect.l, 0, fRect.w, canvasHeight);\n                }\n\n                drawRectangle('reference', toY(score.total()), originY - toY(score.get('reference')) + 1, fRect);\n            });\n\n            var indicatorMinHeightProp = this.config.indicatorProp;\n            var indicatorMinHeight = this.config.indicatorDepth;\n\n            dojo.forEach(features, function (f, i) {\n                var fRect = featureRects[i];\n                var score = f.get('score');\n                var totalHeight = score.total();\n\n                // draw indicators of SNPs if base coverage is greater than 50% of total coverage\n                score.forEach(function (count, category) {\n                    if (!{ reference: true, skip: true, deletion: true }[category] && count >= indicatorMinHeightProp * totalHeight && count >= indicatorMinHeight) {\n                        snpContext.save();\n                        if (thisB.browser.config.highResolutionMode != 'disabled') snpContext.scale(ratio, 1);\n                        snpContext.beginPath();\n                        snpContext.arc(fRect.l + 0.5 * fRect.w, 0.40 * snpCanvas.height / ratio, 0.20 * snpCanvas.height / ratio, 1.75 * Math.PI, 1.25 * Math.PI, false);\n                        snpContext.lineTo(fRect.l + 0.5 * fRect.w, 0);\n                        snpContext.closePath();\n                        snpContext.fillStyle = thisB.colorForBase(category);\n                        snpContext.fill();\n                        snpContext.lineWidth = 1;\n                        snpContext.strokeStyle = 'black';\n                        snpContext.stroke();\n                        if (thisB.browser.config.highResolutionMode != 'disabled') snpContext.restore();\n                    }\n                });\n\n                totalHeight -= score.get('reference');\n\n                score.forEach(function (count, category) {\n                    if (category != 'reference') {\n                        drawRectangle(category, toY(totalHeight), originY - toY(count) + 1, fRect);\n                        totalHeight -= count;\n                    }\n                });\n            }, this);\n        },\n\n        // Overwrites the method from WiggleBase\n        _draw: function _draw(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale, pixels, spans) {\n            // Note: pixels currently has no meaning, as the function that generates it is not yet defined for this track\n            this._preDraw(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale);\n            this._drawFeatures(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale);\n            if (spans) {\n                this._maskBySpans(scale, leftBase, canvas, spans);\n            }\n            this._postDraw(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale);\n        },\n\n        /* If it's a boolean track, mask accordingly */\n        _maskBySpans: function _maskBySpans(scale, leftBase, canvas, spans) {\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n            var booleanAlpha = this.config.style.masked_transparancy || 0.17;\n            this.config.style.masked_transparancy = booleanAlpha;\n\n            // make a temporary canvas to store image data\n            var tempCan = dojo.create('canvas', { height: canvasHeight, width: canvas.width });\n            var ctx2 = tempCan.getContext('2d');\n\n            for (var index in spans) {\n                if (spans.hasOwnProperty(index)) {\n                    var w = Math.round((spans[index].end - spans[index].start) * scale);\n                    var l = Math.round((spans[index].start - leftBase) * scale);\n                    if (l + w >= canvas.width) w = canvas.width - l; // correct possible rounding errors\n                    if (w == 0) continue; // skip if there's no width.\n                    ctx2.drawImage(canvas, l, 0, w, canvasHeight, l, 0, w, canvasHeight);\n                    context.globalAlpha = booleanAlpha;\n                    // clear masked region and redraw at lower opacity.\n                    context.clearRect(l, 0, w, canvasHeight);\n                    context.drawImage(tempCan, l, 0, w, canvasHeight, l, 0, w, canvasHeight);\n                    context.globalAlpha = 1;\n                }\n            }\n        },\n\n        /*\n         * The following method is required to override the equivalent method in \"WiggleBase.js\"\n         * It displays more complete data.\n         */\n        _showPixelValue: function _showPixelValue(scoreDisplay, score) {\n            if (!score || !score.score) return false;\n            score = score.score;\n\n            function fmtNum(num) {\n                return parseFloat(num).toPrecision(6).replace(/0+$/, '').replace(/\\.$/, '');\n            }\n            function pctString(count) {\n                count = Math.round(count / total * 100);\n                if (typeof count == 'number' && !isNaN(count)) return count + '%';\n                return '';\n            }\n            if (score.snpsCounted) {\n                var total = score.total();\n                var scoreSummary = '<table>';\n\n                score.forEach(function (count, category) {\n                    // if this count has more nested categories, do counts of those\n                    var subdistribution = '';\n                    if (count.forEach) {\n                        subdistribution = [];\n                        count.forEach(function (count, category) {\n                            subdistribution.push(fmtNum(count) + ' ' + category);\n                        });\n                        subdistribution = subdistribution.join(', ');\n                        if (subdistribution) subdistribution = '(' + subdistribution + ')';\n                    }\n\n                    category = { '*': 'del', reference: 'Ref', skip: 'Skip/intron' }[category] || category;\n                    scoreSummary += '<tr><td>' + category + '</td><td class=\"count\">' + fmtNum(count) + '</td><td class=\"pct\">' + pctString(count) + '</td><td class=\"subdist\">' + subdistribution + '</td></tr>';\n                });\n                scoreSummary += '<tr class=\"total\"><td>Total</td><td class=\"count\">' + fmtNum(total) + '</td><td class=\"pct\">&nbsp;</td><td class=\"subdist\">&nbsp;</td></tr>';\n                scoreDisplay.innerHTML = scoreSummary + '</table>';\n                return true;\n            } else {\n                scoreDisplay.innerHTML = '<table><tr><td>Total</td><td class=\"count\">' + fmtNum(score) + '</td></tr></table>';\n                return true;\n            }\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var thisB = this;\n            var displayOptions = [];\n\n            displayOptions.push({\n                label: 'View alignments',\n                onClick: function onClick(event) {\n                    thisB.config.type = 'JBrowse/View/Track/Alignments2';\n                    thisB.config._oldSnpCoverageHeight = thisB.config.style.height;\n                    thisB.config.style.height = thisB.config._oldAlignmentsHeight;\n                    thisB.browser.publish('/jbrowse/v1/v/tracks/replace', [thisB.config]);\n                }\n            });\n\n            return Promise.all([this.inherited(arguments), this._alignmentsFilterTrackMenuOptions(), displayOptions]).then(function (options) {\n                var o = options.shift();\n                options.unshift({ type: 'dijit/MenuSeparator' });\n                return o.concat.apply(o, options);\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/SNPCoverage.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Sequence.js":
/*!********************************************!*\
  !*** ./src/JBrowse/View/Track/Sequence.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/dom-class */ \"./node_modules/dojo/dom-class.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\"), __webpack_require__(/*! JBrowse/View/Track/_ExportMixin */ \"./src/JBrowse/View/Track/_ExportMixin.js\"), __webpack_require__(/*! JBrowse/CodonTable */ \"./src/JBrowse/CodonTable.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, dom, domClass, query, BlockBased, ExportMixin, CodonTable, Util) {\n\n    return declare([BlockBased, ExportMixin, CodonTable],\n    /**\n     * @lends JBrowse.View.Track.Sequence.prototype\n     */\n    {\n        /**\n         * Track to display the underlying reference sequence, when zoomed in\n         * far enough.\n         *\n         * @constructs\n         * @extends JBrowse.View.Track.BlockBased\n         */\n        constructor: function constructor(args) {\n            this._charMeasurements = {};\n            this._codonTable = this.generateCodonTable(lang.mixin(this.defaultCodonTable, this.config.codonTable));\n            this._codonStarts = this.config.codonStarts || this.defaultStarts;\n            this._codonStops = this.config.codonStops || this.defaultStops;\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return {\n                maxExportSpan: 500000,\n                showForwardStrand: true,\n                showReverseStrand: true,\n                showTranslation: true,\n                showColor: true,\n                seqType: 'dna',\n                proteinColorScheme: 'taylor'\n            };\n        },\n        _exportFormats: function _exportFormats() {\n            return [{ name: 'FASTA', label: 'FASTA', fileExt: 'fasta' }];\n        },\n\n        endZoom: function endZoom(destScale, destBlockBases) {\n            this.clear();\n        },\n\n        setViewInfo: function setViewInfo(genomeView, heightUpdate, numBlocks, trackDiv, widthPct, widthPx, scale) {\n            this.inherited(arguments);\n            this.show();\n        },\n\n        nbsp: String.fromCharCode(160),\n\n        fillBlock: function fillBlock(args) {\n\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n            var scale = args.scale;\n\n            var leftExtended = leftBase - 2;\n            var rightExtended = rightBase + 2;\n\n            var thisB = this;\n\n            var blur = dojo.create('div', { className: 'sequence_blur',\n                innerHTML: '<span class=\"loading\">Loading</span>'\n            }, block.domNode);\n\n            this.heightUpdate(blur.offsetHeight + 2 * blur.offsetTop, blockIndex);\n\n            // if we are zoomed in far enough to draw bases, then draw them\n            if (scale >= 1.3) {\n                this.store.getReferenceSequence({\n                    ref: this.refSeq.name,\n                    start: leftExtended,\n                    end: rightExtended\n                }, function (seq) {\n                    if (seq.trim() == \"\") {\n                        blur.innerHTML = '<span class=\"zoom\">No sequence available</span>';;\n                    } else {\n                        dom.empty(block.domNode);\n                        thisB._fillSequenceBlock(block, blockIndex, scale, seq);\n                    }\n                    args.finishCallback();\n                }, function (error) {\n                    if (args.errorCallback) args.errorCallback(error);else {\n                        console.error(error);\n                        args.finishCallback();\n                    }\n                });\n            }\n            // otherwise, just draw a sort of line (possibly dotted) that\n            // suggests there are bases there if you zoom in far enough\n            else {\n                    blur.innerHTML = '<span class=\"zoom\">Zoom in to see sequence</span>';\n                    args.finishCallback();\n                }\n        },\n\n        _fillSequenceBlock: function _fillSequenceBlock(block, blockIndex, scale, seq) {\n            seq = seq.replace(/\\s/g, this.nbsp);\n\n            var blockStart = block.startBase;\n            var blockEnd = block.endBase;\n            var blockSeq = seq.substring(2, seq.length - 2);\n            var blockLength = blockSeq.length;\n\n            var extStart = blockStart - 2;\n            var extEnd = blockStart + 2;\n            var leftover = (seq.length - 2) % 3;\n            var extStartSeq = seq.substring(0, seq.length - 2);\n            var extEndSeq = seq.substring(2);\n\n            if (this.config.showForwardStrand && this.config.showTranslation) {\n                var frameDiv = [];\n                for (var i = 0; i < 3; i++) {\n                    var transStart = blockStart + i;\n                    var frame = (transStart % 3 + 3) % 3;\n                    var translatedDiv = this._renderTranslation(extEndSeq, i, blockStart, blockEnd, blockLength, scale);\n                    frameDiv[frame] = translatedDiv;\n                    domClass.add(translatedDiv, \"frame\" + frame);\n                }\n                for (var i = 2; i >= 0; i--) {\n                    block.domNode.appendChild(frameDiv[i]);\n                }\n            }\n\n            // make a table to contain the sequences\n            var charSize = this.getCharacterMeasurements('sequence');\n            var bigTiles = scale > charSize.w + 4; // whether to add .big styles to the base tiles\n            var seqNode;\n            if (this.config.showReverseStrand || this.config.showForwardStrand) seqNode = dom.create(\"table\", {\n                className: \"sequence\" + (bigTiles ? ' big' : '') + (this.config.showColor ? '' : ' nocolor'),\n                style: { width: \"100%\" }\n            }, block.domNode);\n\n            // add a table for the forward strand\n            if (this.config.showForwardStrand) seqNode.appendChild(this._renderSeqTr(blockStart, blockEnd, blockSeq, scale));\n\n            // and one for the reverse strand\n            if (this.config.showReverseStrand) {\n                var comp = this._renderSeqTr(blockStart, blockEnd, Util.complement(blockSeq), scale);\n                comp.className = 'revcom';\n                seqNode.appendChild(comp);\n\n                if (this.config.showTranslation) {\n                    var frameDiv = [];\n                    for (var i = 0; i < 3; i++) {\n                        var transStart = blockStart + 1 - i;\n                        var frame = (transStart % 3 + 3 + leftover) % 3;\n                        var translatedDiv = this._renderTranslation(extStartSeq, i, blockStart, blockEnd, blockLength, scale, true);\n                        frameDiv[frame] = translatedDiv;\n                        domClass.add(translatedDiv, \"frame\" + frame);\n                    }\n                    for (var i = 0; i < 3; i++) {\n                        block.domNode.appendChild(frameDiv[i]);\n                    }\n                }\n            }\n\n            var totalHeight = 0;\n            array.forEach(block.domNode.childNodes, function (table) {\n                totalHeight += table.clientHeight || table.offsetHeight;\n            });\n            this.heightUpdate(totalHeight, blockIndex);\n        },\n\n        _renderTranslation: function _renderTranslation(seq, offset, blockStart, blockEnd, blockLength, scale, reverse) {\n            seq = reverse ? Util.revcom(seq) : seq;\n\n            var extraBases = (seq.length - offset) % 3;\n            var seqSliced = seq.slice(offset, seq.length - extraBases);\n\n            var translated = \"\";\n            for (var i = 0; i < seqSliced.length; i += 3) {\n                var nextCodon = seqSliced.slice(i, i + 3);\n                var aminoAcid = this._codonTable[nextCodon] || this.nbsp;\n                translated += aminoAcid;\n            }\n\n            translated = reverse ? translated.split(\"\").reverse().join(\"\") : translated; // Flip the translated seq for left-to-right rendering\n            var orientedSeqSliced = reverse ? seqSliced.split(\"\").reverse().join(\"\") : seqSliced;\n\n            var charSize = this.getCharacterMeasurements(\"aminoAcid\");\n            var bigTiles = scale > charSize.w + 4; // whether to add .big styles to the base tiles\n\n            var charWidth = 100 / (blockLength / 3);\n\n            var container = dom.create('div', { className: 'translatedSequence' });\n            var table = dom.create('table', {\n                className: 'translatedSequence offset' + offset + (bigTiles ? ' big' : ''),\n                style: {\n                    width: charWidth * translated.length + \"%\"\n                }\n            }, container);\n            var tr = dom.create('tr', {}, table);\n\n            table.style.left = (reverse ? 100 - charWidth * (translated.length + offset / 3) : charWidth * offset / 3) + \"%\";\n\n            charWidth = 100 / translated.length + \"%\";\n\n            var drawChars = scale >= charSize.w;\n            if (drawChars) table.className += ' big';\n\n            for (var i = 0; i < translated.length; i++) {\n                var aminoAcidSpan = document.createElement('td');\n                var originalCodon = orientedSeqSliced.slice(3 * i, 3 * i + 3);\n                originalCodon = reverse ? originalCodon.split(\"\").reverse().join(\"\") : originalCodon;\n                aminoAcidSpan.className = 'aminoAcid aminoAcid_' + translated.charAt(i).toLowerCase();\n\n                // However, if it's known to be a start/stop, apply those CSS classes instead.\n                if (this._codonStarts.indexOf(originalCodon.toUpperCase()) != -1) {\n                    aminoAcidSpan.className = 'aminoAcid aminoAcid_start';\n                }\n                if (this._codonStops.indexOf(originalCodon.toUpperCase()) != -1) {\n                    aminoAcidSpan.className = 'aminoAcid aminoAcid_stop';\n                }\n\n                aminoAcidSpan.style.width = charWidth;\n                if (drawChars) {\n                    aminoAcidSpan.innerHTML = translated.charAt(i);\n                }\n                tr.appendChild(aminoAcidSpan);\n            }\n            return container;\n        },\n\n        /**\n         * Given the start and end coordinates, and the sequence bases,\n         * makes a table row containing the sequence.\n         * @private\n         */\n        _renderSeqTr: function _renderSeqTr(start, end, seq, scale) {\n\n            var charSize = this.getCharacterMeasurements('sequence');\n            var container = document.createElement('tr');\n            var charWidth = 100 / (end - start) + \"%\";\n            var drawChars = scale >= charSize.w;\n            var baseClassDefault = 'base';\n            if (this.config.seqType === 'protein') {\n                baseClassDefault += ' aaScheme_' + this.config.proteinColorScheme;\n            }\n            for (var i = 0; i < seq.length; i++) {\n                var base = document.createElement('td');\n                base.className = baseClassDefault + ' base_' + seq.charAt(i).toLowerCase();\n                base.style.width = charWidth;\n                if (drawChars) {\n                    base.innerHTML = seq.charAt(i);\n                }\n                container.appendChild(base);\n            }\n            return container;\n        },\n\n        startZoom: function startZoom() {\n            query('.base', this.div).empty();\n        },\n\n        /**\n         * @returns {Object} containing <code>h</code> and <code>w</code>,\n         *      in pixels, of the characters being used for sequences\n         */\n        getCharacterMeasurements: function getCharacterMeasurements(className) {\n            return this._charMeasurements[className] || (this._charMeasurements[className] = this._measureSequenceCharacterSize(this.div, className));\n        },\n\n        /**\n         * Conducts a test with DOM elements to measure sequence text width\n         * and height.\n         */\n        _measureSequenceCharacterSize: function _measureSequenceCharacterSize(containerElement, className) {\n            var widthTest = document.createElement(\"td\");\n            widthTest.className = className;\n            widthTest.style.visibility = \"hidden\";\n            var widthText = \"12345678901234567890123456789012345678901234567890\";\n            widthTest.appendChild(document.createTextNode(widthText));\n            containerElement.appendChild(widthTest);\n            var result = {\n                w: widthTest.clientWidth / widthText.length + 1,\n                h: widthTest.clientHeight\n            };\n            containerElement.removeChild(widthTest);\n            return result;\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var track = this;\n            var o = this.inherited(arguments);\n            o.push({ type: 'dijit/MenuSeparator' });\n            o.push.apply(o, [{ label: 'Show forward strand',\n                type: 'dijit/CheckedMenuItem',\n                checked: !!this.config.showForwardStrand,\n                onClick: function onClick(event) {\n                    track.config.showForwardStrand = this.checked;\n                    track.changed();\n                }\n            }, { label: 'Show reverse strand',\n                type: 'dijit/CheckedMenuItem',\n                checked: !!this.config.showReverseStrand,\n                onClick: function onClick(event) {\n                    track.config.showReverseStrand = this.checked;\n                    track.changed();\n                }\n            }, { label: 'Show translation',\n                type: 'dijit/CheckedMenuItem',\n                checked: !!this.config.showTranslation,\n                onClick: function onClick(event) {\n                    track.config.showTranslation = this.checked;\n                    track.changed();\n                }\n            }, { label: 'Show color',\n                type: 'dijit/CheckedMenuItem',\n                checked: !!this.config.showColor,\n                onClick: function onClick(event) {\n                    track.config.showColor = this.checked;\n                    track.changed();\n                }\n            }]);\n            return o;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Sequence.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Wiggle.js":
/*!******************************************!*\
  !*** ./src/JBrowse/View/Track/Wiggle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! JBrowse/View/Track/Wiggle/XYPlot */ \"./src/JBrowse/View/Track/Wiggle/XYPlot.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (xyplot) {\n            return xyplot;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Wiggle.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Wiggle/Density.js":
/*!**************************************************!*\
  !*** ./src/JBrowse/View/Track/Wiggle/Density.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/Color */ \"./node_modules/dojo/_base/Color.js\"), __webpack_require__(/*! JBrowse/View/Track/WiggleBase */ \"./src/JBrowse/View/Track/WiggleBase.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Color, WiggleBase, Util) {\n\n    return declare(WiggleBase,\n\n    /**\n     * Wiggle track that shows data with variations in color.\n     *\n     * @lends JBrowse.View.Track.Wiggle.Density\n     * @extends JBrowse.View.Track.WiggleBase\n     */\n\n    {\n\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                maxExportSpan: 500000,\n                style: {\n                    height: 31,\n                    pos_color: '#00f',\n                    neg_color: '#f00',\n                    bg_color: 'rgba(230,230,230,0.6)',\n                    clip_marker_color: 'black'\n                }\n            });\n        },\n\n        _drawFeatures: function _drawFeatures(scale, leftBase, rightBase, block, canvas, pixels, dataScale) {\n            var thisB = this;\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n            var normalize = dataScale.normalize;\n\n            var featureColor = typeof this.config.style.color == 'function' ? this.config.style.color : function () {\n                // default color function uses conf variables\n                var disableClipMarkers = thisB.config.disable_clip_markers;\n                var normOrigin = dataScale.normalize(dataScale.origin);\n\n                return function (p, n) {\n                    var feature = p['feat'];\n                    return disableClipMarkers || n <= 1 && n >= 0 ?\n                    // not clipped\n                    Color.blendColors(new Color(thisB.getConfForFeature('style.bg_color', feature)), new Color(thisB.getConfForFeature(n >= normOrigin ? 'style.pos_color' : 'style.neg_color', feature)), Math.abs(n - normOrigin)).toString()\n                    // clipped\n                    : n > 1 ? thisB.getConfForFeature('style.pos_color', feature) : thisB.getConfForFeature('style.neg_color', feature);\n                };\n            }();\n\n            dojo.forEach(pixels, function (p, i) {\n                if (p) {\n                    var score = p['score'];\n                    var f = p['feat'];\n\n                    var n = dataScale.normalize(score);\n                    context.fillStyle = '' + featureColor(p, n);\n                    thisB._fillRectMod(context, i, 0, 1, canvasHeight);\n                    if (n > 1) {\n                        // pos clipped\n                        context.fillStyle = thisB.getConfForFeature('style.clip_marker_color', f) || 'red';\n                        thisB._fillRectMod(context, i, 0, 1, 3);\n                    } else if (n < 0) {\n                        // neg clipped\n                        context.fillStyle = thisB.getConfForFeature('style.clip_marker_color', f) || 'red';\n                        thisB._fillRectMod(context, i, canvasHeight - 3, 1, 3);\n                    }\n                }\n            });\n        },\n\n        /* If boolean track, mask accordingly */\n        _maskBySpans: function _maskBySpans(scale, leftBase, rightBase, block, canvas, pixels, dataScale, spans) {\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n            context.fillStyle = this.config.style.mask_color || 'rgba(128,128,128,0.6)';\n            this.config.style.mask_color = context.fillStyle;\n\n            for (var index in spans) {\n                if (spans.hasOwnProperty(index)) {\n                    var w = Math.ceil((spans[index].end - spans[index].start) * scale);\n                    var l = Math.round((spans[index].start - leftBase) * scale);\n                    context.fillRect(l, 0, w, canvasHeight);\n                    context.clearRect(l, 0, w, canvasHeight / 3);\n                    context.clearRect(l, 2 / 3 * canvasHeight, w, canvasHeight / 3);\n                }\n            }\n            dojo.forEach(pixels, function (p, i) {\n                if (!p) {\n                    // if there is no data at a point, erase the mask.\n                    context.clearRect(i, 0, 1, canvasHeight);\n                }\n            });\n        },\n\n        _postDraw: function _postDraw() {}\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Wiggle/Density.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Wiggle/XYPlot.js":
/*!*************************************************!*\
  !*** ./src/JBrowse/View/Track/Wiggle/XYPlot.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/Color */ \"./node_modules/dojo/_base/Color.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! JBrowse/View/Track/WiggleBase */ \"./src/JBrowse/View/Track/WiggleBase.js\"), __webpack_require__(/*! JBrowse/View/Track/_YScaleMixin */ \"./src/JBrowse/View/Track/_YScaleMixin.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! ./_Scale */ \"./src/JBrowse/View/Track/Wiggle/_Scale.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, Color, on, WiggleBase, YScaleMixin, Util, Scale) {\n\n    var XYPlot = declare([WiggleBase, YScaleMixin],\n\n    /**\n     * Wiggle track that shows data with an X-Y plot along the reference.\n     *\n     * @lends JBrowse.View.Track.Wiggle.XYPlot\n     * @extends JBrowse.View.Track.WiggleBase\n     */\n    {\n        _defaultConfig: function _defaultConfig() {\n            return Util.deepUpdate(dojo.clone(this.inherited(arguments)), {\n                style: {\n                    pos_color: 'blue',\n                    neg_color: 'red',\n                    origin_color: '#888',\n                    variance_band_color: 'rgba(0,0,0,0.3)'\n                }\n            });\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var track = this;\n            var options = this.inherited(arguments) || [];\n\n            options.push({\n                label: 'No fill',\n                type: 'dijit/CheckedMenuItem',\n                checked: !!(this.config.noFill == true),\n                onClick: function onClick(event) {\n                    if (this.checked) {\n                        track.config.noFill = true;\n                    } else {\n                        track.config.noFill = false;\n                    }\n                    track.browser.publish('/jbrowse/v1/v/tracks/replace', [track.config]);\n                }\n            });\n\n            return options;\n        },\n\n        _getScaling: function _getScaling(viewArgs, successCallback, errorCallback) {\n\n            this._getScalingStats(viewArgs, dojo.hitch(this, function (stats) {\n\n                //calculate the scaling if necessary\n                if (!this.lastScaling || !this.lastScaling.sameStats(stats) || this.trackHeightChanged) {\n\n                    var scaling = new Scale(this.config, stats);\n\n                    // bump minDisplayed to 0 if it is within 0.5% of it\n                    if (Math.abs(scaling.min / scaling.max) < 0.005) scaling.min = 0;\n\n                    // update our track y-scale to reflect it\n                    this.makeYScale({\n                        fixBounds: 'fixBounds' in this.config ? this.config.fixBounds : true,\n                        min: scaling.min,\n                        max: scaling.max\n                    });\n\n                    // and finally adjust the scaling to match the ruler's scale rounding\n                    scaling.min = this.ruler.scaler.bounds.lower;\n                    scaling.max = this.ruler.scaler.bounds.upper;\n                    scaling.range = scaling.max - scaling.min;\n\n                    this.lastScaling = scaling;\n                    this.trackHeightChanged = false; //reset flag\n                }\n\n                successCallback(this.lastScaling);\n            }), errorCallback);\n        },\n\n        updateStaticElements: function updateStaticElements(coords) {\n            this.inherited(arguments);\n            this.updateYScaleFromViewDimensions(coords);\n        },\n\n        /**\n         * Draw a set of features on the canvas.\n         * @private\n         */\n        _drawFeatures: function _drawFeatures(scale, leftBase, rightBase, block, canvas, pixels, dataScale) {\n            var thisB = this;\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n\n            var ratio = Util.getResolution(context, this.browser.config.highResolutionMode);\n            var toY = dojo.hitch(this, function (val) {\n                return canvasHeight * (1 - dataScale.normalize(val)) / ratio;\n            });\n            var originY = toY(dataScale.origin);\n\n            var disableClipMarkers = this.config.disable_clip_markers;\n\n            dojo.forEach(pixels, function (p, i) {\n                if (!p) return;\n                var score = toY(p['score']);\n                var f = p['feat'];\n\n                // draw the background color if we are configured to do so\n                if (score >= 0) {\n                    var bgColor = this.getConfForFeature('style.bg_color', f);\n                    if (bgColor) {\n                        context.fillStyle = bgColor;\n                        thisB._fillRectMod(context, i, 0, 1, canvasHeight);\n                    }\n                }\n\n                if (score <= canvasHeight || score > originY) {\n                    // if the rectangle is visible at all\n                    if (score <= originY) {\n                        // bar goes upward\n                        context.fillStyle = this.getConfForFeature('style.pos_color', f);\n                        var height = originY - score + 1;\n                        if (this.getConfForFeature('noFill', f) == true) {\n                            height = 1;\n                        }\n                        thisB._fillRectMod(context, i, score, 1, height);\n                        if (!disableClipMarkers && score < 0) {\n                            // draw clip marker if necessary\n                            context.fillStyle = this.getConfForFeature('style.clip_marker_color', f) || this.getConfForFeature('style.neg_color', f);\n                            thisB._fillRectMod(context, i, 0, 1, 3);\n                        }\n                    } else {\n                        // bar goes downward\n                        context.fillStyle = this.getConfForFeature('style.neg_color', f);\n                        var top = originY;\n                        var height = score - originY;\n                        if (this.getConfForFeature('noFill', f) == true) {\n                            top = score - 1;\n                            height = 1;\n                        }\n                        thisB._fillRectMod(context, i, top, 1, height);\n                        if (!disableClipMarkers && score >= canvasHeight) {\n                            // draw clip marker if necessary\n                            context.fillStyle = this.getConfForFeature('style.clip_marker_color', f) || this.getConfForFeature('style.pos_color', f);\n                            thisB._fillRectMod(context, i, canvasHeight - 3, 1, 3);\n                        }\n                    }\n                }\n            }, this);\n        },\n\n        /* If it's a boolean track, mask accordingly */\n        _maskBySpans: function _maskBySpans(scale, leftBase, rightBase, block, canvas, pixels, dataScale, spans) {\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n\n            for (var index in spans) {\n                if (spans.hasOwnProperty(index)) {\n                    var w = Math.ceil((spans[index].end - spans[index].start) * scale);\n                    var l = Math.round((spans[index].start - leftBase) * scale);\n                    context.clearRect(l, 0, w, canvasHeight);\n                }\n            }\n            context.globalAlpha = this.config.style.masked_transparancy || 0.2;\n            this.config.style.masked_transparancy = context.globalAlpha;\n            this._drawFeatures(scale, leftBase, rightBase, block, canvas, pixels, dataScale);\n        },\n\n        /**\n         * Draw anything needed after the features are drawn.\n         */\n        _postDraw: function _postDraw(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale) {\n            var context = canvas.getContext('2d');\n            var canvasHeight = canvas.height;\n\n            var ratio = Util.getResolution(context, this.browser.config.highResolutionMode);\n            var toY = dojo.hitch(this, function (val) {\n                return canvasHeight * (1 - dataScale.normalize(val)) / ratio;\n            });\n            var thisB = this;\n\n            // draw the variance_band if requested\n            if (this.config.variance_band) {\n                var bandPositions = _typeof(this.config.variance_band) == 'object' ? array.map(this.config.variance_band, function (v) {\n                    return parseFloat(v);\n                }).sort().reverse() : [2, 1];\n                this.getGlobalStats(dojo.hitch(this, function (stats) {\n                    if ('scoreMean' in stats && 'scoreStdDev' in stats) {\n                        var drawVarianceBand = function drawVarianceBand(plusminus, fill, label) {\n                            context.fillStyle = fill;\n                            var varTop = toY(stats.scoreMean + plusminus);\n                            var varHeight = toY(stats.scoreMean - plusminus) - varTop;\n                            varHeight = Math.max(1, varHeight);\n                            thisB._fillRectMod(context, 0, varTop, canvas.width, varHeight);\n                            context.font = '12px sans-serif';\n                            if (plusminus > 0) {\n                                context.fillText('+' + label, 2, varTop);\n                                context.fillText('-' + label, 2, varTop + varHeight);\n                            } else {\n                                context.fillText(label, 2, varTop);\n                            }\n                        };\n\n                        var maxColor = new Color(this.config.style.variance_band_color);\n                        var minColor = new Color(this.config.style.variance_band_color);\n                        minColor.a /= bandPositions.length;\n\n                        var bandOpacityStep = 1 / bandPositions.length;\n                        var minOpacity = bandOpacityStep;\n\n                        array.forEach(bandPositions, function (pos, i) {\n                            drawVarianceBand(pos * stats.scoreStdDev, Color.blendColors(minColor, maxColor, (i + 1) / bandPositions.length).toCss(true), pos + 'σ');\n                        });\n                        drawVarianceBand(0, 'rgba(255,255,0,0.7)', 'mean');\n                    }\n                }));\n            }\n\n            // draw the origin line if it is not disabled\n            var originColor = this.config.style.origin_color;\n            if (typeof originColor == 'string' && !{ 'none': 1, 'off': 1, 'no': 1, 'zero': 1 }[originColor]) {\n                var originY = toY(dataScale.origin);\n                context.fillStyle = originColor;\n                context.fillRect(0, originY, canvas.width, 1);\n            }\n        }\n\n    });\n\n    return XYPlot;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Wiggle/XYPlot.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/Wiggle/_Scale.js":
/*!*************************************************!*\
  !*** ./src/JBrowse/View/Track/Wiggle/_Scale.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * The scaling used for drawing a Wiggle track, which is the data's\n * origin.\n *\n * Has numeric attributes range, min, max, origin, and offset.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Digest/Crc32 */ \"./src/JBrowse/Digest/Crc32.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (lang, Util, Digest) {\n    return Util.fastDeclare({\n\n        // Returns a boolean value saying whether a stats object is needed\n        // to calculate the scale for the given configuration.\n        //\n        // This is invokable either on the class (prototype) or on\n        // the object itself, so does not use `this` in its implementation.\n        needStats: function needStats(config) {\n            return !('min_score' in config && 'max_score' in config && config.bicolor_pivot != 'z_score' && config.bicolor_pivot != 'mean' && config.scale != 'z_score');\n        },\n\n        constructor: function constructor(config, stats) {\n            var needStats = this.needStats(config);\n            if (needStats && !stats) throw 'No stats object provided, cannot calculate scale';\n\n            if (needStats && stats.scoreMin == stats.scoreMax) {\n                stats = lang.mixin({}, stats);\n                if (stats.scoreMin < 0) stats.scoreMax = 0;else stats.scoreMin = 0;\n            }\n\n            // if either autoscale or scale is set to z_score, the other one should default to z_score\n            if (config.autoscale == 'z_score' && !config.scale || config.scale == 'z_score' && !config.autoscale) {\n                config.scale = 'z_score';\n                config.autoscale = 'z_score';\n            }\n\n            var z_score_bound = parseFloat(config.z_score_bound) || 4;\n            var min = 'min_score' in config ? parseFloat(config.min_score) : function () {\n                switch (config.autoscale) {\n                    case 'z_score':\n                        return Math.max(-z_score_bound, (stats.scoreMin - stats.scoreMean) / stats.scoreStdDev);\n                    case 'global':\n                    case 'local':\n                        return stats.scoreMin;\n                    case 'clipped_global':\n                    /* fall through */\n                    default:\n                        return Math.max(stats.scoreMin, stats.scoreMean - z_score_bound * stats.scoreStdDev);\n                }\n            }();\n            var max = 'max_score' in config ? parseFloat(config.max_score) : function () {\n                switch (config.autoscale) {\n                    case 'z_score':\n                        return Math.min(z_score_bound, (stats.scoreMax - stats.scoreMean) / stats.scoreStdDev);\n                    case 'global':\n                    case 'local':\n                        return stats.scoreMax;\n                    case 'clipped_global':\n                    /* fall through */\n                    default:\n                        return Math.min(stats.scoreMax, stats.scoreMean + z_score_bound * stats.scoreStdDev);\n                }\n            }();\n\n            if (typeof min != 'number' || isNaN(min)) {\n                min = 0;\n            }\n            if (typeof max != 'number' || isNaN(max)) {\n                max = min + 10;\n            }\n\n            var offset = parseFloat(config.data_offset) || 0;\n\n            if (config.scale == 'log') {\n                max = this.log(max + offset);\n                min = this.log(min + offset);\n            } else {\n                max += offset;\n                min += offset;\n            }\n\n            var origin = function () {\n                if ('bicolor_pivot' in config) {\n                    if (config.bicolor_pivot == 'mean') {\n                        return stats.scoreMean || 0;\n                    } else if (config.bicolor_pivot == 'zero') {\n                        return 0;\n                    } else {\n                        return parseFloat(config.bicolor_pivot);\n                    }\n                } else if (config.scale == 'z_score') {\n                    return stats.scoreMean || 0;\n                } else if (config.scale == 'log') {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }();\n\n            lang.mixin(this, {\n                offset: offset,\n                min: min,\n                max: max,\n                range: max - min,\n                origin: origin,\n                _statsFingerprint: Digest.objectFingerprint(stats)\n            });\n            if (needStats) {\n                this.scoreMean = stats.scoreMean;\n                this.scoreStdDev = stats.scoreStdDev;\n            }\n\n            // make this.normalize a func that converts wiggle values to a\n            // range between 0 and 1, depending on what kind of scale we\n            // are using\n            this.normalize = function (config) {\n                switch (config.scale) {\n                    case 'z_score':\n                        return function (value) {\n                            return (value + this.offset - this.scoreMean) / this.scoreStdDev - this.min / this.range;\n                        };\n                    case 'log':\n                        return function (value) {\n                            return (this.log(value + this.offset) - this.min) / this.range;\n                        };\n                    case 'linear':\n                    /* fall through */\n                    default:\n                        return function (value) {\n                            return (value + this.offset - this.min) / this.range;\n                        };\n                }\n            }(config);\n        },\n\n        log: function log(value) {\n            return value ? Math.log(Math.abs(value)) * (value < 0 ? -1 : 1) : 0;\n        },\n\n        /**\n         * Standard comparison function, compare this scale to another one.\n         */\n        compare: function compare(b) {\n            if (!b) return 1;\n\n            var a = this;\n            return a.offset - b.offset || a.min - b.min || a.max - b.max || a.range - b.range || a.origin - b.origin;\n        },\n\n        /**\n         * Return true if this scaling was generated from the same set of stats.\n         */\n        sameStats: function sameStats(stats) {\n            return this._statsFingerprint == Digest.objectFingerprint(stats);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/Wiggle/_Scale.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/WiggleBase.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/Track/WiggleBase.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/event */ \"./node_modules/dojo/_base/event.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/mouse */ \"./node_modules/dojo/mouse.js\"), __webpack_require__(/*! JBrowse/View/Track/BlockBased */ \"./src/JBrowse/View/Track/BlockBased.js\"), __webpack_require__(/*! JBrowse/View/Track/_ExportMixin */ \"./src/JBrowse/View/Track/_ExportMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_TrackDetailsStatsMixin */ \"./src/JBrowse/View/Track/_TrackDetailsStatsMixin.js\"), __webpack_require__(/*! JBrowse/View/Dialog/SetTrackHeight */ \"./src/JBrowse/View/Dialog/SetTrackHeight.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! ./Wiggle/_Scale */ \"./src/JBrowse/View/Track/Wiggle/_Scale.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, domEvent, dom, on, mouse, BlockBasedTrack, ExportMixin, DetailStatsMixin, TrackHeightDialog, Util, has, Scale) {\n\n    return declare([BlockBasedTrack, ExportMixin, DetailStatsMixin], {\n\n        constructor: function constructor(args) {\n            this.trackPadding = args.trackPadding || 0;\n\n            if (!('style' in this.config)) {\n                this.config.style = {};\n            }\n\n            this.store = args.store;\n\n            this._setupEventHandlers();\n        },\n\n        _defaultConfig: function _defaultConfig() {\n            return {\n                maxExportSpan: 500000,\n                autoscale: 'global',\n                logScaleOption: true\n            };\n        },\n\n        _setupEventHandlers: function _setupEventHandlers() {\n            // make a default click event handler\n            var eventConf = dojo.clone(this.config.events || {});\n            if (!eventConf.click) {\n                // unlike CanvasFeatures, linkTemplate or nothing here... no default contentDialog since no equivalent to defaultFeatureDetail\n                if ((this.config.style || {}).linkTemplate) {\n                    eventConf.click = { action: \"newWindow\", url: this.config.style.linkTemplate };\n                }\n            }\n\n            // process the configuration to set up our event handlers\n            this.eventHandlers = function () {\n                var handlers = dojo.clone(eventConf);\n                // find conf vars that set events, like `onClick`\n                for (var key in this.config) {\n                    var handlerName = key.replace(/^on(?=[A-Z])/, '');\n                    if (handlerName != key) handlers[handlerName.toLowerCase()] = this.config[key];\n                }\n                // interpret handlers that are just strings to be URLs that should be opened\n                for (key in handlers) {\n                    if (typeof handlers[key] == 'string') handlers[key] = { url: handlers[key] };\n                }\n                return handlers;\n            }.call(this);\n            // only call _makeClickHandler() if we have related settings in config\n            if (this.eventHandlers.click) this.eventHandlers.click = this._makeClickHandler(this.eventHandlers.click);\n        },\n\n        _getScaling: function _getScaling(viewArgs, successCallback, errorCallback) {\n            this._getScalingStats(viewArgs, dojo.hitch(this, function (stats) {\n\n                //calculate the scaling if necessary\n                if (!this.lastScaling || !this.lastScaling.sameStats(stats)) {\n                    try {\n                        this.lastScaling = new Scale(this.config, stats);\n                        successCallback(this.lastScaling);\n                    } catch (e) {\n                        errorCallback(e);\n                    }\n                } else {\n                    successCallback(this.lastScaling);\n                }\n            }), errorCallback);\n        },\n\n        // get the statistics to use for scaling, if necessary, either\n        // from the global stats for the store, or from the local region\n        // if config.autoscale is 'local'\n        _getScalingStats: function _getScalingStats(viewArgs, callback, errorCallback) {\n            if (!Scale.prototype.needStats(this.config)) {\n                callback(null);\n                return null;\n            } else if (this.config.autoscale == 'local') {\n                var region = lang.mixin({ scale: viewArgs.scale }, this.browser.view.visibleRegion());\n                region.start = Math.ceil(region.start);\n                region.end = Math.floor(region.end);\n                return this.getRegionStats.call(this, region, callback, errorCallback);\n            } else {\n                return this.getGlobalStats.call(this, callback, errorCallback);\n            }\n        },\n\n        getFeatures: function getFeatures(query, callback, errorCallback) {\n            this.store.getFeatures.apply(this.store, arguments);\n        },\n\n        getGlobalStats: function getGlobalStats(successCallback, errorCallback) {\n            this.store.getGlobalStats(successCallback, errorCallback);\n        },\n\n        getRegionStats: function getRegionStats(region, successCallback, errorCallback) {\n            this.store.getRegionStats(region, successCallback, errorCallback);\n        },\n\n        // the canvas width in pixels for a block\n        _canvasWidth: function _canvasWidth(block) {\n            return Math.ceil((block.endBase - block.startBase) * block.scale);\n        },\n\n        // the canvas height in pixels for a block\n        _canvasHeight: function _canvasHeight() {\n            return parseInt((this.config.style || {}).height) || 100;\n        },\n\n        _getBlockFeatures: function _getBlockFeatures(args) {\n            var thisB = this;\n            var blockIndex = args.blockIndex;\n            var block = args.block;\n\n            var leftBase = args.leftBase;\n            var rightBase = args.rightBase;\n\n            var scale = args.scale;\n            var finishCallback = args.finishCallback || function () {};\n\n            var canvasWidth = this._canvasWidth(args.block);\n\n            var features = [];\n            this.getFeatures({ ref: this.refSeq.name,\n                basesPerSpan: 1 / scale,\n                scale: scale,\n                start: leftBase,\n                end: rightBase + 1\n            }, function (f) {\n                if (thisB.filterFeature(f)) features.push(f);\n            }, dojo.hitch(this, function (args) {\n\n                // if the block has been freed in the meantime,\n                // don't try to render\n                if (!(block.domNode && block.domNode.parentNode)) return;\n\n                var featureRects = array.map(features, function (f) {\n                    return this._featureRect(scale, leftBase, canvasWidth, f);\n                }, this);\n\n                block.features = features; //< TODO: remove this\n                block.featureRects = featureRects;\n                block.pixelScores = this._calculatePixelScores(this._canvasWidth(block), features, featureRects);\n\n                if (args && args.maskingSpans) block.maskingSpans = args.maskingSpans; // used for masking\n\n                finishCallback();\n            }), dojo.hitch(this, function (e) {\n                console.error(e.stack || '' + e, e);\n                this._handleError(e, args);\n            }));\n        },\n\n        // render the actual graph display for the block.  should be called only after a scaling\n        // has been decided upon and stored in this.scaling\n        renderBlock: function renderBlock(args) {\n            var block = args.block;\n\n            // don't render this block again if we have already rendered\n            // it with this scaling scheme\n            if (!this.scaling.compare(block.scaling) || !block.pixelScores) return;\n\n            block.scaling = this.scaling;\n\n            dom.empty(block.domNode);\n\n            try {\n                dojo.create('canvas').getContext('2d').fillStyle = 'red';\n            } catch (e) {\n                this.fatalError = 'This browser does not support HTML canvas elements.';\n                this.fillBlockError(args.blockIndex, block, this.fatalError);\n                return;\n            }\n\n            var features = block.features;\n            var featureRects = block.featureRects;\n            var dataScale = this.scaling;\n            var canvasHeight = this._canvasHeight();\n\n            var c = dojo.create('canvas', { height: canvasHeight,\n                width: this._canvasWidth(block),\n                style: {\n                    cursor: 'default',\n                    height: canvasHeight + \"px\",\n                    width: has('inaccurate-html-width') ? \"\" : \"100%\",\n                    \"min-width\": has('inaccurate-html-width') ? \"100%\" : \"\",\n                    \"max-width\": has('inaccurate-html-width') ? \"102%\" : \"\"\n\n                },\n                innerHTML: 'Your web browser cannot display this type of track.',\n                className: 'canvas-track'\n            }, block.domNode);\n\n            var ctx = c.getContext('2d');\n            var ratio = Util.getResolution(ctx, this.browser.config.highResolutionMode);\n\n            // upscale canvas if the two ratios don't match\n            if (this.browser.config.highResolutionMode != 'disabled' && ratio >= 1) {\n                var oldWidth = c.width;\n                var oldHeight = c.height;\n\n                c.width = Math.round(oldWidth * ratio);\n                c.height = Math.round(oldHeight * ratio);\n\n                //c.style.width = oldWidth + 'px';\n                c.style.height = oldHeight + 'px';\n\n                // now scale the context to counter\n                // the fact that we've manually scaled\n                // our canvas element\n                ctx.scale(ratio, ratio);\n            }\n\n            c.startBase = block.startBase;\n            block.canvas = c;\n\n            //Calculate the score for each pixel in the block\n            var pixels = this._calculatePixelScores(c.width, features, featureRects);\n\n            this._draw(block.scale, block.startBase, block.endBase, block, c, features, featureRects, dataScale, pixels, block.maskingSpans); // note: spans may be undefined.\n\n            this.heightUpdate(c.height / ratio, args.blockIndex);\n            if (!(c.parentNode && c.parentNode.parentNode)) {\n                var blockWidth = block.endBase - block.startBase;\n\n                c.style.position = \"absolute\";\n                c.style.left = 100 * ((c.startBase - block.startBase) / blockWidth) + \"%\";\n                switch (this.config.align) {\n                    case \"top\":\n                        c.style.top = \"0px\";\n                        break;\n                    case \"bottom\":\n                    /* fall through */\n                    default:\n                        c.style.bottom = this.trackPadding + \"px\";\n                        break;\n                }\n            }\n        },\n\n        fillBlock: function fillBlock(args) {\n            var thisB = this;\n            this.heightUpdate(this._canvasHeight(), args.blockIndex);\n\n            // hook updateGraphs onto the end of the block feature fetch\n            var oldFinish = args.finishCallback || function () {};\n            args.finishCallback = function () {\n                thisB.updateGraphs(args, oldFinish);\n            };\n\n            // get the features for this block, and then set in motion the\n            // updating of the graphs\n            this._getBlockFeatures(args);\n        },\n\n        updateGraphs: function updateGraphs(viewArgs, callback) {\n            var thisB = this;\n\n            // update the global scaling\n            this._getScaling(viewArgs, function (scaling) {\n                thisB.scaling = scaling;\n                // render all of the blocks that need it\n                array.forEach(thisB.blocks, function (block, blockIndex) {\n                    if (block && block.domNode.parentNode) thisB.renderBlock({\n                        block: block,\n                        blockIndex: blockIndex\n                    });\n                });\n                callback();\n            }, function (e) {\n                thisB._handleError(e, viewArgs);\n            });\n        },\n\n        // Draw features\n        _draw: function _draw(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale, pixels, spans) {\n            this._preDraw(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale);\n            this._drawFeatures(scale, leftBase, rightBase, block, canvas, pixels, dataScale);\n            if (spans) {\n                this._maskBySpans(scale, leftBase, rightBase, block, canvas, pixels, dataScale, spans);\n            }\n            this._postDraw(scale, leftBase, rightBase, block, canvas, features, featureRects, dataScale);\n        },\n\n        startZoom: function startZoom(destScale, destStart, destEnd) {},\n\n        endZoom: function endZoom(destScale, destBlockBases) {\n            this.clear();\n        },\n\n        /**\n         * Calculate the left and width, in pixels, of where this feature\n         * will be drawn on the canvas.\n         * @private\n         * @returns {Object} with l, r, and w\n         */\n        _featureRect: function _featureRect(scale, leftBase, canvasWidth, feature) {\n            var fRect = {\n                w: Math.ceil((feature.get('end') - feature.get('start')) * scale),\n                l: Math.round((feature.get('start') - leftBase) * scale)\n            };\n\n            // if fRect.l is negative (off the left\n            // side of the canvas), clip off the\n            // (possibly large!) non-visible\n            // portion\n            if (fRect.l < 0) {\n                fRect.w += fRect.l;\n                fRect.l = 0;\n            }\n\n            // also don't let fRect.w get overly big\n            fRect.w = Math.min(canvasWidth - fRect.l, fRect.w);\n            fRect.r = fRect.w + fRect.l;\n\n            return fRect;\n        },\n\n        _preDraw: function _preDraw(canvas) {},\n\n        /**\n         * Draw a set of features on the canvas.\n         * @private\n         */\n        _drawFeatures: function _drawFeatures(scale, leftBase, rightBase, block, canvas, features, featureRects) {},\n\n        // If we are making a boolean track, this will be called. Overwrite.\n        _maskBySpans: function _maskBySpans(scale, leftBase, canvas, spans, pixels) {},\n\n        _postDraw: function _postDraw() {},\n\n        _calculatePixelScores: function _calculatePixelScores(canvasWidth, features, featureRects) {\n            var scoreType = this.config.scoreType || \"maxScore\";\n            var pixelValues = new Array(canvasWidth);\n            if (scoreType == \"maxScore\") {\n                // make an array of the max score at each pixel on the canvas\n                dojo.forEach(features, function (f, i) {\n                    var store = f.source;\n                    var fRect = featureRects[i];\n                    var jEnd = fRect.r;\n                    var score = f.get(scoreType);\n                    if (score === undefined) {\n                        score = f.get('score'); // we are not in a summary block and have no maxScore so use regular score\n                    }\n                    for (var j = Math.round(fRect.l); j < jEnd; j++) {\n                        if (pixelValues[j] && pixelValues[j]['lastUsedStore'] == store) {\n                            /* Note: if the feature is from a different store, the condition should fail,\n                             *       and we will add to the value, rather than adjusting for overlap */\n                            pixelValues[j]['score'] = Math.max(pixelValues[j]['score'], score);\n                        } else if (pixelValues[j]) {\n                            pixelValues[j]['score'] = pixelValues[j]['score'] + score;\n                            pixelValues[j]['lastUsedStore'] = store;\n                        } else {\n                            pixelValues[j] = { score: score, lastUsedStore: store, feat: f };\n                        }\n                    }\n                }, this);\n                // when done looping through features, forget the store information.\n                for (var i = 0; i < pixelValues.length; i++) {\n                    if (pixelValues[i]) {\n                        delete pixelValues[i]['lastUsedStore'];\n                    }\n                }\n            } else if (scoreType == \"avgScore\") {\n                // make an array of the average score at each pixel on the canvas\n                dojo.forEach(features, function (f, i) {\n                    var store = f.source;\n                    var fRect = featureRects[i];\n                    var jEnd = fRect.r;\n                    var score = f.get('score');\n                    for (var j = Math.round(fRect.l); j < jEnd; j++) {\n                        // bin scores according to store\n                        if (pixelValues[j] && store in pixelValues[j]['scores']) {\n                            pixelValues[j]['scores'][store].push(score);\n                        } else if (pixelValues[j]) {\n                            pixelValues[j]['scores'][store] = [score];\n                        } else {\n                            pixelValues[j] = { scores: {}, feat: f };\n                            pixelValues[j]['scores'][store] = [score];\n                        }\n                    }\n                }, this);\n                // when done looping through features, average the scores in the same store then add them all together as the final score\n                for (var i = 0; i < pixelValues.length; i++) {\n                    if (pixelValues[i]) {\n                        pixelValues[i]['score'] = 0;\n                        for (var store in pixelValues[i]['scores']) {\n                            var j,\n                                sum = 0,\n                                len = pixelValues[i]['scores'][store].length;\n                            for (j = 0; j < len; j++) {\n                                sum += pixelValues[i]['scores'][store][j];\n                            }\n                            pixelValues[i]['score'] += sum / len;\n                        }\n                        delete pixelValues[i]['scores'];\n                    }\n                }\n            }\n            return pixelValues;\n        },\n\n        setViewInfo: function setViewInfo() {\n            this.inherited(arguments);\n            this._makeScoreDisplay();\n        },\n\n        _makeScoreDisplay: function _makeScoreDisplay() {\n            var gv = this.browser.view;\n            var thisB = this;\n\n            if (!this._mouseoverEvent) this._mouseoverEvent = this.own(on(this.div, 'mousemove', function (evt) {\n                evt = domEvent.fix(evt);\n                var bpX = gv.absXtoBp(evt.clientX);\n                thisB.mouseover(bpX, evt);\n            }))[0];\n            if (!this._mouseoutEvent) this._mouseoutEvent = this.own(on(this.div, mouse.leave, function (evt) {\n                thisB.mouseover(undefined);\n            }))[0];\n\n            // only add if we have config setting a click eventHandler for this track\n            if (thisB.eventHandlers.click && !this._mouseClickEvent) this._mouseClickEvent = this.own(on(this.div, \"click\", thisB.eventHandlers.click))[0];\n\n            // make elements and events to display it\n            if (!this.scoreDisplay) this.scoreDisplay = {\n                flag: dojo.create('div', {\n                    className: 'wiggleValueDisplay',\n                    style: {\n                        position: 'fixed',\n                        display: 'none',\n                        zIndex: 15\n                    }\n                }, this.div),\n                pole: dojo.create('div', {\n                    className: 'wigglePositionIndicator',\n                    style: {\n                        position: 'fixed',\n                        display: 'none',\n                        zIndex: 15\n                    }\n                }, this.div)\n            };\n        },\n\n        mouseover: function mouseover(bpX, evt) {\n            // if( this._scoreDisplayHideTimeout )\n            //     window.clearTimeout( this._scoreDisplayHideTimeout );\n            if (bpX === undefined) {\n                var thisB = this;\n                //this._scoreDisplayHideTimeout = window.setTimeout( function() {\n                thisB.scoreDisplay.flag.style.display = 'none';\n                thisB.scoreDisplay.pole.style.display = 'none';\n                //}, 1000 );\n            } else {\n                var block;\n                array.some(this.blocks, function (b) {\n                    if (b && b.startBase <= bpX && b.endBase >= bpX) {\n                        block = b;\n                        return true;\n                    }\n                    return false;\n                });\n\n                if (!(block && block.canvas && block.pixelScores && evt)) return;\n\n                var pixelValues = block.pixelScores;\n                var canvas = block.canvas;\n                var cPos = dojo.position(canvas);\n                var x = evt.pageX;\n                var cx = evt.pageX - cPos.x;\n\n                if (this._showPixelValue(this.scoreDisplay.flag, pixelValues[Math.round(cx)])) {\n                    this.scoreDisplay.flag.style.display = 'block';\n                    this.scoreDisplay.pole.style.display = 'block';\n\n                    this.scoreDisplay.flag.style.left = evt.clientX + 'px';\n                    this.scoreDisplay.flag.style.top = cPos.y + 'px';\n                    this.scoreDisplay.pole.style.left = evt.clientX + 'px';\n                    this.scoreDisplay.pole.style.height = cPos.h + 'px';\n                    this.scoreDisplay.pole.style.top = cPos.y + 'px';\n                }\n            }\n        },\n\n        _showPixelValue: function _showPixelValue(scoreDisplay, score) {\n            if (typeof score == 'number') {\n                // display the score with only 6\n                // significant digits, avoiding\n                // most confusion about the\n                // approximative properties of\n                // IEEE floating point numbers\n                // parsed out of BigWig files\n                scoreDisplay.innerHTML = parseFloat(score.toPrecision(6));\n                return true;\n            } else if (score && typeof score['score'] == 'number') {\n                // \"score\" may be an object.\n                scoreDisplay.innerHTML = parseFloat(score['score'].toPrecision(6));\n                return true;\n            } else {\n                return false;\n            }\n        },\n\n        _exportFormats: function _exportFormats() {\n            return [{ name: 'bedGraph', label: 'bedGraph', fileExt: 'bedgraph' }, { name: 'Wiggle', label: 'Wiggle', fileExt: 'wig' }, { name: 'GFF3', label: 'GFF3', fileExt: 'gff3' }];\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var track = this;\n            var options = this.inherited(arguments) || [];\n\n            options.push({\n                label: 'Change height',\n                iconClass: 'jbrowseIconVerticalResize',\n                action: function action() {\n                    new TrackHeightDialog({\n                        height: track._canvasHeight(),\n                        setCallback: function setCallback(newHeight) {\n                            track.trackHeightChanged = true;\n                            track.updateUserStyles({ height: newHeight });\n                        }\n                    }).show();\n                }\n            });\n            if (this.config.logScaleOption) {\n                options.push({\n                    label: 'Log scale',\n                    type: 'dijit/CheckedMenuItem',\n                    checked: !!(this.config.scale == 'log'),\n                    onClick: function onClick(event) {\n                        if (this.checked) {\n                            track.config.scale = 'log';\n                        } else {\n                            track.config.scale = 'linear';\n                        }\n                        track.browser.publish('/jbrowse/v1/v/tracks/replace', [track.config]);\n                    }\n                });\n            }\n\n            return options;\n        },\n\n        // this draws either one or two width pixels based on whether there is a fractional devicePixelRatio\n        _fillRectMod: function _fillRectMod(ctx, left, top, width, height) {\n            var devicePixelRatio = window.devicePixelRatio || 1;\n            var drawWidth = width;\n            // check for fractional devicePixelRatio, and if so, draw wider pixels to avoid subpixel rendering\n            if (this.browser.config.highResolutionMode != 'disabled' && devicePixelRatio - Math.floor(devicePixelRatio) > 0) {\n                drawWidth = width + 0.3; // Minimal for subpixel gap, heuristic\n            }\n            ctx.fillRect(left, top, drawWidth, height);\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/WiggleBase.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_AlignmentsMixin.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/View/Track/_AlignmentsMixin.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Mixin with methods used for displaying alignments and their mismatches.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/when */ \"./node_modules/dojo/when.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/Store/SeqFeature/_MismatchesMixin */ \"./src/JBrowse/Store/SeqFeature/_MismatchesMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_NamedFeatureFiltersMixin */ \"./src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, when, Util, MismatchesMixin, NamedFeatureFiltersMixin) {\n\n    return declare([MismatchesMixin, NamedFeatureFiltersMixin], {\n\n        /**\n         * Make a default feature detail page for the given feature.\n         * @returns {HTMLElement} feature detail page HTML\n         */\n        defaultFeatureDetail: function defaultFeatureDetail( /** JBrowse.Track */track, /** Object */f, /** HTMLElement */div) {\n            var container = void 0;\n            if (f.pairedFeature() && track.config.viewAsPairs) {\n                container = dojo.create('div', {\n                    className: 'detail feature-detail feature-detail-' + track.name.replace(/\\s+/g, '_').toLowerCase(),\n                    style: { width: '1000px' }\n                });\n                dojo.place('<div><h1>Paired read details</h1></div><br />', container);\n                var flexContainer = dojo.create('div', {\n                    className: 'detail feature-detail feature-detail-' + track.name.replace(/\\s+/g, '_').toLowerCase(),\n                    style: {\n                        display: 'flex',\n                        'flex-direction': 'row'\n                    }\n                }, container);\n                var c1 = dojo.create('div', { className: 'detail feature-detail' }, flexContainer);\n                var c2 = dojo.create('div', { className: 'detail feature-detail' }, flexContainer);\n                var ret = this.defaultAlignmentDetail(track, f.read1, c1);\n                var ret2 = this.defaultAlignmentDetail(track, f.read2, c2);\n                dojo.place(ret, c1);\n                dojo.place(ret2, c2);\n                return container;\n            } else {\n                container = this.defaultAlignmentDetail(track, f, div);\n            }\n            return container;\n        },\n        defaultAlignmentDetail: function defaultAlignmentDetail(track, f, div) {\n            var container = dojo.create('div', {\n                className: 'detail feature-detail feature-detail-' + track.name.replace(/\\s+/g, '_').toLowerCase(),\n                innerHTML: ''\n            });\n            var fmt = dojo.hitch(this, function (name, value, feature, unsafe) {\n                name = Util.ucFirst(name.replace(/_/g, ' '));\n                return this.renderDetailField(container, name, value, feature, null, {}, unsafe);\n            });\n\n            this._renderCoreDetails(track, f, div, container);\n\n            if (f.get('seq')) {\n                fmt('Sequence and Quality', this._renderSeqQual(f), f, true);\n            }\n\n            var renameTags = { length_on_ref: 'seq_length_on_ref' };\n            var additionalTags = array.filter(f.tags(), function (t) {\n                return !{ name: 1, score: 1, start: 1, end: 1, strand: 1, note: 1, subfeatures: 1, type: 1, cram_read_features: 1 }[t.toLowerCase()];\n            }).map(function (tagName) {\n                return [renameTags[tagName] || tagName, f.get(tagName)];\n            }).sort(function (a, b) {\n                return a[0].localeCompare(b[0]);\n            });\n\n            dojo.forEach(additionalTags, function (t) {\n                fmt(t[0], t[1], f);\n            });\n\n            // genotypes in a separate section\n            if (this.config.renderAlignment || this.config.renderPrettyAlignment) {\n                this._renderTable(container, track, f, div);\n            }\n\n            return container;\n        },\n\n\n        // takes a feature, returns an HTML representation of its 'seq'\n        // and 'qual', if it has at least a seq. empty string otherwise.\n        _renderSeqQual: function _renderSeqQual(feature) {\n\n            var seq = feature.get('seq'),\n                qual = feature.get('qual') || '';\n            if (!seq) return '';\n\n            qual = qual.split(/\\s+/);\n\n            var html = '';\n            for (var i = 0; i < seq.length; i++) {\n                html += '<div class=\"basePosition\" title=\"position ' + (i + 1) + '\"><span class=\"seq\">' + seq[i] + '</span>';\n                if (qual[i]) html += '<span class=\"qual\">' + qual[i] + '</span>';\n                html += '</div>';\n            }\n            return '<div class=\"baseQuality\">' + html + '</div>';\n        },\n\n        // recursively find all the stylesheets that are loaded in the\n        // current browsing session, traversing imports and such\n        _getStyleSheets: function _getStyleSheets(inSheets) {\n            var _this = this;\n\n            var outSheets = [];\n            array.forEach(inSheets, function (sheet) {\n                try {\n                    var rules = sheet.cssRules || sheet.rules;\n                    var includedSheets = [sheet];\n                    array.forEach(rules, function (rule) {\n                        if (rule.styleSheet) includedSheets.push.apply(includedSheets, _toConsumableArray(_this._getStyleSheets([rule.styleSheet])));\n                    });\n                    outSheets.push.apply(outSheets, includedSheets);\n                } catch (e) {\n                    //console.warn('could not read stylesheet',sheet)\n                }\n            });\n\n            return outSheets;\n        },\n\n        // get the appropriate HTML color string to use for a given base\n        // letter.  case insensitive.  'reference' gives the color to draw matches with the reference.\n        colorForBase: function colorForBase(base) {\n            // get the base colors out of CSS\n            this._baseStyles = this._baseStyles || function () {\n                var colors = {};\n                try {\n                    var styleSheets = this._getStyleSheets(document.styleSheets);\n                    array.forEach(styleSheets, function (sheet) {\n                        // avoid modifying cssRules for plugins which generates SecurityException on Firefox\n                        var classes = sheet.rules || sheet.cssRules;\n                        if (!classes) return;\n                        array.forEach(classes, function (c) {\n                            var match = /^\\.jbrowse\\s+\\.base_([^\\s_]+)$/.exec(c.selectorText);\n                            if (match && match[1]) {\n                                var base = match[1];\n                                match = /\\#[0-9a-f]{3,6}|(?:rgb|hsl)a?\\([^\\)]*\\)/gi.exec(c.cssText);\n                                if (match && match[0]) {\n                                    colors[base.toLowerCase()] = match[0];\n                                    colors[base.toUpperCase()] = match[0];\n                                }\n                            }\n                        });\n                    });\n                } catch (e) {\n                    console.error(e);\n                    /* catch errors from cross-domain stylesheets */\n                }\n\n                return colors;\n            }.call(this);\n\n            return this._baseStyles[base] || '#999';\n        },\n\n        // filters for BAM alignments according to some flags\n        _getNamedFeatureFilters: function _getNamedFeatureFilters() {\n            return lang.mixin({}, this.inherited(arguments), {\n                hideDuplicateReads: {\n                    desc: 'Hide PCR/Optical duplicate reads',\n                    func: function func(f) {\n                        return !(f.get('duplicate') === true);\n                    }\n                },\n                hideQCFailingReads: {\n                    desc: 'Hide reads failing vendor QC',\n                    func: function func(f) {\n                        return !(f.get('qc_failed') === true);\n                    }\n                },\n                hideSecondary: {\n                    desc: 'Hide secondary alignments',\n                    func: function func(f) {\n                        return !(f.get('secondary_alignment') === true);\n                    }\n                },\n                hideSupplementary: {\n                    desc: 'Hide supplementary alignments',\n                    func: function func(f) {\n                        return !(f.get('supplementary_alignment') === true);\n                    }\n                },\n                hideMissingMatepairs: {\n                    desc: 'Hide reads with missing mate pairs',\n                    func: function func(f) {\n                        return !(f.get('multi_segment_template') && f.get('multi_segment_next_segment_unmapped'));\n                    }\n                },\n                hideImproperPairs: {\n                    desc: 'Hide reads that with improper pairs',\n                    func: function func(f) {\n                        return !(f.get('multi_segment_template') && !f.get('multi_segment_all_aligned'));\n                    }\n                },\n\n                hideUnmapped: {\n                    desc: 'Hide unmapped reads',\n                    func: function func(f) {\n                        return !(f.get('unmapped') === true);\n                    }\n                },\n                hideForwardStrand: {\n                    desc: 'Hide reads aligned to the forward strand',\n                    func: function func(f) {\n                        return f.get('strand') !== 1;\n                    }\n                },\n                hideReverseStrand: {\n                    desc: 'Hide reads aligned to the reverse strand',\n                    func: function func(f) {\n                        return f.get('strand') !== -1;\n                    }\n                },\n                hideUnsplicedReads: {\n                    desc: 'Hide unspliced reads',\n                    func: function func(f) {\n                        return (f.get('cigar') || '').indexOf('N') != -1;\n                    }\n                }\n            });\n        },\n\n        _alignmentsFilterTrackMenuOptions: function _alignmentsFilterTrackMenuOptions() {\n            // add toggles for feature filters\n            var track = this;\n            return when(this._getNamedFeatureFilters()).then(function (filters) {\n                return track._makeFeatureFilterTrackMenuItems(['hideDuplicateReads', 'hideQCFailingReads', 'hideMissingMatepairs', 'hideImproperPairs', 'hideSecondary', 'hideSupplementary', 'hideUnmapped', 'SEPARATOR', 'hideForwardStrand', 'hideReverseStrand', 'hideUnsplicedReads'], filters);\n            });\n        },\n\n        _renderTable: function _renderTable(parentElement, track, feat, featDiv) {\n            var thisB = this;\n\n            var mismatches = track._getMismatches(feat);\n            var seq = feat.get('seq');\n            if (!seq) {\n                var gContainer = dojo.create('div', {\n                    className: 'renderTable',\n                    innerHTML: '<h2 class=\"sectiontitle\">Matches</h2><div style=\\\"font-family: Courier; white-space: pre;\\\">' + 'No sequence on feature, cannot render alignment</div>'\n                }, parentElement);\n                return;\n            }\n\n            var start = feat.get('start');\n            var query_str = '',\n                align_str = '',\n                refer_str = '';\n            var curr_mismatch = 0;\n            var genome_pos = 0;\n            var curr_pos = 0;\n\n            mismatches.sort(function (a, b) {\n                return a.start - b.start;\n            });\n            for (var i = 0; curr_pos < seq.length; i++) {\n                var f = false;\n                var mismatchesAtCurrentPosition = [];\n                for (var j = curr_mismatch; j < mismatches.length; j++) {\n                    var mismatch = mismatches[j];\n                    if (genome_pos == mismatch.start) {\n                        mismatchesAtCurrentPosition.push(mismatch);\n                    }\n                }\n\n                mismatchesAtCurrentPosition.sort(function (a, b) {\n                    if (a.type == \"insertion\") return -1;else if (a.type == \"deletion\") return 1;else if (a.type == \"mismatch\") return 1;else if (a.type == \"skip\") return 1;else return 0;\n                });\n\n                for (var k = 0; k < mismatchesAtCurrentPosition.length; k++) {\n                    var mismatch = mismatchesAtCurrentPosition[k];\n                    curr_mismatch++;\n                    if (mismatch.type == \"softclip\") {\n                        for (var l = 0; l < mismatch.cliplen; l++) {\n                            query_str += seq[curr_pos + l];\n                            align_str += ' ';\n                            refer_str += '.';\n                        }\n                        curr_pos += mismatch.cliplen;\n                        f = true;\n                    } else if (mismatch.type == \"insertion\") {\n                        for (var l = 0; l < +mismatch.base; l++) {\n                            query_str += seq[curr_pos + l];\n                            align_str += ' ';\n                            refer_str += '-';\n                        }\n                        curr_pos += +mismatch.base || mismatch.base.length;\n                        f = true;\n                    } else if (mismatch.type == \"deletion\") {\n                        for (var l = 0; l < mismatch.length; l++) {\n                            query_str += '-';\n                            align_str += ' ';\n                            refer_str += (mismatch.seq || {})[l] || \".\";\n                        }\n                        genome_pos += mismatch.length;\n                        f = true;\n                    } else if (mismatch.type == \"skip\") {\n                        for (var l = 0; l < Math.min(mismatch.length, 10000); l++) {\n                            query_str += '.';\n                            align_str += ' ';\n                            refer_str += 'N';\n                        }\n                        genome_pos += mismatch.length;\n                        f = true;\n                    } else if (mismatch.type == \"mismatch\") {\n                        query_str += mismatch.base;\n                        align_str += ' ';\n                        refer_str += mismatch.altbase;\n                        curr_pos++;\n                        genome_pos++;\n                        f = true;\n                    }\n                }\n                if (!f) {\n                    query_str += seq[curr_pos];\n                    align_str += '|';\n                    refer_str += seq[curr_pos];\n                    genome_pos++;\n                    curr_pos++;\n                }\n            }\n            if (this.config.renderPrettyAlignment) {\n                var s1, s2, s3, ret_str;\n                s1 = s2 = s3 = ret_str = '';\n                var qpos = 0;\n                var rpos = mismatches.length && mismatches[0].type == 'softclip' ? start - mismatches[0].cliplen : start;\n                var w = this.config.renderAlignmentWidth || 50;\n                for (var i = 0; i < query_str.length; i += w) {\n                    s1 = query_str.substring(i, i + w);\n                    s2 = align_str.substring(i, i + w);\n                    s3 = refer_str.substring(i, i + w);\n                    var padding = rpos.toString().replace(/./g, \" \");\n                    var offset1 = s1.length - (s1.match(/[-N\\.]/g) || []).length;\n                    var offset2 = s3.length - (s3.match(/[-]/g) || []).length;\n                    ret_str += 'Query    ' + this.pad(padding, qpos, true) + ': ' + s1 + ' ' + (qpos + offset1) + '<br>';\n                    ret_str += '         ' + padding + '  ' + s2 + '   <br>';\n                    ret_str += 'Ref:     ' + rpos + ': ' + s3 + ' ' + (rpos + offset2) + '  <br><br>';\n                    qpos += offset1;\n                    rpos += offset2;\n                }\n                var gContainer = dojo.create('div', {\n                    className: 'renderTable',\n                    innerHTML: '<h2 class=\"sectiontitle\">Matches</h2><div style=\\\"font-family: Courier; white-space: pre;\\\">' + ret_str + '</div>'\n                }, parentElement);\n            } else if (this.config.renderAlignment) {\n                var gContainer = dojo.create('div', {\n                    className: 'renderTable',\n                    innerHTML: '<h2 class=\"sectiontitle\">Matches</h2><div style=\\\"font-family: Courier; white-space: pre;\\\">' + 'Query: ' + query_str + '   <br>' + '       ' + align_str + '   <br>' + 'Ref:   ' + refer_str + '   </div>'\n                }, parentElement);\n            }\n\n            return {\n                val1: query_str,\n                val2: align_str,\n                val3: refer_str\n            };\n        },\n\n        //stackoverflow http://stackoverflow.com/questions/2686855/is-there-a-javascript-function-that-can-pad-a-string-to-get-to-a-determined-leng\n        pad: function pad(_pad, str, padLeft) {\n            if (typeof str === 'undefined') return _pad;\n            if (padLeft) {\n                return (_pad + str).slice(-_pad.length);\n            } else {\n                return (str + _pad).substring(0, _pad.length);\n            }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_AlignmentsMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_ExportMixin.js":
/*!************************************************!*\
  !*** ./src/JBrowse/View/Track/_ExportMixin.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! JBrowse/has */ \"./src/JBrowse/has.js\"), __webpack_require__(/*! dojo/window */ \"./node_modules/dojo/window.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\"), __webpack_require__(/*! dijit/form/RadioButton */ \"./node_modules/dijit/form/RadioButton.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! FileSaver/FileSaver */ \"./node_modules/filesaver.js/FileSaver.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, aspect, on, has, dojoWindow, dom, Util, dijitTextBox, dijitButton, dijitRadioButton, dijitDialog, FileSaver) {\n\n    /**\n     * Mixin for a track that can export its data.\n     * @lends JBrowse.View.Track.ExportMixin\n     */\n    return declare(null, {\n\n        _canSaveFiles: function _canSaveFiles() {\n            return has('save-generated-files') && !this.config.noExportFiles;\n        },\n\n        _canExport: function _canExport() {\n            if (this.config.noExport) return false;\n\n            var highlightedRegion = this.browser.getHighlight();\n            var visibleRegion = this.browser.view.visibleRegion();\n            var wholeRefSeqRegion = { ref: this.refSeq.name, start: this.refSeq.start, end: this.refSeq.end };\n            var canExportVisibleRegion = this._canExportRegion(visibleRegion);\n            var canExportWholeRef = this._canExportRegion(wholeRefSeqRegion);\n            return highlightedRegion && this._canExportRegion(highlightedRegion) || this._canExportRegion(visibleRegion) || this._canExportRegion(wholeRefSeqRegion);\n        },\n\n        _possibleExportRegions: function _possibleExportRegions() {\n            var regions = [\n            // the visible region\n            function () {\n                var r = dojo.clone(this.browser.view.visibleRegion());\n                r.description = 'Visible region';\n                r.name = 'visible';\n                return r;\n            }.call(this),\n            // whole reference sequence\n            { ref: this.refSeq.name, start: this.refSeq.start, end: this.refSeq.end, description: 'Whole reference sequence', name: 'wholeref' }];\n\n            var highlightedRegion = this.browser.getHighlight();\n            if (highlightedRegion) {\n                var start = highlightedRegion.start,\n                    end = highlightedRegion.end,\n                    ref = highlightedRegion.ref;\n\n                regions.unshift({ start: start, end: end, ref: ref, description: \"Highlighted region\", name: \"highlight\" });\n            }\n\n            return regions;\n        },\n\n        _exportDialogContent: function _exportDialogContent() {\n            // note that the `this` for this content function is not the track, it's the menu-rendering context\n            var possibleRegions = this.track._possibleExportRegions();\n\n            // for each region, calculate its length and determine whether we can export it\n            array.forEach(possibleRegions, function (region) {\n                region.length = Math.round(region.end - region.start + 1);\n                region.canExport = this._canExportRegion(region);\n            }, this.track);\n\n            var setFilenameValue = dojo.hitch(this.track, function () {\n                var region = this._readRadio(form.elements.region);\n                var format = nameToExtension[this._readRadio(form.elements.format)];\n                form.elements.filename.value = ((this.key || this.label) + \"-\" + region).replace(/[^ .a-zA-Z0-9_-]/g, '-') + \".\" + format;\n            });\n\n            var form = dom.create('form', { onSubmit: function onSubmit() {\n                    return false;\n                } });\n            var regionFieldset = dom.create('fieldset', { className: \"region\" }, form);\n            dom.create('legend', { innerHTML: \"Region to save\" }, regionFieldset);\n\n            var checked = 0;\n            array.forEach(possibleRegions, function (r) {\n                var locstring = Util.assembleLocString(r);\n                var regionButton = new dijitRadioButton({ name: \"region\", id: \"region_\" + r.name,\n                    value: locstring, checked: r.canExport && !checked++ ? \"checked\" : \"\"\n                });\n                regionFieldset.appendChild(regionButton.domNode);\n                var regionButtonLabel = dom.create(\"label\", { \"for\": regionButton.id, innerHTML: r.description + ' - <span class=\"locString\">' + locstring + '</span> (' + Util.humanReadableNumber(r.length) + (r.canExport ? 'b' : 'b, too large') + ')' }, regionFieldset);\n                if (!r.canExport) {\n                    regionButton.domNode.disabled = \"disabled\";\n                    regionButtonLabel.className = \"ghosted\";\n                }\n\n                on(regionButton, \"click\", setFilenameValue);\n\n                dom.create('br', {}, regionFieldset);\n            });\n\n            var formatFieldset = dom.create(\"fieldset\", { className: \"format\" }, form);\n            dom.create(\"legend\", { innerHTML: \"Format\" }, formatFieldset);\n\n            checked = 0;\n            var nameToExtension = {};\n            array.forEach(this.track._exportFormats(), function (fmt) {\n                if (!fmt.name) {\n                    fmt = { name: fmt, label: fmt };\n                }\n                if (!fmt.fileExt) {\n                    fmt.fileExt = fmt.name || fmt;\n                }\n                nameToExtension[fmt.name] = fmt.fileExt;\n                var formatButton = new dijitRadioButton({ name: \"format\", id: \"format\" + fmt.name, value: fmt.name, checked: checked++ ? \"\" : \"checked\" });\n                formatFieldset.appendChild(formatButton.domNode);\n                var formatButtonLabel = dom.create(\"label\", { \"for\": formatButton.id, innerHTML: fmt.label }, formatFieldset);\n\n                on(formatButton, \"click\", setFilenameValue);\n                dom.create(\"br\", {}, formatFieldset);\n            }, this);\n\n            var filenameFieldset = dom.create(\"fieldset\", { className: \"filename\" }, form);\n            dom.create(\"legend\", { innerHTML: \"Filename\" }, filenameFieldset);\n            dom.create(\"input\", { type: \"text\", name: \"filename\", style: { width: \"100%\" } }, filenameFieldset);\n\n            setFilenameValue();\n\n            var actionBar = dom.create('div', {\n                className: 'dijitDialogPaneActionBar'\n            });\n\n            // note that the `this` for this content function is not the track, it's the menu-rendering context\n            var dialog = this.dialog;\n\n            new dijitButton({ iconClass: 'dijitIconDelete', onClick: dojo.hitch(dialog, 'hide'), label: 'Cancel' }).placeAt(actionBar);\n            var viewButton = new dijitButton({ iconClass: 'dijitIconTask',\n                label: 'View',\n                disabled: !array.some(possibleRegions, function (r) {\n                    return r.canExport;\n                }),\n                onClick: lang.partial(this.track._exportViewButtonClicked, this.track, form, dialog)\n            }).placeAt(actionBar);\n\n            // don't show a download button if we for some reason can't save files\n            if (this.track._canSaveFiles()) {\n\n                var dlButton = new dijitButton({ iconClass: 'dijitIconSave',\n                    label: 'Save',\n                    disabled: !array.some(possibleRegions, function (r) {\n                        return r.canExport;\n                    }),\n                    onClick: dojo.hitch(this.track, function () {\n                        var format = this._readRadio(form.elements.format);\n                        var region = this._readRadio(form.elements.region);\n                        var filename = form.elements.filename.value.replace(/[^ .a-zA-Z0-9_-]/g, '-');\n                        dlButton.set('disabled', true);\n                        dlButton.set('iconClass', 'jbrowseIconBusy');\n                        this.exportRegion(region, format, dojo.hitch(this, function (output) {\n                            dialog.hide();\n                            this._fileDownload({ format: format, data: output, filename: filename });\n                        }));\n                    }) }).placeAt(actionBar);\n            }\n\n            return [form, actionBar];\n        },\n\n        // run when the 'View' button is clicked in the export dialog\n        _exportViewButtonClicked: function _exportViewButtonClicked(track, form, dialog) {\n            var viewButton = this;\n            viewButton.set('disabled', true);\n            viewButton.set('iconClass', 'jbrowseIconBusy');\n\n            var region = track._readRadio(form.elements.region);\n            var format = track._readRadio(form.elements.format);\n            var filename = form.elements.filename.value.replace(/[^ .a-zA-Z0-9_-]/g, '-');\n            track.exportRegion(region, format, function (output) {\n                dialog.hide();\n                var text = dom.create('textarea', {\n                    rows: Math.round(dojoWindow.getBox().h / 12 * 0.5),\n                    wrap: 'off',\n                    cols: 80,\n                    style: \"maxWidth: 90em; overflow: scroll; overflow-y: scroll; overflow-x: scroll; overflow:-moz-scrollbars-vertical;\",\n                    readonly: true\n                });\n                text.value = output;\n                var actionBar = dom.create('div', {\n                    className: 'dijitDialogPaneActionBar'\n                });\n                var exportView = new dijitDialog({\n                    className: 'export-view-dialog',\n                    title: format + ' export - <span class=\"locString\">' + region + '</span> (' + Util.humanReadableNumber(output.length) + 'bytes)',\n                    content: [text, actionBar]\n                });\n                new dijitButton({ iconClass: 'dijitIconDelete',\n                    label: 'Close', onClick: dojo.hitch(exportView, 'hide')\n                }).placeAt(actionBar);\n\n                // only show a button if the browser can save files\n                if (track._canSaveFiles()) {\n                    var saveDiv = dom.create(\"div\", { className: \"save\" }, actionBar);\n\n                    var saveButton = new dijitButton({\n                        iconClass: 'dijitIconSave',\n                        label: 'Save',\n                        onClick: function onClick() {\n                            var filename = fileNameText.get('value').replace(/[^ .a-zA-Z0-9_-]/g, '-');\n                            exportView.hide();\n                            track._fileDownload({ format: format, data: output, filename: filename });\n                        }\n                    }).placeAt(saveDiv);\n                    var fileNameText = new dijitTextBox({\n                        value: filename,\n                        style: \"width: 24em\"\n                    }).placeAt(saveDiv);\n                }\n\n                aspect.after(exportView, 'hide', function () {\n                    // manually unhook and free the (possibly huge) text area\n                    text.parentNode.removeChild(text);\n                    text = null;\n                    setTimeout(function () {\n                        exportView.destroyRecursive();\n                    }, 500);\n                });\n                exportView.show();\n            });\n        },\n\n        _fileDownload: function _fileDownload(args) {\n            FileSaver.saveAs(new Blob([args.data], { type: args.format ? 'application/x-' + args.format.toLowerCase() : 'text/plain' }), args.filename);\n            // We will need to check whether this breaks the WebApollo plugin.\n        },\n\n        // cross-platform function for (portably) reading the value of a radio control. sigh. *rolls eyes*\n        _readRadio: function _readRadio(r) {\n            if (r.length) {\n                for (var i = 0; i < r.length; i++) {\n                    if (r[i].checked) return r[i].value;\n                }\n            }\n            return r.value;\n        },\n\n        exportRegion: function exportRegion(region, format, callback) {\n            // parse the locstring if necessary\n            if (typeof region == 'string') region = Util.parseLocString(region);\n\n            // we can only export from the currently-visible reference\n            // sequence right now\n            if (region.ref != this.refSeq.name) {\n                console.error(\"cannot export data for ref seq \" + region.ref + \", \" + \"exporting is currently only supported for the \" + \"currently-visible reference sequence\");\n                return;\n            }\n\n            dojo.global.require([format.match(/\\//) ? format : 'JBrowse/View/Export/' + format], dojo.hitch(this, function (exportDriver) {\n                new exportDriver({\n                    refSeq: this.refSeq,\n                    track: this,\n                    store: this.store\n                }).exportRegion(region, callback);\n            }));\n        },\n\n        _trackMenuOptions: function _trackMenuOptions() {\n            var opts = this.inherited(arguments);\n\n            if (!this.config.noExport)\n                // add a \"Save track data as\" option to the track menu\n                opts.push({ label: 'Save track data',\n                    iconClass: 'dijitIconSave',\n                    disabled: !this._canExport(),\n                    action: 'bareDialog',\n                    content: this._exportDialogContent,\n                    dialog: { id: 'exportDialog', className: 'export-dialog' }\n                });\n\n            return opts;\n        },\n\n        _canExportRegion: function _canExportRegion(l) {\n            //console.log('can generic export?');\n            if (!l) return false;\n\n            // if we have a maxExportSpan configured for this track, use it.\n            if (typeof this.config.maxExportSpan == 'number' || typeof this.config.maxExportSpan == 'string') {\n                return l.end - l.start + 1 <= this.config.maxExportSpan;\n            } else {\n                // if we know the store's feature density, then use that with\n                // a limit of maxExportFeatures or 5,000 features\n                var thisB = this;\n                var storeStats = {};\n                // will return immediately if the stats are available\n                this.store.getGlobalStats(function (s) {\n                    storeStats = s;\n                }, function (error) {}); // error callback does nothing for now\n                if (storeStats.featureDensity) {\n                    return storeStats.featureDensity * (l.end - l.start) <= (thisB.config.maxExportFeatures || 50000);\n                }\n            }\n\n            // otherwise, i guess we can export\n            return true;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_ExportMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_FeatureContextMenusMixin.js":
/*!*************************************************************!*\
  !*** ./src/JBrowse/View/Track/_FeatureContextMenusMixin.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang) {\n    return declare(null, {\n\n        _refreshContextMenu: function _refreshContextMenu(fRect) {\n            // if we already have a menu generated for this feature,\n            // give it a new lease on life\n            if (!fRect.contextMenu) {\n                fRect.contextMenu = this._makeFeatureContextMenu(fRect, this.getConfForFeature('menuTemplate', fRect.f));\n            }\n\n            // give the menu a timeout so that it's cleaned up if it's not used within a certain time\n            if (fRect.contextMenuTimeout) {\n                window.clearTimeout(fRect.contextMenuTimeout);\n            }\n            var timeToLive = 30000; // clean menus up after 30 seconds\n            fRect.contextMenuTimeout = window.setTimeout(function () {\n                if (fRect.contextMenu) {\n                    fRect.contextMenu.destroyRecursive();\n                    delete fRect.contextMenu;\n                }\n                delete fRect.contextMenuTimeout;\n            }, timeToLive);\n        },\n\n        /**\n         * Make the right-click dijit menu for a feature.\n         */\n        _makeFeatureContextMenu: function _makeFeatureContextMenu(fRect, menuTemplate) {\n            var context = lang.mixin({ track: this, feature: fRect.f, callbackArgs: [this, fRect.f, fRect] }, fRect);\n            // interpolate template strings in the menuTemplate\n            menuTemplate = this._processMenuSpec(dojo.clone(menuTemplate), context);\n\n            // render the menu, start it up, and bind it to right-clicks\n            // both on the feature div and on the label div\n            var menu = this._renderContextMenu(menuTemplate, context);\n            menu.startup();\n            return menu;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_FeatureContextMenusMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_FeatureDetailMixin.js":
/*!*******************************************************!*\
  !*** ./src/JBrowse/View/Track/_FeatureDetailMixin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Mixin with methods for parsing making default feature detail dialogs.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/FASTA */ \"./src/JBrowse/View/FASTA.js\"), __webpack_require__(/*! JBrowse/View/_FeatureDescriptionMixin */ \"./src/JBrowse/View/_FeatureDescriptionMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, aspect, on, domConstruct, Util, FASTAView, FeatureDescriptionMixin) {\n\n    return declare(FeatureDescriptionMixin, {\n\n        constructor: function constructor() {\n\n            // clean up the eventHandlers at destruction time if possible\n            if (typeof this.destroy == 'function') {\n                aspect.before(this, 'destroy', function () {\n                    delete this.eventHandlers;\n                });\n            }\n        },\n\n        _setupEventHandlers: function _setupEventHandlers() {\n            // make a default click event handler\n            var eventConf = dojo.clone(this.config.events || {});\n            if (!eventConf.click) {\n                eventConf.click = (this.config.style || {}).linkTemplate ? { action: \"newWindow\", url: this.config.style.linkTemplate } : { action: \"contentDialog\",\n                    title: '{type} {name}',\n                    content: dojo.hitch(this, 'defaultFeatureDetail') };\n            }\n\n            // process the configuration to set up our event handlers\n            this.eventHandlers = function () {\n                var handlers = dojo.clone(eventConf);\n                // find conf vars that set events, like `onClick`\n                for (var key in this.config) {\n                    var handlerName = key.replace(/^on(?=[A-Z])/, '');\n                    if (handlerName != key) handlers[handlerName.toLowerCase()] = this.config[key];\n                }\n                // interpret handlers that are just strings to be URLs that should be opened\n                for (key in handlers) {\n                    if (typeof handlers[key] == 'string') handlers[key] = { url: handlers[key] };\n                }\n                return handlers;\n            }.call(this);\n            this.eventHandlers.click = this._makeClickHandler(this.eventHandlers.click);\n        },\n\n        /**\n         * Make a default feature detail page for the given feature.\n         * @returns {HTMLElement} feature detail page HTML\n         */\n        defaultFeatureDetail: function defaultFeatureDetail( /** JBrowse.Track */track, /** Object */f, /** HTMLElement */featDiv, /** HTMLElement */container, layer) {\n            container = container || dojo.create('div', { className: 'detail feature-detail feature-detail-' + track.name.replace(/\\s+/g, '_').toLowerCase(), innerHTML: '' });\n\n            this._renderCoreDetails(track, f, featDiv, container);\n\n            this._renderAdditionalTagsDetail(track, f, featDiv, container);\n\n            if (!this.config.hideSequenceBox) {\n                this._renderUnderlyingReferenceSequence(track, f, featDiv, container);\n            }\n\n            this._renderSubfeaturesDetail(track, f, featDiv, container, layer || 1);\n\n            // hook function extendedRender(track,f,featDiv,container)\n            if (typeof this.extendedRender === 'function') {\n                this.extendedRender(track, f, featDiv, container);\n            }\n\n            return container;\n        },\n\n        _renderCoreDetails: function _renderCoreDetails(track, f, featDiv, container) {\n            var coreDetails = dojo.create('div', { className: 'core' }, container);\n            var fmt = dojo.hitch(this, 'renderDetailField', coreDetails);\n            coreDetails.innerHTML += '<h2 class=\"sectiontitle\">Primary Data</h2>';\n\n            fmt('Name', this.getFeatureLabel(f), f);\n            fmt('Type', f.get('type'), f);\n            fmt('Score', f.get('score'), f);\n            fmt('Description', this.getFeatureDescription(f), f);\n            fmt('Position', Util.assembleLocString({ start: f.get('start'),\n                end: f.get('end'),\n                ref: this.refSeq.name,\n                strand: f.get('strand')\n            }), f);\n            fmt('Length', Util.addCommas(f.get('end') - f.get('start')) + ' bp', f);\n        },\n\n        // render any subfeatures this feature has\n        _renderSubfeaturesDetail: function _renderSubfeaturesDetail(track, f, featDiv, container, layer) {\n            var thisB = this;\n            var subfeatures = f.get('subfeatures');\n            if (subfeatures && subfeatures.length) {\n                if (f.get('strand') == -1) {\n                    // Feature is on the oposite strand, lets reverse the order of the subfeatures according to their start position\n                    subfeatures.sort(function (a, b) {\n                        return b.get('start') - a.get('start');\n                    });\n                }\n                if (!(track.config.subfeatureDetailLevel != null) || layer < track.config.subfeatureDetailLevel) {\n                    this._subfeaturesDetail(track, subfeatures, container, f, layer + 1);\n                } else if (layer >= track.config.subfeatureDetailLevel) {\n                    var b = domConstruct.create('button', {\n                        className: 'subfeature-load-button',\n                        innerHTML: 'Show subfeatures...'\n                    }, container);\n                    on(b, 'click', function () {\n                        thisB._subfeaturesDetail(track, subfeatures, container, f, layer + 1);\n                        dojo.destroy(b);\n                    });\n                }\n            }\n        },\n\n        _isReservedTag: function _isReservedTag(t) {\n            return { name: 1, start: 1, end: 1, strand: 1, note: 1, subfeatures: 1, type: 1, score: 1 }[t.toLowerCase()];\n        },\n\n        // render any additional tags as just key/value\n        _renderAdditionalTagsDetail: function _renderAdditionalTagsDetail(track, f, featDiv, container) {\n            var _this = this;\n\n            var thisB = this;\n            var additionalTags = array.filter(f.tags(), function (t) {\n                if (thisB.config.showNoteInAttributes && t.toLowerCase() == 'note') {\n                    return true;\n                }\n                return !this._isReservedTag(t);\n            }, this);\n\n            if (additionalTags.length) {\n                var atElement = domConstruct.create('div', { className: 'additional',\n                    innerHTML: '<h2 class=\"sectiontitle\">Attributes</h2>'\n                }, container);\n                additionalTags.sort().forEach(function (t) {\n                    _this.renderDetailField(atElement, t, f.get(t), f, undefined, track.store.getTagMetadata(t));\n                });\n            }\n        },\n\n        _renderUnderlyingReferenceSequence: function _renderUnderlyingReferenceSequence(track, f, featDiv, container) {\n\n            // render the sequence underlying this feature if possible\n            var field_container = dojo.create('div', { className: 'field_container feature_sequence' }, container);\n            dojo.create('h2', { className: 'field feature_sequence', innerHTML: 'Region sequence', title: 'reference sequence underlying this ' + (f.get('type') || 'feature') }, field_container);\n            var valueContainerID = 'feature_sequence' + this._uniqID();\n            var valueContainer = dojo.create('div', {\n                id: valueContainerID,\n                innerHTML: '<div style=\"height: 12em\">Loading...</div>',\n                className: 'value feature_sequence'\n            }, field_container);\n            var maxSize = this.config.maxFeatureSizeForUnderlyingRefSeq;\n            if (maxSize < f.get('end') - f.get('start')) {\n                valueContainer.innerHTML = 'Not displaying underlying reference sequence, feature is longer than maximum of ' + Util.humanReadableNumber(maxSize) + 'bp';\n            } else {\n                track.browser.getStore('refseqs', dojo.hitch(this, function (refSeqStore) {\n                    valueContainer = dojo.byId(valueContainerID) || valueContainer;\n                    if (refSeqStore) {\n                        refSeqStore.getReferenceSequence({ ref: this.refSeq.name, start: f.get('start'), end: f.get('end') },\n                        // feature callback\n                        dojo.hitch(this, function (seq) {\n                            valueContainer = dojo.byId(valueContainerID) || valueContainer;\n                            valueContainer.innerHTML = '';\n                            // the HTML is rewritten by the dojo dialog\n                            // parser, but this callback may be called either\n                            // before or after that happens.  if the fetch by\n                            // ID fails, we have come back before the parse.\n                            var textArea = new FASTAView({ track: this, width: 62, htmlMaxRows: 10 }).renderHTML({ ref: this.refSeq.name,\n                                start: f.get('start'),\n                                end: f.get('end'),\n                                strand: f.get('strand'),\n                                type: f.get('type')\n                            }, f.get('strand') == -1 ? Util.revcom(seq) : seq, valueContainer);\n                        }),\n                        // end callback\n                        function () {},\n                        // error callback\n                        dojo.hitch(this, function () {\n                            valueContainer = dojo.byId(valueContainerID) || valueContainer;\n                            valueContainer.innerHTML = '<span class=\"ghosted\">reference sequence not available</span>';\n                        }));\n                    } else {\n                        valueContainer.innerHTML = '<span class=\"ghosted\">reference sequence not available</span>';\n                    }\n                }));\n            }\n        },\n\n        _uniqID: function _uniqID() {\n            this._idCounter = this._idCounter || 0;\n            return this._idCounter++;\n        },\n\n        _subfeaturesDetail: function _subfeaturesDetail(track, subfeatures, container, f, layer) {\n            var field_container = dojo.create('div', { className: 'field_container subfeatures' }, container);\n            dojo.create('h2', { className: 'field subfeatures', innerHTML: 'Subfeatures' }, field_container);\n            var subfeaturesContainer = dojo.create('div', { className: 'value subfeatures' }, field_container);\n\n            array.forEach(subfeatures || [], function (subfeature) {\n                this.defaultFeatureDetail(track, subfeature, null, dojo.create('div', {\n                    className: 'detail feature-detail subfeature-detail feature-detail-' + track.name + ' subfeature-detail-' + track.name,\n                    innerHTML: ''\n                }, subfeaturesContainer), layer);\n            }, this);\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_FeatureDetailMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js":
/*!*************************************************************!*\
  !*** ./src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/when */ \"./node_modules/dojo/when.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, when) {\n    return declare(null, {\n        constructor: function constructor() {\n            this._initializeConfiguredFeatureFilters();\n        },\n\n        _initializeConfiguredFeatureFilters: function _initializeConfiguredFeatureFilters() {\n            // initialize toggling feature filters\n            var thisB = this;\n            return when(this._getNamedFeatureFilters()).then(function (filters) {\n                for (var filtername in filters) {\n                    if (thisB.config[filtername]) thisB.addFeatureFilter(filters[filtername].func, filtername);else thisB.removeFeatureFilter(filtername);\n                }\n            });\n        },\n\n        _toggleFeatureFilter: function _toggleFeatureFilter(filtername, setActive) {\n            // if no setActive, we will toggle it\n            if (setActive === undefined) setActive = !this.config[filtername];\n\n            // nothing to do if not changed\n            if (!!setActive === !!this.config[filtername]) return;\n\n            this.config[filtername] = setActive;\n\n            var thisB = this;\n            when(this._getNamedFeatureFilters(), function (filters) {\n                if (setActive) thisB.addFeatureFilter(filters[filtername].func, filtername);else thisB.removeFeatureFilter(filtername);\n\n                thisB.changed();\n            });\n        },\n\n        _getNamedFeatureFilters: function _getNamedFeatureFilters() {\n            return {};\n            // return lang.mixin(\n            //     {},\n            //     this.inherited(arguments),\n            //     {\n\n            //     });\n        },\n\n        _makeFeatureFilterTrackMenuItems: function _makeFeatureFilterTrackMenuItems(names, filters) {\n            var thisB = this;\n            return when(filters || this._getNamedFeatureFilters()).then(function (filters) {\n                return array.map(names, function (name) {\n                    return thisB._makeFeatureFilterTrackMenuItem(name, filters[name]);\n                });\n            });\n        },\n\n        _makeFeatureFilterTrackMenuItem: function _makeFeatureFilterTrackMenuItem(filtername, filterspec) {\n            var thisB = this;\n            if (filtername == 'SEPARATOR') return { type: 'dijit/MenuSeparator' };\n            return { label: filterspec.desc,\n                title: filterspec.title,\n                type: 'dijit/CheckedMenuItem',\n                checked: !!thisB.config[filtername],\n                onClick: function onClick(event) {\n                    thisB._toggleFeatureFilter(filtername, this.checked);\n                }\n            };\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_TrackDetailsStatsMixin.js":
/*!***********************************************************!*\
  !*** ./src/JBrowse/View/Track/_TrackDetailsStatsMixin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, Deferred) {\n\n    return declare(null, {\n\n        _trackDetailsContent: function _trackDetailsContent() {\n            var thisB = this;\n            var d = new Deferred();\n            var args = arguments;\n            // this.store.getRegionStats(\n            //     { ref: this.refSeq.name, start: this.refSeq.start, end: this.refSeq.end },\n            this.store.getGlobalStats(function (stats) {\n                d.resolve(thisB.inherited(args, [{ \"Stats (current reference sequence)\": stats }]));\n            }, lang.hitch(d, 'reject'));\n            return d;\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_TrackDetailsStatsMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_VariantDetailMixin.js":
/*!*******************************************************!*\
  !*** ./src/JBrowse/View/Track/_VariantDetailMixin.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Mixin to provide a `defaultFeatureDetail` method that is optimized\n * for displaying variant data from VCF files.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! JBrowse/View/Track/_FeatureDetailMixin */ \"./src/JBrowse/View/Track/_FeatureDetailMixin.js\"), __webpack_require__(/*! JBrowse/View/Track/_NamedFeatureFiltersMixin */ \"./src/JBrowse/View/Track/_NamedFeatureFiltersMixin.js\"), __webpack_require__(/*! JBrowse/Model/NestedFrequencyTable */ \"./src/JBrowse/Model/NestedFrequencyTable.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, domConstruct, all, Util, FeatureDetailMixin, NamedFeatureFiltersMixin, NestedFrequencyTable) {\n\n    return declare([FeatureDetailMixin, NamedFeatureFiltersMixin], {\n\n        defaultFeatureDetail: function defaultFeatureDetail( /** JBrowse.Track */track, /** Object */f, /** HTMLElement */featDiv, /** HTMLElement */container) {\n            container = container || domConstruct.create('div', { className: 'detail feature-detail feature-detail-' + track.name, innerHTML: '' });\n\n            this._renderCoreDetails(track, f, featDiv, container);\n\n            this._renderAdditionalTagsDetail(track, f, featDiv, container);\n\n            // genotypes in a separate section\n            this._renderGenotypes(container, track, f, featDiv);\n\n            return container;\n        },\n        renderDetailValue: function renderDetailValue(parent, title, val, f, class_) {\n            if (title == \"alternative_alleles\") {\n                val = val.join(',');\n            }\n            return this.inherited(arguments, [parent, title, val, f, class_]);\n        },\n        _isReservedTag: function _isReservedTag(t) {\n            return this.inherited(arguments) || { genotypes: 1 }[t.toLowerCase()];\n        },\n\n        _renderGenotypes: function _renderGenotypes(parentElement, track, f) {\n            var thisB = this;\n            var genotypes = f.get('genotypes');\n            if (!genotypes) return;\n\n            var keys = Util.dojof.keys(genotypes).sort();\n            var gCount = keys.length;\n            if (!gCount) return;\n\n            var alt = (f.get('alternative_alleles') || {}).values;\n\n            var gContainer = domConstruct.create('div', {\n                className: 'genotypes',\n                innerHTML: '<h2 class=\"sectiontitle\">Genotypes (' + gCount + ')</h2>'\n            }, parentElement);\n\n            function render(underlyingRefSeq) {\n                thisB._renderGenotypeSummary(gContainer, genotypes, alt);\n\n                var valueContainer = domConstruct.create('div', { className: 'value_container genotypes' }, gContainer);\n\n                thisB.renderDetailValueGrid(valueContainer, 'Genotypes', f,\n                // iterator\n                function () {\n                    if (!keys.length) return null;\n                    var k = keys.shift();\n                    var value = genotypes[k];\n                    var item = { id: k };\n                    for (var field in value) {\n                        item[field] = field === 'GT' ? thisB._mungeGenotypeVal(value[field].values, alt, underlyingRefSeq) : genotypes[k][field];\n                    }\n                    return item;\n                }, {\n                    descriptions: function () {\n                        if (!keys.length) return {};\n\n                        var subValue = genotypes[keys[0]];\n                        var descriptions = {};\n                        for (var k in subValue) {\n                            descriptions[k] = f.parser.getMetadata('FORMAT', k, 'Description') || null;\n                        }\n                        return descriptions;\n                    }(),\n                    renderCell: {\n                        \"GT\": function GT(field, value, node, options) {\n                            thisB.renderDetailValue(node, '', value, f, '');\n                        }\n                    }\n                });\n            };\n\n            track.browser.getStore('refseqs', function (refSeqStore) {\n                if (refSeqStore) {\n                    refSeqStore.getReferenceSequence({ ref: track.refSeq.name,\n                        start: f.get('start'),\n                        end: f.get('end')\n                    }, render, function () {\n                        render();\n                    });\n                } else {\n                    render();\n                }\n            });\n        },\n\n        _mungeGenotypeVal: function _mungeGenotypeVal(values, alt, underlyingRefSeq) {\n            // handle the GT field specially, translating the genotype indexes into the actual ALT strings\n            var value_parse = void 0;\n            if (values == null) value_parse = '.';else value_parse = values[0];\n\n            var splitter = (value_parse.match(/[\\|\\/]/g) || [])[0]; // only accept | and / splitters since . can mean no call\n            var refseq = underlyingRefSeq ? 'ref (' + underlyingRefSeq + ')' : 'ref';\n            values = array.map(splitter ? value_parse.split(splitter) : value_parse, function (gtIndex) {\n                gtIndex = parseInt(gtIndex) || gtIndex;\n                if (gtIndex == '.') {\n                    return 'no-call';\n                } else if (gtIndex == 0) {\n                    return refseq;\n                } else return alt ? alt[gtIndex - 1] : gtIndex;\n            }).join(' ' + splitter + ' ');\n            return values;\n        },\n\n        _renderGenotypeSummary: function _renderGenotypeSummary(parentElement, genotypes, alt) {\n            if (!genotypes) return;\n\n            var counts = new NestedFrequencyTable();\n            for (var gname in genotypes) {\n                if (genotypes.hasOwnProperty(gname)) {\n                    // increment the appropriate count\n                    var gtVals = (genotypes[gname].GT || {}).values;\n                    if (gtVals == null) gtVals = ['.'];\n                    var gt = gtVals[0].split(/\\||\\//);\n                    if (lang.isArray(gt)) {\n                        // if all zero, non-variant/hom-ref\n                        if (array.every(gt, function (g) {\n                            return parseInt(g) == 0;\n                        })) {\n                            counts.getNested('non-variant').increment('homozygous for reference');\n                        } else if (array.every(gt, function (g) {\n                            return g == '.';\n                        })) {\n                            counts.getNested('non-variant').increment('no call');\n                        } else if (array.every(gt, function (g) {\n                            return g == gt[0];\n                        })) {\n                            if (alt) counts.getNested('variant/homozygous').increment(alt[parseInt(gt[0]) - 1] + ' variant');else counts.getNested('variant').increment('homozygous');\n                        } else {\n                            counts.getNested('variant').increment('heterozygous');\n                        }\n                    }\n                }\n            }\n\n            var total = counts.total();\n            if (!total) return;\n\n            var valueContainer = domConstruct.create('div', { className: 'value_container big genotype_summary' }, parentElement);\n            //domConstruct.create('h3', { innerHTML: 'Summary' }, valueContainer);\n\n            var tableElement = domConstruct.create('table', {}, valueContainer);\n\n            function renderFreqTable(table, level) {\n                table.forEach(function (count, categoryName) {\n                    var tr = domConstruct.create('tr', {}, tableElement);\n                    domConstruct.create('td', { className: 'category level_' + level, innerHTML: categoryName }, tr);\n                    if ((typeof count === 'undefined' ? 'undefined' : _typeof(count)) == 'object') {\n                        var thisTotal = count.total();\n                        domConstruct.create('td', { className: 'count level_' + level, innerHTML: thisTotal }, tr);\n                        domConstruct.create('td', { className: 'pct level_' + level, innerHTML: Math.round(thisTotal / total * 10000) / 100 + '%' }, tr);\n                        renderFreqTable(count, level + 1);\n                    } else {\n                        domConstruct.create('td', { className: 'count level_' + level, innerHTML: count }, tr);\n                        domConstruct.create('td', { className: 'pct level_' + level, innerHTML: Math.round(count / total * 10000) / 100 + '%' }, tr);\n                    }\n                });\n            }\n\n            renderFreqTable(counts, 0);\n\n            var totalTR = domConstruct.create('tr', {}, tableElement);\n            domConstruct.create('td', { className: 'category total', innerHTML: 'Total' }, totalTR);\n            domConstruct.create('td', { className: 'count total', innerHTML: total }, totalTR);\n            domConstruct.create('td', { className: 'pct total', innerHTML: '100%' }, totalTR);\n        },\n\n        // filters for VCF sites\n        _getNamedFeatureFilters: function _getNamedFeatureFilters() {\n            var thisB = this;\n            return all([this.store.getParser().then(function (parser) {\n                return parser.getMetadata();\n            }), this.inherited(arguments)]).then(function (results) {\n                if (results[0]) return thisB._makeVCFFilters.apply(thisB, results);else return results[1];\n            });\n        },\n\n        // given VCF metadata, make some appropriate named feature\n        // filters to filter its data\n        _makeVCFFilters: function _makeVCFFilters(vcfMetadata, inheritedFilters) {\n            // wraps the callback to return true if there\n            // is no filter attr\n            function makeFilterFilter(condition) {\n                return function (f) {\n                    f = f.get('filter');\n                    return !f || condition(f);\n                };\n            }\n            var filters = lang.mixin({}, inheritedFilters, {\n                hideFilterPass: {\n                    desc: 'Hide sites passing all filters',\n                    func: makeFilterFilter(function (filter) {\n                        try {\n                            return filter.values.join('').toUpperCase() != 'PASS';\n                        } catch (e) {\n                            return filter.toUpperCase() != 'PASS';\n                        }\n                    })\n                },\n                hideNotFilterPass: {\n                    desc: 'Hide sites not passing all filters',\n                    func: makeFilterFilter(function (f) {\n                        try {\n                            return f.values.join('').toUpperCase() == 'PASS';\n                        } catch (e) {\n                            return f.toUpperCase() != 'PASS';\n                        }\n                    })\n                }\n            });\n            if (vcfMetadata.FILTER) {\n                for (var filterName in vcfMetadata.FILTER) {\n                    filters[filterName] = function (filterName, filterSpec) {\n                        return {\n                            desc: 'Hide sites not passing filter \"' + filterName + '\"',\n                            title: filterName + ': ' + filterSpec.description,\n                            func: makeFilterFilter(function (f) {\n                                var fs = f.values || f;\n                                if (!fs[0]) return true;\n\n                                return !array.some(fs, function (fname) {\n                                    return fname == filterName;\n                                });\n                            })\n                        };\n                    }.call(this, filterName, vcfMetadata.FILTER[filterName]);\n                }\n            }\n            return filters;\n        },\n\n        _variantsFilterTrackMenuOptions: function _variantsFilterTrackMenuOptions() {\n            // add toggles for feature filters\n            var track = this;\n            return this._getNamedFeatureFilters().then(function (filters) {\n\n                // merge our builtin filters with additional ones\n                // that might have been generated in\n                // _getNamedFeatureFilters() based on e.g. the VCF\n                // header\n                var menuItems = ['hideFilterPass', 'hideNotFilterPass', 'SEPARATOR'];\n                var withAdditional = Util.uniq(menuItems.concat(Util.dojof.keys(filters)));\n                if (withAdditional.length > menuItems.length) menuItems = withAdditional;else menuItems.pop(); //< pop off the separator since we have no additional ones\n\n                return track._makeFeatureFilterTrackMenuItems(menuItems, filters);\n            });\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_VariantDetailMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/Track/_YScaleMixin.js":
/*!************************************************!*\
  !*** ./src/JBrowse/View/Track/_YScaleMixin.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! JBrowse/View/Ruler */ \"./src/JBrowse/View/Ruler.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, query, Ruler) {\n    /**\n     * Mixin for a track that has a Y-axis scale bar on its left side.\n     * Puts the scale div in <code>this.yscale</code>, stores the 'left' CSS pixel\n     * offset in <code>this.yscale_left</code>.\n     * @lends JBrowse.View.Track.YScaleMixin\n     */\n\n    return declare(null, {\n        /**\n         * @param {Number} [min] Optional minimum value for the scale.\n         * Defaults to value of <code>this.minDisplayed</code>.\n         * @param {Number} [max] Optional maximum value for the scale.\n         * Defaults to value of <code>this.maxDisplayed</code>.\n         */\n        makeYScale: function makeYScale(args) {\n            args = args || {};\n            var min = typeof args.min == 'number' ? args.min : this.minDisplayed;\n            var max = typeof args.max == 'number' ? args.max : this.maxDisplayed;\n\n            // make and style the main container div for the axis\n            if (this.yscale) {\n                this.yscale.parentNode.removeChild(this.yscale);\n            }\n            var rulerdiv = dojo.create('div', {\n                className: 'ruler vertical_ruler',\n                style: {\n                    height: this.height + 'px',\n                    width: '10px',\n                    position: 'absolute',\n                    zIndex: 17\n                }\n            }, this.div);\n            this.yscale = rulerdiv;\n\n            if (this.window_info && 'x' in this.window_info) {\n                if ('yScalePosition' in this.config) {\n                    if (this.config.yScalePosition == 'right') {\n                        this.yscale.style.left = this.window_info.x + (this.window_info.width - 1 || 0) + \"px\";\n                    } else if (this.config.yScalePosition == 'left') {\n                        this.yscale.style.left = this.window_info.x + 10 + 1 + \"px\";\n                    } else if (this.config.yScalePosition == 'center') {\n                        this.yscale.style.left = this.window_info.x + (this.window_info.width || 0) / 2 + \"px\";\n                    }\n                } else {\n                    this.yscale.style.left = this.window_info.x + (this.window_info.width || 0) / 2 + \"px\";\n                }\n            }\n\n            dojo.style(rulerdiv, this.config.align == 'top' ? { bottom: 0 } : { top: 0 });\n\n            // now make a Ruler and draw the axis in the div we just made\n            var ruler = new Ruler({\n                min: min,\n                max: max,\n                direction: 'up',\n                leftBottom: !('yScalePosition' in this.config && this.config.yScalePosition == 'left'),\n                fixBounds: args.fixBounds || false\n            });\n            ruler.render_to(rulerdiv);\n\n            this.ruler = ruler;\n        },\n\n        /**\n         * Delete the Y-axis scale if present.\n         * @private\n         */\n        removeYScale: function removeYScale() {\n            if (!this.yscale) {\n                query('.ruler', this.div).orphan();\n                return;\n            }\n            if (this.yscale) {\n                this.yscale.parentNode.removeChild(this.yscale);\n                delete this.yscale;\n            }\n            delete this.yscale_params;\n        },\n\n        updateYScaleFromViewDimensions: function updateYScaleFromViewDimensions(coords) {\n            if (typeof coords.x == 'number' || typeof coords.width == 'number') {\n                if (this.yscale) {\n                    if ('yScalePosition' in this.config) {\n                        if (this.config.yScalePosition == 'right') {\n                            this.yscale.style.left = this.window_info.x + (this.window_info.width - 1 || 0) + \"px\";\n                        } else if (this.config.yScalePosition == 'left') {\n                            this.yscale.style.left = this.window_info.x + 10 + \"px\";\n                        } else if (this.config.yScalePosition == 'center') {\n                            this.yscale.style.left = this.window_info.x + (this.window_info.width || 0) / 2 + \"px\";\n                        }\n                    } else {\n                        this.yscale.style.left = this.window_info.x + (this.window_info.width || 0) / 2 + \"px\";\n                    }\n                }\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/Track/_YScaleMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/TrackConfigEditor.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/View/TrackConfigEditor.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Pops up a dialog to edit the configuration of a single track.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dijit/Dialog */ \"./node_modules/dijit/Dialog.js\"), __webpack_require__(/*! dijit/form/Button */ \"./node_modules/dijit/form/Button.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, aspect, JSON, on, dom, Dialog, Button) {\n\n    return declare(null, {\n\n        constructor: function constructor(trackConfig) {\n            this.trackConfig = trackConfig;\n        },\n\n        _makeActionBar: function _makeActionBar(editCallback, cancelCallback) {\n            var actionBar = dom.create('div', {\n                className: 'dijitDialogPaneActionBar'\n            });\n\n            new Button({ iconClass: 'dijitIconDelete', label: 'Cancel',\n                onClick: dojo.hitch(this, function () {\n                    cancelCallback && cancelCallback();\n                    this.dialog.hide();\n                })\n            }).placeAt(actionBar);\n            this.applyButton = new Button({\n                iconClass: 'dijitIconEdit',\n                label: 'Apply',\n                onClick: dojo.hitch(this, function () {\n                    if (this.newConfig) {\n                        editCallback && editCallback({\n                            conf: this.newConfig\n                        });\n                    } else {\n                        cancelCallback && cancelCallback();\n                    }\n                    this.dialog.hide();\n                })\n            });\n            this.applyButton.placeAt(actionBar);\n\n            return { domNode: actionBar };\n        },\n\n        show: function show(editCallback, cancelCallback) {\n            var dialog = this.dialog = new Dialog({ title: \"Edit track configuration\", className: 'trackConfigEditor' });\n\n            var content = [this._makeEditControls().domNode, this._makeActionBar(editCallback, cancelCallback).domNode];\n            dialog.set('content', content);\n            dialog.show();\n\n            aspect.after(dialog, 'hide', dojo.hitch(this, function () {\n                setTimeout(function () {\n                    dialog.destroyRecursive();\n                }, 500);\n            }));\n        },\n\n        _makeEditControls: function _makeEditControls() {\n            var realChange = dojo.hitch(this, function () {\n                this.newConfig = this._parseNewConfig(textArea.value);\n            });\n\n            var container = dom.create('div', { className: 'editControls' });\n\n            var confString = this._stringifyConfig(this.trackConfig);\n            var textArea = dom.create('textarea', {\n                rows: Math.min((confString || '').match(/\\n/g).length + 4, 20),\n                cols: 70,\n                value: confString,\n                spellcheck: false,\n                onchange: realChange\n            }, container);\n            // watch the input text for changes.  just do it every 700ms\n            // because there are many ways that text can get changed (like\n            // pasting), not all of which fire the same events.  not using\n            // the onchange event, because that doesn't fire until the\n            // textarea loses focus.\n            var previousText = '';\n            var checkFrequency = 700;\n            var that = this;\n            var checkForChange = function checkForChange() {\n                if (that.dialog.get('open')) {\n                    if (textArea.value != previousText) {\n                        realChange();\n                        previousText = textArea.value;\n                    }\n                    // TODO: do not renew this timeout if the dialog is destroyed\n                    window.setTimeout(checkForChange, checkFrequency);\n                }\n            };\n            window.setTimeout(checkForChange, checkFrequency);\n\n            var errorArea = dom.create('div', { className: 'errors' }, container);\n            this.errorReportArea = errorArea;\n\n            return { domNode: container };\n        },\n\n        _stringifyConfig: function _stringifyConfig(config) {\n\n            // don't let people edit the store configuration, just the\n            // track configuration.  make a shallow copy and delete the\n            // store conf.  will add back in later.\n            var c = dojo.mixin({}, config); // shallow copy\n            delete c.store;\n\n            // put a style in there if there isn't already one, for convenience\n            if (!c.style) c.style = {};\n            if (!c.metadata) c.metadata = {};\n\n            return JSON.stringify(c, undefined, 2);\n        },\n\n        _reportError: function _reportError(error) {\n            this.errorReportArea.innerHTML = '<div class=\"error\">' + error + '</div>';\n            this.applyButton.set('disabled', true);\n        },\n        _clearErrors: function _clearErrors() {\n            dom.empty(this.errorReportArea);\n            this.applyButton.set('disabled', false);\n        },\n\n        _parseNewConfig: function _parseNewConfig(conf) {\n            var newconf;\n            try {\n                newconf = JSON.parse(conf, true);\n                this._clearErrors();\n            } catch (e) {\n                this._reportError(e);\n            }\n            if (newconf) newconf.store = this.trackConfig.store;\n            return newconf;\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/TrackConfigEditor.js?");

/***/ }),

/***/ "./src/JBrowse/View/TrackList/Faceted.js":
/*!***********************************************!*\
  !*** ./src/JBrowse/View/TrackList/Faceted.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojo/promise/all */ \"./node_modules/dojo/promise/all.js\"), __webpack_require__(/*! dijit/TitlePane */ \"./node_modules/dijit/TitlePane.js\"), __webpack_require__(/*! dijit/layout/ContentPane */ \"./node_modules/dijit/layout/ContentPane.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! dojox/grid/EnhancedGrid */ \"./node_modules/dojox/grid/EnhancedGrid.js\"), __webpack_require__(/*! dojox/grid/enhanced/plugins/IndirectSelection */ \"./node_modules/dojox/grid/enhanced/plugins/IndirectSelection.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, Deferred, all, TitlePane, ContentPane, Util, EnhancedGrid) {\n\n    var dojof = Util.dojof;\n    return declare('JBrowse.View.TrackList.Faceted', null,\n    /**\n     * @lends JBrowse.View.TrackList.Faceted.prototype\n     */\n    {\n\n        /**\n          * Track selector with facets and text searching.\n          * @constructs\n          */\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n            this.tracksActive = {};\n            this.config = args;\n\n            this.storeReady = new Deferred();\n            this.gridReady = new Deferred();\n            this.ready = all([this.storeReady, this.gridReady]);\n\n            // construct the discriminator for whether we will display a\n            // facet selector for this facet\n            this._isSelectableFacet = this._coerceFilter(args.selectableFacetFilter\n            // default facet filtering function\n            || function (facetName, store) {\n                return (\n                    // has an avg bucket size > 1\n                    store.getFacetStats(facetName).avgBucketSize > 1 &&\n                    // and not an ident or label attribute\n                    !array.some(store.getLabelAttributes().concat(store.getIdentityAttributes()), function (l) {\n                        return l == facetName;\n                    })\n                );\n            });\n\n            // construct a similar discriminator for which columns will be displayed\n            this.displayColumns = args.displayColumns;\n            this._isDisplayableColumn = this._coerceFilter(args.displayColumnFilter || function (l) {\n                return l.toLowerCase() != 'label';\n            });\n\n            // data store that fetches and filters our track metadata\n            this.trackDataStore = args.trackMetaData;\n\n            // subscribe to commands coming from the the controller\n            this.browser.subscribe('/jbrowse/v1/c/tracks/show', lang.hitch(this, 'setTracksActive'));\n            // subscribe to commands coming from the the controller\n            this.browser.subscribe('/jbrowse/v1/c/tracks/hide', lang.hitch(this, 'setTracksInactive'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/delete', lang.hitch(this, 'setTracksInactive'));\n\n            this.renderInitial();\n\n            // once its data is loaded and ready\n            this.trackDataStore.onReady(this, function () {\n                var _this = this;\n\n                // render our controls and so forth\n                this.renderSelectors();\n\n                // connect events so that when a grid row is selected or\n                // deselected (with the checkbox), publish a message\n                // indicating that the user wants that track turned on or\n                // off\n                dojo.connect(this.dataGrid.selection, 'onSelected', this, function (index) {\n                    this._ifNotSuppressed('selectionEvents', function () {\n                        this._suppress('gridUpdate', function () {\n                            this.browser.publish('/jbrowse/v1/v/tracks/show', [this.dataGrid.getItem(index).conf]);\n                        });\n                    });\n                });\n                dojo.connect(this.dataGrid.selection, 'onDeselected', this, function (index) {\n                    this._ifNotSuppressed('selectionEvents', function () {\n                        this._suppress('gridUpdate', function () {\n                            this.browser.publish('/jbrowse/v1/v/tracks/hide', [this.dataGrid.getItem(index).conf]);\n                        });\n                    });\n                });\n\n                this._updateFacetCounts();\n                this._updateMatchCount();\n                this.storeReady.resolve();\n\n                dojo.connect(this.trackDataStore, 'onFetchSuccess', this, function () {\n                    _this._updateGridSelections();\n                    _this._updateMatchCount();\n                });\n            });\n        },\n\n        /**\n         * Coerces a string or array of strings into a function that,\n         * given a string, returns true if the string matches one of the\n         * given strings.  If passed a function, just returns that\n         * function.\n         * @private\n         */\n        _coerceFilter: function _coerceFilter(_filter) {\n            // if we have a non-function filter, coerce to an array,\n            // then convert that array to a function\n            if (typeof _filter == 'string') _filter = [_filter];\n            if (dojo.isArray(_filter)) {\n                _filter = function filter(store, facetName) {\n                    return array.some(_filter, function (fn) {\n                        return facetName == fn;\n                    });\n                };\n            }\n            return _filter;\n        },\n\n        /**\n         * Call the given callback if none of the given event suppression flags are set.\n         * @private\n         */\n        _ifNotSuppressed: function _ifNotSuppressed(suppressFlags, callback) {\n            if (typeof suppressFlags == 'string') suppressFlags = [suppressFlags];\n            if (!this.suppress) this.suppress = {};\n            if (array.some(suppressFlags, function (f) {\n                return this.suppress[f];\n            }, this)) return undefined;\n            return callback.call(this);\n        },\n\n        /**\n         * Call the given callback while setting the given event suppression flags.\n         * @private\n         */\n        _suppress: function _suppress(suppressFlags, callback) {\n            if (typeof suppressFlags == 'string') suppressFlags = [suppressFlags];\n            if (!this.suppress) this.suppress = {};\n            dojo.forEach(suppressFlags, function (f) {\n                this.suppress[f] = true;\n            }, this);\n            var retval = callback.call(this);\n            dojo.forEach(suppressFlags, function (f) {\n                this.suppress[f] = false;\n            }, this);\n            return retval;\n        },\n\n        _suppressAsync: function _suppressAsync(suppressFlags, callback) {\n            var _this2 = this;\n\n            if (typeof suppressFlags == 'string') suppressFlags = [suppressFlags];\n            if (!this.suppress) this.suppress = {};\n            dojo.forEach(suppressFlags, function (f) {\n                this.suppress[f] = true;\n            }, this);\n            return callback.call(this).then(function (retval) {\n                suppressFlags.forEach(function (f) {\n                    return _this2.suppress[f] = false;\n                });\n                return retval;\n            }, function (err) {\n                suppressFlags.forEach(function (f) {\n                    return _this2.suppress[f] = false;\n                });\n                console.error(err);\n            });\n        },\n\n        /**\n         * Call a method of our object such that it cannot call itself\n         * by way of event cycles.\n         * @private\n         */\n        _suppressRecursion: function _suppressRecursion(methodName) {\n            var flag = ['method_' + methodName];\n            var method = this[methodName];\n            return this._ifNotSuppressed(flag, function () {\n                this._suppress(flag, method);\n            });\n        },\n\n        renderInitial: function renderInitial() {\n            this.containerElem = dojo.create('div', {\n                id: 'faceted_tracksel',\n                className: 'jbrowse',\n                style: {\n                    left: '-95%',\n                    width: '95%',\n                    zIndex: 500\n                }\n            }, document.body);\n\n            // make the tab that turns the selector on and off\n            dojo.create('div', {\n                className: 'faceted_tracksel_on_off tab',\n                innerHTML: '<img src=\"' + this.browser.resolveUrl('img/left_arrow.png') + '\"><div>Select<br>tracks</div>'\n            }, this.containerElem);\n            this.mainContainer = new dijit.layout.BorderContainer({ design: 'headline', gutters: false }, dojo.create('div', { className: 'mainContainer' }, this.containerElem));\n\n            this.topPane = new dijit.layout.ContentPane({ region: 'top',\n                id: \"faceted_tracksel_top\",\n                content: '<div class=\"title\">Select Tracks</div> ' + '<div class=\"topLink\" style=\"cursor: help\"><a title=\"Track selector help\">Help</a></div>'\n            });\n            dojo.query('div.topLink a[title=\"Track selector help\"]', this.topPane.domNode).forEach(function (helplink) {\n                var helpdialog = new dijit.Dialog({\n                    \"class\": 'jbrowse help_dialog',\n                    refocus: false,\n                    draggable: false,\n                    title: 'Track Selection',\n                    content: '<div class=\"main\">' + '<p>The JBrowse Faceted Track Selector makes it easy to search through' + ' large numbers of available tracks to find exactly the ones you want.' + ' You can incrementally filter the track display to narrow it down to' + ' those your are interested in.  There are two types of filtering available,' + ' which can be used together:' + ' <b>filtering with data fields</b>, and free-form <b>filtering with text</b>.' + '</p>' + '  <dl><dt>Filtering with Data Fields</dt>' + '  <dd>The left column of the display contains the available <b>data fields</b>.  Click on the data field name to expand it, and then select one or more values for that field.  This narrows the search to display only tracks that have one of those values for that field.  You can do this for any number of fields.<dd>' + '  <dt>Filtering with Text</dt>' + '  <dd>Type text in the \"Contains text\" box to filter for tracks whose data contains that text.  If you type multiple words, tracks are filtered such that they must contain all of those words, in any order.  Placing \"quotation marks\" around the text filters for tracks that contain that phrase exactly.  All text matching is case insensitive.</dd>' + '  <dt>Activating Tracks</dt>' + \"  <dd>To activate and deactivate a track, click its check-box in the left-most column.  When the box contains a check mark, the track is activated.  You can also turn whole groups of tracks on and off using the check-box in the table heading.</dd>\" + \"  </dl>\" + \"</div>\"\n                });\n                dojo.connect(helplink, 'onclick', this, function (evt) {\n                    helpdialog.show();return false;\n                });\n            }, this);\n\n            this.mainContainer.addChild(this.topPane);\n\n            // make both buttons toggle this track selector\n            dojo.query('.faceted_tracksel_on_off').onclick(lang.hitch(this, 'toggle'));\n\n            this.centerPane = new dijit.layout.BorderContainer({ region: 'center', \"class\": 'gridPane', gutters: false });\n            this.mainContainer.addChild(this.centerPane);\n            var textFilterContainer = this.renderTextFilter();\n\n            this.busyIndicator = dojo.create('div', {\n                innerHTML: '<img src=\"' + this.browser.resolveUrl('img/spinner.gif') + '\">',\n                className: 'busy_indicator'\n            }, this.containerElem);\n\n            this.centerPane.addChild(new dijit.layout.ContentPane({ region: 'top',\n                \"class\": 'gridControls',\n                content: [dojo.create('button', {\n                    className: 'faceted_tracksel_on_off',\n                    innerHTML: '<img src=\"' + this.browser.resolveUrl('img/left_arrow.png') + '\"> <div>Back to browser</div>',\n                    onclick: lang.hitch(this, 'hide')\n                }), dojo.create('button', {\n                    className: 'clear_filters',\n                    innerHTML: '<img src=\"' + this.browser.resolveUrl('img/red_x.png') + '\">' + '<div>Clear All Filters</div>',\n                    onclick: lang.hitch(this, function (evt) {\n                        this._clearTextFilterControl();\n                        this._clearAllFacetControls();\n                        this._async(function () {\n                            this.updateQuery();\n                            this._updateFacetCounts();\n                        }, this).call();\n                    })\n                }), this.busyIndicator, textFilterContainer, dojo.create('div', { className: 'matching_record_count' })]\n            }));\n        },\n        renderSelectors: function renderSelectors() {\n\n            // make our main components\n            var facetContainer = this.renderFacetSelectors();\n            // put them in their places in the overall layout of the track selector\n            facetContainer.set('region', 'left');\n            this.mainContainer.addChild(facetContainer);\n\n            this.dataGrid = this.renderGrid();\n            this.dataGrid.set('region', 'center');\n\n            // code around a dijit bug with width calculation in IE.\n            // doesn't seem to harm other browsers, the width gets overwritten anyway\n            // by dijit's calculations.\n            this.dataGrid.domNode.style.width = '500px';\n\n            this.centerPane.addChild(this.dataGrid);\n\n            this.mainContainer.startup();\n            this.gridReady.resolve();\n        },\n\n        /** do something in a timeout to avoid blocking the UI */\n        _async: function _async(func, scope) {\n            var that = this;\n            return function () {\n                var args = arguments;\n                var nativeScope = this;\n                that._busy(true);\n                window.setTimeout(function () {\n                    func.apply(scope || nativeScope, args);\n                    that._busy(false);\n                }, 50);\n            };\n        },\n\n        _busy: function _busy(busy) {\n            this.busyCount = Math.max(0, (this.busyCount || 0) + (busy ? 1 : -1));\n            if (this.busyCount > 0) dojo.addClass(this.containerElem, 'busy');else dojo.removeClass(this.containerElem, 'busy');\n        },\n\n        renderGrid: function renderGrid() {\n\n            var displayColumns = this.displayColumns || dojo.filter(this.trackDataStore.getFacetNames(), lang.hitch(this, '_isDisplayableColumn'));\n\n            var colWidth = 90 / displayColumns.length;\n\n            var grid = new EnhancedGrid({\n                id: 'trackSelectGrid',\n                store: this.trackDataStore,\n                selectable: true,\n                escapeHTMLInData: 'escapeHTMLInData' in this.config ? this.config.escapeHTMLInData : false,\n                noDataMessage: \"No tracks match the filtering criteria.\",\n                structure: [dojo.map(displayColumns, function (facetName) {\n                    // rename name to key to avoid configuration confusion\n                    facetName = { name: 'key' }[facetName.toLowerCase()] || facetName;\n                    return { 'name': this._facetDisplayName(facetName), 'field': facetName.toLowerCase(), 'width': colWidth + '%' };\n                }, this)],\n                plugins: {\n                    indirectSelection: {\n                        headerSelector: true\n                    }\n                }\n            });\n\n            // set the grid's initial sort index\n            var sortIndex = this.config.initialSortColumn || 0;\n            if (typeof sortIndex == 'string') sortIndex = array.indexOf(displayColumns, sortIndex);\n            grid.setSortIndex(sortIndex + 1);\n\n            // monkey-patch the grid to customize some of its behaviors\n            this._monkeyPatchGrid(grid);\n\n            return grid;\n        },\n\n        /**\n         * Given a raw facet name, format it for user-facing display.\n         * @private\n         */\n        _facetDisplayName: function _facetDisplayName(facetName) {\n            // make renameFacets if needed, and lowercase all the keys to\n            // make it case-insensitive\n            this.renameFacets = this.renameFacets || function () {\n                var renameFacets = this.config.renameFacets;\n                var lc = {};\n                for (var k in renameFacets) {\n                    lc[k.toLowerCase()] = renameFacets[k];\n                }\n                lc.key = lc.key || 'Name';\n                return lc;\n            }.call(this);\n\n            return this.renameFacets[facetName.toLowerCase()] || Util.ucFirst(facetName.replace('_', ' '));\n        },\n\n        /**\n         * Apply several run-time patches to the dojox.grid.EnhancedGrid\n         * code to fix bugs and customize the behavior in ways that aren't\n         * quite possible using the regular Dojo APIs.\n         * @private\n         */\n        _monkeyPatchGrid: function _monkeyPatchGrid(grid) {\n\n            // 1. monkey-patch the grid's onRowClick handler to not do\n            // anything.  without this, clicking on a row selects it, and\n            // deselects everything else, which is quite undesirable.\n            grid.onRowClick = function () {};\n\n            // 2. monkey-patch the grid's range-selector to refuse to select\n            // if the selection is too big\n            var origSelectRange = grid.selection.selectRange;\n            grid.selection.selectRange = function (inFrom, inTo) {\n                var selectionLimit = 30;\n                if (inTo - inFrom > selectionLimit) {\n                    alert(\"Too many tracks selected, please select fewer than \" + selectionLimit + \" tracks. Note: you can use shift+click to select a range of tracks\");\n                    return undefined;\n                }\n                return origSelectRange.apply(this, arguments);\n            };\n        },\n\n        renderTextFilter: function renderTextFilter(parent) {\n            // make the text input for text filtering\n            this.textFilterLabel = dojo.create('label', { className: 'textFilterControl',\n                innerHTML: 'Contains text ',\n                id: 'tracklist_textfilter',\n                style: { position: 'relative' }\n            }, parent);\n            this.textFilterInput = dojo.create('input', { type: 'text',\n                size: 40,\n                disabled: true, // disabled until shown\n                onkeypress: lang.hitch(this, function (evt) {\n                    // don't pay attention to modifier keys\n                    if (evt.keyCode == dojo.keys.SHIFT || evt.keyCode == dojo.keys.CTRL || evt.keyCode == dojo.keys.ALT) return;\n\n                    // use a timeout to avoid updating the display too fast\n                    if (this.textFilterTimeout) window.clearTimeout(this.textFilterTimeout);\n                    this.textFilterTimeout = window.setTimeout(lang.hitch(this, function () {\n                        // do a new search and update the display\n                        this._updateTextFilterControl();\n                        this._async(function () {\n                            this.updateQuery();\n                            this._updateFacetCounts();\n                            this.textFilterInput.focus();\n                        }, this).call();\n                        this.textFilterInput.focus();\n                    }), 500);\n                    this._updateTextFilterControl();\n\n                    evt.stopPropagation();\n                })\n            }, this.textFilterLabel);\n            // make a \"clear\" button for the text filtering input\n            this.textFilterClearButton = dojo.create('img', {\n                src: this.browser.resolveUrl('img/red_x.png'),\n                className: 'text_filter_clear',\n                onclick: lang.hitch(this, function () {\n                    this._clearTextFilterControl();\n                    this._async(function () {\n                        this.updateQuery();\n                        this._updateFacetCounts();\n                    }, this).call();\n                }),\n                style: {\n                    position: 'absolute',\n                    right: '4px',\n                    top: '20%'\n                }\n            }, this.textFilterLabel);\n\n            return this.textFilterLabel;\n        },\n\n        /**\n         * Clear the text filter control input.\n         * @private\n         */\n        _clearTextFilterControl: function _clearTextFilterControl() {\n            this.textFilterInput.value = '';\n            this._updateTextFilterControl();\n        },\n        /**\n         * Update the display of the text filter control based on whether\n         * it has any text in it.\n         * @private\n         */\n        _updateTextFilterControl: function _updateTextFilterControl() {\n            if (this.textFilterInput.value.length) dojo.addClass(this.textFilterLabel, 'selected');else dojo.removeClass(this.textFilterLabel, 'selected');\n        },\n\n        /**\n         * Create selection boxes for each searchable facet.\n         */\n        renderFacetSelectors: function renderFacetSelectors() {\n            var container = new ContentPane({ style: 'width: 200px' });\n\n            var store = this.trackDataStore;\n            this.facetSelectors = {};\n\n            // render a facet selector for a pseudo-facet holding\n            // attributes regarding the tracks the user has been working\n            // with\n            var usageFacet = this._renderFacetSelector('My Tracks', ['Currently Active', 'Recently Used']);\n            usageFacet.set('class', 'myTracks');\n            container.addChild(usageFacet);\n\n            // for the facets from the store, only render facet selectors\n            // for ones that are not identity attributes, and have an\n            // average bucket size greater than 1\n            var selectableFacets = dojo.filter(this.config.selectableFacets || store.getFacetNames(), function (facetName) {\n                return this._isSelectableFacet(facetName, this.trackDataStore);\n            }, this);\n\n            dojo.forEach(selectableFacets, function (facetName) {\n\n                // get the values of this facet\n                var values = store.getFacetValues(facetName).sort();\n                if (!values || !values.length) return;\n\n                var facetPane = this._renderFacetSelector(facetName, values);\n                container.addChild(facetPane);\n            }, this);\n\n            return container;\n        },\n\n        /**\n         * Make HTML elements for a single facet selector.\n         * @private\n         * @returns {dijit.layout.TitlePane}\n         */\n        _renderFacetSelector: function _renderFacetSelector( /**String*/facetName, /**Array[String]*/values) {\n\n            var facetPane = new TitlePane({\n                title: '<span id=\"facet_title_' + facetName + '\" ' + 'class=\"facetTitle\">' + this._facetDisplayName(facetName) + ' <a class=\"clearFacet\"><img src=\"' + this.browser.resolveUrl('img/red_x.png') + '\" /></a>' + '</span>'\n            });\n\n            // make a selection control for the values of this facet\n            var facetControl = dojo.create('table', { className: 'facetSelect' }, facetPane.containerNode);\n            // populate selector's options\n            this.facetSelectors[facetName] = dojo.map(values, function (val) {\n                var that = this;\n                var node = dojo.create('tr', { className: 'facetValue',\n                    innerHTML: '<td class=\"count\"></td><td class=\"value\">' + val + '</td>',\n                    onclick: function onclick(evt) {\n                        dojo.toggleClass(this, 'selected');\n                        that._updateFacetControl(facetName);\n                        that._async(function () {\n                            that.updateQuery();\n                            that._updateFacetCounts(facetName);\n                        }).call();\n                    }\n                }, facetControl);\n                node.facetValue = val;\n                return node;\n            }, this);\n\n            return facetPane;\n        },\n\n        /**\n         * Clear all the selections from all of the facet controls.\n         * @private\n         */\n        _clearAllFacetControls: function _clearAllFacetControls() {\n            dojo.forEach(dojof.keys(this.facetSelectors), function (facetName) {\n                this._clearFacetControl(facetName);\n            }, this);\n        },\n\n        /**\n         * Clear all the selections from the facet control with the given name.\n         * @private\n         */\n        _clearFacetControl: function _clearFacetControl(facetName) {\n            dojo.forEach(this.facetSelectors[facetName] || [], function (selector) {\n                dojo.removeClass(selector, 'selected');\n            }, this);\n            this._updateFacetControl(facetName);\n        },\n\n        /**\n         * Incrementally update the facet counts as facet values are selected.\n         * @private\n         */\n        _updateFacetCounts: function _updateFacetCounts( /**String*/skipFacetName) {\n            dojo.forEach(dojof.keys(this.facetSelectors), function (facetName) {\n                if (facetName == 'My Tracks') // || facetName == skipFacetName )\n                    return;\n                var thisFacetCounts = this.trackDataStore.getFacetCounts(facetName);\n                dojo.forEach(this.facetSelectors[facetName] || [], function (selectorNode) {\n                    dojo.query('.count', selectorNode).forEach(function (countNode) {\n                        var count = thisFacetCounts ? thisFacetCounts[selectorNode.facetValue] || 0 : 0;\n                        countNode.innerHTML = Util.addCommas(count);\n                        if (count) dojo.removeClass(selectorNode, 'disabled');else dojo.addClass(selectorNode, 'disabled');\n                    }, this);\n                    //dojo.removeClass(selector,'selected');\n                }, this);\n                this._updateFacetControl(facetName);\n            }, this);\n        },\n\n        /**\n         * Update the title bar of the given facet control to reflect\n         * whether it has selected values in it.\n         */\n        _updateFacetControl: function _updateFacetControl(facetName) {\n            var titleContent = dojo.byId('facet_title_' + facetName);\n\n            // if all our values are disabled, add 'disabled' to our\n            // title's CSS classes\n            if (array.every(this.facetSelectors[facetName] || [], function (sel) {\n                return dojo.hasClass(sel, 'disabled');\n            }, this)) {\n                dojo.addClass(titleContent, 'disabled');\n            }\n\n            // if we have some selected values, make a \"clear\" button, and\n            // add 'selected' to our title's CSS classes\n            if (array.some(this.facetSelectors[facetName] || [], function (sel) {\n                return dojo.hasClass(sel, 'selected');\n            }, this)) {\n                var clearFunc = lang.hitch(this, function (evt) {\n                    this._clearFacetControl(facetName);\n                    this._async(function () {\n                        this.updateQuery();\n                        this._updateFacetCounts(facetName);\n                    }, this).call();\n                    evt.stopPropagation();\n                });\n                dojo.addClass(titleContent.parentNode.parentNode, 'activeFacet');\n                dojo.query('> a', titleContent).forEach(function (node) {\n                    node.onclick = clearFunc;\n                }, this).attr('title', 'clear selections');\n            }\n            // otherwise, no selected values\n            else {\n                    dojo.removeClass(titleContent.parentNode.parentNode, 'activeFacet');\n                    dojo.query('> a', titleContent).onclick(function () {\n                        return false;\n                    }).removeAttr('title');\n                }\n        },\n\n        /**\n         * Update the query we are using with the track metadata store\n         * based on the values of the search form elements.\n         */\n        updateQuery: function updateQuery() {\n            this._suppressRecursion('_updateQuery');\n        },\n        _updateQuery: function _updateQuery() {\n            var newQuery = {};\n\n            var is_selected = function is_selected(node) {\n                return dojo.hasClass(node, 'selected');\n            };\n\n            // update from the My Tracks pseudofacet\n            (function () {\n                var mytracks_options = this.facetSelectors['My Tracks'];\n\n                // index the optoins by name\n                var byname = {};\n                dojo.forEach(mytracks_options, function (opt) {\n                    byname[opt.facetValue] = opt;\n                });\n\n                // if filtering for active tracks, add the labels for the\n                // currently selected tracks to the query\n                if (is_selected(byname['Currently Active'])) {\n                    var activeTrackLabels = dojof.keys(this.tracksActive || {});\n                    newQuery.label = Util.uniq((newQuery.label || []).concat(activeTrackLabels));\n                }\n\n                // if filtering for recently used tracks, add the labels of recently used tracks\n                if (is_selected(byname['Recently Used'])) {\n                    var recentlyUsed = dojo.map(this.browser.getRecentlyUsedTracks(), function (t) {\n                        return t.label;\n                    });\n\n                    newQuery.label = Util.uniq((newQuery.label || []).concat(recentlyUsed));\n                }\n\n                // finally, if something is selected in here, but we have\n                // not come up with any track labels, then insert a dummy\n                // track label value that will never match, because the\n                // query engine ignores empty arrayrefs.\n                if ((!newQuery.label || !newQuery.label.length) && array.some(mytracks_options, is_selected)) {\n                    newQuery.label = ['FAKE LABEL THAT IS HIGHLY UNLIKELY TO EVER MATCH ANYTHING'];\n                }\n            }).call(this);\n\n            // update from the text filter\n            if (this.textFilterInput.value.length) {\n                newQuery.text = this.textFilterInput.value;\n            }\n\n            // update from the data-based facet selectors\n            dojo.forEach(this.trackDataStore.getFacetNames(), function (facetName) {\n                var options = this.facetSelectors[facetName];\n                if (!options) return;\n\n                var selectedFacets = dojo.map(dojo.filter(options, is_selected), function (opt) {\n                    return opt.facetValue;\n                });\n                if (selectedFacets.length) newQuery[facetName] = selectedFacets;\n            }, this);\n\n            this.query = newQuery;\n            this.dataGrid.setQuery(this.query);\n            this._updateMatchCount();\n        },\n\n        /**\n         * Update the match-count text in the grid controls bar based\n         * on the last query that was run against the store.\n         * @private\n         */\n        _updateMatchCount: function _updateMatchCount() {\n            var count = this.dataGrid.store.getCount();\n            dojo.query('.matching_record_count', this.containerElem).forEach(function (n) {\n                n.innerHTML = Util.addCommas(count) + ' ' + (dojof.keys(this.query || {}).length ? 'matching ' : '') + 'track' + (count == 1 ? '' : 's');\n            }, this);\n        },\n\n        /**\n         * Update the grid to have only rows checked that correspond to\n         * tracks that are currently active.\n         * @private\n         */\n        _updateGridSelections: function _updateGridSelections() {\n            var _this3 = this;\n\n            this.ready.then(function () {\n                // keep selection events from firing while we mess with the\n                // grid\n                _this3._ifNotSuppressed(['gridUpdate', 'selectionEvents'], function () {\n                    this._suppress('selectionEvents', function () {\n                        this.dataGrid.selection.deselectAll();\n\n                        // check the boxes that should be checked, based on our\n                        // internal memory of what tracks should be on.\n                        for (var i = 0; i < Math.min(this.dataGrid.get('rowCount'), this.dataGrid.get('rowsPerPage')); i++) {\n                            var item = this.dataGrid.getItem(i);\n                            if (item) {\n                                var label = this.dataGrid.store.getIdentity(item);\n                                if (this.tracksActive[label]) this.dataGrid.rowSelectCell.toggleRow(i, true);\n                            }\n                        }\n                    });\n                });\n            });\n        },\n\n        /**\n         * Given an array of track configs, update the track list to show\n         * that they are turned on.\n         */\n        setTracksActive: function setTracksActive( /**Array[Object]*/trackConfigs) {\n            dojo.forEach(trackConfigs, function (conf) {\n                this.tracksActive[conf.label] = true;\n            }, this);\n            this._updateGridSelections();\n        },\n\n        /**\n         * Given an array of track configs, update the track list to show\n         * that they are turned off.\n         */\n        setTracksInactive: function setTracksInactive( /**Array[Object]*/trackConfigs) {\n            dojo.forEach(trackConfigs, function (conf) {\n                delete this.tracksActive[conf.label];\n            }, this);\n            this._updateGridSelections();\n        },\n\n        /**\n         * Make the track selector visible.\n         */\n        show: function show() {\n            window.setTimeout(lang.hitch(this, function () {\n                this.textFilterInput.disabled = false;\n                this.textFilterInput.focus();\n            }), 300);\n\n            dojo.addClass(this.containerElem, 'active');\n            dojo.animateProperty({\n                node: this.containerElem,\n                properties: {\n                    left: { start: -95, end: 0, units: '%' }\n                }\n            }).play();\n\n            this.shown = true;\n        },\n\n        /**\n         * Make the track selector invisible.\n         */\n        hide: function hide() {\n\n            dojo.removeClass(this.containerElem, 'active');\n\n            dojo.animateProperty({\n                node: this.containerElem,\n                properties: {\n                    left: { start: 0, end: -95, units: '%' }\n                }\n            }).play();\n\n            this.textFilterInput.blur();\n            this.textFilterInput.disabled = true;\n\n            this.shown = false;\n        },\n\n        /**\n         * Toggle whether the track selector is visible.\n         */\n        toggle: function toggle() {\n            this.shown ? this.hide() : this.show();\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/TrackList/Faceted.js?");

/***/ }),

/***/ "./src/JBrowse/View/TrackList/Hierarchical.js":
/*!****************************************************!*\
  !*** ./src/JBrowse/View/TrackList/Hierarchical.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\"), __webpack_require__(/*! dijit/TitlePane */ \"./node_modules/dijit/TitlePane.js\"), __webpack_require__(/*! dijit/layout/ContentPane */ \"./node_modules/dijit/layout/ContentPane.js\"), __webpack_require__(/*! JBrowse/Util */ \"./src/JBrowse/Util.js\"), __webpack_require__(/*! ./_TextFilterMixin */ \"./src/JBrowse/View/TrackList/_TextFilterMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, lang, dom, query, on, JSON, TitlePane, ContentPane, Util, _TextFilterMixin) {\n\n    return declare('JBrowse.View.TrackList.Hierarchical', [ContentPane, _TextFilterMixin], {\n\n        region: 'left',\n        splitter: true,\n        style: 'width: 25%',\n\n        id: 'hierarchicalTrackPane',\n        baseClass: 'jbrowseHierarchicalTrackSelector',\n\n        categoryFacet: 'category',\n\n        constructor: function constructor(args) {\n            this.categories = {};\n            this.config = lang.mixin({\n                \"sortHierarchical\": true\n            }, args);\n\n            this._loadState();\n        },\n        postCreate: function postCreate() {\n            this.placeAt(this.browser.container);\n\n            // subscribe to commands coming from the the controller\n            this.browser.subscribe('/jbrowse/v1/c/tracks/show', lang.hitch(this, 'setTracksActive'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/hide', lang.hitch(this, 'setTracksInactive'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/new', lang.hitch(this, 'addTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/replace', lang.hitch(this, 'replaceTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/delete', lang.hitch(this, 'deleteTracks'));\n        },\n        buildRendering: function buildRendering() {\n            this.inherited('buildRendering', arguments);\n\n            var topPane = dom.create('div', { className: 'header' }, this.containerNode);\n            dom.create('h2', { className: 'title',\n                innerHTML: 'Available Tracks'\n            }, topPane);\n\n            this._makeTextFilterNodes(dom.create('div', { className: 'textfilterContainer' }, topPane));\n            this._updateTextFilterControl();\n        },\n        induceCategoryOrder: function induceCategoryOrder(tracks, categoryOrder) {\n            var order = categoryOrder.split(\",\").map(function (s) {\n                return s.trim();\n            }).map(function (s) {\n                return s.split(\"/\").map(function (s) {\n                    return s.trim();\n                }).join('/');\n            });\n            tracks.forEach(function (t) {\n                if (t.category) {\n                    t.cat = t.category.trim().split('/').map(function (s) {\n                        return s.trim();\n                    }).join('/');\n                }\n            });\n            var unordered = tracks.filter(function (t) {\n                return order.indexOf(t.cat) === -1;\n            });\n            var ordered = tracks.filter(function (t) {\n                return order.indexOf(t.cat) !== -1;\n            });\n            ordered.sort(function (a, b) {\n                return order.indexOf(a.cat) - order.indexOf(b.cat);\n            });\n            tracks.forEach(function (t) {\n                return delete t.cat;\n            });\n            return ordered.concat(unordered);\n        },\n        startup: function startup() {\n            var _this = this;\n\n            this.inherited('startup', arguments);\n\n            var tracks = [];\n            var categoryFacet = this.get('categoryFacet');\n            var sorter;\n            if (this.config.sortHierarchical) {\n                sorter = [{ attribute: categoryFacet.toLowerCase() }, { attribute: 'key' }, { attribute: 'label' }];\n            }\n\n            // add initally collapsed categories to the local storage\n            var arr = (this.get('collapsedCategories') || \"\").split(\",\").map(function (s) {\n                return s.trim();\n            }).map(function (s) {\n                return s.split(\"/\").map(function (s) {\n                    return s.trim();\n                }).join('/');\n            });\n            for (var i = 0; i < arr.length; i++) {\n                lang.setObject('collapsed.' + arr[i], true, this.state);\n            }\n            this._saveState();\n\n            this.get('trackMetaData').fetch({\n                onItem: function onItem(i) {\n                    if (i.conf) tracks.push(i);\n                },\n                onComplete: function onComplete() {\n                    // make a pane at the top to hold uncategorized tracks\n                    _this.categories.Uncategorized = {\n                        pane: new ContentPane({ className: 'uncategorized' }).placeAt(_this.containerNode),\n                        tracks: {},\n                        categories: {}\n                    };\n                    if (_this.config.categoryOrder) {\n                        tracks = _this.induceCategoryOrder(tracks, _this.config.categoryOrder);\n                    }\n\n                    _this.addTracks(tracks, true);\n\n                    // hide the uncategorized pane if it is empty\n                    if (!_this.categories.Uncategorized.pane.containerNode.children.length) {\n                        _this.categories.Uncategorized.pane.domNode.style.display = 'none';\n                    }\n                },\n                sort: sorter\n            });\n        },\n\n\n        addTracks: function addTracks(tracks, inStartup) {\n            this.pane = this;\n            var thisB = this;\n\n            array.forEach(tracks, function (track) {\n                var trackConf = track.conf || track;\n\n                var categoryFacet = this.get('categoryFacet');\n                var categoryNames = (trackConf.metadata && trackConf.metadata[categoryFacet] || trackConf[categoryFacet] || track[categoryFacet] || 'Uncategorized').split(/\\s*\\/\\s*/);\n\n                var category = _findCategory(this, categoryNames, []);\n\n                function _findCategory(obj, names, path) {\n                    var categoryName = names.shift();\n                    path = path.concat(categoryName);\n                    var categoryPath = path.join('/');\n\n                    var cat = obj.categories[categoryName] || (obj.categories[categoryName] = function () {\n                        var isCollapsed = lang.getObject('collapsed.' + categoryPath, false, thisB.state);\n                        var c = new TitlePane({ title: '<span class=\"categoryName\">' + categoryName + '</span>' + ' <span class=\"trackCount\">0</span>',\n                            open: !isCollapsed\n                        });\n                        // save our open/collapsed state in local storage\n                        c.watch('open', function (attr, oldval, newval) {\n                            lang.setObject('collapsed.' + categoryPath, !newval, thisB.state);\n                            thisB._saveState();\n                        });\n                        obj.pane.addChild(c, inStartup ? undefined : 1);\n                        return { parent: obj, pane: c, categories: {}, tracks: {} };\n                    }.call(thisB));\n\n                    return names.length ? _findCategory(cat, names, path) : cat;\n                };\n\n                category.pane.domNode.style.display = 'block';\n\n                // note: sometimes trackConf.description is defined as numeric, so in this case, ignore it\n                var labelNode = dom.create('label', {\n                    className: 'tracklist-label shown',\n                    title: Util.escapeHTML(trackConf.shortDescription || track.shortDescription || (trackConf.description === 1 ? undefined : trackConf.description) || track.description || trackConf.Description || track.Description || trackConf.metadata && (trackConf.metadata.shortDescription || trackConf.metadata.description || trackConf.metadata.Description) || track.key || trackConf.key || trackConf.label)\n                }, category.pane.containerNode);\n\n                var checkBoxProps = { type: 'checkbox', className: 'check' };\n\n                // hook point\n                if (typeof thisB.extendCheckbox === 'function') var checkBoxProps = thisB.extendCheckbox(checkBoxProps, trackConf);\n\n                var checkbox = dom.create('input', checkBoxProps, labelNode);\n                var trackLabel = trackConf.label;\n                var checkListener;\n                this.own(checkListener = on(checkbox, 'click', function () {\n                    thisB.itemClick(this, trackConf);\n                }));\n                dom.create('span', { className: 'key', innerHTML: trackConf.key || trackConf.label }, labelNode);\n\n                category.tracks[trackLabel] = { checkbox: checkbox, checkListener: checkListener, labelNode: labelNode };\n            }, this);\n            this._updateAllTitles();\n        },\n        // called when item checkbox is clicked.\n        itemClick: function itemClick(checkbox, trackConf) {\n\n            this.browser.publish('/jbrowse/v1/v/tracks/' + (checkbox.checked ? 'show' : 'hide'), [trackConf]);\n        },\n\n        _loadState: function _loadState() {\n            this.state = {};\n            try {\n                this.state = JSON.parse(localStorage.getItem('JBrowse-Hierarchical-Track-Selector') || '{}');\n            } catch (e) {}\n            return this.state;\n        },\n        _saveState: function _saveState(state) {\n            try {\n                localStorage.setItem('JBrowse-Hierarchical-Track-Selector', JSON.stringify(this.state));\n            } catch (e) {}\n        },\n\n        // depth-first traverse and update the titles of all the categories\n        _updateAllTitles: function _updateAllTitles(r) {\n            var root = r || this;\n            for (var c in root.categories) {\n                this._updateTitle(root.categories[c]);\n                this._updateAllTitles(root.categories[c]);\n            }\n        },\n\n        _updateTitle: function _updateTitle(category) {\n            category.pane.set('title', category.pane.get('title').replace(/>\\s*\\d+\\s*</, '>' + query('label.shown', category.pane.containerNode).length + '<'));\n        },\n\n        // update the titles of the given category and its parents\n        _updateTitles: function _updateTitles(category) {\n            this._updateTitle(category);\n            if (category.parent) this._updateTitles(category.parent);\n        },\n\n        _findTrack: function _findTrack(trackLabel, callback, r) {\n            var root = r || this;\n            for (var c in root.categories) {\n                var category = root.categories[c];\n                if (category.tracks[trackLabel]) {\n                    callback(category.tracks[trackLabel], category);\n                    return true;\n                } else {\n                    if (this._findTrack(trackLabel, callback, category)) return true;\n                }\n            }\n            return false;\n        },\n        //  hook point\n        replaceTracks: function replaceTracks(trackConfigs) {// notification\n        },\n\n        /**\n         * Given an array of track configs, update the track list to show\n         * that they are turned on.\n         */\n        setTracksActive: function setTracksActive( /**Array[Object]*/trackConfigs) {\n            array.forEach(trackConfigs, function (conf) {\n                this._findTrack(conf.label, function (trackRecord, category) {\n                    trackRecord.checkbox.checked = true;\n                });\n            }, this);\n        },\n\n        deleteTracks: function deleteTracks( /**Array[Object]*/trackConfigs) {\n            array.forEach(trackConfigs, function (conf) {\n                this._findTrack(conf.label, function (trackRecord, category) {\n                    trackRecord.labelNode.parentNode.removeChild(trackRecord.labelNode);\n                    trackRecord.checkListener.remove();\n                    delete category.tracks[conf.label];\n                });\n            }, this);\n        },\n\n        /**\n         * Given an array of track configs, update the track list to show\n         * that they are turned off.\n         */\n        setTracksInactive: function setTracksInactive( /**Array[Object]*/trackConfigs) {\n            array.forEach(trackConfigs, function (conf) {\n                this._findTrack(conf.label, function (trackRecord, category) {\n                    trackRecord.checkbox.checked = false;\n                });\n            }, this);\n        },\n\n        _textFilter: function _textFilter() {\n            this.inherited(arguments);\n            this._updateAllTitles();\n        },\n\n        /**\n         * Make the track selector visible.\n         * This does nothing for this track selector, since it is always visible.\n         */\n        show: function show() {},\n\n        /**\n         * Make the track selector invisible.\n         * This does nothing for this track selector, since it is always visible.\n         */\n        hide: function hide() {},\n\n        /**\n         * Toggle visibility of this track selector.\n         * This does nothing for this track selector, since it is always visible.\n         */\n        toggle: function toggle() {}\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/TrackList/Hierarchical.js?");

/***/ }),

/***/ "./src/JBrowse/View/TrackList/Null.js":
/*!********************************************!*\
  !*** ./src/JBrowse/View/TrackList/Null.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare) {\n\n    return declare(null,\n\n    /**\n     * @lends JBrowse.View.TrackList.Null.prototype\n     */\n    {\n        setTracksActive: function setTracksActive() {},\n        setTracksInactive: function setTracksInactive() {},\n        show: function show() {},\n        hide: function hide() {},\n        toggle: function toggle() {}\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/TrackList/Null.js?");

/***/ }),

/***/ "./src/JBrowse/View/TrackList/Simple.js":
/*!**********************************************!*\
  !*** ./src/JBrowse/View/TrackList/Simple.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/event */ \"./node_modules/dojo/_base/event.js\"), __webpack_require__(/*! dojo/keys */ \"./node_modules/dojo/keys.js\"), __webpack_require__(/*! dojo/on */ \"./node_modules/dojo/on.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/dom-class */ \"./node_modules/dojo/dom-class.js\"), __webpack_require__(/*! dijit/layout/ContentPane */ \"./node_modules/dijit/layout/ContentPane.js\"), __webpack_require__(/*! dojo/dnd/Source */ \"./node_modules/dojo/dnd/Source.js\"), __webpack_require__(/*! dojo/fx/easing */ \"./node_modules/dojo/fx/easing.js\"), __webpack_require__(/*! dijit/form/TextBox */ \"./node_modules/dijit/form/TextBox.js\"), __webpack_require__(/*! ./_TextFilterMixin */ \"./src/JBrowse/View/TrackList/_TextFilterMixin.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, array, event, keys, on, dom, domClass, ContentPane, dndSource, animationEasing, dijitTextBox, _TextFilterMixin) {\n\n    return declare('JBrowse.View.TrackList.Simple', _TextFilterMixin,\n\n    /** @lends JBrowse.View.TrackList.Simple.prototype */\n    {\n\n        /**\n         * Simple drag-and-drop track selector.\n         * @constructs\n         */\n        constructor: function constructor(args) {\n            this.browser = args.browser;\n\n            // make the track list DOM nodes and widgets\n            this.createTrackList(args.browser.container);\n\n            // maintain a list of the HTML nodes of inactive tracks, so we\n            // can flash them and whatnot\n            this.inactiveTrackNodes = {};\n\n            // populate our track list (in the right order)\n            this.trackListWidget.insertNodes(false, args.trackConfigs);\n\n            // subscribe to drop events for tracks being DND'ed\n            this.browser.subscribe(\"/dnd/drop\", dojo.hitch(this, function (source, nodes, copy, target) {\n                if (target !== this.trackListWidget) return;\n\n                // get the configs from the tracks being dragged in\n                var confs = dojo.filter(dojo.map(nodes, function (n) {\n                    return n.track && n.track.config;\n                }), function (c) {\n                    return c;\n                });\n\n                // return if no confs; whatever was\n                // dragged here probably wasn't a\n                // track\n                if (!confs.length) return;\n\n                this.dndDrop = true;\n                this.browser.publish('/jbrowse/v1/v/tracks/hide', confs);\n                this.dndDrop = false;\n            }));\n\n            // subscribe to commands coming from the the controller\n            this.browser.subscribe('/jbrowse/v1/c/tracks/show', dojo.hitch(this, 'setTracksActive'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/hide', dojo.hitch(this, 'setTracksInactive'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/new', dojo.hitch(this, 'addTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/replace', dojo.hitch(this, 'replaceTracks'));\n            this.browser.subscribe('/jbrowse/v1/c/tracks/delete', dojo.hitch(this, 'deleteTracks'));\n        },\n\n        addTracks: function addTracks(trackConfigs) {\n            // note that new tracks are, by default, hidden, so we just put them in the list\n            this.trackListWidget.insertNodes(false, trackConfigs);\n\n            this._blinkTracks(trackConfigs);\n        },\n\n        replaceTracks: function replaceTracks(trackConfigs) {\n            // for each one\n            array.forEach(trackConfigs, function (conf) {\n                var oldNode = this.inactiveTrackNodes[conf.label];\n                if (!oldNode) return;\n                delete this.inactiveTrackNodes[conf.label];\n\n                this.trackListWidget.delItem(oldNode.id);\n                if (oldNode.parentNode) oldNode.parentNode.removeChild(oldNode);\n\n                this.trackListWidget.insertNodes(false, [conf], false, oldNode.previousSibling);\n            }, this);\n        },\n\n        /** @private */\n        createTrackList: function createTrackList(renderTo) {\n            var leftPane = dojo.create('div', { id: 'trackPane',\n                className: 'jbrowseSimpleTrackSelector',\n                style: { width: '12em' }\n            }, renderTo);\n\n            //splitter on left side\n            var leftWidget = new ContentPane({ region: \"left\", splitter: true }, leftPane);\n\n            var trackListDiv = this.div = this.containerNode = dojo.create('div', { id: 'tracksAvail',\n                className: 'container handles',\n                style: { width: '100%', height: '100%', overflowX: 'hidden', overflowY: 'auto' },\n                innerHTML: '<h2>Available Tracks</h2>'\n            }, leftPane);\n\n            this._makeTextFilterNodes(trackListDiv);\n            this._updateTextFilterControl();\n\n            this.trackListWidget = new dndSource(trackListDiv, {\n                accept: [\"track\"], // accepts only tracks into left div\n                withHandles: false,\n                creator: dojo.hitch(this, function (trackConfig, hint) {\n                    var key = trackConfig.key || trackConfig.name || trackConfig.label;\n                    var node = dojo.create('div', { className: 'tracklist-label',\n                        title: key + ' (drag or double-click to activate)',\n                        innerHTML: key\n                    });\n\n                    //in the list, wrap the list item in a container for\n                    //border drag-insertion-point monkeying\n                    if (\"avatar\" != hint) {\n                        on(node, \"dblclick\", dojo.hitch(this, function () {\n                            this.browser.publish('/jbrowse/v1/v/tracks/show', [trackConfig]);\n                        }));\n\n                        var container = dojo.create('div', { className: 'tracklist-container' });\n                        container.appendChild(node);\n                        node = container;\n                        node.id = dojo.dnd.getUniqueId();\n                        this.inactiveTrackNodes[trackConfig.label] = node;\n                    }\n                    return { node: node, data: trackConfig, type: [\"track\"] };\n                })\n            });\n\n            // The dojo onMouseDown and onMouseUp methods don't support the functionality we're looking for,\n            // so we'll substitute our own\n            this.trackListWidget.onMouseDown = dojo.hitch(this, \"onMouseDown\");\n            this.trackListWidget.onMouseUp = dojo.hitch(this, \"onMouseUp\");\n\n            // We want the escape key to deselect all tracks\n            on(document, \"keydown\", dojo.hitch(this, \"onKeyDown\"));\n\n            return trackListDiv;\n        },\n\n        onKeyDown: function onKeyDown(e) {\n            switch (e.keyCode) {\n                case keys.ESCAPE:\n                    this.trackListWidget.selectNone();\n                    break;\n            }\n        },\n\n        onMouseDown: function onMouseDown(e) {\n            var thisW = this.trackListWidget;\n            if (!thisW.mouseDown && thisW._legalMouseDown(e)) {\n                thisW.mouseDown = true;\n                thisW._lastX = e.pageX;\n                thisW._lastY = e.pageY;\n                this._onMouseDown(thisW.current, e);\n            }\n        },\n\n        _onMouseDown: function _onMouseDown(current, e) {\n            if (!current) return;\n            var thisW = this.trackListWidget;\n            if (!e.ctrlKey && !e.shiftKey) {\n                thisW.simpleSelection = true;\n                if (!this._isSelected(current)) {\n                    thisW.selectNone();\n                    thisW.simpleSelection = false;\n                }\n            }\n            if (e.shiftKey && this.anchor) {\n                var i = 0;\n                var nodes = thisW.getAllNodes();\n                this._select(current);\n                if (current != this.anchor) {\n                    for (; i < nodes.length; i++) {\n                        if (nodes[i] == this.anchor || nodes[i] == current) break;\n                    }\n                    i++;\n                    for (; i < nodes.length; i++) {\n                        if (nodes[i] == this.anchor || nodes[i] == current) break;\n                        this._select(nodes[i]);\n                    }\n                }\n            } else {\n                e.ctrlKey ? this._toggle(current) : this._select(current);\n                this.anchor = current;\n            }\n            event.stop(e);\n        },\n\n        onMouseUp: function onMouseUp(e) {\n            var thisW = this.trackListWidget;\n            if (thisW.mouseDown) {\n                thisW.mouseDown = false;\n                this._onMouseUp(e);\n            }\n        },\n\n        _onMouseUp: function _onMouseUp(e) {\n            var thisW = this.trackListWidget;\n            if (thisW.simpleSelection && thisW.current) {\n                thisW.selectNone();\n                this._select(thisW.current);\n            }\n        },\n\n        _isSelected: function _isSelected(node) {\n            return this.trackListWidget.selection[node.id];\n        },\n\n        _select: function _select(node) {\n            this.trackListWidget.selection[node.id] = 1;\n            this.trackListWidget._addItemClass(node, \"Selected\");\n        },\n\n        _deselect: function _deselect(node) {\n            delete this.trackListWidget.selection[node.id];\n            this.trackListWidget._removeItemClass(node, \"Selected\");\n        },\n\n        _toggle: function _toggle(node) {\n            if (this.trackListWidget.selection[node.id]) {\n                this._deselect(node);\n            } else {\n                this._select(node);\n            }\n        },\n\n        /**\n         * Given an array of track configs, update the track list to show\n         * that they are turned on.  For this list, that just means\n         * deleting them from our widget.\n         */\n        setTracksActive: function setTracksActive( /**Array[Object]*/trackConfigs) {\n            this.deleteTracks(trackConfigs);\n        },\n\n        deleteTracks: function deleteTracks( /**Array[Object]*/trackConfigs) {\n            // remove any tracks in our track list that are being set as visible\n            array.forEach(trackConfigs || [], function (conf) {\n                var oldNode = this.inactiveTrackNodes[conf.label];\n                if (!oldNode) return;\n                delete this.inactiveTrackNodes[conf.label];\n\n                if (oldNode.parentNode) oldNode.parentNode.removeChild(oldNode);\n\n                this.trackListWidget.delItem(oldNode.id);\n            }, this);\n        },\n\n        /**\n         * Given an array of track configs, update the track list to show\n         * that they are turned off.\n         */\n        setTracksInactive: function setTracksInactive( /**Array[Object]*/trackConfigs) {\n\n            // remove any tracks in our track list that are being set as visible\n            if (!this.dndDrop) {\n                var n = this.trackListWidget.insertNodes(false, trackConfigs);\n\n                // blink the track(s) that we just turned off to make it\n                // easier for users to tell where they went.\n                // note that insertNodes will have put its html element in\n                // inactivetracknodes\n                this._blinkTracks(trackConfigs);\n            }\n        },\n\n        _blinkTracks: function _blinkTracks(trackConfigs) {\n            // scroll the tracklist all the way to the bottom so we can see the blinking nodes\n            this.trackListWidget.node.scrollTop = this.trackListWidget.node.scrollHeight;\n\n            array.forEach(trackConfigs, function (c) {\n                var label = this.inactiveTrackNodes[c.label].firstChild;\n                if (label) {\n                    dojo.animateProperty({\n                        node: label,\n                        duration: 400,\n                        properties: {\n                            backgroundColor: { start: '#DEDEDE', end: '#FFDE2B' }\n                        },\n                        easing: animationEasing.sine,\n                        repeat: 2,\n                        onEnd: function onEnd() {\n                            label.style.backgroundColor = null;\n                        }\n                    }).play();\n                }\n            }, this);\n        },\n\n        /**\n         * Make the track selector visible.\n         * This does nothing for the Simple track selector, since it is always visible.\n         */\n        show: function show() {},\n\n        /**\n         * Make the track selector invisible.\n         * This does nothing for the Simple track selector, since it is always visible.\n         */\n        hide: function hide() {},\n\n        /**\n         * Toggle visibility of this track selector.\n         * This does nothing for the Simple track selector, since it is always visible.\n         */\n        toggle: function toggle() {}\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/TrackList/Simple.js?");

/***/ }),

/***/ "./src/JBrowse/View/TrackList/_TextFilterMixin.js":
/*!********************************************************!*\
  !*** ./src/JBrowse/View/TrackList/_TextFilterMixin.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/dom-construct */ \"./node_modules/dojo/dom-construct.js\"), __webpack_require__(/*! dojo/dom-class */ \"./node_modules/dojo/dom-class.js\"), __webpack_require__(/*! dojo/keys */ \"./node_modules/dojo/keys.js\"), __webpack_require__(/*! dojo/query */ \"./node_modules/dojo/query.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang, dom, domClass, keys, query) {\n\n    return declare(null, {\n\n        _makeTextFilterNodes: function _makeTextFilterNodes(trackListDiv) {\n\n            this.textFilterDiv = dom.create('div', {\n                className: 'textfilter',\n                style: {\n                    position: 'relative',\n                    overflow: 'hidden'\n                }\n            }, trackListDiv);\n            this.textFilterInput = dom.create('input', { type: 'text',\n                placeholder: 'filter tracks',\n                onkeypress: lang.hitch(this, function (evt) {\n                    if (evt.keyCode == keys.ESCAPE) {\n                        this.textFilterInput.value = '';\n                    }\n\n                    if (this.textFilterTimeout) window.clearTimeout(this.textFilterTimeout);\n                    this.textFilterTimeout = window.setTimeout(lang.hitch(this, function () {\n                        this._updateTextFilterControl();\n                        this._textFilter(this.textFilterInput.value);\n                    }), 500);\n                    this._updateTextFilterControl();\n\n                    evt.stopPropagation();\n                })\n            }, this.textFilterDiv);\n\n            // make a \"clear\" button for the text filtering input\n            this.textFilterClearButton = dom.create('div', {\n                className: 'jbrowseIconCancel',\n                onclick: lang.hitch(this, function () {\n                    this._clearTextFilterControl();\n                    this._textFilter(this.textFilterInput.value);\n                })\n            }, this.textFilterDiv);\n        },\n\n        /**\n         * Clear the text filter control input.\n         * @private\n         */\n        _clearTextFilterControl: function _clearTextFilterControl() {\n            this.textFilterInput.value = '';\n            this._updateTextFilterControl();\n        },\n        /**\n         * Update the display of the text filter control based on whether\n         * it has any text in it.\n         * @private\n         */\n        _updateTextFilterControl: function _updateTextFilterControl() {\n            if (this.textFilterInput.value.length) domClass.remove(this.textFilterDiv, 'dijitDisabled');else domClass.add(this.textFilterDiv, 'dijitDisabled');\n        },\n\n        _textFilter: function _textFilter(text) {\n            if (text && /\\S/.test(text)) {\n\n                text = text.toLowerCase();\n\n                query('.tracklist-label', this.containerNode).forEach(function (labelNode, i) {\n                    if (labelNode.innerHTML.toLowerCase().indexOf(text) != -1) {\n                        domClass.remove(labelNode, 'collapsed');\n                        domClass.add(labelNode, 'shown');\n                    } else {\n                        domClass.add(labelNode, 'collapsed');\n                        domClass.remove(labelNode, 'shown');\n                    }\n                });\n            } else {\n                query('.tracklist-label', this.containerNode).removeClass('collapsed').addClass('shown');\n            }\n        }\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/TrackList/_TextFilterMixin.js?");

/***/ }),

/***/ "./src/JBrowse/View/_FeatureDescriptionMixin.js":
/*!******************************************************!*\
  !*** ./src/JBrowse/View/_FeatureDescriptionMixin.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/declare */ \"./node_modules/dojo/_base/declare.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (declare, lang) {\n\n    return declare(null, {\n\n        // get the label string for a feature, based on the setting\n        // of this.config.label\n        getFeatureLabel: function getFeatureLabel(feature) {\n            return this._getFeatureDescriptiveThing('label', 'name,id', feature);\n        },\n\n        // get the description string for a feature, based on the setting\n        // of this.config.description\n        getFeatureDescription: function getFeatureDescription(feature) {\n            return this._getFeatureDescriptiveThing('description', 'note,description', feature);\n        },\n\n        _getFeatureDescriptiveThing: function _getFeatureDescriptiveThing(field, defaultFields, feature) {\n            var dConf = this.config.style[field] || this.config[field];\n\n            if (!dConf) return null;\n\n            // if the description is a function, just call it\n            if (typeof dConf == 'function') {\n                return dConf.call(this, feature);\n            }\n            // otherwise try to parse it as a field list\n            else {\n                    if (!this.descriptionFields) this.descriptionFields = {};\n\n                    // parse our description varname conf if necessary\n                    var fields = this.descriptionFields[field] || function () {\n                        var f = dConf;\n                        if (f) {\n                            if (lang.isArray(f)) {\n                                f = f.join(',');\n                            } else if (typeof f != 'string') {\n                                console.warn('invalid `description` setting (' + f + ') for \"' + (this.name || this.track.name) + '\" track, falling back to \"note,description\"');\n                                f = defaultFields;\n                            }\n                            f = f.toLowerCase().split(/\\s*\\,\\s*/);\n                        } else {\n                            f = [];\n                        }\n                        this.descriptionFields[field] = f;\n                        return f;\n                    }.call(this);\n\n                    // return the value of the first field that contains something\n                    for (var i = 0; i < fields.length; i++) {\n                        var d = feature.get(fields[i]);\n                        if (d) return d;\n                    }\n                    return null;\n                }\n        }\n\n    });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/View/_FeatureDescriptionMixin.js?");

/***/ }),

/***/ "./src/JBrowse/has.js":
/*!****************************!*\
  !*** ./src/JBrowse/has.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Extends dojo/has with a few additional tests, and makes sure dojo/sniff is loaded.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! dojo/sniff */ \"./node_modules/dojo/sniff.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (has) {\n\n    // does the browser support typed arrays?\n    has.add('typed-arrays', function () {\n        try {\n            var a = new Uint8Array(1);\n            return !!a;\n        } catch (e) {};\n        return false;\n    });\n\n    // does it support canvas?\n    has.add('canvas', function () {\n        try {\n            return !!document.createElement('canvas').getContext('2d');\n        } catch (e) {}\n        return false;\n    });\n\n    // some browsers don't do a very good job with\n    // percentage-based and fractional-pixel HTML coordinates\n    // and sizes\n    has.add('inaccurate-html-layout', function () {\n        return has('safari') || has('ie') < 9;\n    }, true);\n\n    has.add('save-generated-files', function () {\n        var canSave = false;\n        try {\n            canSave = Blob && !(has('ie') < 10) && !(has('safari') < 10);\n        } catch (e) {}\n        return canSave;\n    }, true);\n\n    // similar to the inaccurate-html-layout problem, but specifically related to width being 100%\n    // rounding on canvas features at the time being\n    has.add('inaccurate-html-width', function () {\n        return has('safari') || has('chrome');\n    }, true);\n\n    return has;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/JBrowse/has.js?");

/***/ }),

/***/ "./src/JBrowse/package.json":
/*!**********************************!*\
  !*** ./src/JBrowse/package.json ***!
  \**********************************/
/*! exports provided: name, version, copyright, main, dependencies, description, licenses, bugs, keywords, homepage, dojoBuild, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"JBrowse\\\",\\\"version\\\":\\\"1.16.9-alpha.0\\\",\\\"copyright\\\":\\\"© 2007-2017 The Evolutionary Software Foundation\\\",\\\"main\\\":\\\"main\\\",\\\"dependencies\\\":{\\\"dojo\\\":\\\"current\\\",\\\"dijit\\\":\\\"current\\\",\\\"dojox\\\":\\\"current\\\",\\\"util\\\":\\\"current\\\"},\\\"description\\\":\\\"A modern client-side genome browser.\\\",\\\"licenses\\\":[{\\\"type\\\":\\\"LGPL-2.1\\\",\\\"url\\\":\\\"https://raw.github.com/GMOD/jbrowse/master/LICENSE\\\"}],\\\"bugs\\\":\\\"https://github.com/gmod/jbrowse/issues\\\",\\\"keywords\\\":[\\\"JavaScript\\\",\\\"JBrowse\\\",\\\"Genome Browser\\\",\\\"Genomics\\\",\\\"Bioinformatics\\\"],\\\"homepage\\\":\\\"http://jbrowse.org\\\",\\\"dojoBuild\\\":\\\"JBrowse.profile.js\\\"}\");\n\n//# sourceURL=webpack:///./src/JBrowse/package.json?");

/***/ }),

/***/ "./src/jdataview-1.1-patch.X.js":
/*!**************************************!*\
  !*** ./src/jdataview-1.1-patch.X.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {//\n// jDataView by Vjeux - Jan 2010\n//\n// A unique way to read a binary file in the browser\n// http://github.com/vjeux/jDataView\n// http://blog.vjeux.com/ <vjeuxx@gmail.com>\n//\n\n(function (global) {\n\n\tvar compatibility = {\n\t\tArrayBuffer: typeof ArrayBuffer !== 'undefined',\n\t\tDataView: typeof DataView !== 'undefined' && ('getFloat64' in DataView.prototype || // Chrome\n\t\t'getFloat64' in new DataView(new ArrayBuffer(1))), // Node\n\t\t// NodeJS Buffer in v0.5.5 and newer\n\t\tNodeBuffer: false //typeof Buffer !== 'undefined' && 'readInt16LE' in Buffer.prototype\n\t};\n\n\tvar dataTypes = {\n\t\t'Int8': 1,\n\t\t'Int16': 2,\n\t\t'Int32': 4,\n\t\t'Uint8': 1,\n\t\t'Uint16': 2,\n\t\t'Uint32': 4,\n\t\t'Float32': 4,\n\t\t'Float64': 8\n\t};\n\n\tvar nodeNaming = {\n\t\t'Int8': 'Int8',\n\t\t'Int16': 'Int16',\n\t\t'Int32': 'Int32',\n\t\t'Uint8': 'UInt8',\n\t\t'Uint16': 'UInt16',\n\t\t'Uint32': 'UInt32',\n\t\t'Float32': 'Float',\n\t\t'Float64': 'Double'\n\t};\n\n\tvar jDataView = function jDataView(buffer, byteOffset, byteLength, littleEndian) {\n\t\tif (!(this instanceof jDataView)) {\n\t\t\tthrow new Error(\"jDataView constructor may not be called as a function\");\n\t\t}\n\n\t\tthis.buffer = buffer;\n\n\t\t// Handle Type Errors\n\t\tif (!(compatibility.NodeBuffer && buffer instanceof Buffer) && !(compatibility.ArrayBuffer && buffer instanceof ArrayBuffer) && typeof buffer !== 'string') {\n\t\t\tthrow new TypeError('jDataView buffer has an incompatible type');\n\t\t}\n\n\t\t// Check parameters and existing functionnalities\n\t\tthis._isArrayBuffer = compatibility.ArrayBuffer && buffer instanceof ArrayBuffer;\n\t\tthis._isDataView = compatibility.DataView && this._isArrayBuffer;\n\t\tthis._isNodeBuffer = compatibility.NodeBuffer && buffer instanceof Buffer;\n\n\t\t// Default Values\n\t\tthis._littleEndian = Boolean(littleEndian);\n\n\t\tvar bufferLength = this._isArrayBuffer ? buffer.byteLength : buffer.length;\n\t\tif (byteOffset === undefined) {\n\t\t\tbyteOffset = 0;\n\t\t}\n\t\tthis.byteOffset = byteOffset;\n\n\t\tif (byteLength === undefined) {\n\t\t\tbyteLength = bufferLength - byteOffset;\n\t\t}\n\t\tthis.byteLength = byteLength;\n\n\t\tif (!this._isDataView) {\n\t\t\t// Do additional checks to simulate DataView\n\t\t\tif (typeof byteOffset !== 'number') {\n\t\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t\t}\n\t\t\tif (typeof byteLength !== 'number') {\n\t\t\t\tthrow new TypeError('jDataView byteLength is not a number');\n\t\t\t}\n\t\t\tif (byteOffset < 0) {\n\t\t\t\tthrow new Error('jDataView byteOffset is negative');\n\t\t\t}\n\t\t\tif (byteLength < 0) {\n\t\t\t\tthrow new Error('jDataView byteLength is negative');\n\t\t\t}\n\t\t}\n\n\t\t// Instanciate\n\t\tif (this._isDataView) {\n\t\t\tthis._view = new DataView(buffer, byteOffset, byteLength);\n\t\t\tthis._start = 0;\n\t\t}\n\t\tthis._start = byteOffset;\n\t\tif (byteOffset + byteLength > bufferLength) {\n\t\t\tthrow new Error(\"jDataView (byteOffset + byteLength) value is out of bounds\");\n\t\t}\n\n\t\tthis._offset = 0;\n\n\t\t// Create uniform reading methods (wrappers) for the following data types\n\n\t\tif (this._isDataView) {\n\t\t\t// DataView: we use the direct method\n\t\t\tfor (var type in dataTypes) {\n\t\t\t\tif (!dataTypes.hasOwnProperty(type)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t(function (type, view) {\n\t\t\t\t\tvar size = dataTypes[type];\n\t\t\t\t\tview['get' + type] = function (byteOffset, littleEndian) {\n\t\t\t\t\t\t// Handle the lack of endianness\n\t\t\t\t\t\tif (littleEndian === undefined) {\n\t\t\t\t\t\t\tlittleEndian = view._littleEndian;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\t\t\tif (byteOffset === undefined) {\n\t\t\t\t\t\t\tbyteOffset = view._offset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move the internal offset forward\n\t\t\t\t\t\tview._offset = byteOffset + size;\n\n\t\t\t\t\t\treturn view._view['get' + type](byteOffset, littleEndian);\n\t\t\t\t\t};\n\t\t\t\t})(type, this);\n\t\t\t}\n\t\t} else if (this._isNodeBuffer && compatibility.NodeBuffer) {\n\t\t\tfor (var type in dataTypes) {\n\t\t\t\tif (!dataTypes.hasOwnProperty(type)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar name;\n\t\t\t\tif (type === 'Int8' || type === 'Uint8') {\n\t\t\t\t\tname = 'read' + nodeNaming[type];\n\t\t\t\t} else if (littleEndian) {\n\t\t\t\t\tname = 'read' + nodeNaming[type] + 'LE';\n\t\t\t\t} else {\n\t\t\t\t\tname = 'read' + nodeNaming[type] + 'BE';\n\t\t\t\t}\n\n\t\t\t\t(function (type, view, name) {\n\t\t\t\t\tvar size = dataTypes[type];\n\t\t\t\t\tview['get' + type] = function (byteOffset, littleEndian) {\n\t\t\t\t\t\t// Handle the lack of endianness\n\t\t\t\t\t\tif (littleEndian === undefined) {\n\t\t\t\t\t\t\tlittleEndian = view._littleEndian;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\t\t\tif (byteOffset === undefined) {\n\t\t\t\t\t\t\tbyteOffset = view._offset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move the internal offset forward\n\t\t\t\t\t\tview._offset = byteOffset + size;\n\n\t\t\t\t\t\treturn view.buffer[name](view._start + byteOffset);\n\t\t\t\t\t};\n\t\t\t\t})(type, this, name);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var type in dataTypes) {\n\t\t\t\tif (!dataTypes.hasOwnProperty(type)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t(function (type, view) {\n\t\t\t\t\tvar size = dataTypes[type];\n\t\t\t\t\tview['get' + type] = function (byteOffset, littleEndian) {\n\t\t\t\t\t\t// Handle the lack of endianness\n\t\t\t\t\t\tif (littleEndian === undefined) {\n\t\t\t\t\t\t\tlittleEndian = view._littleEndian;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\t\t\tif (byteOffset === undefined) {\n\t\t\t\t\t\t\tbyteOffset = view._offset;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move the internal offset forward\n\t\t\t\t\t\tview._offset = byteOffset + size;\n\n\t\t\t\t\t\tif (view._isArrayBuffer && (view._start + byteOffset) % size === 0 && (size === 1 || littleEndian)) {\n\t\t\t\t\t\t\t// ArrayBuffer: we use a typed array of size 1 if the alignment is good\n\t\t\t\t\t\t\t// ArrayBuffer does not support endianess flag (for size > 1)\n\t\t\t\t\t\t\treturn new global[type + 'Array'](view.buffer, view._start + byteOffset, 1)[0];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Error checking:\n\t\t\t\t\t\t\tif (typeof byteOffset !== 'number') {\n\t\t\t\t\t\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (byteOffset + size > view.byteLength) {\n\t\t\t\t\t\t\t\tthrow new Error('jDataView (byteOffset + size) value is out of bounds');\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn view['_get' + type](view._start + byteOffset, littleEndian);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t})(type, this);\n\t\t\t}\n\t\t}\n\t};\n\n\tif (compatibility.NodeBuffer) {\n\t\tjDataView.createBuffer = function () {\n\t\t\treturn new Buffer(arguments);\n\t\t};\n\t} else if (compatibility.ArrayBuffer) {\n\t\tjDataView.createBuffer = function () {\n\t\t\treturn new Uint8Array(arguments).buffer;\n\t\t};\n\t} else {\n\t\tjDataView.createBuffer = function () {\n\t\t\treturn String.fromCharCode.apply(null, arguments);\n\t\t};\n\t}\n\n\tjDataView.prototype = {\n\t\tcompatibility: compatibility,\n\n\t\t// Helpers\n\n\t\t_getBytes: function _getBytes(length, byteOffset, littleEndian) {\n\t\t\tvar result;\n\n\t\t\t// Handle the lack of endianness\n\t\t\tif (littleEndian === undefined) {\n\t\t\t\tlittleEndian = this._littleEndian;\n\t\t\t}\n\n\t\t\t// Handle the lack of byteOffset\n\t\t\tif (byteOffset === undefined) {\n\t\t\t\tbyteOffset = this._offset;\n\t\t\t}\n\n\t\t\t// Error Checking\n\t\t\tif (typeof byteOffset !== 'number') {\n\t\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t\t}\n\t\t\tif (length < 0 || byteOffset + length > this.byteLength) {\n\t\t\t\tthrow new Error('jDataView length or (byteOffset+length) value is out of bounds');\n\t\t\t}\n\n\t\t\tbyteOffset += this._start;\n\n\t\t\tif (this._isArrayBuffer) {\n\t\t\t\tresult = new Uint8Array(this.buffer, byteOffset, length);\n\t\t\t} else {\n\t\t\t\tresult = this.buffer.slice(byteOffset, byteOffset + length);\n\n\t\t\t\tif (!this._isNodeBuffer) {\n\t\t\t\t\tresult = Array.prototype.map.call(result, function (char) {\n\t\t\t\t\t\treturn char.charCodeAt(0) & 0xff;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (littleEndian && length > 1) {\n\t\t\t\tif (!(result instanceof Array)) {\n\t\t\t\t\tresult = Array.prototype.slice.call(result);\n\t\t\t\t}\n\n\t\t\t\tresult.reverse();\n\t\t\t}\n\n\t\t\tthis._offset = byteOffset - this._start + length;\n\n\t\t\treturn result;\n\t\t},\n\n\t\t// wrapper for external calls (do not return inner buffer directly to prevent it's modifying)\n\t\tgetBytes: function getBytes(length, byteOffset, littleEndian) {\n\t\t\tvar result = this._getBytes.apply(this, arguments);\n\n\t\t\tif (!(result instanceof Array)) {\n\t\t\t\tresult = Array.prototype.slice.call(result);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\tgetString: function getString(length, byteOffset) {\n\t\t\tvar value;\n\n\t\t\tif (this._isNodeBuffer) {\n\t\t\t\t// Handle the lack of byteOffset\n\t\t\t\tif (byteOffset === undefined) {\n\t\t\t\t\tbyteOffset = this._offset;\n\t\t\t\t}\n\n\t\t\t\t// Error Checking\n\t\t\t\tif (typeof byteOffset !== 'number') {\n\t\t\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t\t\t}\n\t\t\t\tif (length < 0 || byteOffset + length > this.byteLength) {\n\t\t\t\t\tthrow new Error('jDataView length or (byteOffset+length) value is out of bounds');\n\t\t\t\t}\n\n\t\t\t\tvalue = this.buffer.toString('ascii', this._start + byteOffset, this._start + byteOffset + length);\n\t\t\t\tthis._offset = byteOffset + length;\n\t\t\t} else {\n\t\t\t\tvalue = String.fromCharCode.apply(null, this._getBytes(length, byteOffset, false));\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\n\t\tgetChar: function getChar(byteOffset) {\n\t\t\treturn this.getString(1, byteOffset);\n\t\t},\n\n\t\ttell: function tell() {\n\t\t\treturn this._offset;\n\t\t},\n\n\t\tseek: function seek(byteOffset) {\n\t\t\tif (typeof byteOffset !== 'number') {\n\t\t\t\tthrow new TypeError('jDataView byteOffset is not a number');\n\t\t\t}\n\t\t\tif (byteOffset < 0 || byteOffset > this.byteLength) {\n\t\t\t\tthrow new Error('jDataView byteOffset value is out of bounds');\n\t\t\t}\n\n\t\t\treturn this._offset = byteOffset;\n\t\t},\n\n\t\t// Compatibility functions on a String Buffer\n\n\t\t_getFloat64: function _getFloat64(byteOffset, littleEndian) {\n\t\t\tvar b = this._getBytes(8, byteOffset, littleEndian),\n\t\t\t    sign = 1 - 2 * (b[0] >> 7),\n\t\t\t    exponent = ((b[0] << 1 & 0xff) << 3 | b[1] >> 4) - (Math.pow(2, 10) - 1),\n\n\n\t\t\t// Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead\n\t\t\tmantissa = (b[1] & 0x0f) * Math.pow(2, 48) + b[2] * Math.pow(2, 40) + b[3] * Math.pow(2, 32) + b[4] * Math.pow(2, 24) + b[5] * Math.pow(2, 16) + b[6] * Math.pow(2, 8) + b[7];\n\n\t\t\tif (exponent === 1024) {\n\t\t\t\tif (mantissa !== 0) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t} else {\n\t\t\t\t\treturn sign * Infinity;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (exponent === -1023) {\n\t\t\t\t// Denormalized\n\t\t\t\treturn sign * mantissa * Math.pow(2, -1022 - 52);\n\t\t\t}\n\n\t\t\treturn sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);\n\t\t},\n\n\t\t_getFloat32: function _getFloat32(byteOffset, littleEndian) {\n\t\t\tvar b = this._getBytes(4, byteOffset, littleEndian),\n\t\t\t    sign = 1 - 2 * (b[0] >> 7),\n\t\t\t    exponent = (b[0] << 1 & 0xff | b[1] >> 7) - 127,\n\t\t\t    mantissa = (b[1] & 0x7f) << 16 | b[2] << 8 | b[3];\n\n\t\t\tif (exponent === 128) {\n\t\t\t\tif (mantissa !== 0) {\n\t\t\t\t\treturn NaN;\n\t\t\t\t} else {\n\t\t\t\t\treturn sign * Infinity;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (exponent === -127) {\n\t\t\t\t// Denormalized\n\t\t\t\treturn sign * mantissa * Math.pow(2, -126 - 23);\n\t\t\t}\n\n\t\t\treturn sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);\n\t\t},\n\n\t\t_getInt32: function _getInt32(byteOffset, littleEndian) {\n\t\t\tvar b = this._getUint32(byteOffset, littleEndian);\n\t\t\treturn b > Math.pow(2, 31) - 1 ? b - Math.pow(2, 32) : b;\n\t\t},\n\n\t\t_getUint32: function _getUint32(byteOffset, littleEndian) {\n\t\t\tvar b = this._getBytes(4, byteOffset, littleEndian);\n\t\t\treturn b[3] * Math.pow(2, 24) + (b[2] << 16) + (b[1] << 8) + b[0];\n\t\t},\n\n\t\t_getInt16: function _getInt16(byteOffset, littleEndian) {\n\t\t\tvar b = this._getUint16(byteOffset, littleEndian);\n\t\t\treturn b > Math.pow(2, 15) - 1 ? b - Math.pow(2, 16) : b;\n\t\t},\n\n\t\t_getUint16: function _getUint16(byteOffset, littleEndian) {\n\t\t\tvar b = this._getBytes(2, byteOffset, littleEndian);\n\t\t\treturn (b[1] << 8) + b[0];\n\t\t},\n\n\t\t_getInt8: function _getInt8(byteOffset) {\n\t\t\tvar b = this._getUint8(byteOffset);\n\t\t\treturn b > Math.pow(2, 7) - 1 ? b - Math.pow(2, 8) : b;\n\t\t},\n\n\t\t_getUint8: function _getUint8(byteOffset) {\n\t\t\treturn this._getBytes(1, byteOffset)[0];\n\t\t}\n\t};\n\n\tif (typeof jQuery !== 'undefined' && jQuery.fn.jquery >= \"1.6.2\") {\n\t\tvar convertResponseBodyToText = function convertResponseBodyToText(byteArray) {\n\t\t\t// http://jsperf.com/vbscript-binary-download/6\n\t\t\tvar scrambledStr;\n\t\t\ttry {\n\t\t\t\tscrambledStr = IEBinaryToArray_ByteStr(byteArray);\n\t\t\t} catch (e) {\n\t\t\t\t// http://stackoverflow.com/questions/1919972/how-do-i-access-xhr-responsebody-for-binary-data-from-javascript-in-ie\n\t\t\t\t// http://miskun.com/javascript/internet-explorer-and-binary-files-data-access/\n\t\t\t\tvar IEBinaryToArray_ByteStr_Script = \"Function IEBinaryToArray_ByteStr(Binary)\\r\\n\" + \"\tIEBinaryToArray_ByteStr = CStr(Binary)\\r\\n\" + \"End Function\\r\\n\" + \"Function IEBinaryToArray_ByteStr_Last(Binary)\\r\\n\" + \"\tDim lastIndex\\r\\n\" + \"\tlastIndex = LenB(Binary)\\r\\n\" + \"\tif lastIndex mod 2 Then\\r\\n\" + \"\t\tIEBinaryToArray_ByteStr_Last = AscB( MidB( Binary, lastIndex, 1 ) )\\r\\n\" + \"\tElse\\r\\n\" + \"\t\tIEBinaryToArray_ByteStr_Last = -1\\r\\n\" + \"\tEnd If\\r\\n\" + \"End Function\\r\\n\";\n\n\t\t\t\t// http://msdn.microsoft.com/en-us/library/ms536420(v=vs.85).aspx\n\t\t\t\t// proprietary IE function\n\t\t\t\twindow.execScript(IEBinaryToArray_ByteStr_Script, 'vbscript');\n\n\t\t\t\tscrambledStr = IEBinaryToArray_ByteStr(byteArray);\n\t\t\t}\n\n\t\t\tvar lastChr = IEBinaryToArray_ByteStr_Last(byteArray),\n\t\t\t    result = \"\",\n\t\t\t    i = 0,\n\t\t\t    l = scrambledStr.length % 8,\n\t\t\t    thischar;\n\t\t\twhile (i < l) {\n\t\t\t\tthischar = scrambledStr.charCodeAt(i++);\n\t\t\t\tresult += String.fromCharCode(thischar & 0xff, thischar >> 8);\n\t\t\t}\n\t\t\tl = scrambledStr.length;\n\t\t\twhile (i < l) {\n\t\t\t\tresult += String.fromCharCode((thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 0xff), thischar >> 8);\n\t\t\t}\n\t\t\tif (lastChr > -1) {\n\t\t\t\tresult += String.fromCharCode(lastChr);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tjQuery.ajaxSetup({\n\t\t\tconverters: {\n\t\t\t\t'* dataview': function dataview(data) {\n\t\t\t\t\treturn new jDataView(data);\n\t\t\t\t}\n\t\t\t},\n\t\t\taccepts: {\n\t\t\t\tdataview: \"text/plain; charset=x-user-defined\"\n\t\t\t},\n\t\t\tresponseHandler: {\n\t\t\t\tdataview: function dataview(responses, options, xhr) {\n\t\t\t\t\t// Array Buffer Firefox\n\t\t\t\t\tif ('mozResponseArrayBuffer' in xhr) {\n\t\t\t\t\t\tresponses.text = xhr.mozResponseArrayBuffer;\n\t\t\t\t\t}\n\t\t\t\t\t// Array Buffer Chrome\n\t\t\t\t\telse if ('responseType' in xhr && xhr.responseType === 'arraybuffer' && xhr.response) {\n\t\t\t\t\t\t\tresponses.text = xhr.response;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Internet Explorer (Byte array accessible through VBScript -- convert to text)\n\t\t\t\t\t\telse if ('responseBody' in xhr) {\n\t\t\t\t\t\t\t\tresponses.text = convertResponseBodyToText(xhr.responseBody);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Older Browsers\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tjQuery.ajaxPrefilter('dataview', function (options, originalOptions, jqXHR) {\n\t\t\t// trying to set the responseType on IE 6 causes an error\n\t\t\tif (jQuery.support.ajaxResponseType) {\n\t\t\t\tif (!options.hasOwnProperty('xhrFields')) {\n\t\t\t\t\toptions.xhrFields = {};\n\t\t\t\t}\n\t\t\t\toptions.xhrFields.responseType = 'arraybuffer';\n\t\t\t}\n\t\t\toptions.mimeType = 'text/plain; charset=x-user-defined';\n\t\t});\n\t}\n\n\tglobal.jDataView = (global.module || {}).exports = jDataView;\n\tif (true) {\n\t\tmodule.exports = jDataView;\n\t}\n})(window);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./src/jdataview-1.1-patch.X.js?");

/***/ }),

/***/ "./src/lazyload.js":
/*!*************************!*\
  !*** ./src/lazyload.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jslint browser: true, eqeqeq: true, bitwise: true, newcap: true, immed: true, regexp: false */\n\n/**\nLazyLoad makes it easy and painless to lazily load one or more external\nJavaScript or CSS files on demand either during or after the rendering of a web\npage.\n\nSupported browsers include Firefox 2+, IE6+, Safari 3+ (including Mobile\nSafari), Google Chrome, and Opera 9+. Other browsers may or may not work and\nare not officially supported.\n\nVisit https://github.com/rgrove/lazyload/ for more info.\n\nCopyright (c) 2011 Ryan Grove <ryan@wonko.com>\nAll rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the 'Software'), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n@module lazyload\n@class LazyLoad\n@static\n@version 2.0.3 (git)\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  var LazyLoad = function (doc) {\n    // -- Private Variables ------------------------------------------------------\n\n    // User agent and feature test information.\n    var env,\n\n\n    // Reference to the <head> element (populated lazily).\n    head,\n\n\n    // Requests currently in progress, if any.\n    pending = {},\n\n\n    // Number of times we've polled to check whether a pending stylesheet has\n    // finished loading. If this gets too high, we're probably stalled.\n    pollCount = 0,\n\n\n    // Queued requests.\n    queue = { css: [], js: [] },\n\n\n    // Reference to the browser's list of stylesheets.\n    styleSheets = doc.styleSheets;\n\n    // -- Private Methods --------------------------------------------------------\n\n    /**\n    Creates and returns an HTML element with the specified name and attributes.\n     @method createNode\n    @param {String} name element name\n    @param {Object} attrs name/value mapping of element attributes\n    @return {HTMLElement}\n    @private\n    */\n    function createNode(name, attrs) {\n      var node = doc.createElement(name),\n          attr;\n\n      for (attr in attrs) {\n        if (attrs.hasOwnProperty(attr)) {\n          node.setAttribute(attr, attrs[attr]);\n        }\n      }\n\n      return node;\n    }\n\n    /**\n    Called when the current pending resource of the specified type has finished\n    loading. Executes the associated callback (if any) and loads the next\n    resource in the queue.\n     @method finish\n    @param {String} type resource type ('css' or 'js')\n    @private\n    */\n    function finish(type) {\n      var p = pending[type],\n          callback,\n          urls;\n\n      if (p) {\n        callback = p.callback;\n        urls = p.urls;\n\n        urls.shift();\n        pollCount = 0;\n\n        // If this is the last of the pending URLs, execute the callback and\n        // start the next request in the queue (if any).\n        if (!urls.length) {\n          callback && callback.call(p.context, p.obj);\n          pending[type] = null;\n          queue[type].length && load(type);\n        }\n      }\n    }\n\n    /**\n    Populates the <code>env</code> variable with user agent and feature test\n    information.\n     @method getEnv\n    @private\n    */\n    function getEnv() {\n      var ua = navigator.userAgent;\n\n      env = {\n        // True if this browser supports disabling async mode on dynamically\n        // created script nodes. See\n        // http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n        async: doc.createElement('script').async === true\n      };\n\n      (env.webkit = /AppleWebKit\\//.test(ua)) || (env.ie = /MSIE/.test(ua)) || (env.opera = /Opera/.test(ua)) || (env.gecko = /Gecko\\//.test(ua)) || (env.unknown = true);\n    }\n\n    /**\n    Loads the specified resources, or the next resource of the specified type\n    in the queue if no resources are specified. If a resource of the specified\n    type is already being loaded, the new request will be queued until the\n    first request has been finished.\n     When an array of resource URLs is specified, those URLs will be loaded in\n    parallel if it is possible to do so while preserving execution order. All\n    browsers support parallel loading of CSS, but only Firefox and Opera\n    support parallel loading of scripts. In other browsers, scripts will be\n    queued and loaded one at a time to ensure correct execution order.\n     @method load\n    @param {String} type resource type ('css' or 'js')\n    @param {String|Array} urls (optional) URL or array of URLs to load\n    @param {Function} callback (optional) callback function to execute when the\n      resource is loaded\n    @param {Object} obj (optional) object to pass to the callback function\n    @param {Object} context (optional) if provided, the callback function will\n      be executed in this object's context\n    @private\n    */\n    function load(type, urls, callback, obj, context) {\n      var _finish = function _finish() {\n        finish(type);\n      },\n          isCSS = type === 'css',\n          nodes = [],\n          i,\n          len,\n          node,\n          p,\n          pendingUrls,\n          url;\n\n      env || getEnv();\n\n      if (urls) {\n        // If urls is a string, wrap it in an array. Otherwise assume it's an\n        // array and create a copy of it so modifications won't be made to the\n        // original.\n        urls = typeof urls === 'string' ? [urls] : urls.concat();\n\n        // Create a request object for each URL. If multiple URLs are specified,\n        // the callback will only be executed after all URLs have been loaded.\n        //\n        // Sadly, Firefox and Opera are the only browsers capable of loading\n        // scripts in parallel while preserving execution order. In all other\n        // browsers, scripts must be loaded sequentially.\n        //\n        // All browsers respect CSS specificity based on the order of the link\n        // elements in the DOM, regardless of the order in which the stylesheets\n        // are actually downloaded.\n        if (isCSS || env.async || env.gecko || env.opera) {\n          // Load in parallel.\n          queue[type].push({\n            urls: urls,\n            callback: callback,\n            obj: obj,\n            context: context\n          });\n        } else {\n          // Load sequentially.\n          for (i = 0, len = urls.length; i < len; ++i) {\n            queue[type].push({\n              urls: [urls[i]],\n              callback: i === len - 1 ? callback : null, // callback is only added to the last URL\n              obj: obj,\n              context: context\n            });\n          }\n        }\n      }\n\n      // If a previous load request of this type is currently in progress, we'll\n      // wait our turn. Otherwise, grab the next item in the queue.\n      if (pending[type] || !(p = pending[type] = queue[type].shift())) {\n        return;\n      }\n\n      head || (head = doc.head || doc.getElementsByTagName('head')[0]);\n      pendingUrls = p.urls;\n\n      for (i = 0, len = pendingUrls.length; i < len; ++i) {\n        url = pendingUrls[i];\n\n        if (isCSS) {\n          node = env.gecko ? createNode('style') : createNode('link', {\n            href: url,\n            rel: 'stylesheet'\n          });\n        } else {\n          node = createNode('script', { src: url });\n          node.async = false;\n        }\n\n        node.className = 'lazyload';\n        node.setAttribute('charset', 'utf-8');\n\n        if (env.ie && !isCSS) {\n          node.onreadystatechange = function () {\n            if (/loaded|complete/.test(node.readyState)) {\n              node.onreadystatechange = null;\n              _finish();\n            }\n          };\n        } else if (isCSS && (env.gecko || env.webkit)) {\n          // Gecko and WebKit don't support the onload event on link nodes.\n          if (env.webkit) {\n            // In WebKit, we can poll for changes to document.styleSheets to\n            // figure out when stylesheets have loaded.\n            p.urls[i] = node.href; // resolve relative URLs (or polling won't work)\n            pollWebKit();\n          } else {\n            // In Gecko, we can import the requested URL into a <style> node and\n            // poll for the existence of node.sheet.cssRules. Props to Zach\n            // Leatherman for calling my attention to this technique.\n            node.innerHTML = '@import \"' + url + '\";';\n            pollGecko(node);\n          }\n        } else {\n          node.onload = node.onerror = _finish;\n        }\n\n        nodes.push(node);\n      }\n\n      for (i = 0, len = nodes.length; i < len; ++i) {\n        head.appendChild(nodes[i]);\n      }\n    }\n\n    /**\n    Begins polling to determine when the specified stylesheet has finished loading\n    in Gecko. Polling stops when all pending stylesheets have loaded or after 10\n    seconds (to prevent stalls).\n     Thanks to Zach Leatherman for calling my attention to the @import-based\n    cross-domain technique used here, and to Oleg Slobodskoi for an earlier\n    same-domain implementation. See Zach's blog for more details:\n    http://www.zachleat.com/web/2010/07/29/load-css-dynamically/\n     @method pollGecko\n    @param {HTMLElement} node Style node to poll.\n    @private\n    */\n    function pollGecko(node) {\n      var hasRules;\n\n      try {\n        // We don't really need to store this value or ever refer to it again, but\n        // if we don't store it, Closure Compiler assumes the code is useless and\n        // removes it.\n        hasRules = !!node.sheet.cssRules;\n      } catch (ex) {\n        // An exception means the stylesheet is still loading.\n        pollCount += 1;\n\n        if (pollCount < 200) {\n          setTimeout(function () {\n            pollGecko(node);\n          }, 50);\n        } else {\n          // We've been polling for 10 seconds and nothing's happened. Stop\n          // polling and finish the pending requests to avoid blocking further\n          // requests.\n          hasRules && finish('css');\n        }\n\n        return;\n      }\n\n      // If we get here, the stylesheet has loaded.\n      finish('css');\n    }\n\n    /**\n    Begins polling to determine when pending stylesheets have finished loading\n    in WebKit. Polling stops when all pending stylesheets have loaded or after 10\n    seconds (to prevent stalls).\n     @method pollWebKit\n    @private\n    */\n    function pollWebKit() {\n      var css = pending.css,\n          i;\n\n      if (css) {\n        i = styleSheets.length;\n\n        // Look for a stylesheet matching the pending URL.\n        while (--i >= 0) {\n          if (styleSheets[i].href === css.urls[0]) {\n            finish('css');\n            break;\n          }\n        }\n\n        pollCount += 1;\n\n        if (css) {\n          if (pollCount < 200) {\n            setTimeout(pollWebKit, 50);\n          } else {\n            // We've been polling for 10 seconds and nothing's happened, which may\n            // indicate that the stylesheet has been removed from the document\n            // before it had a chance to load. Stop polling and finish the pending\n            // request to prevent blocking further requests.\n            finish('css');\n          }\n        }\n      }\n    }\n\n    return {\n\n      /**\n      Requests the specified CSS URL or URLs and executes the specified\n      callback (if any) when they have finished loading. If an array of URLs is\n      specified, the stylesheets will be loaded in parallel and the callback\n      will be executed after all stylesheets have finished loading.\n       @method css\n      @param {String|Array} urls CSS URL or array of CSS URLs to load\n      @param {Function} callback (optional) callback function to execute when\n        the specified stylesheets are loaded\n      @param {Object} obj (optional) object to pass to the callback function\n      @param {Object} context (optional) if provided, the callback function\n        will be executed in this object's context\n      @static\n      */\n      css: function css(urls, callback, obj, context) {\n        load('css', urls, callback, obj, context);\n      },\n\n      /**\n      Requests the specified JavaScript URL or URLs and executes the specified\n      callback (if any) when they have finished loading. If an array of URLs is\n      specified and the browser supports it, the scripts will be loaded in\n      parallel and the callback will be executed after all scripts have\n      finished loading.\n       Currently, only Firefox and Opera support parallel loading of scripts while\n      preserving execution order. In other browsers, scripts will be\n      queued and loaded one at a time to ensure correct execution order.\n       @method js\n      @param {String|Array} urls JS URL or array of JS URLs to load\n      @param {Function} callback (optional) callback function to execute when\n        the specified scripts are loaded\n      @param {Object} obj (optional) object to pass to the callback function\n      @param {Object} context (optional) if provided, the callback function\n        will be executed in this object's context\n      @static\n      */\n      js: function js(urls, callback, obj, context) {\n        load('js', urls, callback, obj, context);\n      }\n\n    };\n  }(document);\n\n  return LazyLoad;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./src/lazyload.js?");

/***/ }),

/***/ "./tests/data/human_bigbed/ENST00000610940.4.json":
/*!********************************************************!*\
  !*** ./tests/data/human_bigbed/ENST00000610940.4.json ***!
  \********************************************************/
/*! exports provided: data, _uniqueID, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"data\\\":{\\\"start\\\":18912776,\\\"end\\\":18936553,\\\"name\\\":\\\"ENST00000610940.4\\\",\\\"score\\\":1000,\\\"strand\\\":-1,\\\"thick_start\\\":18913177,\\\"thick_end\\\":18936287,\\\"reserved\\\":\\\"0,0,0\\\",\\\"block_count\\\":15,\\\"block_sizes\\\":[586,89,99,176,147,93,82,80,117,65,150,35,209,313,164],\\\"chrom_starts\\\":[0,661,4113,5539,6674,6929,8565,9548,10040,10338,12274,12911,18213,23238,23613],\\\"gene_id\\\":\\\"ENSG00000100033.16\\\",\\\"gene_name\\\":\\\"PRODH\\\",\\\"method\\\":\\\"protein_coding\\\",\\\"gene_bio_type\\\":\\\"protein_coding\\\",\\\"tags\\\":\\\"basic,appris_principal_3,CCDS\\\"},\\\"_uniqueID\\\":\\\"bb-53429\\\"}\");\n\n//# sourceURL=webpack:///./tests/data/human_bigbed/ENST00000610940.4.json?");

/***/ }),

/***/ "./tests/data/volvox.bb.expected.json":
/*!********************************************!*\
  !*** ./tests/data/volvox.bb.expected.json ***!
  \********************************************/
/*! exports provided: 0, 1, 2, 3, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"[{\\\"data\\\":{\\\"start\\\":1049,\\\"end\\\":9000,\\\"name\\\":\\\"EDEN.1\\\",\\\"score\\\":1000,\\\"strand\\\":1,\\\"thick_start\\\":1200,\\\"thick_end\\\":7608,\\\"reserved\\\":\\\"0,0,0\\\",\\\"block_count\\\":4,\\\"block_sizes\\\":[451,903,501,2001],\\\"chrom_starts\\\":[0,1950,3950,5950],\\\"gene_id\\\":\\\"EDEN\\\",\\\"gene_name\\\":\\\"EDEN\\\",\\\"method\\\":\\\"-\\\",\\\"gene_bio_type\\\":\\\"-\\\",\\\"tags\\\":\\\"-\\\"},\\\"_uniqueID\\\":\\\"bb-94\\\"},{\\\"data\\\":{\\\"start\\\":1049,\\\"end\\\":9000,\\\"name\\\":\\\"EDEN.2\\\",\\\"score\\\":1000,\\\"strand\\\":1,\\\"thick_start\\\":1200,\\\"thick_end\\\":7608,\\\"reserved\\\":\\\"0,0,0\\\",\\\"block_count\\\":3,\\\"block_sizes\\\":[451,501,2001],\\\"chrom_starts\\\":[0,3950,5950],\\\"gene_id\\\":\\\"EDEN\\\",\\\"gene_name\\\":\\\"EDEN\\\",\\\"method\\\":\\\"-\\\",\\\"gene_bio_type\\\":\\\"-\\\",\\\"tags\\\":\\\"-\\\"},\\\"_uniqueID\\\":\\\"bb-179\\\"},{\\\"data\\\":{\\\"start\\\":1299,\\\"end\\\":9000,\\\"name\\\":\\\"EDEN.3\\\",\\\"score\\\":1000,\\\"strand\\\":1,\\\"thick_start\\\":3300,\\\"thick_end\\\":7600,\\\"reserved\\\":\\\"0,0,0\\\",\\\"block_count\\\":4,\\\"block_sizes\\\":[201,903,501,2001],\\\"chrom_starts\\\":[0,1700,3700,5700],\\\"gene_id\\\":\\\"EDEN\\\",\\\"gene_name\\\":\\\"EDEN\\\",\\\"method\\\":\\\"-\\\",\\\"gene_bio_type\\\":\\\"-\\\",\\\"tags\\\":\\\"-\\\"},\\\"_uniqueID\\\":\\\"bb-273\\\"},{\\\"data\\\":{\\\"start\\\":17399,\\\"end\\\":23000,\\\"name\\\":\\\"rna-Apple3\\\",\\\"score\\\":1000,\\\"strand\\\":1,\\\"thick_start\\\":17999,\\\"thick_end\\\":21200,\\\"reserved\\\":\\\"0,0,0\\\",\\\"block_count\\\":3,\\\"block_sizes\\\":[1401,501,2001],\\\"chrom_starts\\\":[0,1600,3600],\\\"gene_id\\\":\\\"rna-Apple3\\\",\\\"gene_name\\\":\\\"rna-Apple3\\\",\\\"method\\\":\\\"-\\\",\\\"gene_bio_type\\\":\\\"-\\\",\\\"tags\\\":\\\"-\\\"},\\\"_uniqueID\\\":\\\"bb-377\\\"}]\");\n\n//# sourceURL=webpack:///./tests/data/volvox.bb.expected.json?");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ })

}]);