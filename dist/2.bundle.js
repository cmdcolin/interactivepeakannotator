(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	"JBrowse/Util":"./src/JBrowse/Util.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[2],{

/***/ "./src/JBrowse/Util.js":
/*!*****************************!*\
  !*** ./src/JBrowse/Util.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar url = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\n\n/**\n * Miscellaneous utility functions.\n */\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\"), __webpack_require__(/*! dojox/lang/functional/object */ \"./node_modules/dojox/lang/functional/object.js\"), __webpack_require__(/*! dojox/lang/functional/fold */ \"./node_modules/dojox/lang/functional/fold.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (array, lang, Deferred) {\n    var Util;\n    Util = {\n        dojof: dojox.lang.functional,\n        is_ie: navigator.appVersion.indexOf('MSIE') >= 0,\n        is_ie6: navigator.appVersion.indexOf('MSIE 6') >= 0,\n        addCommas: function addCommas(nStr) {\n            nStr += '';\n            var x = nStr.split('.');\n            var x1 = x[0];\n            var x2 = x.length > 1 ? '.' + x[1] : '';\n            var rgx = /(\\d+)(\\d{3})/;\n            while (rgx.test(x1)) {\n                x1 = x1.replace(rgx, '$1' + ',' + '$2');\n            }\n            return x1 + x2;\n        },\n\n        commifyNumber: function commifyNumber() {\n            return this.addCommas.apply(this, arguments);\n        },\n\n        escapeHTML: function escapeHTML(str) {\n            if (str === null || str === undefined) {\n                return str;\n            }\n            return str.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n        },\n\n        unescapeHTML: function unescapeHTML(str) {\n            return str.toString().replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n        },\n\n        /**\n         * Fast, simple class-maker, used for classes that need speed more\n         * than they need dojo.declare's nice features.\n         */\n        fastDeclare: function fastDeclare(members, className) {\n            var constructor = members.constructor;\n            var fastDeclareClass = function fastDeclareClass() {\n                constructor.apply(this, arguments);\n            };\n            dojo.mixin(fastDeclareClass.prototype, members);\n            return fastDeclareClass;\n        },\n\n        isRightButton: function isRightButton(e) {\n            if (!e) var e = window.event;\n            if (e.which) return e.which == 3;else if (e.button) return e.button == 2;else return false;\n        },\n\n        getViewportWidth: function getViewportWidth() {\n            var width = 0;\n            if (document.documentElement && document.documentElement.clientWidth) {\n                width = document.documentElement.clientWidth;\n            } else if (document.body && document.body.clientWidth) {\n                width = document.body.clientWidth;\n            } else if (window.innerWidth) {\n                width = window.innerWidth - 18;\n            }\n            return width;\n        },\n\n        getViewportHeight: function getViewportHeight() {\n            var height = 0;\n            if (document.documentElement && document.documentElement.clientHeight) {\n                height = document.documentElement.clientHeight;\n            } else if (document.body && document.body.clientHeight) {\n                height = document.body.clientHeight;\n            } else if (window.innerHeight) {\n                height = window.innerHeight - 18;\n            }\n            return height;\n        },\n\n        findNearest: function findNearest(numArray, num) {\n            var minIndex = 0;\n            var min = Math.abs(num - numArray[0]);\n            for (var i = 1; i < numArray.length; i++) {\n                if (Math.abs(num - numArray[i]) < min) {\n                    minIndex = i;\n                    min = Math.abs(num - numArray[i]);\n                }\n            }\n            return minIndex;\n        },\n\n        /**\n         * replace variables in a template string with values\n         * @param template String with variable names in curly brackets\n         *                 e.g., \"http://foo/{bar}?arg={baz.foo}\n         * @param fillWith object with attribute-value mappings\n         *                 e.g., { 'bar': 'someurl', 'baz': { 'foo': 42 } }\n         * @returns the template string with variables in fillWith replaced\n         *                 e.g., 'htp://foo/someurl?arg=valueforbaz'\n         *\n         */\n\n        fillTemplate: function fillTemplate(template, fillWith) {\n            return template.replace(/\\{([\\w\\s\\.]+)\\}/g, function (match, varname) {\n                varname = varname.replace(/\\s+/g, ''); // remove all whitespace\n                var fill = lang.getObject(varname, false, fillWith);\n                if (fill !== undefined) {\n                    if (typeof fill == 'function') return fill(varname);else return fill;\n                } else if (fillWith.callback) {\n                    var v = fillWith.callback.call(this, varname);\n                    if (v !== undefined) return v;\n                }\n                return match;\n            });\n        },\n\n        /**\n         * function to load a specified resource only once\n         * @param {Object}   dojoXhrArgs object containing arguments for dojo.xhrGet,\n         *                               like <code>url</code> and <code>handleAs</code>\n         * @param {Object}   stateObj object that stores the state of the load\n         * @param {Function} successCallback function to call on a successful load\n         * @param {Function} errorCallback function to call on an unsuccessful load\n         */\n        maybeLoad: function maybeLoad(dojoXhrArgs, stateObj, successCallback, errorCallback) {\n            if (stateObj.state) {\n                if (\"loaded\" == stateObj.state) {\n                    successCallback(stateObj.data);\n                } else if (\"error\" == stateObj.state) {\n                    errorCallback();\n                } else if (\"loading\" == stateObj.state) {\n                    stateObj.successCallbacks.push(successCallback);\n                    if (errorCallback) stateObj.errorCallbacks.push(errorCallback);\n                }\n            } else {\n                stateObj.state = \"loading\";\n                stateObj.successCallbacks = [successCallback];\n                stateObj.errorCallbacks = [errorCallback];\n\n                var args = dojo.clone(dojoXhrArgs);\n                args.load = function (o) {\n                    stateObj.state = \"loaded\";\n                    stateObj.data = o;\n                    var cbs = stateObj.successCallbacks;\n                    for (var c = 0; c < cbs.length; c++) {\n                        cbs[c](o);\n                    }\n                };\n                args.error = function (error) {\n                    console.error('' + error);\n                    stateObj.state = \"error\";\n                    var cbs = stateObj.errorCallbacks;\n                    for (var c = 0; c < cbs.length; c++) {\n                        cbs[c]();\n                    }\n                };\n\n                dojo.xhrGet(args);\n            }\n        },\n\n        /**\n         * updates a with values from b, recursively\n         */\n        deepUpdate: function deepUpdate(a, b) {\n            for (var prop in b) {\n                if (prop in a && \"object\" == _typeof(b[prop]) && \"object\" == _typeof(a[prop])) {\n                    Util.deepUpdate(a[prop], b[prop]);\n                } else if (typeof a[prop] == 'undefined' || typeof b[prop] != 'undefined') {\n                    a[prop] = b[prop];\n                }\n            }\n            return a;\n        },\n\n        humanReadableNumber: function humanReadableNumber(num) {\n            num = parseInt(num);\n            var suffix = '';\n            if (num >= 1e12) {\n                num /= 1e12;\n                suffix = 'T';\n            } else if (num >= 1e9) {\n                num /= 1e9;\n                suffix = 'G';\n            } else if (num >= 1e6) {\n                num /= 1e6;\n                suffix = 'M';\n            } else if (num >= 1000) {\n                num /= 1000;\n                suffix = 'K';\n            }\n\n            return (num.toFixed(2) + ' ' + suffix).replace(/0+ /, ' ').replace(/\\. /, ' ');\n        },\n\n        resolved: function resolved(val) {\n            var d = new Deferred();\n            d.resolve(val);\n            return d;\n        },\n\n        resolveUrl: function resolveUrl(baseUrl, relativeUrl) {\n            if (this.isElectron()) {\n                // url.resolve does not correctly resolve absolute file urls\n                if (relativeUrl.substr(0, 8) === 'file:///') return relativeUrl;\n            }\n            return url.resolve(baseUrl, relativeUrl);\n        },\n\n        loadJS: function loadJS(paths) {\n            var d = new Deferred();\n            dojo.global.require(paths, function () {\n                var modules = Array.prototype.slice.call(arguments);\n\n                // check the loaded modules for success\n                for (var i = 0; i < modules.length; i++) {\n                    if (!{ \"object\": true, \"function\": true }[_typeof(modules[i])]) {\n                        d.reject(\"could not load \" + paths[i] + \": \" + modules[i]);\n                        return;\n                    }\n                }\n\n                d.resolve(modules);\n            });\n            return d;\n        },\n\n        isElectron: function isElectron() {\n            var process = window.process;\n            return !!(process && process.versions && process.versions.electron);\n        },\n\n        parseLocString: function parseLocString(locstring) {\n            if (typeof locstring != 'string') return null;\n            locstring = locstring.trim();\n\n            var location = {};\n\n            // Strip out any extra info in parentheses?\n            var extraRegex = new RegExp([/^\\s*/ // optional whitespace at start of locstring\n            , /(.+?)/ // capture remaining characters, non-greedily, as the locstring without the \"extra\" info\n            , /(\\((.+?)\\))?/ // capture the contents of the perentheses, if they exist, as the \"extra\" info\n            , /\\s*$/ // optional whitespace at end locstring\n            ].map(function (r) {\n                return r.source;\n            }).join(''));\n\n            var tokens_extra = locstring.match(extraRegex);\n\n            locstring = tokens_extra[1];\n\n            if (tokens_extra[3]) {\n                location.extra = tokens_extra[3];\n            }\n\n            // Regex to match coordinate ranges, with or without a ref seq id\n            var rangeRegex = new RegExp([/^((.+):)?/ // ref seq id\n            , /\\s*/ // optional whitespace preceeding range\n            , /-?([\\d,]+(\\.\\d+)?)/ // extract positive integer part of first number - thousand separator (\",\") safe\n            , /\\s*/ // optional whitespace\n            , /(\\.{2,}|-+)/ // range separator of 2 or more dots OR 1 or more hyphen\n            , /\\s*/ // optional whitespace\n            , /-?([\\d,]+(\\.\\d+)?)/ // extract positive integer part of second number - thousand separator (\",\") safe\n            , /\\s*$/ // optional whitespace\n            ].map(function (r) {\n                return r.source;\n            }).join(''));\n\n            var rangeTokens = locstring.match(rangeRegex);\n\n            if (rangeTokens) {\n                // locstring specified a range\n                location.ref = rangeTokens[2];\n                location.start = Number(rangeTokens[3].replace(/\\,/g, ''));\n                location.end = Number(rangeTokens[6].replace(/\\,/g, ''));\n\n                // reverse the numbers if necessary\n                if (location.start > location.end) {\n                    var t = location.start;\n                    location.start = location.end;\n                    location.end = t;\n                }\n            } else {\n                // locstring comprises a single point location coordinate, with or without a ref seq id\n                var pointRegex = new RegExp([/^((.+):)?/ // ref\n                , /\\s*/ // optional whitespace\n                , /-?([\\d,]+(\\.\\d+)?)?/ // extract positive integer part of first number - thousand separator (\",\") safe\n                , /\\s*$/ // optional whitespace\n                ].map(function (r) {\n                    return r.source;\n                }).join(''));\n\n                var pointTokens = locstring.match(pointRegex);\n\n                if (pointTokens) {\n                    if (pointTokens[2]) {\n                        location.ref = pointTokens[2];\n                    }\n                    if (pointTokens[3]) {\n                        location.start = Number(pointTokens[3].replace(/\\,/g, ''));\n                        location.end = location.start;\n                    } else {\n                        return null;\n                    }\n                } else {\n                    return null;\n                }\n            }\n\n            // Make coordinates 0-start, half-open (like BED cordinates)\n            location.start = location.start - 1;\n\n            return location;\n        },\n\n        basename: function basename(str, suffixList) {\n            if (!str || !str.match) return undefined;\n            var m = str.match(/[\\/\\\\]([^\\/\\\\]+)[\\/\\/\\/]*$/);\n            var bn = m ? m[1] || undefined : str;\n            if (bn && suffixList) {\n                if (!(suffixList instanceof Array)) suffixList = [suffixList];\n                suffixList = array.map(suffixList, function (s) {\n                    return s.replace(/([\\.\\?\\+])/g, '\\\\$1');\n                });\n                bn = bn.replace(new RegExp(suffixList.join('|') + '$', 'i'), '');\n            }\n            return bn;\n        },\n\n        assembleLocString: function assembleLocString(loc_in) {\n            var useExtra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            var s = '',\n                types = { start: 'number', end: 'number', ref: 'string', strand: 'number' },\n                location = {};\n\n            // filter the incoming loc_in to only pay attention to slots that we\n            // know how to handle\n            for (var slot in types) {\n                if (types[slot] == _typeof(loc_in[slot]) && (types[slot] != 'number' || !isNaN(loc_in[slot])) //filter any NaNs\n                ) {\n                        location[slot] = loc_in[slot];\n                    }\n            }\n\n            //finally assemble our string\n            if ('ref' in location) {\n                s += location.ref;\n                if (location.start || location.end) s += ':';\n            }\n            if ('start' in location) {\n                s += (Math.round(location.start) + 1).toFixed(0).toLocaleString();\n                if ('end' in location) s += '..';\n            }\n            if ('end' in location) s += Math.round(location.end).toFixed(0).toLocaleString();\n\n            if ('strand' in location) s += { '1': ' (+ strand)', '-1': ' (- strand)', '0': ' (no strand)' }[location.strand || ''] || '';\n\n            // add on any extra stuff if it was passed in\n            if (useExtra && 'extra' in loc_in) s += loc_in.extra;\n\n            return s;\n        },\n\n        /**\n         * Complement a sequence (without reversing).\n         * @param {String} seqString sequence\n         * @returns {String} complemented sequence\n         */\n        complement: function () {\n            var compl_rx = /[ACGT]/gi;\n\n            // from bioperl: tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/\n            // generated with:\n            // perl -MJSON -E '@l = split \"\",\"acgtrymkswhbvdnxACGTRYMKSWHBVDNX\"; print to_json({ map { my $in = $_; tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/; $in => $_ } @l})'\n            var compl_tbl = { \"S\": \"S\", \"w\": \"w\", \"T\": \"A\", \"r\": \"y\", \"a\": \"t\", \"N\": \"N\", \"K\": \"M\", \"x\": \"x\", \"d\": \"h\", \"Y\": \"R\", \"V\": \"B\", \"y\": \"r\", \"M\": \"K\", \"h\": \"d\", \"k\": \"m\", \"C\": \"G\", \"g\": \"c\", \"t\": \"a\", \"A\": \"T\", \"n\": \"n\", \"W\": \"W\", \"X\": \"X\", \"m\": \"k\", \"v\": \"b\", \"B\": \"V\", \"s\": \"s\", \"H\": \"D\", \"c\": \"g\", \"D\": \"H\", \"b\": \"v\", \"R\": \"Y\", \"G\": \"C\" };\n\n            var nbsp = String.fromCharCode(160);\n            var compl_func = function compl_func(m) {\n                return compl_tbl[m] || nbsp;\n            };\n            return function (seqString) {\n                return seqString.replace(compl_rx, compl_func);\n            };\n        }(),\n\n        /**\n         * Reverse-complement a sequence string.\n         * @param {String} seqString\n         * @returns {String} reverse-complemented sequence\n         */\n        revcom: function revcom(seqString) {\n            return Util.complement(seqString).split('').reverse().join('');\n        },\n\n        assembleLocStringWithLength: function assembleLocStringWithLength(def) {\n            var locString = Util.assembleLocString(def);\n            var length = def.length || def.end - def.start;\n            return locString + ' (' + Util.humanReadableNumber(length) + 'b)';\n        },\n\n        // given a possible reference sequence name and an object as { 'foo':\n        // <refseq foo>, ... }, try to match that reference sequence name\n        // against the actual name of one of the reference sequences.  returns\n        // the reference sequence record, or null\n        // if none matched.\n        matchRefSeqName: function matchRefSeqName(name, refseqs) {\n            for (var ref in refseqs) {\n                if (!refseqs.hasOwnProperty(ref)) continue;\n\n                var ucname = name.toUpperCase();\n                var ucref = ref.toUpperCase();\n\n                if (ucname == ucref || \"CHR\" + ucname == ucref || ucname == \"CHR\" + ucref) {\n                    return refseqs[ref];\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Wrap a handler function to be called 1ms later in a window timeout.\n         * This will usually give a better stack trace for figuring out where\n         * errors are happening.\n         */\n        debugHandler: function debugHandler(context, func) {\n            return function () {\n                var args = arguments;\n                window.setTimeout(function () {\n                    var f = func;\n                    if (typeof f == 'string') f = context[f];\n                    f.apply(context, args);\n                }, 1);\n            };\n        },\n\n        ucFirst: function ucFirst(str) {\n            if (typeof str != 'string') return undefined;\n            return str.charAt(0).toUpperCase() + str.slice(1);\n        },\n\n        /**\n         * Uniqify an array.\n         * @param stuff {Array} array of stuff\n         * @param normalizer {Function} optional function to be called on\n         * each element to convert them to a comparable string.  By\n         * default, just does default stringification.\n         */\n        uniq: function uniq(stuff, normalizer) {\n            normalizer = normalizer || function (t) {\n                return '' + t;\n            };\n            var result = [],\n                seen = {};\n            dojo.forEach(stuff, function (thing) {\n                var norm = normalizer(thing);\n                if (!seen[normalizer(thing)]) result.push(thing);\n                seen[norm] = true;\n            });\n            return result;\n        },\n\n        /**\n         * Replace windows file path, e.g. C:\\ to use file:/// prefixes\n         */\n        replacePath: function replacePath(path) {\n            return path.replace(/^(\\w):/, \"file:///$1:\").replace(/\\\\/g, \"/\");\n        },\n        unReplacePath: function unReplacePath(path) {\n            path = path.replace(/^file:\\/\\//, \"\");\n            var process = window.process;\n            return process.platform === \"win32\" && path[0] == \"/\" ? path.substr(1) : path;\n        },\n\n        // back-compatible way to remove properties/attributes from DOM\n        // nodes.  IE 7 and older do not support the `delete` operator on\n        // DOM nodes.\n        removeAttribute: function removeAttribute(domNode, attrName) {\n            try {\n                delete domNode[attrName];\n            } catch (e) {\n                if (domNode.removeAttribute) domNode.removeAttribute(attrName);\n            }\n        },\n        // Return resolution, accounting for config possibly specifying that highres is disabled\n        getResolution: function getResolution(ctx, highResolutionMode) {\n            var ratio;\n            if (highResolutionMode == 'auto') {\n                // finally query the various pixel ratios\n                var devicePixelRatio = window.devicePixelRatio || 1;\n                var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n                ratio = Math.ceil(devicePixelRatio / backingStoreRatio);\n            } else if (highResolutionMode == 'disabled') {\n                ratio = 1;\n            } else {\n                ratio = highResolutionMode;\n            }\n            return ratio >= 1 ? ratio : 1;\n        },\n\n        /**\n         * flatten array like [ [1,2], [3,4] ] to [ 1,2,3,4 ]\n         * @param {Array} ar\n         */\n        flattenOneLevel: function flattenOneLevel(ar) {\n            var r = [];\n            for (var i = 0; i < ar.length; i += 1) {\n                r.push.apply(r, _toConsumableArray(ar[i]));\n            }\n            return r;\n        },\n\n\n        /**\n         * Coerce a value of unknown type to a boolean, treating string 'true'\n         * and 'false' as the values they indicate, and string numbers as\n         * numbers.\n         * @private\n         */\n        coerceBoolean: function coerceBoolean(val) {\n            if (typeof val == 'string') {\n                val = val.toLowerCase();\n                if (val == 'true') {\n                    return true;\n                } else if (val == 'false') return false;else return parseInt(val);\n            } else if (typeof val == 'boolean') {\n                return val;\n            } else if (typeof val == 'number') {\n                return !!val;\n            } else {\n                return true;\n            }\n        },\n\n        intersect: function intersect(x1, x2, y1, y2) {\n            return x2 >= y1 && y2 >= x1;\n        },\n\n\n        // orientation definitions from igv.js, see also https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\n        orientationTypes: {\n            fr: {\n\n                \"F1R2\": \"LR\",\n                \"F2R1\": \"LR\",\n\n                \"F1F2\": \"LL\",\n                \"F2F1\": \"LL\",\n\n                \"R1R2\": \"RR\",\n                \"R2R1\": \"RR\",\n\n                \"R1F2\": \"RL\",\n                \"R2F1\": \"RL\"\n            },\n\n            rf: {\n\n                \"R1F2\": \"LR\",\n                \"R2F1\": \"LR\",\n\n                \"R1R2\": \"LL\",\n                \"R2R1\": \"LL\",\n\n                \"F1F2\": \"RR\",\n                \"F2F1\": \"RR\",\n\n                \"F1R2\": \"RL\",\n                \"F2R1\": \"RL\"\n            },\n\n            ff: {\n\n                \"F2F1\": \"LR\",\n                \"R1R2\": \"LR\",\n\n                \"F2R1\": \"LL\",\n                \"R1F2\": \"LL\",\n\n                \"R2F1\": \"RR\",\n                \"F1R2\": \"RR\",\n\n                \"R2R1\": \"RL\",\n                \"F1F2\": \"RL\"\n            }\n        }\n\n    };\n\n    return Util;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/*\n\nCopyright (c) 2007-2018 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n\n//# sourceURL=webpack:///./src/JBrowse/Util.js?");

/***/ })

}]);